

    
    export as namespace vjmap3d;

    declare namespace vjmap3d {
    import { AnimationAction } from 'three';
import { AnimationActionLoopStyles } from 'three';
import { AnimationBlendMode } from 'three';
import { AnimationClip } from 'three';
import { AnimationMixer } from 'three';
import { AxesHelper } from 'three';
import { BlendFunction } from './postprocessing/src';
import { BlendFunction as BlendFunction_2 } from '../../../postprocessing/src';
import { Blending } from 'three';
import { BloomEffect } from './postprocessing/src';
import { BloomEffect as BloomEffect_2 } from '../../../postprocessing/src';
import { Box2 } from 'three';
import { Box3 } from 'three';
import { BoxGeometry } from 'three';
import { BufferAttribute } from 'three';
import { BufferGeometry } from 'three';
import { Camera } from 'three';
import { CanvasTexture } from 'three';
import { CatmullRomCurve3 } from 'three';
import { ChromaticAberrationEffect } from './postprocessing/src';
import { Clock } from 'three';
import { Color } from 'three';
import { ColorDepthEffect } from './postprocessing/src';
import { ColorRepresentation } from 'three';
import { ColorSpace } from 'three';
import { CopyPass } from './postprocessing/src';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS2DParameters } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DParameters } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DSprite } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CubeTexture } from 'three';
import { DataTexture } from 'three';
import { DDSLoader } from 'three/examples/jsm/loaders/DDSLoader.js';
import { DepthOfFieldEffect } from './postprocessing/src';
import { DepthPass } from './postprocessing/src';
import { DepthPickingPass } from './postprocessing/src';
import { DepthPickingPass as DepthPickingPass_2 } from '../../../postprocessing/src';
import { DotScreenEffect } from './postprocessing/src';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { EdgeDetectionMode } from './postprocessing/src';
import { Effect } from './postprocessing/src';
import { EffectAttribute } from './postprocessing/src';
import { EffectComposer } from './postprocessing/src';
import { EffectComposer as EffectComposer_2 } from '../../../postprocessing/src';
import { EffectComposer as EffectComposer_3 } from '../postprocessing/src';
import { EffectPass } from './postprocessing/src';
import { Euler } from 'three';
import { EulerOrder } from 'three/src/math/Euler';
import { EventDispatcher as EventDispatcher_2 } from 'three';
import { ExtrudeGeometryOptions } from 'three';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
import { FileLoader } from 'three';
import type { Float32BufferAttribute } from 'three';
import { Fog } from 'three';
import { FXAAEffect } from './postprocessing/src';
import { GlitchEffect } from './postprocessing/src';
import { GlitchMode } from './postprocessing/src';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GodRaysEffect } from './postprocessing/src';
import { GridHelper } from 'three';
import { Group as Group_2 } from 'three';
import { ImageLoader } from 'three';
import { InstancedBufferGeometry } from 'three';
import { InstancedInterleavedBuffer } from 'three';
import { InstancedMesh } from 'three';
import { InterleavedBufferAttribute } from 'three';
import { InterpolationModes } from 'three';
import { Intersection } from 'three';
import { IUniform } from 'three';
import { KawaseBlurPass } from './postprocessing/src';
import { KernelSize } from './postprocessing/src';
import { KernelSize as KernelSize_2 } from '../../../postprocessing/src';
import { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';
import { Layers } from 'three';
import { Light } from 'three';
import { Line3 } from 'three';
import { Line as Line_2 } from 'three';
import { LineBasicMaterial } from 'three';
import { LineBasicMaterialParameters } from 'three';
import { LineDashedMaterialParameters } from 'three';
import { LineMaterialParameters as LineMaterialParameters_2 } from 'three/examples/jsm/lines/LineMaterial.js';
import { LineSegments } from 'three';
import { LineSegments2 as LineSegments2_2 } from 'three/examples/jsm/lines/LineSegments2.js';
import { Loader } from 'three';
import { LoadingManager } from 'three';
import { Lut } from 'three/examples/jsm/math/Lut.js';
import { MagnificationTextureFilter } from 'three';
import { Material } from 'three';
import { MaterialParameters } from 'three';
import { Matrix3 } from 'three';
import { Matrix4 } from 'three';
import { Matrix4Tuple } from 'three';
import { Mesh } from 'three';
import { MeshBasicMaterial } from 'three';
import { MeshBasicMaterialParameters } from 'three';
import { MeshLambertMaterialParameters } from 'three';
import { MeshPhongMaterial } from 'three';
import { MeshPhysicalMaterial } from 'three';
import { MeshStandardMaterial } from 'three';
import { MeshStandardMaterialParameters } from 'three';
import { MinificationTextureFilter } from 'three';
import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
import { NormalBufferAttributes } from 'three';
import { NormalPass } from './postprocessing/src';
import { Object3D } from 'three';
import { Object3DEventMap } from 'three';
import { ObjectLoader } from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
import { OrthographicCamera } from 'three';
import { OutlineEffect } from './postprocessing/src';
import { OutlineEffect as OutlineEffect_2 } from '../../../postprocessing/src';
import { OutlineEffect as OutlineEffect_3 } from '../postprocessing/src';
import { OverrideMaterialManager } from './postprocessing/src';
import { ParametricGeometry } from 'three/examples/jsm/geometries/ParametricGeometry.js';
import { Pass } from './postprocessing/src';
import { Pass as Pass_2 } from '../../../postprocessing/src';
import { Pass as Pass_3 } from '../postprocessing/src';
import { PerspectiveCamera } from 'three';
import { PixelationEffect } from './postprocessing/src';
import { Plane } from 'three';
import { PlaneGeometry } from 'three';
import { Points } from 'three';
import { PointsMaterial } from 'three';
import { PointsMaterialParameters } from 'three';
import { PredicationMode } from './postprocessing/src';
import { Quaternion } from 'three';
import { RawShaderMaterial } from 'three';
import { Ray } from 'three';
import { Raycaster } from 'three';
import { RaycasterParameters } from 'three';
import { Renderer } from 'three';
import { RenderPass } from './postprocessing/src';
import { RenderTargetOptions } from 'three';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { Scene } from 'three';
import { SelectiveBloomEffect } from './postprocessing/src';
import { SelectiveBloomEffect as SelectiveBloomEffect_2 } from '../postprocessing/src';
import { SelectiveBloomEffect as SelectiveBloomEffect_3 } from '../../../postprocessing/src';
import { ShaderMaterial } from 'three';
import { ShaderMaterialParameters } from 'three';
import { ShaderPass } from './postprocessing/src';
import { Shape as Shape_2 } from 'three';
import { Side } from 'three';
import { SMAAEffect } from './postprocessing/src';
import { SMAAPreset } from './postprocessing/src';
import { Sphere } from 'three';
import { Spherical } from 'three';
import { Sprite } from 'three';
import { SpriteMaterial } from 'three';
import { SpriteMaterialParameters } from 'three';
import { SSAOEffect } from './postprocessing/src';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import { Texture } from 'three';
import { TextureDataType } from 'three';
import { TextureEffect } from './postprocessing/src';
import { TextureImageData } from 'three/src/textures/types';
import { ToneMappingEffect } from './postprocessing/src';
import { ToneMappingMode } from './postprocessing/src';
import { Triangle } from 'three';
import { TrianglesDrawModes } from 'three';
import type { Uint16BufferAttribute } from 'three';
import { Uniform as Uniform_2 } from 'three';
import { UniformsLib } from 'three';
import { Usage } from 'three';
import { Vector2 } from 'three';
import { Vector3 } from 'three';
import { Vector3Tuple } from 'three';
import { Vector4 } from 'three';
import { WebGLMultipleRenderTargets } from 'three';
import { WebGLRenderer } from 'three';
import { WebGLRendererParameters } from 'three';
import { WebGLRenderTarget } from 'three';

export declare const __buildDate: any;

export declare const __buildVerNo: any;

export declare const __buildVersion: any;

export declare const __DEV: any;

/**
 * Axis aligned bounding box class.
 */
declare class AABB {
    /**
     * The lower bound of the bounding box
     */
    lowerBound: Vec3;
    /**
     * The upper bound of the bounding box
     */
    upperBound: Vec3;
    constructor(options?: {
        /**
         * The lower bound of the bounding box
         */
        upperBound?: Vec3;
        /**
         * The upper bound of the bounding box
         */
        lowerBound?: Vec3;
    });
    /**
     * Set the AABB bounds from a set of points.
     * @param points An array of Vec3's.
     * @return The self object
     */
    setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion_2, skinSize?: number): AABB;
    /**
     * Copy bounds from an AABB to this AABB
     * @param aabb Source to copy from
     * @return The this object, for chainability
     */
    copy(aabb: AABB): AABB;
    /**
     * Clone an AABB
     */
    clone(): AABB;
    /**
     * Extend this AABB so that it covers the given AABB too.
     */
    extend(aabb: AABB): void;
    /**
     * Returns true if the given AABB overlaps this AABB.
     */
    overlaps(aabb: AABB): boolean;
    volume(): number;
    /**
     * Returns true if the given AABB is fully contained in this AABB.
     */
    contains(aabb: AABB): boolean;
    getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void;
    /**
     * Get the representation of an AABB in another frame.
     * @return The "target" AABB object.
     */
    toLocalFrame(frame: Transform, target: AABB): AABB;
    /**
     * Get the representation of an AABB in the global frame.
     * @return The "target" AABB object.
     */
    toWorldFrame(frame: Transform, target: AABB): AABB;
    /**
     * Check if the AABB is hit by a ray.
     */
    overlapsRay(ray: Ray_2): boolean;
}

declare type AbortCallback = () => void;

/**
 * Returns the number which is larger in absolute value.
 * @param a
 * @param b
 *
 * @category Maths
 */
export declare function absMax(a: number, b: number): number;

export declare class AbstractDecoratorBehavior extends Behavior {
    protected __source: Behavior;
    constructor();
    /**
     *
     * @return {Behavior}
     */
    getSource(): Behavior;
    /**
     *
     * @param {Behavior} source
     */
    setSource(source: Behavior): void;
    initialize(context: BehaviorContext): void;
    finalize(): void;
}

export declare function acceleratedRaycast(raycaster: any, intersects: any): void;

declare function acceleratedRaycast_2(raycaster: Raycaster, intersects: Array<Intersection>): void;

declare const ACTION: Readonly<{
    readonly NONE: 0;
    readonly ROTATE: 1;
    readonly TRUCK: 2;
    readonly OFFSET: 4;
    readonly DOLLY: 8;
    readonly ZOOM: 16;
    readonly TOUCH_ROTATE: 32;
    readonly TOUCH_TRUCK: 64;
    readonly TOUCH_OFFSET: 128;
    readonly TOUCH_DOLLY: 256;
    readonly TOUCH_ZOOM: 512;
    readonly TOUCH_DOLLY_TRUCK: 1024;
    readonly TOUCH_DOLLY_OFFSET: 2048;
    readonly TOUCH_DOLLY_ROTATE: 4096;
    readonly TOUCH_ZOOM_TRUCK: 8192;
    readonly TOUCH_ZOOM_OFFSET: 16384;
    readonly TOUCH_ZOOM_ROTATE: 32768;
}>;

declare type ACTION = number;

export declare class ActionBehavior extends Behavior {
    #private;
    __action: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined;
    __context: any;
    /**
     *
     * @param {function(timeDelta:number)} func
     */
    constructor(func: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined, options?: {
        context?: any;
        isRepeat?: boolean;
    });
    tick(timeDelta: number): BehaviorStatus;
}

export declare class Adapter {
    node: Node_2;
    isInput: boolean;
    paramIndex: number;
    type: NodeValueType;
    inputs: (Wire | undefined)[];
    outputs: Wire[][];
    constructor(type: NodeValueType, isInput: boolean, node: Node_2, paramIndex: number);
}

/**
 * 向量相加
 */
declare function add<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

declare const ADDITION: CSGOperation;

export declare class AddObject3DCommand extends BaseCommand {
    private object;
    constructor(object: Object3D);
    execute(): void;
    undo(): void;
    redo(): void;
}

/**
 * 增加资源引用次数。如果在对象dispose销毁前，资源引用次数为零。将调用资源的dispose进行资源回收
 * resource 资源对象
 * count 引用次数，默认1
 */
export declare function addResourceRefCount(resource: Object3D | Material | Material[] | Texture | WebGLRenderTarget, count?: number): void;

/**
 * 将脚本注入.
 * 脚本选项信息:
 *   `strategy`: 用于运行 JavaScript 的策略。可以是`inject`、`eval` 或`href`。默认自动检测.
 *   `injectLocation`: 用于注入资源的位置的 `document.querySelector` 参数。默认为 `head`.
 *   `async`: 异步加载脚本
 *   `src`: 脚本的来源
 * @method
 * @async
 * @param {typeof defaultOptions |  Array<typeof defaultOptions>} scripts - Options for a script
 * @return {Promise<void>}
 * @example
 * // you can add multiple loads
 * awit addScript([{
 *  src: "https://code.jquery.com/jquery-3.5.0.js"
 * }, {
 *  src: "https://code.jquery.com/jquery-3.2.0.js",
 *  async: true
 * }, {
 *  src: "https://code.jquery.com/jquery-3.3.0.js",
 *  async: true,
 *  injectLocation: '#main div.test',
 * }, {
 *  src: "https://code.jquery.com/jquery-3.4.0.js",
 *  strategy: 'eval',
 * }, {
 * // link tag
 * // css autodetected
 *  src: "https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap-grid.min.css",
 * }])
 */
export declare function addScript(scripts: ScriptDefaultOptions | ScriptDefaultOptions[]): Promise<unknown[]>;

/**
 * Decrypts ciphertext encrypted with aesGcmEncrypt() using supplied password.
 *                                                                      (c) Chris Veness MIT Licence
 *
 * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
 * Modified to work with Uint8Array and string content.
 *
 * @param ciphertext - Ciphertext to be decrypted.
 * @param password - Password to use to decrypt ciphertext.
 * @returns Decrypted content. If ciphertext is a string, the plaintext is a string. If ciphertext is a Uint8Array, the plaintext is a new Uint8Array.
 *
 * @example
 *   const plaintext = await aesGcmDecrypt(ciphertext, 'pw');
 *   aesGcmDecrypt(ciphertext, 'pw').then(function(plaintext) { console.log(plaintext); });
 *
 * @category Encryption
 */
export declare function aesGcmDecrypt<T extends string | Uint8Array>(ciphertext: T, password: string | Uint8Array): Promise<T>;

/**
 * Encrypts plaintext using AES-GCM with supplied password, for decryption with aesGcmDecrypt().
 *                                                                      (c) Chris Veness MIT Licence
 * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
 * Modified to work with Uint8Array and string content.
 *
 * @param content - Plaintext or Uint8 Buffer to be encrypted.
 * @param password - Plaintext or Uint8 Buffer Password to use to encrypt content.
 * @param prefix - Optional prefix to prepend to the ciphertext.
 * @returns Encrypted ciphertext. If content is a string, the ciphertext is a string. If content is a Uint8Array, the ciphertext is a new Uint8Array.
 *
 *
 * @example
 *   const ciphertext = await aesGcmEncrypt('my secret text', 'pw');
 *   aesGcmEncrypt('my secret text', 'pw').then(function(ciphertext) { console.log(ciphertext); });
 *
 * @category Encryption
 */
export declare function aesGcmEncrypt<T extends string | Uint8Array>(content: T, password: string | Uint8Array, prefix?: string | Uint8Array): Promise<T>;

declare namespace AlgorithmPluginType {
    export {
        getTriangleDefinitions,
        logTriangleDefinitions,
        generateRandomTriangleColors,
        computeMeshVolume,
        createProjectionTask,
        computeBoundsTree_2 as computeBoundsTree,
        disposeBoundsTree_2 as disposeBoundsTree,
        acceleratedRaycast_2 as acceleratedRaycast,
        estimateMemoryInBytes,
        getBVHExtremes,
        validateBounds,
        getJSONStructure,
        getTriangleHitPointInfo,
        mergeGeometries,
        mergeAttributes,
        interleaveAttributes,
        estimateBytesUsed,
        mergeVertices,
        toTrianglesDrawMode,
        computeMorphedAttributes,
        computeMikkTSpaceTangents,
        mergeGroups,
        toCreasedNormals,
        Brush,
        TypedAttributeData,
        CSGOperation,
        ADDITION,
        SUBTRACTION,
        REVERSE_SUBTRACTION,
        INTERSECTION,
        DIFFERENCE,
        HOLLOW_SUBTRACTION,
        HOLLOW_INTERSECTION,
        Evaluator,
        Operation,
        OperationGroup,
        CullableTriangle,
        TrianglePool,
        TriangleSplitter,
        HalfEdgeMap,
        GridMaterial,
        TriangleSetHelper,
        EdgesHelper,
        TriangleIntersectData,
        TriangleIntersectionSets,
        OperationDebugData,
        PointsHelper,
        HalfEdgeHelper,
        ProjectionGenerator,
        SilhouetteGenerator,
        SplitStrategy,
        CENTER,
        AVERAGE,
        SAH,
        ShapecastIntersection,
        NOT_INTERSECTED,
        INTERSECTED,
        CONTAINED,
        HitPointInfo,
        MeshBVHOptions,
        MeshBVHSerializeOptions,
        MeshBVHDeserializeOptions,
        MeshBVH,
        SerializedBVH,
        MeshBVHHelper,
        ExtremeInfo,
        TreeNode,
        HitTriangleInfo,
        MeshBVHUniformStruct,
        shaderStructs,
        shaderFunctions,
        ExtendedTriangle,
        OrientedBox,
        StaticGeometryGenerator,
        Delatin
    }
}
export { AlgorithmPluginType }

/**
 * Make two bezier arrays aligns on structure. To have better animation.
 *
 * It will:
 * Make two bezier arrays have same number of subpaths.
 * Make each subpath has equal number of bezier curves.
 *
 * array is the convert result of pathToBezierCurves.
 */
declare function alignBezierCurves(array1: number[][], array2: number[][]): any[][];

export declare type AllowedTypes = number | Vector3 | Quaternion | Euler | ColorRepresentation;

export declare type Anchor = 'center' /** 正中 */ | 'top' /** 上面居中 */ | 'bottom' /** 下面居中 */ | 'left' /** 左边居中 */ | 'right' /** 右边居中 */ | 'top-left' /** 左上 */ | 'top-right' /** 右上 */ | 'bottom-left' /** 左下 */ | 'bottom-right';

export declare type Anchor3d = "default" /** 模型默认位置 */ | 'front-center' /** 前面-正中 */ | 'front-top' /** 前面-上面居中 */ | 'front-bottom' /** 前面-下面居中 */ | 'front-left' /** 前面-左边居中 */ | 'front-right' /** 前面-右边居中 */ | 'front-top-left' /** 前面-左上 */ | 'front-top-right' /** 前面-右上 */ | 'front-bottom-left' /** 前面-左下 */ | 'front-bottom-right' /** 前面-右下 */ | 'middle-center' /** 中间-正中 */ | 'middle-top' /** 中间-上面居中 */ | 'middle-bottom' /** 中间-下面居中 */ | 'middle-left' /** 中间-左边居中 */ | 'middle-right' /** 中间-右边居中 */ | 'middle-top-left' /** 中间-左上 */ | 'middle-top-right' /** 中间-右上 */ | 'middle-bottom-left' /** 中间-左下 */ | 'middle-bottom-right' /** 中间-右下 */ | 'back-center' /** 后面-正中 */ | 'back-top' /** 后面-上面居中 */ | 'back-bottom' /** 后面-下面居中 */ | 'back-left' /** 后面-左边居中 */ | 'back-right' /** 后面-右边居中 */ | 'back-top-left' /** 后面-左上 */ | 'back-top-right' /** 后面-右上 */ | 'back-bottom-left' /** 后面-左下 */ | 'back-bottom-right';

export declare const anchorOrigin: {
    center: string;
    top: string;
    'top-left': string;
    'top-right': string;
    bottom: string;
    'bottom-left': string;
    'bottom-right': string;
    left: string;
    right: string;
};

export declare const anchorTranslate: {
    center: string;
    top: string;
    'top-left': string;
    'top-right': string;
    bottom: string;
    'bottom-left': string;
    'bottom-right': string;
    left: string;
    right: string;
};

export declare class AnimateMarkerBase {
    protected options: AnimateMarkerLayerOption;
    protected markersElement: any;
    protected features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    };
    constructor(features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setFeatures(features: FeatureCollection): void;
    getMarkersElement(): any;
    getElement(index?: number): any;
    getPosition(index?: number): any;
    createMarker2d(options?: Marker2dOptions, index?: number): Marker2D;
    createMarker3d(options?: Marker3dOptions, index?: number): Marker3D;
    setMarkersTextField(textField: string): void;
    setMarkersText(text: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    protected _getColorWithOpacity(color: string, opacity: string | number): string;
    protected _getTextContainer(feature: any, className: string): HTMLDivElement;
    set16ToRgb(str: string): string;
    getColorWithOpacity(color: string, opacity: string | number): string;
}

export declare interface AnimateMarkerLayerOption {
    /** 动画标记类型，默认为breathingAperture */
    type?: AnimateMarkerType;
    /** 宽度 */
    width?: number;
    /** 高度 */
    height?: number;
    /** 颜色值 */
    colors?: string[];
    /** 字体大小 */
    textFontSize?: number;
    /** 字体颜色 */
    textColor?: string;
    /** 字段内容位于哪个属性数据中（默认为name属性中去获取) */
    textField?: string;
}

/**
 * breathingAperture 呼吸的光圈.
 * rotatingAperture 旋转的光环
 * haloRing 发光的光环
 * diffusedAperture 扩散的点
 * rotatingTextBorder 旋转的文本框
 * fluorescence 荧光点
 */
export declare type AnimateMarkerType = "breathingAperture" | 'rotatingAperture' | 'haloRing' | 'diffusedAperture' | 'rotatingTextBorder' | 'fluorescence';

/** 创建动画，对Tween的封装 */
export declare function animation<T extends Record<string, any>>(props: {
    /** id */
    id?: string;
    /** 分类 */
    tag?: string;
    /** 开始值(默认{value: 0}) */
    from?: T;
    /** 结束值(默认{value: 1) */
    to?: T;
    /** 为true的时候，to的值为相对值 */
    by?: boolean;
    /** 持续时长 */
    duration: number;
    /** easing 默认 linear */
    easing?: Easing;
    /** 是否往返循环 */
    yoyoForever?: boolean;
    /** 往返次数 */
    yoyoTimes?: number;
    /** 重复循环 */
    repeatForever?: boolean;
    /** 重复次数 */
    repeatTimes?: number;
    /** 延迟时长 */
    delay?: number;
    /** 自动播放动画，默认是 */
    autoPlay?: boolean;
    /**
     * A callback function to execute when the animation completes.
     * @param target - The target object that was tweened.
     */
    onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
    /**
     * A callback function to execute when the animation starts.
     * @param target - The target object that is being tweened.
     */
    onStart?: (target: T) => void;
    /**
     * A callback function to be executed after each property has been updated.
     * @param target - The target object that is being tweened.
     */
    onUpdate?: (target: T) => void;
    /**
     * A callback function to be executed before each property is updated.
     * @param target - The target object that is being tweened.
     * @param key - The key or property being animated.
     * @param start - The initial value of the animated property.
     * @param end - The final value of the animated property.
     * @param alpha - The current animation progress as a normalized value (0 to 1).
     * @returns If `false`, will not assign a new value to the property.
     */
    onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
}): Tween<T>;

/**
 * @example
 *     const animation = new Animation();
 *     const obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start();
 */
declare class Animation_2 extends Eventful {
    stage: Stage;
    private _head;
    private _tail;
    private _running;
    private _time;
    private _pausedTime;
    private _pauseStart;
    private _paused;
    constructor(opts?: AnimationOption);
    /**
     * Add clip
     */
    addClip(clip: Clip): void;
    /**
     * Add animator
     */
    addAnimator(animator: Animator_2<any>): void;
    /**
     * Delete animation clip
     */
    removeClip(clip: Clip): void;
    /**
     * Delete animation clip
     */
    removeAnimator(animator: Animator_2<any>): void;
    update(notTriggerFrameAndStageUpdate?: boolean): void;
    _startLoop(): void;
    /**
     * Start animation.
     */
    start(): void;
    /**
     * Stop animation.
     */
    stop(): void;
    /**
     * Pause animation.
     */
    pause(): void;
    /**
     * Resume animation.
     */
    resume(): void;
    /**
     * Clear animation.
     */
    clear(): void;
    /**
     * Whether animation finished.
     */
    isFinished(): boolean;
    /**
     * Creat animator for a target, whose props can be animated.
     */
    animate<T>(target: T, options: {
        loop?: boolean;
    }): Animator_2<T>;
}

/** 创建动画，对Tween的封装，返回一个promise,动画结束后返回 */
export declare function animationAsync<T extends Record<string, any>>(props: {
    /** id */
    id?: string;
    /** 分类 */
    tag?: string;
    /** 开始值(默认{value: 0}) */
    from?: T;
    /** 结束值(默认{value: 1) */
    to?: T;
    /** 为true的时候，to的值为相对值 */
    by?: boolean;
    /** 持续时长 */
    duration: number;
    /** easing 默认 linear */
    easing?: Easing;
    /** 是否往返循环 */
    yoyoForever?: boolean;
    /** 往返次数 */
    yoyoTimes?: number;
    /** 重复循环 */
    repeatForever?: boolean;
    /** 重复次数 */
    repeatTimes?: number;
    /** 延迟时长 */
    delay?: number;
    /** 自动播放动画，默认是 */
    autoPlay?: boolean;
    /**
     * A callback function to execute when the animation completes.
     * @param target - The target object that was tweened.
     */
    onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
    /**
     * A callback function to execute when the animation starts.
     * @param target - The target object that is being tweened.
     */
    onStart?: (target: T) => void;
    /**
     * A callback function to be executed after each property has been updated.
     * @param target - The target object that is being tweened.
     */
    onUpdate?: (target: T) => void;
    /**
     * A callback function to be executed before each property is updated.
     * @param target - The target object that is being tweened.
     * @param key - The key or property being animated.
     * @param start - The initial value of the animated property.
     * @param end - The final value of the animated property.
     * @param alpha - The current animation progress as a normalized value (0 to 1).
     * @returns If `false`, will not assign a new value to the property.
     */
    onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
}): Promise<unknown>;

export declare class AnimationBehavior extends Behavior {
    animation: AnimationTrackPlayback;
    /**
     *
     * @param {AnimationTrackPlayback} animation
     */
    constructor(animation: AnimationTrackPlayback);
    /**
     *
     * @param {number} timeDelta
     * @returns {BehaviorStatus}
     */
    tick(timeDelta: any): BehaviorStatus.Running | BehaviorStatus.Succeeded;
    initialize(): void;
}

/**
 * 关键帧动画选项
 */
export declare interface AnimationClipOptions {
    /** 动画名称 */
    name?: string;
    /** 时长 */
    duration?: number;
    /** 混合模式 */
    blendMode?: AnimationBlendMode;
    /** uuid */
    uuid?: number;
    /** 帧率 */
    fps?: number;
    /** 关键帧数据 */
    tracks: {
        /** 类型 */
        type: "double" | "float" | "number" | "integer" | "vector" | "vector2" | "vector3" | "vector4" | "color" | "quaternion" | "bool" | "boolean" | "string";
        /** 名称 */
        name?: string;
        /** 时间 */
        times: number[];
        /** 值 */
        values: any[];
        /** 插值方法 */
        interpolation?: InterpolationModes;
    }[];
}

declare type AnimationEasing = keyof typeof easingFuncs | easingFunc;

declare interface AnimationOption {
    stage?: Stage;
}

export declare class AnimationTrack {
    properties: String[];
    propertyCount: number;
    keyValues: any;
    keyTimes: any;
    timeStart: number;
    timeEnd: number;
    transitionKeys: any[];
    transitionFunctions: any[];
    constructor(properties: String[]);
    optimize(): void;
    /**
     *
     * @param {number} keyTime
     * @param {number[]} values
     */
    addKey(keyTime: number, values: number[]): void;
    /**
     *
     * @param {number} startKeyIndex
     * @param {function(number):number} transitionFunction
     */
    addTransition(startKeyIndex: number, transitionFunction: (number: any) => number): void;
    /**
     *
     * @param {number} time
     * @returns {number}
     */
    keyLowerBoundIndexAt(time: number): number;
    /**
     *
     * @param {number} time
     * @returns {number}
     */
    transitionIndexAt(time: number): number;
    /**
     *
     * @param {number} keyIndex
     * @param {number[]} result
     */
    readKeyValues(keyIndex: number, result: number[]): void;
}

/**
 *
 * @param {AnimationTrack} track
 * @param updateCallback
 * @param {Object} [updateTarget]
 * @constructor
 * @property {AnimationTrack} track
 * @property {number} position Current playback time
 */
export declare class AnimationTrackPlayback {
    track: AnimationTrack;
    position: number;
    updateCallback: any;
    updateTraget: any;
    __lastKeyIndex: number;
    __lastTransitionIndex: number;
    __nextKeyIndex: number;
    __nextKeyTime: number;
    __loop: boolean;
    __valueBuffer: any;
    on: {
        ended: any;
    };
    constructor(track: AnimationTrack, updateCallback?: Function, updateTarget?: any);
    /**
     *
     * @returns {Promise<void>}
     */
    promiseEnded(): Promise<unknown>;
    /**
     *
     * @param {boolean} v
     */
    setLoop(v: any): void;
    isLoop(): boolean;
    reset(): void;
    /**
     *
     * @param {number} time
     */
    setPosition(time: number): void;
    /**
     *
     * @returns {boolean} Indicated whenever or not a key was advanced, no advancement is possible past end of the sequence
     */
    advanceKey(): boolean;
    /**
     * Advance animation by given time delta
     * @param {number} timeDelta
     */
    advance(timeDelta: number): void;
    update(): void;
    /**
     *
     * @param {number[]} result
     */
    readCurrentValues(result: number[]): void;
}

/**
 * 生成动画
 */
export declare class Animator {
    #private;
    uiConfig: UiObjectConfig;
    animateMixer: AnimationMixer;
    animationClips: AnimationClip[];
    isAnimator: boolean;
    signal: {
        onLoop: Signal;
        onFinished: Signal;
    };
    constructor(options: AnimatorOptions);
    /**
     * 停止所有动作
     */
    stopAllAction(): AnimationMixer;
    /**
     * 获取所有关键动画帧名称
     */
    getClipNames(): string[];
    /**
     * 设置时间
     */
    setTime(timeInSeconds: number): AnimationMixer;
    /**
     * 增加关键帧动画
     * @param clip
     * @returns
     */
    addAnimationClip(clip: AnimatorOptions | AnimationClip): AnimationClip;
    /**
     * 获取动画混合器
     * @returns
     */
    getAnimateMixer(): AnimationMixer;
    /**
     * 获取关键帧动画数组
     * @returns
     */
    getAnimationClips(): AnimationClip[];
    /**
     * 获取关键帧动画
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    getClip(name: string | number | AnimationClip): AnimationClip;
    /**
     * 增加子裁剪关键帧动画
     * @param sourceClip 源关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param startFrame 开始帧位置
     * @param endFrame 结束帖位置
     * @param subclipName 子帧名称
     * @param fps 帖率
     */
    addAnimationSubclip(sourceClip: string | number | AnimationClip, startFrame: number, endFrame?: number, subclipName?: string, fps?: number): void;
    /**
     * 获取关键帧动画动作
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    getclipAction(name: string | number | AnimationClip): AnimationAction;
    /**
     * 播放关键帧动画
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象 如果不输入，则指第1个动画
     * @returns
     */
    play(name?: string | number | AnimationClip): AnimationAction;
    /**
     * 停止关键帧动画
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象 如果不输入，则指所有的动画名称
     * @returns
     */
    stop(name?: string | number | AnimationClip): AnimationAction;
    /**
     * 重置关键帧动画
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    reset(name: string | number | AnimationClip): AnimationAction;
    /**
     * 关键帧动画是否在运行
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    isRunning(name: string | number | AnimationClip): boolean;
    /**
     * 如果动作是在混合器中被激活的，返回true。这并不意味着动画正在执行中 (需要额外判断isRunning值)
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    isScheduled(name: string | number | AnimationClip): boolean;
    /**
     * 设置动画播放结束后是停在最后还是回到开始位置
     *
     * @param {string} name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param {boolean} clampWhenFinished 如果 clampWhenFinished 值设为true, 那么动画将在最后一帧之后自动暂停 如果 clampWhenFinished 值为false, enabled 属性值将在动作的最后一次循环完成之后自动改为false, 那么这个动作以后就不会再执行
     * @memberof Animation
     */
    setClampWhenFinished(name: string | number | AnimationClip, clampWhenFinished: boolean): void;
    /**
     * 设置动画是否能用
     *
     * @param {string} name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param {boolean} enabled 是否启用
     * @memberof Animation
     */
    setEnable(name: string | number | AnimationClip, enabled: boolean): void;
    /**
     * 动画开始时间
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param time 开始时间
     * @returns
     */
    startAt(name: string | number | AnimationClip, time: number): AnimationAction;
    /**
     * 设置动画循环参数
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param mode 循环状态
     * @param repetitions 循环次数
     * @returns mode 循环状态
     */
    setLoop(name: string | number | AnimationClip, mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
    /**
     * 设置权重以及停止所有淡入淡出
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param weight 权重值
     * @returns
     */
    setEffectiveWeight(name: string | number | AnimationClip, weight: number): AnimationAction;
    /**
     * 获取权重
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    getEffectiveWeight(name: string | number | AnimationClip): number;
    /**
     * 在传入的时间间隔内，逐渐将此动作的权重（weight）由0升到1
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param duration 持续时间
     * @returns
     */
    fadeIn(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * 在传入的时间间隔内，逐渐将此动作的权重（weight）由1降至0。
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param duration 持续时间
     * @returns
     */
    fadeOut(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * 在传入的时间段内，让此动作淡入(fade in),同时让另一个动作淡出。
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param fadeOutAction 淡出的另一个动作
     * @param duration 持续时间
     * @param warp 如值是true, 额外的 warping (时间比例的渐变)将会被应用。
     * @returns
     */
    crossFadeFrom(name: string | number | AnimationClip, fadeOutAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
    /**
     * 在传入的时间段内, 让此动作淡出（fade out），同时让另一个动作淡入
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param fadeInAction 淡出的动作
     * @param duration 持续时间
     * @param warp 如值是true, 额外的 warping (时间比例的渐变)将会被应用。
     * @returns
     */
    crossFadeTo(name: string | number | AnimationClip, fadeInAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
    /**
     * 停止动作中所有预定的淡入淡出（fading）
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    stopFading(name: string | number | AnimationClip): AnimationAction;
    /**
     * 设置时间比例（timeScale）以及停用所有的变形)
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param timeScale 时间比例
     * @returns
     */
    setEffectiveTimeScale(name: string | number | AnimationClip, timeScale: number): AnimationAction;
    /**
     * 获取时间比例
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    getEffectiveTimeScale(name: string | number | AnimationClip): number;
    /**
     * 设置单次循环的持续时间(通过调整时间比例（timeScale）以及停用所有的变形)
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    setDuration(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * 将此动作与传入的其它动作同步
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param action 需同步的动作
     * @returns
     */
    syncWith(name: string | number | AnimationClip, action: AnimationAction): AnimationAction;
    /**
     * 在传入的时间间隔内，通过从当前值开始逐渐降低时间比例(timeScale)使动画逐渐减速至0
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param duration 持续时间
     * @returns
     */
    halt(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * 在传入的事件间隔内，通过逐渐将时间比例timeScale由startTimeScale修改至endTimeScale来改变回放速度。
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @param statTimeScale 开始时间比例
     * @param endTimeScale 终止时间比例
     * @param duration 持续时长
     * @returns
     */
    warp(name: string | number | AnimationClip, statTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
    /**
     * 停用动作中所有预定的变形warping
     * @param name 关键帧动画名称或关键帧动画数组索引或关键帧动画对象
     * @returns
     */
    stopWarping(name: string | number | AnimationClip): AnimationAction;
    /**
     * 增加旋转动作
     * @param period 周期时间 默认3s = 60 * 3
     * @param axis 方向轴 默认绕y轴 "y"
     * @param name 动作名称
     */
    addRotationAnimation(period?: number, axis?: string, name?: any): AnimationClip;
    /**
     * 增加缩放动作
     * @param period 周期时间 默认3s = 60 * 3
     * @param axis 方向轴 默认绕y轴 "y"
     * @param name 动作名称
     */
    addScaleAxisAnimation(period?: number, axis?: string, name?: any): AnimationClip;
    /**
     * 增加晃动动作
     * @param period 持继时间 默认3s = 60 * 3
     * @param shakeScale 晃动比例 默认 1.2
     * @param name 动作名称
     */
    addShakeAnimation(duration?: number, shakeScale?: Vector3 | number, name?: any): AnimationClip;
    /**
     * 增加脉动动作
     * @param period 持继时间 默认3s = 60 * 3
     * @param pulseScale 脉动比例 默认1.2
     * @param name 动作名称
     */
    addPulsationAnimation(duration?: number, pulseScale?: number, name?: any): AnimationClip;
    /**
     * 增加闪烁动作
     * @param period 持继时间 默认0.5
     * @param name 动作名称
     */
    addVisibilityAnimation(duration?: number, name?: any): AnimationClip;
    /**
     * 增加颜色变化动作
     * @param period 持继时间 3s = 60 * 3
     * @param colors 颜色列表
     * @param name 动作名称
     */
    addMaterialColorAnimation(duration?: number, colors?: {
        r: number;
        g: number;
        b: number;
    }[], name?: any): AnimationClip;
    update(delta: number): void;
    dispose(): void;
    /**
     * 主动添加加至应用中
     * @param app
     * @param autoPlay 是否自动播放动画，默认是
     * @returns
     */
    addTo(app: App, autoPlay?: boolean): void;
    /**
     * 从应用中移除此动画
     * @returns
     */
    remove(): void;
}

declare class Animator_2<T> {
    animation?: Animation_2;
    targetName?: string;
    scope?: string;
    __fromStateTransition?: string;
    private _tracks;
    private _trackKeys;
    private _target;
    private _loop;
    private _delay;
    private _maxTime;
    /**
     * If force run regardless of empty tracks when duration is set.
     */
    private _force;
    /**
     * If animator is paused
     * @default false
     */
    private _paused;
    private _started;
    /**
     * If allow discrete animation
     * @default false
     */
    private _allowDiscrete;
    private _additiveAnimators;
    private _doneCbs;
    private _onframeCbs;
    private _abortedCbs;
    private _clip;
    constructor(target: T, loop: boolean, allowDiscreteAnimation?: boolean, // If doing discrete animation on the values can't be interpolated
    additiveTo?: Animator_2<any>[]);
    getMaxTime(): number;
    getDelay(): number;
    getLoop(): boolean;
    getTarget(): T;
    /**
     * Target can be changed during animation
     * For example if style is changed during state change.
     * We need to change target to the new style object.
     */
    changeTarget(target: T): void;
    /**
     * Set Animation keyframe
     * @param time time of keyframe in ms
     * @param props key-value props of keyframe.
     * @param easing
     */
    when(time: number, props: Dictionary<any>, easing?: AnimationEasing): this;
    whenWithKeys(time: number, props: Dictionary<any>, propNames: string[], easing?: AnimationEasing): this;
    pause(): void;
    resume(): void;
    isPaused(): boolean;
    /**
     * Set duration of animator.
     * Will run this duration regardless the track max time or if trackes exits.
     * @param duration
     * @returns
     */
    duration(duration: number): this;
    private _doneCallback;
    private _abortedCallback;
    private _setTracksFinished;
    private _getAdditiveTrack;
    /**
     * Start the animation
     * @param easing
     * @return
     */
    start(easing?: AnimationEasing): this;
    /**
     * Stop animation
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stop(forwardToLast?: boolean): void;
    /**
     * Set when animation delay starts
     * @param time 单位ms
     */
    delay(time: number): this;
    /**
     * 添加动画每一帧的回调函数
     * @param callback
     */
    during(cb: OnframeCallback_2<T>): this;
    /**
     * Add callback for animation end
     * @param cb
     */
    done(cb: DoneCallback): this;
    aborted(cb: AbortCallback): this;
    getClip(): Clip;
    getTrack(propName: string): Track;
    getTracks(): Track[];
    /**
     * Return true if animator is not available anymore.
     */
    stopTracks(propNames: string[], forwardToLast?: boolean): boolean;
    /**
     * Save values of final state to target.
     * It is mainly used in state mangement. When state is switching during animation.
     * We need to save final state of animation to the normal state. Not interpolated value.
     *
     * @param target
     * @param trackKeys
     * @param firstOrLast If save first frame or last frame
     */
    saveTo(target: T, trackKeys?: readonly string[], firstOrLast?: boolean): void;
    __changeFinalValue(finalProps: Dictionary<any>, trackKeys?: readonly string[]): void;
}

export declare const AnimatorFrameMaterial: (new (parameters?: ShaderMaterialParameters & Partial<AnimatorFrameMaterialProps>, uniforms?: Partial<AnimatorFrameMaterialProps>) => ShaderMaterial & AnimatorFrameMaterialProps) & {
    key: string;
};

export declare type AnimatorFrameMaterialProps = {
    /** 颜色 */
    color?: Color;
    /** 纹理宽 */
    imageWidth: number;
    /** 纹理高 */
    imageHeight: number;
    /** 精灵有多少行 */
    rowCount: number;
    /** 精灵有多少列 */
    colCount: number;
    /** 精灵子图片的总个数 不输入时自动计算 */
    spriteCount?: number;
    /** 一个精灵宽 不输入时自动计算 */
    spriteWidth?: number;
    /** 一个精灵高 不输入时自动计算 */
    spriteHeight?: number;
    /** 当前运行时的帧数 */
    curRunFrameCount?: number;
    /** 是否停止 */
    isStop?: boolean;
    /** 停止时sprite的索引 默认0 */
    stopSpriteIndex?: number;
    /** 时间变量 */
    time?: Vector4 | {
        value: Vector4;
    };
    /** Material side, default: BackSide */
    side?: Side;
    /** Material depthWrite, default: false */
    depthWrite?: boolean;
    /** 纹理 */
    map?: Texture;
    [key: string]: any;
};

/**
 * 动画模块
 */
export declare class AnimatorModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    animators: Animator[];
    constructor(entity: Entity, options?: AnimatorModuleOptions | Animator);
    setupUiConfig(): {
        type: string;
        expanded: boolean;
        app: App;
        label: string;
        children: ((() => {
            type: string;
            label: string;
            property: (string | {
                index: number;
            })[];
            bounds: number[];
            stepSize: number;
            onChange: (v: any) => void;
        }) | (() => UiObjectConfig<any, string, any>))[];
    };
    /**
     * 根据索引获取动画库。默认是第0个
     * @param index 增加一个动画库
     */
    getAnimator(index?: number): Animator;
    /**
     * 增加一个动画库
     * @param index
     */
    addAnimator(options: AnimatorOptions): Animator;
    /**
     * 删除一个动画库
     * @param index
     */
    removeAnimator(index: number | Animator): void;
    onAppUpdate(time: Time): void;
}

/**
 * 生成动画选项
 */
export declare interface AnimatorModuleOptions {
    /** 关联动画的对象 */
    object?: Object3D | Object3D[] | Entity | Entity[];
    /** 动画剪辑 */
    animations?: AnimationClip[] | AnimationClip | AnimationClipOptions | AnimationClipOptions[];
}

/**
 * 生成动画选项
 */
export declare interface AnimatorOptions {
    /** 关联动画的对象 */
    object: Object3D | Object3D[] | Entity | Entity[];
    /** 关键帧动画 */
    animations?: AnimationClip[] | AnimationClip | AnimationClipOptions | AnimationClipOptions[];
}

/**
 * Type for any function
 */
export declare type AnyFunction = (...args: any[]) => any;

/**
 * Type for any object
 */
export declare type AnyOptions = Record<string, any>;

export declare class App extends AppBase implements IWebGLRendererModule, ISceneModule, ICameraModule, ICSS2DRendererModule, ICSS3DRendererModule, ICoordSystemModule, IEntityManagerModule, IEntityQueryModule, IStatModule, IInputModule, IOrbitControlModule, IPickModule, IRectCollideModule, IToolStateModule, ICommandModule, IParticleRenderModule, IPhysicsManagerModule, IUiModule, IPostProcessModule {
    #private;
    /** 渲染器 */
    readonly renderer: WebGLRenderer;
    /** 2d渲染器 */
    readonly css2dRenderer: CSS2DRenderer;
    /** 获取所有的marker2d */
    getMarker2Ds: () => Marker2D[];
    /**获取所有的popup2d */
    getPopup2Ds: () => Popup2D[];
    /** 全局的popup对象 */
    readonly popup2d: Popup2D;
    /** css3d渲染器 */
    readonly css3dRenderer: CSS3DRenderer;
    /** 能遮挡的css3d渲染器 */
    readonly css3dOccludeRenderer: CSS3DRenderer;
    /** 设置3d物体能否被场景遮挡 */
    setCss3dObjectCanOcclude: (object: CSS3DObject, canOcclude?: boolean) => void;
    /** 获取渲染截图 */
    getScreenshot: (params?: Screenshot) => Promise<Blob | null | undefined>;
    /** 地图模式 */
    readonly isMapMode: boolean;
    readonly commonUniforms: {
        time: Uniform_2<Vector4>;
        resolution: Uniform_2<Vector2>;
        iGlobalTime: Uniform_2<number>;
        iTime: Uniform_2<number>;
        iTimeDelta: Uniform_2<number>;
        iResolution: Uniform_2<Vector3>;
        iMouse: Uniform_2<Vector4>;
        iFrame: Uniform_2<number>;
        iDate: Uniform_2<Vector4>;
        iSampleRate: Uniform_2<number>;
        iChannelTime: Uniform_2<[number, number, number, number]>;
    };
    /** 增加场景 */
    addScene: (scene?: Scene, camera?: CameraOptions) => Scene;
    /** 切换场景 */
    activeScene: (_scene: Scene) => Promise<void>;
    /** 设置场景，（将删除之前场景，增加此场景此把此场景设置为当前场景） */
    setScene: (scene?: Scene, camera?: CameraOptions) => Promise<Scene>;
    /** 移除场景 */
    removeScene: (_scene: Scene) => Promise<void>;
    /** 初始化场景 */
    initScene: (scene: Scene) => void;
    /** 清空所有场景 */
    clearScenes: () => void;
    /** 场景实体 */
    readonly sceneEntity: Entity;
    /** 增加缺省灯光 */
    addDefaultLights: (scene?: Scene) => {};
    /** 获取场景的统计数据 */
    getSceneStatData: () => {
        /** 物体对象数 */
        objects: number;
        /** 顶点数 */
        vertices: number;
        /** 三角形数 */
        triangles: number;
    };
    /** 环境变量 */
    readonly envConfig: EnvConfigOption & {
        [key: string]: any;
    };
    /** 设置环境变量 */
    setEnvConfig: (key: keyof EnvConfigOption, value: any) => void;
    /** 设置场景背景及环境参数 */
    setBackgroundEnvironment: (options?: BackgroundEnvironmentOptions) => Promise<void>;
    /** 获取焦点 */
    setFocus: () => void;
    /** 加载资源数组 */
    loadResources: (_resources: ResourceItem[], options?: loadResourcesOptions) => Promise<RosourceItemsReturnType>;
    /** 获取通过loadResources已加载的资源 */
    getLoadedResources: () => RosourceItemsReturnType;
    getEntities: () => Entity[];
    getRayQueryEntities: () => Entity[];
    addSelectedEntity: (ent: Entity) => {};
    removeSelectEntity: (ent: Entity) => {};
    getSelectObjects: () => Object3D[];
    getSelectObjectsRef: () => ShallowReactive<Object3D[]>;
    addBloomEntity: (ent: Entity) => {};
    removeBloomEntity: (ent: Entity) => {};
    getBloomObjects: () => Object3D[];
    getBloomObjectsRef: () => ShallowReactive<Object3D[]>;
    addOutlineEntity: (ent: Entity) => {};
    removeOutlineEntity: (ent: Entity) => {};
    getOutlineObjects: () => Object3D[];
    getOutlineObjectsRef: () => ShallowReactive<Object3D[]>;
    setSelectBoomRefreshFlag: () => void;
    showStat: boolean;
    /**是否显示视角显示器 */
    viewHelperEnable: boolean;
    /**
     * 设置相机朝向
     * @param position 相机位置
     * @param lookAt 朝向
     * @param options 选项
     */
    setCameraLookAt: (position: Vector3, lookAt: Vector3, options?: boolean | Record<string, any>) => void;
    /** 是否启用相机控制器 */
    enableCameraControl: boolean;
    /** 相机控制器响应式对象 */
    enableCameraControlRef: Ref<boolean>;
    /** 当相机禁止时还允许滚轮进行缩放操作 */
    enableWheelWhenCtrlDisabled: boolean;
    /**
     * 屏幕坐标转世界坐标
     * @param x
     * @param y
     * @param opts (undefined根据地图配置决定， false 不用场景数据, true用场景数据)  深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面) 或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
     * @param retIntersectObject 如果需要返回与哪个实体相交而转化的世界坐标，可传入一个object对象
     */
    unproject: (x: number | Vector2, y?: number, opts?: UnProjectOpts, retIntersectObject?: {}) => Vector3 | undefined;
    /**
     * 屏幕坐标转世界坐标（同 unproject 函数，不同的地方是他支持通过后期处理的深度进行转换，是异步执行的）
     * @param x  屏幕坐标x
     * @param y 屏幕坐标y
     * @param opts (false 不用场景数据, true用场景数据) "depth" 后期处理的深度进行转换，  深度值 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面) 或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
     * @param retIntersectObject 如果需要返回与哪个实体相交而转化的世界坐标，可传入一个object对象
     */
    unprojectAsync: (x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}) => Promise<Vector3 | undefined>;
    /**
     * 世界坐标转屏幕坐标
     */
    project: (x: number | Vector3, y?: number, z?: number) => Vector2;
    /**
     * 屏幕坐标转NDC坐标
     */
    screenToNdc: (x: number | Vector2, y?: number) => Vector2;
    /**
     * NDC坐标转屏幕坐标
     */
    ndcToScreen: (x: number | Vector2, y?: number) => Vector2;
    /**
     * 设置的中心点坐标
     */
    centerOrigin: Vector3 | undefined;
    /**
     * 开始缩放比例，x,y,z方向都同比例缩放，默认1
     */
    scaleOrigin: number | undefined;
    /**
     * 当前应该是否处于自由状态
     */
    isFreeStatus: boolean;
    /**
     * 自由状态响应式对象
     */
    isFreeStatusRef: Ref<boolean>;
    /**
     * 拾取一个点
     */
    pickPoint: (opts?: PickPointOptions) => Promise<{
        cancel: boolean;
        point?: Vector3;
        reason?: string;
        intersectObject?: any;
        event?: InteractiveEvent;
    }>;
    /**
     * 拾取实体
     */
    pickEntity: (opts?: PickEntityOptions) => Promise<{
        cancel: boolean;
        entities: Entity[];
        reason?: string;
        clearHighlight: Function;
    }>;
    /**
     * 绘制一个选择框
     */
    drawSelectBox: (style?: Record<string, any>) => Promise<{
        cancel: boolean;
        reason?: string;
    } | [Vector2, Vector2]>;
    /**
     * 绘制一个点，获取点坐标
     */
    actionDrawPoint: (opts?: IDrawPointEnterOptions) => Promise<{
        isCancel?: boolean;
        data: SymbolItemData;
    }>;
    /**
     * 绘制一条线，获取线坐标
     */
    actionDrawLineSting: (opts?: IDrawLineEnterOptions) => Promise<{
        isCancel?: boolean;
        data: PolylineItemData;
    }>;
    /**
     * 绘制一个多边形，获取多边形坐标
     */
    actionDrawPolygon: (opts?: IDrawPolygonEnterOptions) => Promise<{
        isCancel?: boolean;
        data: PolygonItemData;
    }>;
    actionDrawEdit: (opts?: IDrawEditEnterOptions) => Promise<{}>;
    /** 选中一个实体对象 */
    actionPickSelect: (opts?: PickEnterOptions) => Promise<{
        isCancel: boolean;
        info?: TLEventHandler;
        select?: InteractiveObject;
    }>;
    /** 通过图层名称获取当前绘图层的实体 */
    getDrawLayer: (layerName?: string, noCreateStyle?: Record<string, any>) => {
        symbol: () => SymbolEntity | undefined;
        polylines: () => PolylinesEntity | undefined;
        polygons: () => PolygonsEntity | undefined;
        addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
        addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
        addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
        updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
        updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
        updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
        deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
        deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
        deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
    };
    addPointerEventsObject: (entity: Entity) => {};
    removePointerEventsObject: (entity: Entity) => {};
    Input: {
        /** 获取键是否开始按下 exam: getKeyDown("KeyW") */
        getKeyDown: (keyCode: string) => boolean;
        /** 获取键是否按住 如 Space Enter ShiftLeft ControlLeft */
        getKeyPressed: (keyCode: string) => boolean;
        /** 获取键是否松开 */
        getKeyUp: (keyCode: string) => boolean;
        x: () => number;
        y: () => number;
        movementX: () => number;
        movementY: () => number;
        isMoving: () => boolean;
        isDragging: () => boolean;
        isLeftButtonDown: () => boolean;
        isLeftButtonPressed: () => boolean;
        isLeftButtonUp: () => boolean;
        isRightButtonDown: () => boolean;
        isRightButtonPressed: () => boolean;
        isRightButtonUp: () => boolean;
        isMidButtonDown: () => boolean;
        isMidButtonPressed: () => boolean;
        isMidButtonUp: () => boolean;
        enabled: () => boolean;
        setEnable: (b: boolean) => {};
        /** 是否可用的响应式对象 */
        enabledRef: () => Ref<boolean>;
        /** 当前离鼠标最近的物体实体 */
        closestObject: () => InteractiveObject | undefined | null;
    };
    /**
     * 设置地图右键上下文菜单，运行时将触发 上下文菜单将要打开`contextMenuPreOpen`, 上下文菜单已打开`contextMenuOpened`, 上下文菜单打开无内容`contextMenuNoContent`事件
     * @param menu 获取菜单的函数
     * @param key 多次调用setMenu时，同样的key会覆盖之前的事件函数；有多个key时，调用次序为key的字母次序倒序；多次调用时，直到函数返回一个非null的ContextMenu为止
     */
    setMenu: (menu?: (event: InteractiveEvent | any, object?: InteractiveObject) => ContextMenu | null | undefined, key?: string) => void;
    /**
     * 通过相机查询实体
     */
    queryEntitiesByCamera: (option?: EntityQueryOption) => InteractiveObject;
    /**
     * 通过射线查询实体
     */
    queryEntitiesByRaycast: (ray: Ray, option?: EntityQueryOption) => InteractiveObject;
    /**
     * 通过屏幕像素坐标查询实体
     */
    queryEntitiesByScreenPos: (x: number, y: number, option?: EntityQueryOption) => InteractiveObject;
    /**
     * 通过框选查询实体
     */
    queryEntitiesByBox: (startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number) => InteractiveObject[];
    /**
     * 通过屏幕坐标获取射线
     */
    getRayByScreenPos: (x: number, y: number, camera?: Camera) => Ray;
    /**
     * 获取查询的射线对象
     */
    getQueryRaycaster: () => Raycaster;
    /** 效果合成器 */
    readonly composer: EffectComposer_3;
    /** 效果合成器是否可用 */
    isComposerEnable: () => boolean;
    /** 设置效果合成器是否可用 */
    setComposerEnable: (b: boolean) => void;
    /** 给效果合成器增加渲染通道 */
    addEffectRenderPass: (pass: Pass_3, orderIndex?: number) => void;
    /** 给效果合成器移除渲染通道 */
    removeEffectRenderPass: (pass: Pass_3) => void;
    /** 刷新渲染通道 foreceUpdate是否强制更新*/
    refreshEffectRenderPass: (foreceUpdate?: boolean) => void;
    /** 根据屏幕坐标获取深度值 */
    getDepth: (x: number, y: number) => Promise<number>;
    /** OutlineEffect */
    readonly outlineEffect: OutlineEffect_3;
    /** bloomEffect */
    readonly bloomEffect: SelectiveBloomEffect_2;
    /** selectedEffect */
    readonly selectedEffect: OutlineEffect_3;
    /** 后期处理是否空闲 */
    readonly isPostProcessIdle: boolean;
    /** 增加碰撞检测的对象 */
    addCollideRectObject: (item: IRectCollide) => void;
    /** 移除碰撞检测的对象 */
    removeCollideRectObject: (item: IRectCollide) => void;
    /** 更新碰撞检测 */
    updateCollideRect: () => void;
    /** 设置更新碰撞检测为脏数据，使其重新检测 */
    setCollideRectDirty: () => void;
    readonly rootState: StateNode;
    getStatePath: () => string;
    stateIsIn: (path: string) => boolean;
    stateInAny: (...paths: string[]) => boolean;
    setCurrentTool: (id?: string, info?: Record<string, any>) => App;
    getCurrentTool: () => StateNode;
    getCurrentToolId: () => string;
    getStateDescendant: <T extends StateNode>(path: string) => T | undefined;
    addTool: (Tool: TLStateNodeConstructor) => void;
    removeTool: (Tool: TLStateNodeConstructor) => void;
    /**
     * 判断当前是否有工具处于运行中
     */
    isInActiveTool: () => boolean;
    /**
     * 是否正在交互
     */
    isInteracting: () => boolean;
    /**
     *  对一个物体进行变换控制器操作
     */
    transformObject: (options: TransformEnterOptions) => Promise<StateNode>;
    readonly commandHistory: CommandHistory;
    /** 清空命令 */
    clearCommands: () => void;
    /** 执行命令，自动执行 */
    executeCommand: (cmd: ICommand) => void;
    /** 执行所有命令，自动执行 */
    executeAllCommands: (cmds: ICommand[]) => void;
    /** 执行多个命令，自动执行 */
    executeManyCommands: (...cmds: ICommand[]) => void;
    /** 增加命令，不会自动执行 */
    addCommand: (cmd: ICommand) => void;
    /** 增加所有命令，不会自动执行 */
    addAllCommands: (cmds: ICommand[]) => void;
    /** 增加多个命令，不会自动执行 */
    addManyCommands: (...cmds: ICommand[]) => void;
    /** 撤销 */
    undo: () => any;
    /** 还原 */
    redo: () => any;
    /**
     * 增加控件 (会调用 `control.onAdd(this)` ).
     *
     * @param control 需要增加的控件.
     * @param {string} [position] 位置. 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
     */
    addControl: (control: IControl, position?: ControlPosition) => App;
    /**
     * 移除控件.
     *
     * @param {IControl} control 要移除的控件.

     */
    removeControl: (control: IControl) => App;
    /**
     * 是否有控件.
     *
     * @param {IControl} control 要查询的控件.
     */
    hasControl: (control: IControl) => void;
    /**
     * 设置光标
     * @param cur 光标名称
     */
    setCursor: (cur: string) => void;
    /**
     * 获取配置面板
     */
    getConfigPane: (opts?: {
        /** 是否清空，默认是 */
        isReset?: boolean;
        /** 标题 */
        title?: string;
        /** 样式 */
        style?: Partial<CSSStyleDeclaration>;
    }) => Promise<{
        configPane: any;
        rootPane: any;
        element: HTMLElement;
        isInit: boolean;
        setVisible: (b: boolean) => void;
        isVisible: () => boolean;
        reset: () => void;
        appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
        renderUiConfig: (uiConfig: UiObjectConfig) => void;
        renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
    }>;
    /**
     * 信息弹窗提示
     * text（必填）：需要输出的文本
     * type（可选）：输出类型 默认是 "log"
     * time（可选）：停留时间 默认是 2500
     */
    logInfo: (text: string, type?: logInfoType | number, time?: number) => void;
    readonly particleRenderer: BatchedRenderer;
    /**
     *  增加粒子系统
     * @param system   粒子系统参数
     * @param parent  parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中
     * @param disposeWhenEnd 当结束时自动删除，默认为true
     * @returns
     */
    addParticleSystem: (system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean) => void;
    /** 增加粒子 */
    addParticle: (opts: {
        /** 粒子系统参数 */
        system: ParticleSystemParameters;
        /** 粒子模拟行为  */
        simulations?: Simulation | Simulation[];
        /** 名称 */
        name?: string;
        /** 位置  */
        position?: Vector3 | [number, number, number];
        /** 旋转 */
        rotation?: Vector3 | [number, number, number];
        /** 缩放 */
        scale?: Vector3 | [number, number, number] | number;
        /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
        parent?: Object3D;
        /** 当结束时自动删除，默认为true */
        disposeWhenEnd?: boolean;
    }) => ParticleEmitter<Object3DEventMap>;
    /** 从文件加载粒子场景 */
    loadParticle: (url: string, opts?: {
        /** 粒子系统参数 */
        system?: ParticleSystemParameters;
        /** 粒子模拟行为 */
        simulations?: Simulation | Simulation[];
        /** 名称 */
        name?: string;
        /** 位置 */
        position?: Vector3 | [number, number, number];
        /** 旋转 */
        rotation?: Vector3 | [number, number, number];
        /** 缩放 */
        scale?: Vector3 | [number, number, number] | number;
        /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
        parent?: Object3D;
        /** 当结束时自动删除，默认为true */
        disposeWhenEnd?: boolean;
        /** 加载完json的回调 可对json进行修改 */
        onData?: (data: any) => any;
        /** 加载粒子系统前回调 */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        crossOrigin?: string;
        withCredentials?: boolean;
        urlPath?: string;
        resourcePath?: string;
        requestHeader?: {
            [header: string]: string;
        };
    }) => Promise<ParticleEmitter<Object3DEventMap>>;
    /** 从JSON字符串加载粒子场景 */
    loadParticleFromJson: (json: string | JSON, opts?: {
        /** 粒子系统参数 */
        system?: ParticleSystemParameters;
        /** 粒子模拟行为  */
        simulations?: Simulation | Simulation[];
        /** 名称 */
        name?: string;
        /** 位置  */
        position?: Vector3 | [number, number, number];
        /** 旋转 */
        rotation?: Vector3 | [number, number, number];
        /** 缩放 */
        scale?: Vector3 | [number, number, number] | number;
        /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
        parent?: Object3D;
        /** 当结束时自动删除，默认为true */
        disposeWhenEnd?: boolean;
        /** 加载粒子系统前回调 */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        /** 加载数据完成回调 */
        onData?: (data: any) => any;
    }) => ParticleEmitter<Object3DEventMap>;
    /** 从资源加载粒子场景 */
    loadParticleFromRes: (obj: Object3D, opts?: {
        /** 粒子系统参数 */
        system?: ParticleSystemParameters;
        /** 粒子模拟行为  */
        simulations?: Simulation | Simulation[];
        /** 名称 */
        name?: string;
        /** 位置  */
        position?: Vector3 | [number, number, number];
        /** 旋转 */
        rotation?: Vector3 | [number, number, number];
        /** 缩放 */
        scale?: Vector3 | [number, number, number] | number;
        /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
        parent?: Object3D;
        /** 当结束时自动删除，默认为true */
        disposeWhenEnd?: boolean;
        /** 加载粒子系统前回调 */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
    }) => ParticleEmitter<Object3DEventMap>;
    /** 移除粒子系统 */
    removeParticle: (obj: ParticleEmitter<Object3DEventMap>) => void;
    /** 是否能用物理引擎 */
    physicsEnable: boolean;
    /** 得到物理引擎世界对象 */
    readonly physicsWorld: World;
    /** 得到物理引擎对象 */
    readonly physicsEngine: typeof CANNON;
    /** 启动物体引擎 */
    enablePhysicsEngine: () => Promise<typeof CANNON>;
    /** 增加物理刚体 */
    addPhysicsBody: (phyObject: MeshPhysicsObjectParams) => MeshPhysicsObjectParams;
    /** 通过实体或对象移除物理刚体 */
    removePhysicsObject: (object: Object3D | Entity) => void;
    /** 增加一个物理地面 */
    addPhysicsGround: () => CANNON.Plane;
    /** 设置物理引擎调试 */
    setPhysicsDebugger: (enable: boolean) => void;
    isApp: boolean;
    static defaultModules: Array<AppModuleConstructor | [AppModuleConstructor, string]>;
    /** 注册的模块 */
    static registerModules: Set<EntityModuleConstructor>;
    signal: {
        /** 物体选择信息改变事件 */
        onSelectedChange: Signal;
        onEntitySelected: Signal;
        onEntityUnSelected: Signal;
        onBloomedChange: Signal;
        onEntityBloomed: Signal;
        onEntityUnBloomed: Signal;
        onOutlineChange: Signal;
        onEntityOutline: Signal;
        onEntityUnOutline: Signal;
        onMouseUp: Signal;
        onMouseMove: Signal;
        onMouseDown: Signal;
        onMousePreClick: Signal;
        onMouseClick: Signal;
        onMouseDblClick: Signal;
        onMouseOver: Signal;
        onMouseOut: Signal;
        onMouseEnter: Signal;
        onMouseLeave: Signal;
        onContextMenu: Signal;
        onPointerDown: Signal;
        onPointerMove: Signal;
        onPointerUp: Signal;
        /** 鼠标直接按下松开，没有拖动 */
        onPointerDownUp: Signal;
        onPointerCancel: Signal;
        onMouseWheel: Signal;
        onKeyDown: Signal;
        onKeyUp: Signal;
        onAppBeforeUpdate: Signal;
        onAppUpdate: Signal;
        onAppAfterUpdate: Signal;
        onAppBeforeRender: Signal;
        onAppRender: Signal;
        onAppAfterRender: Signal;
        onAppBeforeAddEntity: Signal;
        onAppAddEntity: Signal;
        onAppBeforeRemoveObject: Signal;
        onAppRemoveObject: Signal;
        onAppBeforeRemoveEntity: Signal;
        onAppRemoveEntity: Signal;
        /** 窗口大小变化事件 */
        onContainerSizeChange: Signal;
        /** 相机控件事件 */
        onCameraControl: Signal;
        /** 相机更新事件 */
        onCameraUpdate: Signal;
        /** 相机变化事件，当相机对象变化或远近裁剪面变化时触发 */
        onCameraChange: Signal;
        /** 上下文菜单即将打开 */
        contextMenuPreOpen: Signal;
        /** 没有上下文菜单  */
        contextMenuOpened: Signal;
        /** 上下文菜单已打开 */
        contextMenuNoContent: Signal;
        /** 上下文菜单取消 */
        contextMenuCancel: Signal;
        /** 自定义事件 */
        onCustomEvent: Signal;
        /** 新增场景 */
        onAddScene: Signal;
        /** 把场景置为当前 */
        onActiveScene: Signal;
        /** 移除场景 */
        onRemoveScene: Signal;
    };
    /** 三维场景中地图实体 */
    mapViewEntity: MapViewEntity;
    svc: Service;
    constructor(svc: Service, options?: AppOptions);
    setupUiConfig(): {
        type: string;
        expanded: boolean;
        app: any;
        label: string;
        children: (() => (UiObjectConfig<any, string, any> | {
            type: string;
            expanded: boolean;
            label: any;
            children: any[];
        })[])[];
    };
    dispose(): void;
    fromJSON(json: Record<string, any>): Promise<void>;
    toJSON(): {
        metadata: {};
        project: {};
        camera: any;
        scene: any;
        entities: any[];
    };
}

export declare class AppBase extends EventDispatcher {
    #private;
    readonly _modules: ModuleBase[];
    readonly options: AppBaseOptions;
    needRenderUpdate: boolean;
    readonly moduleManager: ModuleManager;
    data: ShallowReactive<{
        container?: HTMLElement;
        domElement?: HTMLElement;
        camera?: Camera;
        scene?: Scene;
        [key: string]: any;
    }>;
    containerSize: {
        width: number;
        height: number;
    };
    tweenManager: TweenManager;
    [key: string]: any;
    private _uiConfig;
    get uiConfig(): UiObjectConfig<any, string, any>;
    constructor(param?: AppBaseOptions);
    private readonly _animate;
    get container(): HTMLElement;
    set container(value: HTMLElement);
    get domElement(): HTMLElement;
    set domElement(value: HTMLElement);
    get camera(): Camera;
    set camera(value: Camera);
    get scene(): Scene;
    set scene(value: Scene);
    get cameraControl(): CameraControls;
    /**
     * Whether the engine is paused.
     */
    get isPaused(): boolean;
    /**
     * 在vSyncCount被设置为0时才能生效，而当其设置为大于0时，则不生效。
     当vSyncCount为1时，游戏帧率会与设备的刷新帧率保持一致，例如一台设备刷新频率是60Hz则，此时其游戏帧率为60FPS
     当vSyncCount为2时，游戏帧率会设置为刷新帧率的一半，例如一台设备刷新帧率是60Hz时，则游戏帧率为30FPS
     * @remarks 0 means that the vertical synchronization is turned off.
     */
    get vSyncCount(): number;
    set vSyncCount(value: number);
    /**
     * The time information of the engine.
     */
    get time(): Time;
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
    get targetFrameRate(): number;
    set targetFrameRate(value: number);
    /**
     * 下帧回调
     */
    onNextFrame(callback: (app: AppBase) => void): void;
    /**
     * Pause the engine.
     */
    pause(): void;
    /**
     * Resume the engine.
     */
    resume(): void;
    /**
     * Execution engine loop.
     */
    run(): void;
    /**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */
    update(): void;
    /**
     * Indicates whether the engine is destroyed.
     */
    get destroyed(): boolean;
    private _destroy;
    /**
     * Destroy engine.
     * @remarks If call during frame execution will delay until the end of the frame
     */
    destroy(): void;
    /**
     * 增加模块，等同于this.add(xxx)
     */
    addModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T, params?: U): T;
    /**
     * 增加模块，等同于this.addModule(xxx)
     */
    add<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T, params?: U): T;
    getModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T): T;
    removeModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T): void;
    removeAllModules(): void;
    callModules(methodName: string, ...args: any): void;
}

export declare interface AppBaseOptions {
    /** 应用容器 */
    container?: string | HTMLElement;
    /** 是否自动开始，默认true */
    autoStart?: boolean;
    /** 启动tween管理 默认true*/
    enableTweenManager?: boolean;
    /** 是否是临时创建的app对象 */
    isTemp?: boolean;
    /** 离屏渲染画布参数 */
    offscreenCanvas?: {
        width: number;
        height: number;
    };
}

/**
 * Apply collision to particles from a physics resolver.
 */
export declare class ApplyCollision implements Simulation {
    resolver: PhysicsResolver;
    bounce: number;
    type: string;
    tempV: Vector3;
    constructor(resolver: PhysicsResolver, bounce: number);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

/**
 * Apply a global force to particles.
 */
export declare class ApplyForce implements Simulation {
    direction: Vector3;
    magnitude: ValueGenerator;
    type: string;
    magnitudeValue: number;
    constructor(direction: Vector3, magnitude: ValueGenerator);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

export declare const applyMixins: (toClassInst: any, fromClasseInst: any, methodNames: string[]) => () => void;

export declare class ApplyRoute implements Simulation {
    type: string;
    paths: [number, number, number][];
    _allDistance: number;
    _segmentDist: number[];
    _nextPoint: [number, number, number];
    _time: number;
    _curtime: number;
    constructor(paths: [number, number, number][], time?: number);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

/**
 * Apply sequences to particles.
 * {@link Sequencer}
 */
export declare class ApplySequences implements Simulation {
    static BEZIER: Bezier;
    type: string;
    sequencers: Array<[IntervalValue, Sequencer]>;
    time: number;
    index: number;
    pCount: number;
    delay: number;
    tempV: Vector3;
    constructor(delayBetweenParticles: number);
    initialize(particle: Particle): void;
    reset(): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    appendSequencer(range: IntervalValue, sequencer: Sequencer): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
}

/**
 * 矩阵左乘向量
 */
declare function applyTransform<T extends VectorArray>(out: T, v: VectorArray, m: MatrixArray): T;

export declare class AppModuleBase extends ModuleBase {
    constructor(app?: App);
}

export declare type AppModuleConstructor = new (obj: any) => AppModuleBase;

/**
 * EntityBase.
 */
export declare abstract class AppObject extends EventDispatcher {
    #private;
    private static _instanceIdCounter;
    readonly instanceId: number;
    _app?: App;
    onSetApp: Signal;
    data: ShallowReactive<{
        [key: string]: any;
    }>;
    extData: {
        [key: string]: any;
    };
    private _uiConfig;
    get uiConfig(): UiObjectConfig<any, string, any>;
    protected _destroyed: boolean;
    constructor(app?: App);
    get app(): App;
    set app(value: App);
    /**
     * Whether it has been destroyed.
     */
    get destroyed(): boolean;
    /**
     * Destroy self.
     */
    destroy(): void;
    effectScope(fn: () => any): void;
    applyMixinsTo(toClassInst: any, methodNames?: string[], addMethods?: string[], filterName?: string[]): void;
    addDispose(cb: Function): void;
    removeDispose(cb: Function): void;
}

export declare interface AppOptions extends AppBaseOptions {
    render?: WebGLRendererModuleOptions;
    control?: OrbitControlModuleOptions;
    camera?: CameraModuleOptions;
    input?: InputModuleOptions;
    stat?: StatModuleOptions;
    scene?: SceneModuleOptions;
    css2dRender?: CSS2DRendererModuleOptions;
    css3dRender?: CSS3DRendererModuleOptions;
    modules?: Array<AppModuleConstructor | [AppModuleConstructor, string]>;
    postProcess?: PostProcessModuleOptions;
    coordSystem?: CoordSystemOption;
    entityOutline?: EntityOutlineModuleOptions;
    physics?: PhysicsManagerModuleOptions;
    ui?: UiModuleOptions;
}

export declare function approxArrayEquals(a: number[], b: number[], error?: number): boolean;

/** 两数是否近似相等 */
export declare function approxEquals(a: number, b: number, error?: number): boolean;

/** 是否近似为零 */
export declare function approxZero(number: number, error?: number): boolean;

declare class Arc extends Path<ArcProps> {
    shape: ArcShape;
    constructor(opts?: ArcProps);
    getDefaultStyle(): {
        stroke: string;
        fill: string;
    };
    getDefaultShape(): ArcShape;
    buildPath(ctx: CanvasRenderingContext2D, shape: ArcShape): void;
}

declare interface ArcProps extends PathProps {
    shape?: Partial<ArcShape>;
}

declare class ArcShape {
    cx: number;
    cy: number;
    r: number;
    startAngle: number;
    endAngle: number;
    clockwise?: boolean;
}

/**
 * Convert an ArrayBuffer to Base64 string
 * @param buffer - ArrayBuffer to convert
 * @category ArrayBuffer
 */
export declare function arrayBufferToBase64(buffer: ArrayBuffer): string;

/**
 * Collision "matrix".
 * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 */
declare class ArrayCollisionMatrix {
    /**
     * The matrix storage.
     */
    matrix: number[];
    constructor();
    /**
     * Get an element
     */
    get(bi: Body_2, bj: Body_2): number;
    /**
     * Set an element
     */
    set(bi: Body_2, bj: Body_2, value: boolean): void;
    /**
     * Sets all elements to zero
     */
    reset(): void;
    /**
     * Sets the max number of objects
     */
    setNumObjects(n: number): void;
}

/**
 * Not readonly ArrayLike
 * Include Array, TypedArray
 */
declare type ArrayLike_2<T> = {
    [key: number]: T;
    length: number;
};

declare function assert(condition: any, message?: string): void;

export declare type AtlasData = {
    data: Uint8ClampedArray;
    width: number;
    height: number;
    charInfo: Record<string, CharInfo>;
    maxAscent: number;
    lineHeight: number;
};

declare const AVERAGE: SplitStrategy;

export declare class AxisAngleGenerator implements RotationGenerator {
    axis: Vector3;
    angle: FunctionValueGenerator | ValueGenerator;
    type: 'rotation';
    constructor(axis: Vector3, angle: FunctionValueGenerator | ValueGenerator);
    genValue(quat: Quaternion, t?: number): Quaternion;
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): AxisAngleGenerator;
    clone(): RotationGenerator;
}

export declare interface BackgroundEnvironmentOptions {
    /** 自动创建房间环境 */
    roomEnvironment?: boolean;
    /** 背景 */
    background?: ColorRepresentation | BackgroundTexture;
    /** 环境 */
    environment?: BackgroundTexture;
    /** 背景模糊. (0-1) 缺省 0 */
    backgroundBlurriness?: number;
    /** 背景增强 缺省1. */
    backgroundIntensity?: number;
    /** 环境是否与背景一样 默认true*/
    environmentSameAsBackground?: boolean;
    /** 绘制坐标轴辅助对象 */
    showAxesHelper?: boolean;
    /** 坐标轴辅助对象大小 */
    axesHelperSize?: number;
    defaultLights?: boolean;
    /** 网格 */
    gridHelper?: GridHelperModuleOptions;
}

export declare interface BackgroundTexture {
    isHdr?: boolean;
    path?: string;
    texture?: DataTexture;
    url?: string | string[];
}

/**
 * Convert a Base64 string to ArrayBuffer
 * @param base64 - Base64 string to convert
 * @category ArrayBuffer
 */
export declare function base64ToArrayBuffer(base64: string): ArrayBuffer | Uint8Array;

export declare abstract class BaseCommand implements ICommand {
    app: App;
    /** 是否自动执行。默认是 */
    autoExecute?: boolean;
    callbacks?: ICommandCallback;
    abstract execute(): void;
    abstract undo(): void;
    redo(): void;
}

declare abstract class BaseCompiler {
    static Instance: BaseCompiler;
    constructor();
    visited: Set<string>;
    debug: boolean;
    protected buildExecutionOrder(graph: NodeGraph, context: ExecutionContext): void;
    private _traverseWire;
    private _traverse;
    abstract run(graph: NodeGraph, context: ExecutionContext): void;
    abstract build(graph: NodeGraph, context: ExecutionContext): string;
}

declare type BaseTypes = string | number | boolean;

/**
 * the class represents the batch renderer. a three.js scene should only have one batchedRenderer
 * It keeps references of all particle systems and rendering batch.
 * It batches all particle systems that has the same rendering pipeline to a single VFXBatch.
 */
export declare class BatchedRenderer extends Object3D {
    /**
     * Batches for rendering.
     * @type {Array<VFXBatch>}
     */
    batches: Array<VFXBatch>;
    /**
     * Map of systems to batch indices.
     * @type {Map<IParticleSystem, number>}
     */
    systemToBatchIndex: Map<IParticleSystem, number>;
    type: string;
    /**
     * Depth texture.
     * @type {Texture | null}
     */
    depthTexture: Texture | null;
    constructor();
    private static equals;
    /**
     * Adds a particle system to a batch.
     * @param {IParticleSystem} system - The particle system to add.
     */
    addSystem(system: IParticleSystem): void;
    /**
     * Deletes a particle system from its batch.
     * @param {IParticleSystem} system - The particle system to delete.
     */
    deleteSystem(system: IParticleSystem): void;
    /**
     * Sets the depth texture for all batches. it will be used for soft particles.
     * @param {Texture | null} depthTexture - The depth texture to set.
     */
    setDepthTexture(depthTexture: Texture | null): void;
    /**
     * Updates a particle system when the particle system has changed requires reloading.
     * @param {IParticleSystem} system - The particle system to update.
     */
    updateSystem(system: IParticleSystem): void;
    /**
     * Updates all batches.
     * @param {number} delta - The time delta for the update.
     */
    update(delta: number): void;
}

declare type BBox = BBox2d | BBox3d;

/**
 * Bounding box
 *
 * https://tools.ietf.org/html/rfc7946#section-5
 * A GeoJSON object MAY have a member named 'bbox' to include information on the coordinate range for its Geometries, Features, or FeatureCollections.
 * The value of the bbox member MUST be an array of length 2*n where n is the number of dimensions represented in the contained geometries,
 * with all axes of the most southwesterly point followed by all axes of the more northeasterly point.
 * The axes order of a bbox follows the axes order of geometries.
 */
declare type BBox2d = [number, number, number, number];

declare type BBox3d = [number, number, number, number, number, number];

/**
 * Base class of behavior tree implementation
 */
export declare class Behavior {
    /**
     * Any internal state used by the behavior
     * This provides a way to interact with the outside as well as to pass data between themselves
     */
    context: BehaviorContext;
    /**
     * Dispatched after initialization is complete
     * @readonly
     */
    onInitialized: Signal;
    /**
     * Dispatched after finalization is complete
     * @readonly
     */
    onFinalized: Signal;
    isBehavior: boolean;
    typeName: string;
    /**
     * Main update function. Every behavior executes some logic, some behaviors are long-running and some are instantaneous
     * @param {number} timeDelta time step in seconds
     * @returns {BehaviorStatus} signals status of the behavior, "success" or "failure" are used to signal completion of the behavior
     */
    tick(timeDelta: number): BehaviorStatus;
    /**
     * Called before behavior gets executed via tick for the first time
     * Used to prepare the behavior for execution
     * You can think of it as "start"
     */
    initialize(context: BehaviorContext): void;
    /**
     * Called when behavior is finished, or interrupted
     * Used to clean up any resources
     * You can think of it as "stop"
     */
    finalize(): void;
}

export declare interface BehaviorContext {
    entity: Entity;
}

export declare class BehaviorModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    behaviors: Behavior[];
    ids: string[];
    constructor(entity: Entity, behavior?: Behavior | Behavior[]);
    addBehavior(behavior: Behavior, id?: string): string;
    addAction(func: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined, id?: string): string;
    removeBehavior(behavior: Behavior): void;
    removeBehaviorByTypeName(typename: string): void;
    removeBehaviorById(id: string): void;
    getBehaviorById(id: string): Behavior;
    getBehaviors(): Behavior[];
    onAppUpdate(time: Time): void;
    setupUiConfig(): {
        type: string;
        expanded: boolean;
        label: string;
        children: (() => {
            type: string;
            expanded: boolean;
            app: App;
            label: string;
            children: {
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
            }[];
        }[])[];
    };
}

/**
 *
 * @enum {number}
 */
export declare enum BehaviorStatus {
    Initial = 0,
    Running = 1,
    Succeeded = 2,
    Failed = 3,
    Suspended = 4,
    Invalid = 5
}

export declare class BetterRaycastingPoints extends Points {
    isMapMode: boolean;
    raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}

export declare class Bezier {
    p: number[];
    constructor(p1: number, p2: number, p3: number, p4: number);
    genValue(t: number): number;
    derivativeCoefficients(points: number[]): number[][];
    getSlope(t: number): number;
    controlCurve(d0: number, d1: number): void;
    hull(t: number): any[];
    split(t: number): {
        left: Bezier;
        right: Bezier;
        span: any[];
    };
    clone(): Bezier;
    toJSON(): {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    };
    static fromJSON(json: {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    }): Bezier;
}

declare class BezierCurve extends Path<BezierCurveProps> {
    shape: BezierCurveShape;
    constructor(opts?: BezierCurveProps);
    getDefaultStyle(): {
        stroke: string;
        fill: string;
    };
    getDefaultShape(): BezierCurveShape;
    buildPath(ctx: CanvasRenderingContext2D, shape: BezierCurveShape): void;
    /**
     * Get point at percent
     */
    pointAt(t: number): number[];
    /**
     * Get tangent at percent
     */
    tangentAt(t: number): number[];
}

declare interface BezierCurveProps extends PathProps {
    shape?: Partial<BezierCurveShape>;
}

declare class BezierCurveShape {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    cpx1: number;
    cpy1: number;
    cpx2?: number;
    cpy2?: number;
    percent: number;
}

export declare class BidirectionalMap {
    fwdMap: {
        [sid: string]: number;
    };
    revMap: {
        [index: number]: string;
    };
    constructor(map: {
        [key: string]: number;
    });
    get(key: string): number | undefined;
    getByValue(value: number): string;
    add(sid: string, index: number): void;
    remove(sid: string): void;
    removeByValue(index: number): void;
}

export declare const Billboard: ({ object, follow, lockX, lockY, lockZ, baseOnPreRotation, }: BillboardProps) => BillboardType;

/**
 * 实体公告板模块
 */
export declare class BillboardModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    options: BillboardProps;
    billboard: BillboardType;
    constructor(entity: Entity, options?: BillboardProps);
    setupUiConfig(): {
        type: string;
        expanded: boolean;
        app: App;
        label: string;
        children: UiObjectConfig<any, string, any>[];
        onChange: (v: any) => void;
    };
    onAppUpdate(time: Time): void;
}

export declare type BillboardProps = {
    object?: Object3D;
    /**
     * @default true
     */
    follow?: boolean;
    /**
     * @default false
     */
    lockX?: boolean;
    /**
     * @default false
     */
    lockY?: boolean;
    /**
     * @default false
     */
    lockZ?: boolean;
    /**
     * 在原来的旋转基础上再面向相机
     * @default false
     */
    baseOnPreRotation?: boolean;
};

export declare interface BillBoardSettings {
}

export declare type BillboardType = {
    object: Object3D;
    /**
     * Should called every frame to update the billboard
     */
    update: (camera: Camera) => void;
    dispose: () => void;
    updateProps: (newProps: Partial<BillboardProps>) => void;
};

declare const bind: FunctionBind;

declare type Bind1<F, Ctx> = F extends (this: Ctx, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Bind2<F, Ctx, T1> = F extends (this: Ctx, a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Bind3<F, Ctx, T1, T2> = F extends (this: Ctx, a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Bind4<F, Ctx, T1, T2, T3> = F extends (this: Ctx, a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Bind5<F, Ctx, T1, T2, T3, T4> = F extends (this: Ctx, a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param fns list of member function names
 * @param context the context value
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
export declare function bindAll(fns: string[], context: Object): void;

declare type BindFunc<Ctx> = (this: Ctx, ...arg: any[]) => any;

/**
 * Dynamically sized bit field
 * @constructor
 */
export declare function BitSet(): void;

export declare namespace BitSet {
    var fixedSize: (x: any) => any;
}

export { BlendFunction }

/**
 * Convert a blob to a data url.
 * @param blob - blob to convert
 * @category Browser
 */
export declare function blobToDataURL(blob: Blob): Promise<string>;

export { BloomEffect }

declare class BlurPass {
    renderTargetA: WebGLRenderTarget;
    renderTargetB: WebGLRenderTarget;
    convolutionMaterial: ConvolutionMaterial;
    scene: Scene;
    camera: Camera;
    screen: Mesh;
    renderToScreen: boolean;
    constructor({ gl, resolution, width, height, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, }: BlurPassProps);
    render(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, outputBuffer: WebGLRenderTarget): void;
}

declare interface BlurPassProps {
    gl: WebGLRenderer;
    resolution: number;
    width?: number;
    height?: number;
    minDepthThreshold?: number;
    maxDepthThreshold?: number;
    depthScale?: number;
    depthToBlurRatioBias?: number;
}

/**
 * Base class for all body types.
 * @example
 *     const shape = new CANNON.Sphere(1)
 *     const body = new CANNON.Body({
 *       mass: 1,
 *       shape,
 *     })
 *     world.addBody(body)
 */
declare class Body_2 extends EventTarget_2 {
    static idCounter: number;
    /**
     * Dispatched after two bodies collide. This event is dispatched on each
     * of the two bodies involved in the collision.
     * @event collide
     * @param body The body that was involved in the collision.
     * @param contact The details of the collision.
     */
    static COLLIDE_EVENT_NAME: string;
    /**
     * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
     */
    static DYNAMIC: 1;
    /**
     * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
     */
    static STATIC: 2;
    /**
     * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
     */
    static KINEMATIC: 4;
    /**
     * AWAKE
     */
    static AWAKE: 0;
    /**
     * SLEEPY
     */
    static SLEEPY: 1;
    /**
     * SLEEPING
     */
    static SLEEPING: 2;
    /**
     * Dispatched after a sleeping body has woken up.
     * @event wakeup
     */
    static wakeupEvent: {
        type: string;
    };
    /**
     * Dispatched after a body has gone in to the sleepy state.
     * @event sleepy
     */
    static sleepyEvent: {
        type: string;
    };
    /**
     * Dispatched after a body has fallen asleep.
     * @event sleep
     */
    static sleepEvent: {
        type: string;
    };
    /**
     * Identifier of the body.
     */
    id: number;
    /**
     * Position of body in World.bodies. Updated by World and used in ArrayCollisionMatrix.
     */
    index: number;
    /**
     * Reference to the world the body is living in.
     */
    world: World | null;
    vlambda: Vec3;
    /**
     * The collision group the body belongs to.
     * @default 1
     */
    collisionFilterGroup: number;
    /**
     * The collision group the body can collide with.
     * @default -1
     */
    collisionFilterMask: number;
    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
     */
    collisionResponse: boolean;
    /**
     * World space position of the body.
     */
    position: Vec3;
    previousPosition: Vec3;
    /**
     * Interpolated position of the body.
     */
    interpolatedPosition: Vec3;
    /**
     * Initial position of the body.
     */
    initPosition: Vec3;
    /**
     * World space velocity of the body.
     */
    velocity: Vec3;
    /**
     * Initial velocity of the body.
     */
    initVelocity: Vec3;
    /**
     * Linear force on the body in world space.
     */
    force: Vec3;
    /**
     * The mass of the body.
     * @default 0
     */
    mass: number;
    invMass: number;
    /**
     * The physics material of the body. It defines the body interaction with other bodies.
     */
    material: Material_2 | null;
    /**
     * How much to damp the body velocity each step. It can go from 0 to 1.
     * @default 0.01
     */
    linearDamping: number;
    /**
     * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
     */
    type: BodyType;
    /**
     * If true, the body will automatically fall to sleep.
     * @default true
     */
    allowSleep: boolean;
    /**
     * Current sleep state.
     */
    sleepState: BodySleepState;
    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @default 0.1
     */
    sleepSpeedLimit: number;
    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @default 1
     */
    sleepTimeLimit: number;
    timeLastSleepy: number;
    wakeUpAfterNarrowphase: boolean;
    /**
     * World space rotational force on the body, around center of mass.
     */
    torque: Vec3;
    /**
     * World space orientation of the body.
     */
    quaternion: Quaternion_2;
    /**
     * Initial quaternion of the body.
     */
    initQuaternion: Quaternion_2;
    previousQuaternion: Quaternion_2;
    /**
     * Interpolated orientation of the body.
     */
    interpolatedQuaternion: Quaternion_2;
    /**
     * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
     */
    angularVelocity: Vec3;
    /**
     * Initial angular velocity of the body.
     */
    initAngularVelocity: Vec3;
    /**
     * List of Shapes that have been added to the body.
     */
    shapes: Shape[];
    /**
     * Position of each Shape in the body, given in local Body space.
     */
    shapeOffsets: Vec3[];
    /**
     * Orientation of each Shape, given in local Body space.
     */
    shapeOrientations: Quaternion_2[];
    /**
     * The inertia of the body.
     */
    inertia: Vec3;
    invInertia: Vec3;
    invInertiaWorld: Mat3;
    invMassSolve: number;
    invInertiaSolve: Vec3;
    invInertiaWorldSolve: Mat3;
    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
     * @default false
     */
    fixedRotation: boolean;
    /**
     * How much to damp the body angular velocity each step. It can go from 0 to 1.
     * @default 0.01
     */
    angularDamping: number;
    /**
     * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
     */
    linearFactor: Vec3;
    /**
     * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
     */
    angularFactor: Vec3;
    /**
     * World space bounding box of the body and its shapes.
     */
    aabb: AABB;
    /**
     * Indicates if the AABB needs to be updated before use.
     */
    aabbNeedsUpdate: boolean;
    /**
     * Total bounding radius of the Body including its shapes, relative to body.position.
     */
    boundingRadius: number;
    wlambda: Vec3;
    /**
     * When true the body behaves like a trigger. It does not collide
     * with other bodies but collision events are still triggered.
     * @default false
     */
    isTrigger: boolean;
    entity?: Entity;
    object3d?: Object3D;
    constructor(options?: {
        /**
         * The collision group the body belongs to.
         * @default 1
         */
        collisionFilterGroup?: number;
        /**
         * The collision group the body can collide with.
         * @default -1
         */
        collisionFilterMask?: number;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
         */
        collisionResponse?: boolean;
        /**
         * World space position of the body.
         */
        position?: Vec3;
        /**
         * World space velocity of the body.
         */
        velocity?: Vec3;
        /**
         * The mass of the body.
         * @default 0
         */
        mass?: number;
        /**
         * The physics material of the body. It defines the body interaction with other bodies.
         */
        material?: Material_2;
        /**
         * How much to damp the body velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        linearDamping?: number;
        /**
         * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
         */
        type?: BodyType;
        /**
         * If true, the body will automatically fall to sleep.
         * @default true
         */
        allowSleep?: boolean;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @default 0.1
         */
        sleepSpeedLimit?: number;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @default 1
         */
        sleepTimeLimit?: number;
        /**
         * World space orientation of the body.
         */
        quaternion?: Quaternion_2;
        /**
         * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
         */
        angularVelocity?: Vec3;
        /**
         * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
         * @default false
         */
        fixedRotation?: boolean;
        /**
         * How much to damp the body angular velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        angularDamping?: number;
        /**
         * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
         */
        linearFactor?: Vec3;
        /**
         * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
         */
        angularFactor?: Vec3;
        /**
         * Add a Shape to the body.
         */
        shape?: Shape;
        /**
         * When true the body behaves like a trigger. It does not collide
         * with other bodies but collision events are still triggered.
         * @default false
         */
        isTrigger?: boolean;
    });
    /**
     * Wake the body up.
     */
    wakeUp(): void;
    /**
     * Force body sleep
     */
    sleep(): void;
    /**
     * Called every timestep to update internal sleep timer and change sleep state if needed.
     * @param time The world time in seconds
     */
    sleepTick(time: number): void;
    /**
     * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
     */
    updateSolveMassProperties(): void;
    /**
     * Convert a world point to local body frame.
     */
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a world vector to local body frame.
     */
    vectorToLocalFrame(worldVector: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a local body point to world frame.
     */
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a local body point to world frame.
     */
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
    /**
     * Add a shape to the body with a local offset and orientation.
     * @return The body object, for chainability.
     */
    addShape(shape: Shape, _offset?: Vec3, _orientation?: Quaternion_2): Body_2;
    /**
     * Remove a shape from the body.
     * @return The body object, for chainability.
     */
    removeShape(shape: Shape): Body_2;
    /**
     * Update the bounding radius of the body. Should be done if any of the shapes are changed.
     */
    updateBoundingRadius(): void;
    /**
     * Updates the .aabb
     */
    updateAABB(): void;
    /**
     * Update `.inertiaWorld` and `.invInertiaWorld`
     */
    updateInertiaWorld(force?: boolean): void;
    /**
     * Apply force to a point of the body. This could for example be a point on the Body surface.
     * Applying force this way will add to Body.force and Body.torque.
     * @param force The amount of force to add.
     * @param relativePoint A point relative to the center of mass to apply the force on.
     */
    applyForce(force: Vec3, relativePoint?: Vec3): void;
    /**
     * Apply force to a local point in the body.
     * @param force The force vector to apply, defined locally in the body frame.
     * @param localPoint A local point in the body to apply the force on.
     */
    applyLocalForce(localForce: Vec3, localPoint?: Vec3): void;
    /**
     * Apply torque to the body.
     * @param torque The amount of torque to add.
     */
    applyTorque(torque: Vec3): void;
    /**
     * Apply impulse to a point of the body. This could for example be a point on the Body surface.
     * An impulse is a force added to a body during a short period of time (impulse = force * time).
     * Impulses will be added to Body.velocity and Body.angularVelocity.
     * @param impulse The amount of impulse to add.
     * @param relativePoint A point relative to the center of mass to apply the force on.
     */
    applyImpulse(impulse: Vec3, relativePoint?: Vec3): void;
    /**
     * Apply locally-defined impulse to a local point in the body.
     * @param force The force vector to apply, defined locally in the body frame.
     * @param localPoint A local point in the body to apply the force on.
     */
    applyLocalImpulse(localImpulse: Vec3, localPoint?: Vec3): void;
    /**
     * Should be called whenever you change the body shape or mass.
     */
    updateMassProperties(): void;
    /**
     * Get world velocity of a point in the body.
     * @param worldPoint
     * @param result
     * @return The result vector.
     */
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;
    /**
     * Move the body forward in time.
     * @param dt Time step
     * @param quatNormalize Set to true to normalize the body quaternion
     * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
     */
    integrate(dt: number, quatNormalize: boolean, quatNormalizeFast: boolean): void;
}

/**
 * BODY_SLEEP_STATES
 */
declare const BODY_SLEEP_STATES: {
    /** AWAKE */
    readonly AWAKE: 0;
    /** SLEEPY */
    readonly SLEEPY: 1;
    /** SLEEPING */
    readonly SLEEPING: 2;
};

/**
 * BODY_TYPES
 */
declare const BODY_TYPES: {
    /** DYNAMIC */
    readonly DYNAMIC: 1;
    /** STATIC */
    readonly STATIC: 2;
    /** KINEMATIC */
    readonly KINEMATIC: 4;
};

declare type BodyOptions = ConstructorParameters<typeof Body_2>[0];

/**
 * BodySleepState
 */
declare type BodySleepState = typeof BODY_SLEEP_STATES[keyof typeof BODY_SLEEP_STATES];

/**
 * BodyType
 */
declare type BodyType = typeof BODY_TYPES[keyof typeof BODY_TYPES];

declare class BoundingRect {
    x: number;
    y: number;
    width: number;
    height: number;
    constructor(x: number, y: number, width: number, height: number);
    union(other: BoundingRect): void;
    applyTransform(m: matrix.MatrixArray): void;
    calculateTransform(b: RectLike): matrix.MatrixArray;
    intersect(b: RectLike, mtv?: PointLike): boolean;
    contain(x: number, y: number): boolean;
    clone(): BoundingRect;
    /**
     * Copy from another rect
     */
    copy(other: RectLike): void;
    plain(): RectLike;
    /**
     * If not having NaN or Infinity with attributes
     */
    isFinite(): boolean;
    isZero(): boolean;
    static create(rect: RectLike): BoundingRect;
    static copy(target: RectLike, source: RectLike): void;
    static applyTransform(target: RectLike, source: RectLike, m: matrix.MatrixArray): void;
}

/**
 * A 3d box shape.
 * @example
 *     const size = 1
 *     const halfExtents = new CANNON.Vec3(size, size, size)
 *     const boxShape = new CANNON.Box(halfExtents)
 *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
 *     world.addBody(boxBody)
 */
declare class Box extends Shape {
    /**
     * The half extents of the box.
     */
    halfExtents: Vec3;
    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example.
     */
    convexPolyhedronRepresentation: ConvexPolyhedron;
    constructor(halfExtents: Vec3);
    /**
     * Updates the local convex polyhedron representation used for some collisions.
     */
    updateConvexPolyhedronRepresentation(): void;
    /**
     * Calculate the inertia of the box.
     */
    calculateLocalInertia(mass: number, target?: Vec3): Vec3;
    static calculateInertia(halfExtents: Vec3, mass: number, target: Vec3): void;
    /**
     * Get the box 6 side normals
     * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
     * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
     */
    getSideNormals(sixTargetVectors: Vec3[], quat: Quaternion_2): Vec3[];
    /**
     * Returns the volume of the box.
     */
    volume(): number;
    /**
     * updateBoundingSphereRadius
     */
    updateBoundingSphereRadius(): void;
    /**
     * forEachWorldCorner
     */
    forEachWorldCorner(pos: Vec3, quat: Quaternion_2, callback: (x: number, y: number, z: number) => void): void;
    /**
     * calculateWorldAABB
     */
    calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
}

export declare class BoxHelper extends Group_2 {
    lineSegs: LineSegments;
    object: Object3D;
    mesh: Mesh;
    options: BoxHelperOptions;
    box3: Box3;
    constructor(object: Object3D | Box3, options?: BoxHelperOptions);
    update(): void;
    setFromObject(object: Object3D): this;
    copy(source: any, recursive: any): this;
    dispose(): void;
}

export declare interface BoxHelperOptions {
    /** 边框线颜色 */
    lineColor?: ColorRepresentation;
    /** 填充线颜色 */
    fillColor?: ColorRepresentation;
    /** 填充线透明度，为零时不显示填充 */
    fillOpacity?: number;
    /** 线材质 */
    lineMaterialParam?: LineBasicMaterialParameters;
    /** 填充材质 */
    fillMaterialParam?: MeshBasicMaterialParameters;
}

export declare type BoxParameters = {
    x: number;
    y: number;
    z: number;
};

/**
 * Utility behavior that works just like an IF/ELSE statement
 * If you are not sure if this is the right behavior for your use-case, consider using a selector behavior instead,
 * as selector is a more commonly applicable behavior type
 */
export declare class BranchBehavior extends Behavior {
    #private;
    constructor();
    /**
     *
     * @param {Behavior} condition
     * @param {Behavior} successBranch
     * @param {Behavior} failureBranch
     */
    static from(condition: Behavior, successBranch?: Behavior, failureBranch?: Behavior): BranchBehavior;
    initialize(context: BehaviorContext): void;
    tick(timeDelta: number): any;
    finalize(): void;
}

/**
 * 呼吸的光圈.
 */
export declare class BreathingApertureMarker extends AnimateMarkerBase {
    constructor(features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    _createMarker(): void;
    private _createMakerElement;
    setMarkersWidth(width: number, index?: number): void;
    private _setBreathingApertureWidth;
    setDotSize(size: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
}

/**
 * Base class for broadphase implementations
 * @author schteppe
 */
declare class Broadphase {
    /**
     * The world to search for collisions in.
     */
    world: World | null;
    /**
     * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
     */
    useBoundingBoxes: boolean;
    /**
     * Set to true if the objects in the world moved.
     */
    dirty: boolean;
    constructor();
    /**
     * Get the collision pairs from the world
     * @param world The world to search in
     * @param p1 Empty array to be filled with body objects
     * @param p2 Empty array to be filled with body objects
     */
    collisionPairs(world: World, p1: Body_2[], p2: Body_2[]): void;
    /**
     * Check if a body pair needs to be intersection tested at all.
     */
    needBroadphaseCollision(bodyA: Body_2, bodyB: Body_2): boolean;
    /**
     * Check if the bounding volumes of two bodies intersect.
     */
    intersectionTest(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Check if the bounding spheres of two bodies are intersecting.
     * @param pairs1 bodyA is appended to this array if intersection
     * @param pairs2 bodyB is appended to this array if intersection
     */
    doBoundingSphereBroadphase(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Check if the bounding boxes of two bodies are intersecting.
     */
    doBoundingBoxBroadphase(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Removes duplicate pairs from the pair arrays.
     */
    makePairsUnique(pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * To be implemented by subcasses
     */
    setWorld(world: World): void;
    /**
     * Check if the bounding spheres of two bodies overlap.
     */
    static boundingSphereCheck(bodyA: Body_2, bodyB: Body_2): boolean;
    /**
     * Returns all the bodies within the AABB.
     */
    aabbQuery(world: World, aabb: AABB, result: Body_2[]): Body_2[];
}

declare class Brush extends Mesh {
    isBrush: boolean;
    markUpdated(): void;
    isDirty(): boolean;
    prepareGeometry(): void;
    disposeCacheData(): void;
}

export declare class BufferShader {
    width: number;
    height: number;
    common: string;
    outputBuffer: WebGLRenderTarget;
    readBuffer: WebGLRenderTarget;
    opacityColor?: Color;
    materialParameters?: MaterialParameters;
    uniformsDefs: string;
    hsbExpr: string;
    iChannel: (Texture | BufferShader)[];
    uniforms: {
        iChannel0: {
            value: Texture;
        };
        iChannel1: {
            value: Texture;
        };
        iChannel2: {
            value: Texture;
        };
        iChannel3: {
            value: Texture;
        };
    };
    camera: OrthographicCamera;
    scene: Scene;
    enabled: boolean;
    plane: Mesh<PlaneGeometry, Material | Material[]>;
    set shader(value: string);
    constructor(width: number, height: number, opacityColor?: Color, materialParameters?: MaterialParameters, renderTargetOptions?: RenderTargetOptions, uniformsDefs?: string, hsbExpr?: string);
    swap(): void;
    private getIChannel;
    render(renderer: WebGLRenderer): void;
}

declare type Builtin = Primitive | Function | Date | Error | RegExp;

declare type BuiltinTextPosition = 'left' | 'right' | 'top' | 'bottom' | 'inside' | 'insideLeft' | 'insideRight' | 'insideTop' | 'insideBottom' | 'insideTopLeft' | 'insideTopRight' | 'insideBottomLeft' | 'insideBottomRight';

export declare interface BurstParameters {
    time: number;
    count: ValueGenerator | FunctionValueGenerator;
    cycle: number;
    interval: number;
    probability: number;
}

/**
 * Interface representing the JSON parameters for a burst.
 */
export declare interface BurstParametersJSON {
    /**
     * The time of the burst.
     */
    time: number;
    /**
     * The count of particles to emit, can be a number or a function.
     */
    count: FunctionJSON | number;
    /**
     * The cycle of the burst.
     */
    cycle: number;
    /**
     * The interval between bursts.
     */
    interval: number;
    /**
     * The probability of the burst occurring.
     */
    probability: number;
}

/** 按钮组控件 */
export declare class ButtonGroupControl {
    app: App;
    container: HTMLElement;
    style: Record<string, any>;
    panel: HTMLElement;
    options: ButtonGroupControlOptions;
    constructor(options: ButtonGroupControlOptions);
    _insertControl(): void;
    onAdd(app: any): HTMLElement;
    onRemove(): void;
    setTheme(isLightTheme?: boolean): void;
    getDefaultPosition(): string;
}

export declare interface ButtonGroupControlOptions {
    buttons: {
        id: string;
        /** 图标 */
        icon?: string;
        /** html (icon为空时有效)*/
        html?: string;
        /** 提示 */
        title?: string;
        /** 是否选中开关 */
        toggle?: boolean;
        /** 点击事件回调 */
        onclick?: Function;
        /** 类名 */
        classList?: string[];
        /** 是否选中 */
        checked?: boolean;
        /** 圆角 */
        round?: boolean;
        /** 样式 */
        style?: Partial<CSSStyleDeclaration>;
    }[];
    direction?: "row" | "column";
    lightTheme?: boolean;
    barSelectMode?: boolean;
    barCurSelectId?: string;
}

export declare class CallFunctionCommand<T> extends BaseCommand {
    private target;
    private executeFn;
    private executeArgs;
    private undoFn?;
    private undoArgs?;
    constructor(target: T, executeFn: (this: T, ...args: any[]) => void, executeArgs: any[], undoFn?: (this: T, ...args: any[]) => void, undoArgs?: any[]);
    execute(): void;
    undo(): void;
    redo(): void;
}

export declare class CameraControls extends EventDispatcher {
    #private;
    static install(): void;
    /**
     * list all ACTIONs
     * @category Statics
     */
    static get ACTION(): typeof ACTION;
    /**
     * Minimum vertical angle in radians.
     * The angle has to be between `0` and `.maxPolarAngle` inclusive.
     * The default value is `0`.
     *
     * e.g.
     * ```
     * cameraControls.maxPolarAngle = 0;
     * ```
     * @category Properties
     */
    minPolarAngle: number;
    /**
     * Maximum vertical angle in radians.
     * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
     * The default value is `Math.PI`.
     *
     * e.g.
     * ```
     * cameraControls.maxPolarAngle = Math.PI;
     * ```
     * @category Properties
     */
    maxPolarAngle: number;
    /**
     * Minimum horizontal angle in radians.
     * The angle has to be less than `.maxAzimuthAngle`.
     * The default value is `- Infinity`.
     *
     * e.g.
     * ```
     * cameraControls.minAzimuthAngle = - Infinity;
     * ```
     * @category Properties
     */
    minAzimuthAngle: number;
    /**
     * Maximum horizontal angle in radians.
     * The angle has to be greater than `.minAzimuthAngle`.
     * The default value is `Infinity`.
     *
     * e.g.
     * ```
     * cameraControls.maxAzimuthAngle = Infinity;
     * ```
     * @category Properties
     */
    maxAzimuthAngle: number;
    /**
     * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
     * PerspectiveCamera only.
     * @category Properties
     */
    minDistance: number;
    /**
     * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
     * PerspectiveCamera only.
     * @category Properties
     */
    maxDistance: number;
    /**
     * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
     * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
     * @category Properties
     */
    infinityDolly: boolean;
    /**
     * Minimum camera zoom.
     * @category Properties
     */
    minZoom: number;
    /**
     * Maximum camera zoom.
     * @category Properties
     */
    maxZoom: number;
    /**
     * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
     * @category Properties
     */
    smoothTime: number;
    /**
     * the smoothTime while dragging
     * @category Properties
     */
    draggingSmoothTime: number;
    /**
     * Max transition speed in unit-per-seconds
     * @category Properties
     */
    maxSpeed: number;
    /**
     * Speed of azimuth (horizontal) rotation.
     * @category Properties
     */
    azimuthRotateSpeed: number;
    /**
     * Speed of polar (vertical) rotation.
     * @category Properties
     */
    polarRotateSpeed: number;
    /**
     * Speed of mouse-wheel dollying.
     * @category Properties
     */
    dollySpeed: number;
    /**
     * `true` to invert direction when dollying or zooming via drag
     * @category Properties
     */
    dollyDragInverted: boolean;
    /**
     * Speed of drag for pan and pedestal.
     * @category Properties
     */
    truckSpeed: number;
    /**
     * `true` to enable Dolly-in to the mouse cursor coords.
     * @category Properties
     */
    dollyToCursor: boolean;
    /**
     * @category Properties
     */
    dragToOffset: boolean;
    /**
     * if true, pan in screen-space
     * @category Properties
     */
    verticalDragToForward: boolean;
    /**
     * Friction ratio of the boundary.
     * @category Properties
     */
    boundaryFriction: number;
    /**
     * Controls how soon the `rest` event fires as the camera slows.
     * @category Properties
     */
    restThreshold: number;
    /**
     * An array of Meshes to collide with camera.
     * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
     * @category Properties
     */
    colliderMeshes: Object3D[];
    /**
     * User's mouse input config.
     *
     * | button to assign      | behavior |
     * | --------------------- | -------- |
     * | `mouseButtons.left`   | `CameraControls.ACTION.ROTATE`* \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
     * | `mouseButtons.right`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK`* \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
     * | `mouseButtons.wheel` ¹ | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
     * | `mouseButtons.middle` ² | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY`* \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
     *
     * 1. Mouse wheel event for scroll "up/down" on mac "up/down/left/right"
     * 2. Mouse click on wheel event "button"
     * - \* is the default.
     * - The default of `mouseButtons.wheel` is:
     *   - `DOLLY` for Perspective camera.
     *   - `ZOOM` for Orthographic camera, and can't set `DOLLY`.
     * @category Properties
     */
    mouseButtons: MouseButtons;
    /**
     * User's touch input config.
     *
     * | fingers to assign     | behavior |
     * | --------------------- | -------- |
     * | `touches.one` | `CameraControls.ACTION.TOUCH_ROTATE`* \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.DOLLY` | `CameraControls.ACTION.ZOOM` | `CameraControls.ACTION.NONE` |
     * | `touches.two` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `ACTION.TOUCH_DOLLY` \| `ACTION.TOUCH_ZOOM` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
     * | `touches.three` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
     *
     * - \* is the default.
     * - The default of `touches.two` and `touches.three` is:
     *   - `TOUCH_DOLLY_TRUCK` for Perspective camera.
     *   - `TOUCH_ZOOM_TRUCK` for Orthographic camera, and can't set `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY`.
     * @category Properties
     */
    touches: Touches;
    dblClickSetToCenter: boolean;
    /**
     * Force cancel user dragging.
     * @category Methods
     */
    cancel: () => void;
    /**
     * Still an experimental feature.
     * This could change at any time.
     * @category Methods
     */
    lockPointer: () => void;
    /**
     * Still an experimental feature.
     * This could change at any time.
     * @category Methods
     */
    unlockPointer: () => void;
    protected _enabled: boolean;
    enableWheelWhenCtrlDisabled: boolean;
    eventFromInputModule: boolean;
    protected _camera: PerspectiveCamera | OrthographicCamera;
    protected _yAxisUpSpace: Quaternion;
    protected _yAxisUpSpaceInverse: Quaternion;
    protected _state: ACTION;
    protected _domElement?: HTMLElement;
    protected _viewport: Vector4 | null;
    protected _target: Vector3;
    protected _targetEnd: Vector3;
    protected _focalOffset: Vector3;
    protected _focalOffsetEnd: Vector3;
    protected _spherical: Spherical;
    protected _sphericalEnd: Spherical;
    protected _lastDistance: number;
    protected _zoom: number;
    protected _zoomEnd: number;
    protected _lastZoom: number;
    protected _cameraUp0: Vector3;
    protected _target0: Vector3;
    protected _position0: Vector3;
    protected _zoom0: number;
    protected _focalOffset0: Vector3;
    protected _dollyControlCoord: Vector2;
    protected _changedDolly: number;
    protected _changedZoom: number;
    protected _nearPlaneCorners: [Vector3, Vector3, Vector3, Vector3];
    protected _hasRested: boolean;
    protected _boundary: Box3;
    protected _boundaryEnclosesCamera: boolean;
    protected _needsUpdate: boolean;
    protected _updatedLastTime: boolean;
    protected _elementRect: DOMRect;
    protected _isDragging: boolean;
    protected _activePointers: PointerInput[];
    protected _lockedPointer: PointerInput | null;
    protected _interactiveArea: DOMRect;
    protected _isUserControllingRotate: boolean;
    protected _isUserControllingDolly: boolean;
    protected _isUserControllingTruck: boolean;
    protected _isUserControllingOffset: boolean;
    protected _isUserControllingZoom: boolean;
    protected _lastDollyDirection: DOLLY_DIRECTION;
    protected _thetaVelocity: RefTypeValue;
    protected _phiVelocity: RefTypeValue;
    protected _radiusVelocity: RefTypeValue;
    protected _targetVelocity: Vector3;
    protected _focalOffsetVelocity: Vector3;
    protected _zoomVelocity: RefTypeValue;
    protected _targetMarker: Marker2D;
    app: App;
    /**
     * Creates a `CameraControls` instance.
     *
     * Note:
     * You **must install** three.js before using camera-controls. see [#install](#install)
     * Not doing so will lead to runtime errors (`undefined` references to THREE).
     *
     * e.g.
     * ```
     * CameraControls.install( { THREE } );
     * const cameraControls = new CameraControls( camera, domElement );
     * ```
     *
     * @param camera A `PerspectiveCamera` or `OrthographicCamera` to be controlled.
     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
     * @category Constructor
     */
    constructor(app: App, domElement?: HTMLElement, eventFromInputModule?: boolean);
    /**
     * The camera to be controlled
     * @category Properties
     */
    get camera(): PerspectiveCamera | OrthographicCamera;
    set camera(camera: PerspectiveCamera | OrthographicCamera);
    /**
     * Whether or not the controls are enabled.
     * `false` to disable user dragging/touch-move, but all methods works.
     * @category Properties
     */
    get enabled(): boolean;
    set enabled(enabled: boolean);
    /**
     * Returns `true` if the controls are active updating.
     * readonly value.
     * @category Properties
     */
    get active(): boolean;
    /**
     * Getter for the current `ACTION`.
     * readonly value.
     * @category Properties
     */
    get currentAction(): ACTION;
    /**
     * get/set Current distance.
     * @category Properties
     */
    get distance(): number;
    set distance(distance: number);
    /**
     * get/set the azimuth angle (horizontal) in radians.
     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
     * @category Properties
     */
    get azimuthAngle(): number;
    set azimuthAngle(azimuthAngle: number);
    /**
     * get/set the polar angle (vertical) in radians.
     * @category Properties
     */
    get polarAngle(): number;
    set polarAngle(polarAngle: number);
    /**
     * Whether camera position should be enclosed in the boundary or not.
     * @category Properties
     */
    get boundaryEnclosesCamera(): boolean;
    set boundaryEnclosesCamera(boundaryEnclosesCamera: boolean);
    /**
     * Set drag-start, touches and wheel enable area in the domElement.
     * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
     * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
     * @category Properties
     */
    set interactiveArea(interactiveArea: DOMRect | {
        x: number;
        y: number;
        width: number;
        height: number;
    });
    /**
     * Adds the specified event listener.
     * Applicable event types (which is `K`) are:
     * | Event name          | Timing |
     * | ------------------- | ------ |
     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
     * | `'control'`         | When the user controls the camera (dragging). |
     * | `'controlend'`      | When the user ends to control the camera. ¹ |
     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
     * | `'update'`          | When the camera position is updated. |
     * | `'wake'`            | When the camera starts moving. |
     * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
     * | `'sleep'`           | When the camera end moving. |
     *
     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
     *
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    addEventListener<K extends keyof CameraControlsEventMap>(type: K, listener: (event: CameraControlsEventMap[K]) => any): void;
    /**
     * Removes the specified event listener
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */
    removeEventListener<K extends keyof CameraControlsEventMap>(type: K, listener: (event: CameraControlsEventMap[K]) => any): void;
    /**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical).
     * Every value is added to the current value.
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotate(azimuthAngle: number, polarAngle: number, enableTransition?: boolean): Promise<void>;
    /**
     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
     *
     * e.g.
     * ```
     * cameraControls.rotateAzimuthTo( 30 * MathUtils.DEG2RAD, true );
     * ```
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotateAzimuthTo(azimuthAngle: number, enableTransition?: boolean): Promise<void>;
    /**
     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
     *
     * e.g.
     * ```
     * cameraControls.rotatePolarTo( 30 * MathUtils.DEG2RAD, true );
     * ```
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    rotatePolarTo(polarAngle: number, enableTransition?: boolean): Promise<void>;
    /**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
     * Camera view will rotate over the orbit pivot absolutely:
     *
     * azimuthAngle
     * ```
     *       0º
     *         \
     * 90º -----+----- -90º
     *           \
     *           180º
     * ```
     * | direction | angle                  |
     * | --------- | ---------------------- |
     * | front     | 0º                     |
     * | left      | 90º (`Math.PI / 2`)    |
     * | right     | -90º (`- Math.PI / 2`) |
     * | back      | 180º (`Math.PI`)       |
     *
     * polarAngle
     * ```
     *     180º
     *      |
     *      90º
     *      |
     *      0º
     * ```
     * | direction            | angle                  |
     * | -------------------- | ---------------------- |
     * | top/sky              | 180º (`Math.PI`)       |
     * | horizontal from view | 90º (`Math.PI / 2`)    |
     * | bottom/floor         | 0º                     |
     *
     * @param azimuthAngle Azimuth rotate angle to. In radian.
     * @param polarAngle Polar rotate angle to. In radian.
     * @param enableTransition  Whether to move smoothly or immediately
     * @category Methods
     */
    rotateTo(azimuthAngle: number, polarAngle: number, enableTransition?: boolean): Promise<void>;
    /**
     * Dolly in/out camera position.
     * @param distance Distance of dollyIn. Negative number for dollyOut.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dolly(distance: number, enableTransition?: boolean): Promise<void>;
    /**
     * Dolly in/out camera position to given distance.
     * @param distance Distance of dolly.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dollyTo(distance: number, enableTransition?: boolean): Promise<void>;
    protected _dollyToNoClamp(distance: number, enableTransition?: boolean): Promise<void>;
    /**
     * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
     * Specify a negative value for dolly out.
     * @param distance Distance of dolly.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */
    dollyInFixed(distance: number, enableTransition?: boolean): Promise<void>;
    /**
     * Zoom in/out camera. The value is added to camera zoom.
     * Limits set with `.minZoom` and `.maxZoom`
     * @param zoomStep zoom scale
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    zoom(zoomStep: number, enableTransition?: boolean): Promise<void>;
    /**
     * Zoom in/out camera to given scale. The value overwrites camera zoom.
     * Limits set with .minZoom and .maxZoom
     * @param zoom
     * @param enableTransition
     * @category Methods
     */
    zoomTo(zoom: number, enableTransition?: boolean): Promise<void>;
    /**
     * pan and pedestal camera using current azimuthal angle
     * @param x Horizontal translate amount
     * @param y Vertical translate amount
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    pan(x: number, y: number, enableTransition?: boolean): Promise<void>;
    /**
     * Move forward / backward.
     * @param distance Amount to move forward / backward. Negative value to move backward
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    forward(distance: number, enableTransition?: boolean): Promise<void>;
    /**
     * Move up / down.
     * @param height Amount to move up / down. Negative value to move down
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    elevate(height: number, enableTransition?: boolean): Promise<void>;
    /**
     * Move target position to given point.
     * @param x x coord to move center position
     * @param y y coord to move center position
     * @param z z coord to move center position
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */
    moveTo(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
    /**
     * Look in the given point direction.
     * @param x point x.
     * @param y point y.
     * @param z point z.
     * @param enableTransition Whether to move smoothly or immediately.
     * @returns Transition end promise
     * @category Methods
     */
    lookInDirectionOf(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
    /**
     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
     * set `cover: true` to fill enter screen.
     * e.g.
     * ```
     * cameraControls.fitToBox( myMesh );
     * ```
     * @param box3OrObject Axis aligned bounding box to fit the view.
     * @param enableTransition Whether to move smoothly or immediately.
     * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
     * @returns Transition end promise
     * @category Methods
     */
    fitToBox(box3OrObject: Box3 | Object3D, enableTransition: boolean, { cover, paddingLeft, paddingRight, paddingBottom, paddingTop }?: Partial<FitToOptions>): Promise<void[]>;
    /**
     * Fit the viewport to the sphere or the bounding sphere of the object.
     * @param sphereOrMesh
     * @param enableTransition
     * @category Methods
     */
    fitToSphere(sphereOrMesh: Sphere | Object3D, enableTransition: boolean): Promise<void[]>;
    fitToRect(rect: {
        width: number;
        height: number;
        center: [number, number, number];
        normal: [number, number, number];
    }): void;
    /**
     * Look at the `target` from the `position`.
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */
    setLookAt(positionX: number, positionY: number, positionZ: number, targetX: number, targetY: number, targetZ: number, enableTransition?: boolean): Promise<void>;
    /**
     * Similar to setLookAt, but it interpolates between two states.
     * @param positionAX
     * @param positionAY
     * @param positionAZ
     * @param targetAX
     * @param targetAY
     * @param targetAZ
     * @param positionBX
     * @param positionBY
     * @param positionBZ
     * @param targetBX
     * @param targetBY
     * @param targetBZ
     * @param t
     * @param enableTransition
     * @category Methods
     */
    lerpLookAt(positionAX: number, positionAY: number, positionAZ: number, targetAX: number, targetAY: number, targetAZ: number, positionBX: number, positionBY: number, positionBZ: number, targetBX: number, targetBY: number, targetBZ: number, t: number, enableTransition?: boolean): Promise<void>;
    /**
     * Set angle and distance by given position.
     * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param enableTransition
     * @category Methods
     */
    setPosition(positionX: number, positionY: number, positionZ: number, enableTransition?: boolean): Promise<void>;
    /**
     * Set the target position where gaze at.
     * An alias of `setLookAt()`, without position change. Thus keep the same position.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */
    setTarget(targetX: number, targetY: number, targetZ: number, enableTransition?: boolean): Promise<void>;
    /**
     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
     * @param x
     * @param y
     * @param z
     * @param enableTransition
     * @category Methods
     */
    setFocalOffset(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
    /**
     * Set orbit point without moving the camera.
     * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @category Methods
     */
    setOrbitPoint(targetX: number, targetY: number, targetZ: number): void;
    /**
     * Set the boundary box that encloses the target of the camera. box3 is in Box3
     * @param box3
     * @category Methods
     */
    setBoundary(box3?: Box3): void;
    /**
     * Set (or unset) the current viewport.
     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
     * @param viewportOrX
     * @param y
     * @param width
     * @param height
     * @category Methods
     */
    setViewport(viewportOrX: Vector4 | number | null, y: number, width: number, height: number): void;
    /**
     * Calculate the distance to fit the box.
     * @param width box width
     * @param height box height
     * @param depth box depth
     * @returns distance
     * @category Methods
     */
    getDistanceToFitBox(width: number, height: number, depth: number, cover?: boolean): number;
    /**
     * Calculate the distance to fit the sphere.
     * @param radius sphere radius
     * @returns distance
     * @category Methods
     */
    getDistanceToFitSphere(radius: number): number;
    /**
     * Returns the orbit center position, where the camera looking at.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getTarget(out: Vector3, receiveEndValue?: boolean): Vector3;
    /**
     * Returns the camera position.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getPosition(out: Vector3, receiveEndValue?: boolean): Vector3;
    /**
     * Returns the spherical coordinates of the orbit.
     * @param out The receiving Spherical instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getSpherical(out: Spherical, receiveEndValue?: boolean): Spherical;
    /**
     * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
     * @param out The receiving Vector3 instance to copy the result
     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
     * @category Methods
     */
    getFocalOffset(out: Vector3, receiveEndValue?: boolean): Vector3;
    /**
     * Normalize camera azimuth angle rotation between 0 and 360 degrees.
     * @category Methods
     */
    normalizeRotations(): void;
    /**
     * Reset all rotation and position to defaults.
     * @param enableTransition
     * @category Methods
     */
    reset(enableTransition?: boolean): Promise<void[]>;
    /**
     * Set current camera position as the default position.
     * @category Methods
     */
    saveState(): CameraState;
    /**
     * load current camera position
     */
    loadState(state: CameraState, enableTransition?: boolean): void;
    /**
     * load current camera position
     */
    loadStateAsync(state: CameraState, duration?: number, opts?: {
        /** id */
        id?: string;
        /** 分类 */
        tag?: string;
        /** easing */
        easing?: Easing;
        /** 往返次数 */
        yoyoTimes?: number;
        /** 重复次数 */
        repeatTimes?: number;
    }): Promise<unknown>;
    /**
     * Sync camera-up direction.
     * When camera-up vector is changed, `.updateCameraUp()` must be called.
     * @category Methods
     */
    updateCameraUp(): void;
    /**
     * Apply current camera-up direction to the camera.
     * The orbit system will be re-initialized with the current position.
     * @category Methods
     */
    applyCameraUp(): void;
    /**
     * Update camera position and directions.
     * This should be called in your tick loop every time, and returns true if re-rendering is needed.
     * @param delta
     * @returns updated
     * @category Methods
     */
    update(delta: number): boolean;
    dispatchEvent(event: string, ...data: any): void;
    /**
     * Get all state in JSON string
     * @category Methods
     */
    toJSON(): string;
    /**
     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
     * @param json
     * @param enableTransition
     * @category Methods
     */
    fromJSON(json: string, enableTransition?: boolean): void;
    /**
     * Attach all internal event handlers to enable drag control.
     * @category Methods
     */
    connect(domElement: HTMLElement): void;
    /**
     * Detach all internal event handlers to disable drag control.
     */
    disconnect(): void;
    /**
     * Dispose the cameraControls instance itself, remove all eventListeners.
     * @category Methods
     */
    dispose(): void;
    protected _getTargetDirection(out: Vector3): Vector3;
    protected _getCameraDirection(out: Vector3): Vector3;
    protected _findPointerById(pointerId: number): PointerInput | undefined;
    protected _findPointerByMouseButton(mouseButton: MOUSE_BUTTON): PointerInput | undefined;
    protected _disposePointer(pointer: PointerInput): void;
    protected _encloseToBoundary(position: Vector3, offset: Vector3, friction: number): Vector3;
    protected _updateNearPlaneCorners(): void;
    protected _truckInternal: (deltaX: number, deltaY: number, dragToOffset: boolean) => void;
    protected _rotateInternal: (deltaX: number, deltaY: number) => void;
    protected _dollyInternal: (delta: number, x: number, y: number) => void;
    protected _zoomInternal: (delta: number, x: number, y: number) => void;
    protected _collisionTest(): number;
    /**
     * Get its client rect and package into given `DOMRect` .
     */
    protected _getClientRect(target: DOMRect): DOMRect | undefined;
    protected _createOnRestPromise(resolveImmediately: boolean): Promise<void>;
    protected _addAllEventListeners(_domElement: HTMLElement): void;
    protected _removeAllEventListeners(): void;
    static createBoundingSphere(object3d: Object3D, out?: Sphere): Sphere;
    /**
     * 对状态进行设置，采用堆栈方案，会保存之前的状态，退出时还原之前的状态
     * @param enabledControl 是否启用 默认false
     * @param enableWheelWhenCtrlDisabled  是否滚轮缩放 默认true
     * @returns
     */
    getStatus(enabledControl?: boolean, enableWheelWhenCtrlDisabled?: boolean): {
        push: () => void;
        pop: () => void;
    };
    /**
     * 相机抖动
     * @param duration 每次持续时长 (ms)  默认 1000
     * @param frequency 抖动频率 默认 10
     * @param strength 强度 默认 1
     * @param isLoop 是否循环抖动 默认 false
     */
    shake(duration?: number, frequency?: number, strength?: number, isLoop?: boolean): {
        cancelShake: () => boolean;
    };
}

declare interface CameraControlsEventMap {
    update: {
        type: 'update';
    };
    wake: {
        type: 'wake';
    };
    rest: {
        type: 'rest';
    };
    sleep: {
        type: 'sleep';
    };
    transitionstart: {
        type: 'transitionstart';
    };
    controlstart: {
        type: 'controlstart';
    };
    control: {
        type: 'control';
    };
    controlend: {
        type: 'controlend';
    };
}

/**
 * 通过距相机的投影平面距离获取深度z值 (需在相机远近裁剪面之间）)
 */
export declare function cameraDistance2NdcZ(camera: PerspectiveCamera, dist: number): number;

export declare class CameraModule extends AppModuleBase implements IAppModuleBase {
    #private;
    static moduleName: string;
    options: CameraModuleOptions;
    viewHelper: ViewHelper;
    constructor(app?: App, options?: CameraModuleOptions);
    onAwake(): void;
    /**
     * 设置相机朝向
     * @param position 相机位置
     * @param lookAt 朝向
     * @param enableTransition 启用平滑过渡 默认true
     */
    setCameraLookAt(position: Vector3, lookAt: Vector3, enableTransition?: boolean): void;
    get viewHelperEnable(): boolean;
    set viewHelperEnable(b: boolean);
    onAppAfterRender(): void;
    updateSceneBox(): void;
    setupUiConfig(): UiObjectConfig;
}

export declare interface CameraModuleOptions extends CameraOptions {
    autoNearFar?: number | boolean;
    viewHelper?: {
        enable?: boolean;
        position?: "leftTop" | "rightTop" | "leftBottom" | "rightBottom";
        size?: number;
    };
}

export declare interface CameraOptions {
    fov?: number;
    /** 缺省 容器宽 / 容器高 */
    aspect?: number;
    near?: number;
    far?: number;
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    isOrthographicCamera?: boolean;
    /** 相机位置，不填默认 [0, 10, 10] */
    position?: Vector3 | [number, number, number];
    lookAt?: Vector3 | [number, number, number];
}

export declare interface CameraState {
    cameraUp?: Vector3;
    cameraTarget: Vector3;
    cameraPosition: Vector3;
    cameraZoom?: number;
    cameraFocalOffset?: Vector3;
}

/** 得到应用的相机世界方向 */
export declare const cameraWorldDirection: (app?: App, camera?: Camera) => Vector3;

/**
 * Cancelable promises extend base promises and provide a cancel functionality than can be used to cancel the execution or task of the promise.
 *
 * These type of promises can be used to prevent additional processing when the data is not longer required (e.g. HTTP request for data that is not longer necessary)
 */
export declare class CancelablePromise<T> {
    onResolve: (value: any) => void;
    onReject: (error: any) => void;
    onCancel: () => void;
    /**
     * Flag to indicate if the promise has been fulfilled.
     *
     * Promise has ben fulfilled when value/error is set.
     */
    fulfilled: boolean;
    /**
     * Flag to indicate if the promise was rejected.
     *
     * Only set when the promise is fulfilled.
     */
    rejected: boolean;
    /**
     * Flag set true when the resolve or reject method are called.
     */
    called: boolean;
    /**
     * Output value of the promise.
     *
     * Set with the output value if promise was fulfilled and not rejected.
     *
     * Stores the error value if the promise was rejected.
     */
    value: T;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void);
    /**
     * Request to cancel the promise execution.
     *
     * @returns True if the promise is canceled successfully, false otherwise.
     */
    cancel(): boolean;
    /**
     * Executed after the promise is fulfilled.
     *
     * @param callback - Callback to receive the value.
     * @returns Promise for chainning.
     */
    then(callback: (value: any) => void): CancelablePromise<T>;
    /**
     * Catch any error that occurs in the promise.
     *
     * @param callback - Method to catch errors.
     * @returns Promise for chainning.
     */
    catch(callback: (error: any) => void): CancelablePromise<T>;
    /**
     * Finally callback
     *
     * @param callback - Method to be called.
     * @returns Promise for chainning.
     */
    finally(callback: Function): CancelablePromise<T>;
    /**
     * Create a resolved promise.
     *
     * @param val - Value to pass.
     * @returns Promise created with resolve value.
     */
    static resolve<T>(val: T): CancelablePromise<T>;
    /**
     * Create a rejected promise.
     *
     * @param reason - Reason to reject the promise.
     * @returns Promise created with rejection reason.
     */
    static reject(reason: any): CancelablePromise<any>;
    /**
     * Wait for a set of promises to finish, creates a promise that waits for all running promises.
     *
     * If any of the promises fail it will reject altough some of them may have been completed with success.
     *
     * @param promises - List of promisses to syncronize.
     * @returns Promise that will resolve when all of the running promises are fullfilled.
     */
    static all(promises: CancelablePromise<any>[]): CancelablePromise<any>;
}

export declare class CancelledCommandException {
    constructor(command: any);
    toString(): string;
}

declare namespace CANNON {
    export {
        AABB,
        ArrayCollisionMatrix,
        Body_2 as Body,
        BODY_SLEEP_STATES,
        BODY_TYPES,
        BodyOptions,
        BodySleepState,
        BodyType,
        Box,
        Broadphase,
        COLLISION_TYPES,
        CollisionType,
        ConeEquation,
        ConeTwistConstraint,
        ConeTwistConstraintOptions,
        Constraint,
        ConstraintOptions,
        ContactEquation,
        ContactMaterial,
        ContactMaterialOptions,
        ConvexPolyhedron,
        ConvexPolyhedronContactPoint,
        Cylinder,
        DistanceConstraint,
        Equation,
        EventTarget_2,
        FrictionEquation,
        GridBroadphase,
        GSSolver,
        Heightfield,
        HeightfieldOptions,
        HeightfieldPillar,
        HingeConstraint,
        HingeConstraintOptions,
        JacobianElement,
        LockConstraint,
        LockConstraintOptions,
        Mat3,
        Material_2 as Material,
        MaterialOptions,
        NaiveBroadphase,
        Narrowphase,
        ObjectCollisionMatrix,
        Octree,
        OctreeNode,
        OverlapKeeper,
        Particle2,
        Plane_2 as Plane,
        PointToPointConstraint,
        Pool,
        Quaternion_2 as Quaternion,
        Ray_2 as Ray,
        RAY_MODES,
        RaycastCallback,
        RaycastResult,
        RaycastVehicle,
        RaycastVehicleOptions,
        RayMode,
        RayOptions,
        RigidVehicle,
        RigidVehicleOptions,
        RotationalEquation,
        RotationalEquationOptions,
        RotationalMotorEquation,
        SAPBroadphase,
        Shape,
        SHAPE_TYPES,
        ShapeOptions2,
        ShapeType,
        Solver,
        Sphere_2 as Sphere,
        SPHSystem,
        SplitSolver,
        SplitSolverNode,
        Spring,
        SpringOptions,
        Transform,
        TransformOptions,
        Trimesh,
        TupleDictionary,
        Vec3,
        Vec3Pool,
        WheelInfo,
        WheelInfoOptions,
        WheelRaycastResult,
        World,
        WorldOptions
    }
}
export { CANNON }

/**
 * Returns a new canvas with the image/canvas-content flipped vertically.
 * Useful for putImageData(as it does not respect scale and translate) and WebGL textures, which are flipped vertically.
 * @param canvas
 */
export declare function canvasFlipY(canvas: Exclude<CanvasImageSource, SVGImageElement>): HTMLCanvasElement;

/**
 * Contains utils to handle canvas element manipulation and common canvas operations.
 */
export declare class CanvasUtils {
    /**
     * Create a offscreen canvas, used to draw content that will not be displayed using DOM.
     *
     * If OffscreenCanvas object is no available creates a regular DOM canvas object instead.
     *
     * @param width - Width of the canvas in pixels.
     * @param height - Height of the canvas in pixels.
     */
    static createOffscreenCanvas(width: number, height: number): (HTMLCanvasElement | OffscreenCanvas);
}

declare type CbThis<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;

declare type CbThis_2<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;

declare const CENTER: SplitStrategy;

declare function centroid(array: number[]): number[];

export declare type ChangeArgs = [ChangeEvent, ...any[]] | never[];

/**
 * Change the emit direction of particles.
 */
export declare class ChangeEmitDirection implements Simulation {
    angle: ValueGenerator;
    type: string;
    _temp: Vector3;
    _q: Quaternion;
    constructor(angle: ValueGenerator);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

export declare interface ChangeEvent {
    target?: UiObjectConfig;
    type: 'change';
    last?: boolean;
    config?: UiObjectConfig;
    configPath?: UiObjectConfig[];
    value?: any;
}

export declare type CharInfo = {
    atlasX: number;
    atlasY: number;
    width: number;
    height: number;
    yOffset: number;
    xAdvance: number;
};

export declare type CharLayoutInfo = {
    left: number;
    top: number;
    width: number;
    height: number;
    xAdvance: number;
    boxTop: number;
    boxHeight: number;
    atlasX: number;
    atlasY: number;
};

export { ChromaticAberrationEffect }

declare class Circle extends Path<CircleProps> {
    shape: CircleShape;
    constructor(opts?: CircleProps);
    getDefaultShape(): CircleShape;
    buildPath(ctx: CanvasRenderingContext2D, shape: CircleShape): void;
}

/**
 * a particle emitter that emits particles from a circle.
 */
export declare class CircleEmitter implements EmitterShape {
    type: string;
    radius: number;
    arc: number;
    thickness: number;
    mode: EmitterMode;
    spread: number;
    speed: ValueGenerator | FunctionValueGenerator;
    private currentValue;
    constructor(parameters?: CircleEmitterParameters);
    update(system: ParticleSystem, delta: number): void;
    initialize(p: Particle, emissionState: EmissionState): void;
    toJSON(): ShapeJSON;
    static fromJSON(json: any): CircleEmitter;
    clone(): EmitterShape;
}

/**
 * Interface representing the parameters for a circle emitter.
 */
export declare interface CircleEmitterParameters {
    /**
     * The radius of the circle.
     */
    radius?: number;
    /**
     * The arc of the circle.
     */
    arc?: number;
    /**
     * The thickness of the ring.
     * 1 is a full circle, 0 is a ring with 0 radius.
     */
    thickness?: number;
    /**
     * The mode of the emitter.
     * {@link EmitterMode}
     */
    mode?: EmitterMode;
    /**
     * The length of segment of which emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
     * {@link EmitterMode}
     */
    spread?: number;
    /**
     * The speed of the emitter start point travels when mode is EmitterMode.Loop or EmitterMode.PingPong.
     * {@link EmitterMode}
     */
    speed?: ValueGenerator | FunctionValueGenerator;
}

declare interface CircleProps extends PathProps {
    shape?: Partial<CircleShape>;
}

declare class CircleShape {
    cx: number;
    cy: number;
    r: number;
}

/** 返回最小值和最大值区间的值 */
export declare function clamp(value: number, min: number, max: number): number;

/**
 * Generic type for class.
 * @example
 * ```ts
 * interface A {
 *    a: number
 * }
 * class B implements A {
 *  a = 1
 * }
 *
 * // Store class in variable
 * const c: Class<A> = B
 * console.log(typeof c === Class<B>) // true
 *
 * // Passing class to function
 * function f(p: Class<A>) {
 *     console.log(p)
 * }
 * f(B) // ok
 * ```
 *
 *
 */
export declare type Class<T> = new (...args: any[]) => T;

/**
 * Clears the bit at the given position.
 * @param number - the number to update
 * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
 */
export declare function clearBit(number: number, bitPosition: number): number;

declare class Clip {
    private _life;
    private _delay;
    private _inited;
    private _startTime;
    private _pausedTime;
    private _paused;
    animation: Animation_2;
    loop: boolean;
    easing: AnimationEasing;
    easingFunc: (p: number) => number;
    next: Clip;
    prev: Clip;
    onframe: OnframeCallback;
    ondestroy: ondestroyCallback;
    onrestart: onrestartCallback;
    constructor(opts: ClipProps);
    step(globalTime: number, deltaTime: number): boolean;
    pause(): void;
    resume(): void;
    setEasing(easing: AnimationEasing): void;
}

declare interface ClipProps {
    life?: number;
    delay?: number;
    loop?: boolean;
    easing?: AnimationEasing;
    onframe?: OnframeCallback;
    ondestroy?: ondestroyCallback;
    onrestart?: onrestartCallback;
}

/**
 * Clone a new matrix.
 */
declare function clone(a: MatrixArray): MatrixArray;

/**
 * 克隆一个向量
 */
declare function clone_2(v: VectorArray): VectorArray;

/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of .
 */
declare function clone_3<T extends any>(source: T): T;

/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
export declare function cloneDeep<T>(obj: T): T;

/**
 * 克隆材质
 * @param material
 */
export declare const cloneMaterial: (material: Mesh | Material | Material[]) => any;

/**
 * Clone a path.
 */
declare function clonePath(sourcePath: Path, opts?: {
    /**
     * If bake global transform to path.
     */
    bakeTransform?: boolean;
    /**
     * Convert global transform to local.
     */
    toLocal?: boolean;
}): Path<PathProps>;

/**
 * 点到多段线的最近点
 * @param p
 * @param points
 */
export declare function closestPointOnPolyline(p: GeoPoint, points: GeoPoint[]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPrePointDist: number;
};

/**
 * 点到多条线的最近点
 * @param p
 * @param lines
 */
export declare function closestPointOnPolylines(p: GeoPoint, lines: GeoPoint[][]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPointIndex: number;
    closestPrePointDist: number;
};

/**
 * 点到线段的最近点
 * @param p
 * @param p1
 * @param p2
 * @return {GeoPoint}
 */
export declare function closestPointOnSegment(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): GeoPoint;

declare type CollectionTypes = IterableCollections | WeakCollections;

declare const COLLISION_TYPES: {
    sphereSphere: 1;
    spherePlane: 3;
    boxBox: 4;
    sphereBox: 5;
    planeBox: 6;
    convexConvex: 16;
    sphereConvex: 17;
    planeConvex: 18;
    boxConvex: 20;
    sphereHeightfield: 33;
    boxHeightfield: 36;
    convexHeightfield: 48;
    sphereParticle: 65;
    planeParticle: 66;
    boxParticle: 68;
    convexParticle: 80;
    cylinderCylinder: 128;
    sphereCylinder: 129;
    planeCylinder: 130;
    boxCylinder: 132;
    convexCylinder: 144;
    heightfieldCylinder: 160;
    particleCylinder: 192;
    sphereTrimesh: 257;
    planeTrimesh: 258;
};

declare type CollisionType = typeof COLLISION_TYPES[keyof typeof COLLISION_TYPES];

/**
 * Color particles by their speed.
 */
export declare class ColorBySpeed implements Simulation {
    color: FunctionColorGenerator | MemorizedFunctionColorGenerator;
    speedRange: IntervalValue;
    type: string;
    constructor(color: FunctionColorGenerator | MemorizedFunctionColorGenerator, speedRange: IntervalValue);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

export { ColorDepthEffect }

export declare interface ColorGenerator {
    type: 'value';
    genColor(color: Vector4): Vector4;
    toJSON(): FunctionJSON;
    clone(): ColorGenerator;
}

export declare function ColorGeneratorFromJSON(json: FunctionJSON): RandomColor | ColorRange | Gradient | RandomColorBetweenGradient | ConstantColor;

/**
 * Color particles by their life.
 */
export declare class ColorOverLife implements Simulation {
    color: FunctionColorGenerator | MemorizedFunctionColorGenerator;
    type: string;
    constructor(color: FunctionColorGenerator | MemorizedFunctionColorGenerator);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

export declare class ColorRange implements ColorGenerator {
    a: Vector4;
    b: Vector4;
    constructor(a: Vector4, b: Vector4);
    genColor(color: Vector4, t?: number): Vector4;
    type: 'value';
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): ColorRange;
    clone(): ColorGenerator;
}

/**
 * Creates an image data url from a color string.
 * @param color - color string (css compatible color)
 * @param width - width of the image (default: 1)
 * @param height - height of the image (default: 1)
 * @return {string} - data url
 */
export declare function colorToDataUrl(color: string, width?: number, height?: number): string;

declare namespace colorTool {
    export {
        parse,
        lift,
        toHex,
        fastLerp,
        lerp_3 as lerp,
        modifyHSL,
        modifyAlpha,
        stringify,
        lum,
        random,
        liftColor,
        fastMapToColor,
        mapToColor
    }
}

declare interface CombineConfig extends ElementAnimateConfig {
    /**
     * Transform of returned will be ignored.
     */
    dividePath?: DividePath;
    /**
     * delay of each individual.
     * Because individual are sorted on z-order. The index is also sorted top-left / right-down.
     */
    individualDelay?: IndividualDelay;
}

/**
 * Make combine morphing from many paths to one.
 * Will return a group to replace the original path.
 */
declare function combineMorph(fromList: (CombineMorphingPath | Path)[], toPath: Path, animationOpts: CombineConfig): {
    fromIndividuals: Path<PathProps>[];
    toIndividuals: any[];
    count: number;
};

declare interface CombineMorphingPath extends Path {
    childrenRef(): (CombineMorphingPath | Path)[];
    __isCombineMorphing: boolean;
}

export declare class CommandHistory {
    #private;
    app: App;
    private undos;
    private redos;
    MaxHistroyLength: number;
    constructor(app: App);
    get debug(): boolean;
    set debug(d: boolean);
    clear(): void;
    execute(cmd: ICommand): void;
    executeAll(cmds: ICommand[]): void;
    executeMany(...cmds: ICommand[]): void;
    undo(): void;
    redo(): any;
}

export declare class CommandModule extends AppModuleBase implements IAppModuleBase {
    #private;
    static moduleName: string;
    options: CommandModuleOptions;
    constructor(app?: App, options?: CommandModuleOptions);
    get commandHistory(): CommandHistory;
    onAwake(): void;
    clearCommands(): void;
    addCommand(cmd: ICommand): void;
    executeCommand(cmd: ICommand): void;
    executeAllCommands(cmds: ICommand[]): void;
    addAllCommands(cmds: ICommand[]): void;
    executeManyCommands(...cmds: ICommand[]): void;
    addManyCommands(...cmds: ICommand[]): void;
    undo(): void;
    redo(): any;
    setupUiConfig(): UiObjectConfig;
}

export declare interface CommandModuleOptions {
    maxHistroyLength?: number;
    debugInfo?: boolean;
    autoListenKeyToUnRedo?: boolean;
    autoListenKeyToUiConfig?: boolean;
}

declare interface CommonStyleProps {
    shadowBlur?: number;
    shadowOffsetX?: number;
    shadowOffsetY?: number;
    shadowColor?: string;
    opacity?: number;
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     */
    blend?: string;
}

/**
 * Abstract class
 */
export declare class CompositeBehavior extends Behavior {
    __children: Behavior[];
    constructor();
    /**
     *
     * @param {Behavior} child
     */
    addChild(child: Behavior): void;
    /**
     *
     * @param {Behavior[]} children
     */
    addChildren(children: Behavior[]): void;
    /**
     * NOTE: do not modify obtained value
     * @return {Behavior[]}
     */
    getChildren(): Behavior[];
    /**
     *
     * @param {Behavior} child
     * @returns {boolean}
     */
    removeChild(child: Behavior): boolean;
    clearChildren(): void;
}

declare class CompoundPath extends Path {
    type: string;
    shape: CompoundPathShape;
    private _updatePathDirty;
    beforeBrush(): void;
    buildPath(ctx: PathProxy | CanvasRenderingContext2D, shape: CompoundPathShape): void;
    afterBrush(): void;
    getBoundingRect(): any;
}

declare interface CompoundPathShape {
    paths: Path[];
}

export declare function computeBoundsTree(options: any): any;

declare function computeBoundsTree_2(options?: MeshBVHOptions): MeshBVH;

/**
 * Takes a getter function and returns a readonly reactive ref object for the
 * returned value from the getter. It can also take an object with get and set
 * functions to create a writable ref object.
 *
 * @example
 * ```js
 * // Creating a readonly computed ref:
 * const count = ref(1)
 * const plusOne = computed(() => count.value + 1)
 *
 * console.log(plusOne.value) // 2
 * plusOne.value++ // error
 * ```
 *
 * ```js
 * // Creating a writable computed ref:
 * const count = ref(1)
 * const plusOne = computed({
 *   get: () => count.value + 1,
 *   set: (val) => {
 *     count.value = val - 1
 *   }
 * })
 *
 * plusOne.value = 1
 * console.log(count.value) // 0
 * ```
 *
 * @param getter - Function that produces the next value.
 */
declare function computed<T>(getter: ComputedGetter<T>, debugOptions?: any): ComputedRef<T>;

declare function computed<T>(options: WritableComputedOptions<T>, debugOptions?: any): WritableComputedRef<T>;

declare type ComputedGetter<T> = (...args: any[]) => T;

declare interface ComputedRef<T = any> extends WritableComputedRef<T> {
    readonly value: T;
    [ComputedRefSymbol]: true;
}

declare const ComputedRefSymbol: unique symbol;

declare type ComputedSetter<T> = (v: T) => void;

declare function computeMeshVolume(mesh: Mesh | BufferGeometry): Number;

declare function computeMikkTSpaceTangents(geometry: BufferGeometry, MikkTSpace: unknown, negateSign?: boolean): BufferGeometry;

declare function computeMorphedAttributes(object: Mesh | Line_2 | Points): object;

declare function concatArray<T, R>(a: ArrayLike_2<T>, b: ArrayLike_2<R>): ArrayLike_2<T | R>;

export declare class ConditionalBehavior extends AbstractDecoratorBehavior {
    condition: Behavior;
    constructor();
    /**
     *
     * @param {Behavior} behavior
     */
    setCondition(behavior: Behavior): void;
    tick(timeDelta: number): BehaviorStatus;
    finalize(): void;
    /**
     *
     * @param {Behavior} condition
     * @param {Behavior} source
     * @return {ConditionalBehavior}
     */
    static from(condition: Behavior, source: Behavior): ConditionalBehavior;
}

export declare class ConditionBehavior extends Behavior {
    __accessor: Function;
    /**
     *
     * @param {function():boolean} accessor
     */
    constructor(accessor: any);
    tick(timeDelta: number): BehaviorStatus.Succeeded | BehaviorStatus.Failed;
}

export declare class ConeEmitter implements EmitterShape {
    type: string;
    radius: number;
    arc: number;
    thickness: number;
    angle: number;
    mode: EmitterMode;
    spread: number;
    speed: ValueGenerator | FunctionValueGenerator;
    private currentValue;
    constructor(parameters?: ConeEmitterParameters);
    update(system: ParticleSystem, delta: number): void;
    initialize(p: Particle, emissionState: EmissionState): void;
    toJSON(): ShapeJSON;
    static fromJSON(json: ShapeJSON): ConeEmitter;
    clone(): EmitterShape;
}

/**
 * Interface representing the parameters for a cone emitter.
 */
export declare interface ConeEmitterParameters {
    /**
     * The radius of the cone base.
     */
    radius?: number;
    /**
     * The arc of the cone.
     */
    arc?: number;
    /**
     * The thickness of the cone. 1 is a full cone, 0 is a cone with 0 thickness.
     */
    thickness?: number;
    /**
     * The angle of the cone, ranging from 0 to Math.PI / 2.
     */
    angle?: number;
    /**
     * The mode of the emitter.
     * {@link EmitterMode}
     */
    mode?: EmitterMode;
    /**
     * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
     * {@link EmitterMode}
     */
    spread?: number;
    /**
     * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
     * {@link EmitterMode}
     */
    speed?: ValueGenerator | FunctionValueGenerator;
}

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 */
declare class ConeEquation extends Equation {
    /**
     * Local axis in A
     */
    axisA: Vec3;
    /**
     * Local axis in B
     */
    axisB: Vec3;
    /**
     * The "cone angle" to keep
     */
    angle: number;
    constructor(bodyA: Body_2, bodyB: Body_2, options?: {
        /**
         * @default 1e6
         */
        maxForce?: number;
        axisA?: Vec3;
        axisB?: Vec3;
        angle?: number;
    });
    computeB(h: number): number;
}

/**
 * A Cone Twist constraint, useful for ragdolls.
 */
declare class ConeTwistConstraint extends PointToPointConstraint {
    /**
     * The axis direction for the constraint of the body A.
     */
    axisA: Vec3;
    /**
     * The axis direction for the constraint of the body B.
     */
    axisB: Vec3;
    /**
     * The aperture angle of the cone.
     */
    angle: number;
    /**
     * The twist angle of the joint.
     */
    twistAngle: number;
    coneEquation: ConeEquation;
    twistEquation: RotationalEquation;
    constructor(bodyA: Body_2, bodyB: Body_2, options?: {
        /**
         * The pivot point for bodyA.
         */
        pivotA?: Vec3;
        /**
         * The pivot point for bodyB.
         */
        pivotB?: Vec3;
        /**
         * The axis direction for the constraint of the body A.
         */
        axisA?: Vec3;
        /**
         * The axis direction for the constraint of the body B.
         */
        axisB?: Vec3;
        /**
         * The aperture angle of the cone.
         * @default 0
         */
        angle?: number;
        /**
         * The twist angle of the joint.
         * @default 0
         */
        twistAngle?: number;
        /**
         * The maximum force that should be applied to constrain the bodies.
         * @default 1e6
         */
        maxForce?: number;
        /**
         * Wether to collide the connected bodies or not.
         * @default false
         */
        collideConnected?: boolean;
    });
    update(): void;
}

declare type ConeTwistConstraintOptions = ConstructorParameters<typeof ConeTwistConstraint>[2];

export declare interface Config<T = unknown> {
    url?: string;
    method: keyof Methods;
    data?: Document | BodyInit;
    headers: {
        [key: string]: string;
    };
    dump: (data: T) => string;
    load: (str: string) => T;
    xmlHttpRequest: () => XMLHttpRequest;
    promise: (fn: () => Promise<unknown>) => Promise<unknown>;
    abort?: any;
    params?: string[][] | Record<string, string> | string | URLSearchParams;
    withCredentials: boolean;
    raw?: boolean;
    events?: {
        [key: string]: () => void;
    };
}

export declare class ConstantColor implements ColorGenerator {
    color: Vector4;
    constructor(color: Vector4);
    genColor(color: Vector4): Vector4;
    type: 'value';
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): ConstantColor;
    clone(): ColorGenerator;
}

export declare class ConstantValue implements ValueGenerator {
    value: number;
    type: "value";
    constructor(value: number);
    genValue(): number;
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): ConstantValue;
    clone(): ValueGenerator;
}

export declare interface ConstInput {
    getValue(context: ExecutionContext): any;
}

/**
 * Constraint base class
 */
declare class Constraint {
    /**
     * Equations to be solved in this constraint.
     */
    equations: Equation[];
    /**
     * Body A.
     */
    bodyA: Body_2;
    /**
     * Body B.
     */
    bodyB: Body_2;
    id: number;
    /**
     * Set to false if you don't want the bodies to collide when they are connected.
     */
    collideConnected: boolean;
    static idCounter: number;
    constructor(bodyA: Body_2, bodyB: Body_2, options?: {
        /**
         * Set to false if you don't want the bodies to collide when they are connected.
         * @default true
         */
        collideConnected?: boolean;
        /**
         * Set to false if you don't want the bodies to wake up when they are connected.
         * @default true
         */
        wakeUpBodies?: boolean;
    });
    /**
     * Update all the equations with data.
     */
    update(): void;
    /**
     * Enables all equations in the constraint.
     */
    enable(): void;
    /**
     * Disables all equations in the constraint.
     */
    disable(): void;
}

declare type ConstraintOptions = ConstructorParameters<typeof Constraint>[2];

export declare interface Constructable<T> {
    new (...args: any): T;
}

/**
 * Contact/non-penetration constraint equation
 */
declare class ContactEquation extends Equation {
    /**
     * "bounciness": u1 = -e*u0
     */
    restitution: number;
    /**
     * World-oriented vector that goes from the center of bi to the contact point.
     */
    ri: Vec3;
    /**
     * World-oriented vector that starts in body j position and goes to the contact point.
     */
    rj: Vec3;
    /**
     * Contact normal, pointing out of body i.
     */
    ni: Vec3;
    constructor(bodyA: Body_2, bodyB: Body_2, maxForce?: number);
    computeB(h: number): number;
    /**
     * Get the current relative velocity in the contact point.
     */
    getImpactVelocityAlongNormal(): number;
}

/**
 * Defines what happens when two materials meet.
 * @todo Refactor materials to materialA and materialB
 */
declare class ContactMaterial {
    /**
     * Identifier of this material.
     */
    id: number;
    /**
     * Participating materials.
     */
    materials: [Material_2, Material_2];
    /**
     * Friction coefficient.
     * @default 0.3
     */
    friction: number;
    /**
     * Restitution coefficient.
     * @default 0.3
     */
    restitution: number;
    /**
     * Stiffness of the produced contact equations.
     * @default 1e7
     */
    contactEquationStiffness: number;
    /**
     * Relaxation time of the produced contact equations.
     * @default 3
     */
    contactEquationRelaxation: number;
    /**
     * Stiffness of the produced friction equations.
     * @default 1e7
     */
    frictionEquationStiffness: number;
    /**
     * Relaxation time of the produced friction equations
     * @default 3
     */
    frictionEquationRelaxation: number;
    static idCounter: number;
    constructor(m1: Material_2, m2: Material_2, options: {
        /**
         * Friction coefficient.
         * @default 0.3
         */
        friction?: number;
        /**
         * Restitution coefficient.
         * @default 0.3
         */
        restitution?: number;
        /**
         * Stiffness of the produced contact equations.
         * @default 1e7
         */
        contactEquationStiffness?: number;
        /**
         * Relaxation time of the produced contact equations.
         * @default 3
         */
        contactEquationRelaxation?: number;
        /**
         * Stiffness of the produced friction equations.
         * @default 1e7
         */
        frictionEquationStiffness?: number;
        /**
         * Relaxation time of the produced friction equations
         * @default 3
         */
        frictionEquationRelaxation?: number;
    });
}

declare type ContactMaterialOptions = ConstructorParameters<typeof ContactMaterial>[2];

declare const CONTAINED: ShapecastIntersection;

/**
 * 是否包含骨骼
 * @param object3D
 */
export declare function containSkeleton(object3D: Object3D): boolean;

/**
 * 上下文菜单.
 *
 **/
export declare class ContextMenu {
    private options;
    private menuControl;
    private position;
    /**
     * Creates a new ContextMenu menu
     * @param {object} opts options which build the menu e.g. position and items
     * @param {number} opts.width sets the width of the menu including children
     * @param {object} opts.event 事件对象
     * @param {theme} opts.theme 自定义的样式主题，支持dark和light，默认dark
     * @param {boolean} opts.isSticky sets how the menu apears, follow the mouse or sticky
     * @param {Array<ContextMenuItem>} opts.items sets the default items in the menu
     */
    constructor(opts: ContextMenuOptions);
    /**
     * Adds item to this ContextMenu menu instance
     * @param {ContextMenuItem} item item to add to the ContextMenu menu
     */
    add(item: any): void;
    /**
     * Makes this ContextMenu menu visible
     */
    show(): void;
    /**
     * Hides this ContextMenu menu
     */
    hide(): void;
    /**
     * Toggle visibility of menu
     */
    toggle(): void;
}

/**
 * 上下文菜单选项.
 *
 **/
export declare interface ContextMenuOptions {
    /** 事件对象. */
    event?: Event;
    /** 菜单宽度（包括子菜单),像素，默认150px. */
    width?: string;
    /** 菜单主题色.(dark和light,默认dark)*/
    theme?: string;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小宽 可通过 map.getContainer().getBoundingClientRect().width来设置 */
    innerWidth?: number;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小高 可通过 map.getContainer().getBoundingClientRect().height来设置 */
    innerHeight?: number;
    /** 子项 */
    items: ContextMenuSubItemOptions[];
    /** 弹出位置，如果不默认，则是event中的位置 . */
    position?: [number, number];
}

/**
 * 上下文菜单子项选项.
 *
 **/
export declare interface ContextMenuSubItemOptions {
    /** 子菜单类型. */
    type?: "custom" | "multi" | "Button" | "seperator" | "submenu" | "hovermenu" | "normal";
    /** 类型为'custom'时的自定义html内容 */
    markup?: string;
    /** 类型为'multi'时子菜单项*/
    items?: ContextMenuSubItemOptions[];
    /** 点击事件*/
    onClick?: Function;
    /** 菜单名称*/
    label?: string;
    /** 快捷菜单*/
    shortcut?: string;
    /** 是否能用*/
    enabled?: boolean;
    /** css图标*/
    cssIcon?: string;
    /** 图标 如果设置为"checked"将用默认选中图标*/
    icon?: string;
}

declare class ContinuousLinearFunction<T extends ObjectValueType<T> | number> {
    keys: Array<[T, number]>;
    type: 'function';
    subType: 'Number' | 'Vector3' | 'Vector4' | 'Color';
    constructor(keys: Array<[T, number]>, subType: 'Number' | 'Vector3' | 'Vector4' | 'Color');
    findKey(t: number): number;
    getStartX(index: number): number;
    getEndX(index: number): number;
    genValue(value: T, t: number): T;
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): ContinuousLinearFunction<any>;
    clone(): ContinuousLinearFunction<any>;
}

declare class Controller {
    isController: boolean;
    object: object;
    property: string;
    callback?: Function;
    _defaultValue?: any;
    _label?: string;
    _type?: string;
    _bounds?: [number, number];
    value?: any;
    getValue?: () => any;
    setValue?: (value: any, ...args: ChangeArgs) => void;
    hidden?: ValOrFunc<boolean>;
    disabled?: ValOrFunc<boolean>;
    readOnly?: ValOrFunc<boolean>;
    tags?: ValOrArr<string>;
    onClick?: (...args: any[]) => void;
    bounds?: ValOrFunc<number[]>;
    stepSize?: ValOrFunc<number>;
    expanded?: ValOrFunc<boolean>;
    onExpand?: (c: UiObjectConfig) => void;
    inlinePicker?: ValOrFunc<boolean>;
    children?: Array<UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>>;
    constructor(object: object, property: string);
    onChange(callback: Function): this;
    on(eventName: any, callback: Function): this;
    defaultValue(v: any): this;
    label(val: string): this;
    name(val: string): this;
    type(val: string): this;
    options(val: any[]): this;
    min(min: number): this;
    max(max: number): this;
    step(step: number): this;
    toJson(): {
        type: string;
        label: string;
        property: (string | object)[];
        onChange: Function;
        value: any;
        getValue: () => any;
        setValue: (value: any, ...args: ChangeArgs) => void;
        hidden: ValOrFunc<boolean>;
        disabled: ValOrFunc<boolean>;
        readOnly: ValOrFunc<boolean>;
        tags: ValOrArr<string>;
        onClick: (...args: any[]) => void;
        bounds: ValOrFunc<number[]>;
        stepSize: ValOrFunc<number>;
        expanded: ValOrFunc<boolean>;
        onExpand: (c: UiObjectConfig<any, string, any>) => void;
        inlinePicker: ValOrFunc<boolean>;
        children: (UiObjectConfig<any, string, any> | Fof<ValOrArrOp<UiObjectConfig<any, string, any>>>)[];
    };
}

export declare interface ControlMarginOptions {
    /** 控件左上角时x边距,默认 0 */
    posTopLeftMarginX?: number;
    /** 控件左上角时y边距,默认 0 */
    posTopLeftMarginY?: number;
    /** 控件右上角时x边距,默认 0 */
    posTopRightMarginX?: number;
    /** 控件右上角时y边距,默认 0 */
    posTopRightMarginY?: number;
    /** 控件左下角时x边距,默认 0 */
    posBottomLeftMarginX?: number;
    /** 控件左下角时y边距,默认 0 */
    posBottomLeftMarginY?: number;
    /** 控件右下角时x边距,默认 0 */
    posBottomRightMarginX?: number;
    /** 控件右下角时y边距,默认 0 */
    posBottomRightMarginY?: number;
}

export declare type ControlPosition = "top-left" | "top-right" | "bottom-left" | "bottom-right";

/**
 * transform
 *
 * @param {geojson|GeoPointLike|GeoPointLike[]|string} input
 * @returns {geojson|GeoPointLike | GeoPointLike[]} output
 */
declare function convert<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(input: T | string, crsFrom: ((pt: GeoPoint) => GeoPoint) | CRSTypes, crsTo?: CRSTypes): T;

export declare const convertToMaterialParameters: (params: any, material?: any) => any;

/**
 * A set of polygons describing a convex shape.
 *
 * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 * @example
 *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
 *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
 *     world.addBody(convexBody)
 */
declare class ConvexPolyhedron extends Shape {
    /** vertices */
    vertices: Vec3[];
    /**
     * Array of integer arrays, indicating which vertices each face consists of
     */
    faces: number[][];
    /** faceNormals */
    faceNormals: Vec3[];
    /** worldVertices */
    worldVertices: Vec3[];
    /** worldVerticesNeedsUpdate */
    worldVerticesNeedsUpdate: boolean;
    /** worldFaceNormals */
    worldFaceNormals: Vec3[];
    /** worldFaceNormalsNeedsUpdate */
    worldFaceNormalsNeedsUpdate: boolean;
    /**
     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
     */
    uniqueAxes: Vec3[] | null;
    /** uniqueEdges */
    uniqueEdges: Vec3[];
    /**
     * @param vertices An array of Vec3's
     * @param faces Array of integer arrays, describing which vertices that is included in each face.
     */
    constructor(props?: {
        /** An array of Vec3's */
        vertices?: Vec3[];
        /** Array of integer arrays, describing which vertices that is included in each face. */
        faces?: number[][];
        /** normals */
        normals?: Vec3[];
        /** axes */
        axes?: Vec3[];
        /** boundingSphereRadius */
        boundingSphereRadius?: number;
    });
    /**
     * Computes uniqueEdges
     */
    computeEdges(): void;
    /**
     * Compute the normals of the faces.
     * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
     */
    computeNormals(): void;
    /**
     * Compute the normal of a face from its vertices
     */
    getFaceNormal(i: number, target: Vec3): void;
    /**
     * Get face normal given 3 vertices
     */
    static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;
    /**
     * @param minDist Clamp distance
     * @param result The an array of contact point objects, see clipFaceAgainstHull
     */
    clipAgainstHull(posA: Vec3, quatA: Quaternion_2, hullB: ConvexPolyhedron, posB: Vec3, quatB: Quaternion_2, separatingNormal: Vec3, minDist: number, maxDist: number, result: ConvexPolyhedronContactPoint[]): void;
    /**
     * Find the separating axis between this hull and another
     * @param target The target vector to save the axis in
     * @return Returns false if a separation is found, else true
     */
    findSeparatingAxis(hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion_2, posB: Vec3, quatB: Quaternion_2, target: Vec3, faceListA?: number[] | null, faceListB?: number[] | null): boolean;
    /**
     * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
     * @return The overlap depth, or FALSE if no penetration.
     */
    testSepAxis(axis: Vec3, hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion_2, posB: Vec3, quatB: Quaternion_2): number | false;
    /**
     * calculateLocalInertia
     */
    calculateLocalInertia(mass: number, target: Vec3): void;
    /**
     * @param face_i Index of the face
     */
    getPlaneConstantOfFace(face_i: number): number;
    /**
     * Clip a face against a hull.
     * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
     * @param minDist Distance clamping
     * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
     */
    clipFaceAgainstHull(separatingNormal: Vec3, posA: Vec3, quatA: Quaternion_2, worldVertsB1: Vec3[], minDist: number, maxDist: number, result: ConvexPolyhedronContactPoint[]): void;
    /**
     * Clip a face in a hull against the back of a plane.
     * @param planeConstant The constant in the mathematical plane equation
     */
    clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3[];
    /**
     * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
     */
    computeWorldVertices(position: Vec3, quat: Quaternion_2): void;
    computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void;
    /**
     * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
     */
    computeWorldFaceNormals(quat: Quaternion_2): void;
    /**
     * updateBoundingSphereRadius
     */
    updateBoundingSphereRadius(): void;
    /**
     * calculateWorldAABB
     */
    calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
    /**
     * Get approximate convex volume
     */
    volume(): number;
    /**
     * Get an average of all the vertices positions
     */
    getAveragePointLocal(target?: Vec3): Vec3;
    /**
     * Transform all local points. Will change the .vertices
     */
    transformAllPoints(offset: Vec3, quat: Quaternion_2): void;
    /**
     * Checks whether p is inside the polyhedra. Must be in local coords.
     * The point lies outside of the convex hull of the other points if and only if the direction
     * of all the vectors from it to those other points are on less than one half of a sphere around it.
     * @param p A point given in local coordinates
     */
    pointIsInside(p: Vec3): 1 | -1 | false;
    /**
     * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
     * Results are saved in the array maxmin.
     * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
     */
    static project(shape: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion_2, result: number[]): void;
}

/** ConvexPolyhedronContactPoint */
declare type ConvexPolyhedronContactPoint = {
    point: Vec3;
    normal: Vec3;
    depth: number;
};

export declare type ConvexPolyhedronParameters = {
    vertices: Float32Array;
    faces: number[][];
};

export declare class ConvolutionMaterial extends ShaderMaterial {
    readonly kernel: Float32Array;
    constructor(texelSize?: Vector2);
    setTexelSize(x: number, y: number): void;
    setResolution(resolution: Vector2): void;
}

export declare class CoordSystemModule extends AppModuleBase implements IAppModuleBase {
    #private;
    static moduleName: string;
    options: CoordSystemOption;
    constructor(app?: App, options?: CoordSystemOption);
    onAwake(): void;
    get centerOrigin(): Vector3;
    set centerOrigin(v: Vector3);
    get scaleOrigin(): number;
    set scaleOrigin(v: number);
    /**
     * 屏幕坐标转世界坐标（同 unproject 函数，不同的地方是他支持通过后期处理的深度进行转换，是异步执行的）
     * @param x  屏幕坐标x
     * @param y 屏幕坐标y
     * @param opts (false 不用场景数据, true用场景数据) "depth" 后期处理的深度进行转换，  深度值 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面) 或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
     * @param retIntersectObject 如果需要返回与哪个实体相交而转化的世界坐标，可传入一个object对象
     */
    unprojectAsync(x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}): Promise<Vector3>;
    /**
     * 屏幕坐标转世界坐标
     * @param x  屏幕坐标x
     * @param y 屏幕坐标y
     * @param opts (false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面) 或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
     * @param retIntersectObject 如果需要返回与哪个实体相交而转化的世界坐标，可传入一个object对象
     */
    unproject(x: number | Vector2, y?: number, opts?: UnProjectOpts, retIntersectObject?: {}): any;
    /**
     * 世界坐标转屏幕坐标
     */
    project(x: number | Vector3, y?: number, z?: number): Vector2;
    /**
     * 屏幕坐标转NDC坐标
     */
    screenToNdc(x: number | Vector2, y?: number): Vector2;
    /**
     * NDC坐标转屏幕坐标
     */
    ndcToScreen(x: number | Vector2, y?: number): Vector2;
    setupUiConfig(): UiObjectConfig;
}

/**
 * 坐标系统模块参数
 */
export declare interface CoordSystemOption {
    centerOrigin?: Vector3;
    scaleOrigin?: number;
}

/**
 * 复制矩阵
 */
declare function copy(out: MatrixArray, m: MatrixArray): MatrixArray;

/**
 * 复制向量数据
 */
declare function copy_2<T extends VectorArray>(out: T, v: VectorArray): T;

export { CopyPass }

/**
 * Copy properties from source to dest. Similar to Object.assign, but only copies properties that exist in source, dest and propList.
 * @param source - source object
 * @param dest - destination object
 * @param propList - list of properties to copy
 *
 * @category JS Object
 */
export declare function copyProps<T = AnyOptions>(source: Record<keyof T, any>, dest: T, propList: Array<keyof T>): T;

/**
 * 创建测量标尺
 */
export declare const creataMeasureRuler: (app: App, opts: MeasureRulerOptions) => Entity;

/**
 * Create a identity matrix.
 */
declare function create(): MatrixArray;

/**
 * 创建一个向量
 */
declare function create_2(x?: number, y?: number): VectorArray;

export declare const createAnimatorFrameSpriteMaterial: (props: SpriteMaterialParameters & AnimatorFrameMaterialProps, app: App) => SpriteMaterial;

declare const createCanvas: () => HTMLCanvasElement;

/**
 * Creates a HTML canvas element.
 * @category DOM
 */
export declare function createCanvasElement(): HTMLCanvasElement;

export declare const createDefaultMarkerElement: (options?: {
    /** 对齐 */
    anchor?: Anchor;
    /** html元素 */
    element?: HTMLElement;
    /** 偏移像素量 */
    offset?: [number, number];
    /** 旋转角度(0-360) */
    rotation?: number;
    /** 颜色 */
    color?: string;
    /** 缩放比例 */
    scale?: number;
}) => HTMLElement;

/**
 * Creates a HTML div element.
 * @param innerHTML - HTML string to add to the div
 * @param id - id of the div
 * @param classList - list of classes to add to the div
 * @param addToBody - add the div to the body
 * @param elementTag - tag of the element to create (default: div)
 *
 * @category DOM
 */
export declare function createDiv<T extends keyof HTMLElementTagNameMap = "div">({ innerHTML, id, classList, addToBody, elementTag }: Partial<InnerHTML> & {
    id?: string;
    classList?: string[];
    addToBody?: boolean;
    elementTag?: T;
}): HTMLElementTagNameMap[T];

/**
 * 创建一个流动的渐变材质
 */
export declare const createFlowGradientMaterial: (app: App, options: {
    /** 关联的物体，用来计算坐标min和max */
    object?: Object3D;
    /** 物体坐标最小值 */
    min?: Vector3;
    /** 物体坐标最大值 */
    max?: Vector3;
    /** 动画线宽占整个高度的比例值(如为负数，表示是宽度绝对值，不是比例) */
    lightScale?: number;
    /** 动画时间速度 */
    circleTime?: number;
    /** 颜色 */
    color?: ColorRepresentation;
    /** 透明度 */
    opacity?: number;
    /** 动画线颜色 */
    lightColor?: ColorRepresentation;
    /** 物体上部颜色，使用渐变时有效 */
    topColor?: ColorRepresentation;
    /** 颜色是否随高度渐变 */
    gradient?: boolean;
    /** 高度比例，用来计算渐变色用  */
    heightScale?: number;
    /** 高度便宜值，用来计算渐变色用 */
    heightOffset?: number;
    /** 透明度随高度渐变，顶部的透明度值 */
    topOpacity?: number;
    /** 动画线数量 */
    uLightCount?: number;
    /** 物体向上的方向轴 */
    axis?: "X" | "Y" | "Z";
    /** 计算物体坐标时， 是否用局部坐标 */
    boxinLocalSpace?: boolean;
} & MaterialParameters) => CustomShaderMaterial<MaterialConstructor>;

export declare const createFlyline: (opts?: {
    /** 开始点位置 */
    source?: [number, number, number] | Vector3;
    /** 目标点位置 */
    target?: [number, number, number] | Vector3;
    /** 高度 */
    height?: number;
    /** 粒子大小 */
    size?: number;
    /** 颜色1  */
    color: ColorRepresentation;
    /** 颜色2  */
    color2: ColorRepresentation;
    /** 粒子总数  */
    count?: number;
    /** 显示当前范围的个数 */
    range?: number;
    /** 速度 */
    speed?: number;
    /** 透明度 */
    opacity?: number;
}, app?: App) => Entity;

/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  opts Other options
 */
declare function createFromString(str: string, opts?: SVGPathOption): SVGPath;

declare function createHashMap<T, KEY extends string | number = string | number>(obj?: HashMap<T, KEY> | {
    [key in KEY]?: T;
} | KEY[]): HashMap<T, KEY>;

/**
 * Creates a HTML image element from a url.
 * @param url - url of the image
 *
 * @category DOM
 */
export declare function createImage(url: string): Promise<HTMLImageElement>;

/** 创建一个文本 */
export declare const createLabel: (opts: LabelOptions) => Label;

export declare function createMapApp(map: any, options?: AppOptions): App;

declare function createObject<T>(proto?: object, properties?: T): T;

declare function createPathGetter(ctx: any, path: string): () => any;

declare function createProjectionTask({ model, silhouette, outlines, updateProgressCb, updateVisible, ANGLE_THRESHOLD }?: any): {
    onUpdate: () => void;
    cancel: () => boolean;
    promise: (tm?: any) => Promise<any>;
};

/** 创建镜面反射的mesh */
export declare function createReflectorShaderMesh<TGeometry extends BufferGeometry = BufferGeometry>(geomerty?: TGeometry | null, materialOptions?: {
    /** 默认 ReflectorMaterial */
    reflectorMaterialType?: "ReflectorMaterial" | "ReflectorDudvMaterial";
    color?: Color;
    map?: Texture | string;
    normalMap?: Texture | string;
    normalScale?: Vector2;
    reflectivity?: number;
    mirror?: number;
    mixStrength?: number;
    fog?: Fog;
    dithering?: boolean;
} & MaterialParameters, ignoreObjects?: Object3D[], includeObjects?: Object3D[]): {
    mesh: any;
    material: any;
    attachMesh: (mesh: Mesh, useMeshMap?: boolean) => void;
    detachMesh: (mesh: any) => void;
};

/**
 * 创建2d绘图渲染材质
 * @param elements 或绘制的元素，元素组或渲染对象
 * @param autoCanvasSize 是否根据绘制的内容计算渲染的大小
 */
export declare const createRender2dTexture: (opts: Render2dTextureOptions) => {
    texture: (param?: {
        copyData?: boolean;
        outputImageDebug?: boolean;
        dispose?: boolean;
        expandRect?: number | [number, number, number, number];
    }) => Texture;
    update: (cb: (context: {
        group: render2d.Group;
        render: render2d.Render2dType;
        canvas: HTMLCanvasElement;
    }) => boolean) => boolean;
    dispatchEvent: (eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number) => void;
    dispose: () => void;
    render: render2d.Render2dType;
};

export declare const createRenderElementFlowMaterial: (app: App, options: RenderElementFlowMaterialOptions) => ShaderMaterial & FlowMaterialProps;

/** 创建一个屏幕位置空间的实体对象 */
export declare const createScreenSpaceEntity: (app?: App) => {
    /** 实体 */
    entity: Entity;
    /** 实体下面的组对象 */
    group: Group_2;
    /** 屏幕像素位置转坐标 */
    pixelToPosition: (pixel: any) => Vector3;
    /** 屏幕像素高度转长度 */
    pixelHeightToLength: (pixelHeight: number) => number;
    /** 增加一个对象 */
    addObject: (obj: Object3D, pixel?: [number, number]) => void;
    /** 销毁 */
    dispose: () => void;
};

/**
 * Creates a HTML script element from a url.
 * @param url - url of the script
 * @param root - root element to add the script to (default: head)
 *
 * @category DOM
 */
export declare function createScriptFromURL(url: string, root?: HTMLHeadElement): Promise<HTMLScriptElement>;

export declare const createSpriteAnimator: ({ startFrame, endFrame, fps, frameName, textureDataURL, textureImageURL, loop, numberOfFrames, autoPlay, animationNames, onStart, onEnd, onLoopEnd, onFrame, play, pause, flipX, alphaTest, asSprite, }: SpriteAnimatorProps) => SpriteAnimatorType;

/**
 * Creates a HTML style element with the given styles.
 * @param styles - CSS string
 * @param root - root element to add the style to (default: head)
 *
 * @category DOM
 */
export declare function createStyles(styles: string, root?: Element | undefined): HTMLStyleElement;

export declare const createSymbolMaterial: (props: SymbolMaterialProps) => PointsMaterial;

export declare const createTextFlowMaterial: (app: App, options: TextFlowMaterialOptions) => ShaderMaterial & FlowMaterialProps;

export declare const createTextMesh: ({ sdfGlyphSize, anchorX, anchorY, fontSize, ...restProps }: TextProps) => Promise<TextType>;

export declare const createUnProjectMenu: (e: MouseEvent, obj: {
    UnProjectOpts: UnProjectOpts | "depth";
}, opts?: {
    /** 菜单宽度（包括子菜单),像素，默认150px. */
    width?: string;
    /** 菜单主题色.(dark和light,默认dark)*/
    theme?: string;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小宽 可通过 map.getContainer().getBoundingClientRect().width来设置 */
    innerWidth?: number;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小高 可通过 map.getContainer().getBoundingClientRect().height来设置 */
    innerHeight?: number;
    /** 子项 */
    items: ContextMenuSubItemOptions[];
    /** 弹出位置，如果不默认，则是event中的位置 . */
    position?: [number, number];
}, app?: App) => ContextMenu;

/** 给定坐标和高度，创建一面墙的几何坐标 */
export declare const createWallBufferGeometry: (opts: {
    /** 坐标数组 */
    points: [number, number][];
    /** 高度 */
    height: number;
    /** 是否闭合 */
    isClose?: boolean;
    /** 坐标轴朝上的方向 */
    axisUp?: "x" | "y" | "z";
    /** 是否用中心点坐标, 默认是 */
    isUseCenter?: boolean;
}) => {
    geometry: BufferGeometry<NormalBufferAttributes>;
    center: [number, number, number];
};

export declare function createWorker(obj: Function | string, funcContext?: Record<string, Function | string>): Worker;

export declare function createWorkerWrap(obj: Function | string, funcContext?: Record<string, Function | string>, target?: any): {
    worker: Worker;
    wrap: any;
};

declare enum CRSTypes {
    WGS84 = "WGS84",
    WGS1984 = "WGS84",
    EPSG4326 = "WGS84",
    GCJ02 = "GCJ02",
    AMap = "GCJ02",
    BD09 = "BD09",
    BD09LL = "BD09",
    Baidu = "BD09",
    BMap = "BD09",
    BD09MC = "BD09MC",
    BD09Meter = "BD09MC",
    EPSG3857 = "EPSG3857",
    EPSG900913 = "EPSG3857",
    EPSG102100 = "EPSG3857",
    WebMercator = "EPSG3857",
    WM = "EPSG3857"
}

declare enum CSGOperation {
}

/**
 * A template literal tag that does nothing. Useful for syntax highlighting of CSS code.
 *
 * @example
 * ```js
 * const vertexShader = css`
 *    .my-class {
 *        color: red;
 *    }
 * `
 * ```
 * @category Template Literals
 */
export declare const css: (strings: any, ...rest: any[]) => string;

export declare class CSS2DRendererModule extends AppModuleBase implements IAppModuleBase {
    #private;
    static moduleName: string;
    options: CSS2DRendererModuleOptions;
    _popup2d: Popup2D;
    constructor(app?: App, options?: CSS2DRendererModuleOptions);
    get popup2d(): Popup2D;
    get css2dRenderer(): CSS2DRenderer;
    getMarker2Ds(): Marker2D[];
    getPopup2Ds(): Popup2D[];
    onAwake(): void;
    updateMarker2d(): void;
    onAppRender(time: Time): void;
    setupUiConfig(): UiObjectConfig;
}

export declare interface CSS2DRendererModuleOptions extends CSS2DParameters {
    /** 刷新marker透明度防抖或节流时间毫秒，默认500 */
    refreshMarkerOpacityTimeout?: number;
    /** 遮挡距离误差值 默认0 */
    occlusionDistanceDelta?: number;
    /** 应用popup2d打开样式 */
    popup2dStyle?: PopupOptions;
    /** 要关联的元素 */
    parent?: HTMLElement;
}

export declare class CSS3DRendererModule extends AppModuleBase implements IAppModuleBase {
    #private;
    static moduleName: string;
    options: CSS3DRendererModuleOptions;
    constructor(app?: App, options?: CSS3DRendererModuleOptions);
    get css3dRenderer(): CSS3DRenderer;
    get css3dOccludeRenderer(): CSS3DRenderer;
    onAwake(): void;
    getMarker3Ds(): unknown[];
    setCss3dObjectCanOcclude(object: CSS3DObject, canOcclude?: boolean): void;
    updateMarker3d(): void;
    onAppRender(time: Time): void;
    setupUiConfig(): UiObjectConfig;
}

export declare interface CSS3DRendererModuleOptions extends CSS3DParameters {
    pixelRatio?: number;
    className?: string;
    style?: Partial<CSSStyleDeclaration>;
    parent?: HTMLElement;
    /** 刷新marker透明度防抖或节流时间毫秒，默认500 */
    refreshMarkerOpacityTimeout?: number;
}

export declare class CubeEmitter implements EmitterShape {
    type: string;
    width: number;
    height: number;
    thickness: number;
    mode: EmitterMode;
    spread: number;
    speed: ValueGenerator | FunctionValueGenerator;
    emissionState: EmissionState;
    constructor(parameters?: CubeEmitterParameters);
    private currentValue;
    update(system: ParticleSystem, delta: number): void;
    initialize(p: Particle): void;
    toJSON(): ShapeJSON;
    static fromJSON(json: any): CubeEmitter;
    clone(): EmitterShape;
}

export declare interface CubeEmitterParameters {
    width?: number;
    height?: number;
    thickness?: number;
    mode?: EmitterMode;
    spread?: number;
    speed?: ValueGenerator | FunctionValueGenerator;
    emissionState?: EmissionState;
}

declare class CullableTriangle extends Triangle {
    initFrom(other: Triangle): void;
    updateSide(plane: Plane, triangle: Triangle, coplanarIndex: number): void;
}

declare function curry<F extends CurryFunc, T1 extends Parameters<F>[0]>(func: F, a: T1): Curry1<F, T1>;

declare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, a: T1, b: T2): Curry2<F, T1, T2>;

declare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, a: T1, b: T2, c: T3): Curry3<F, T1, T2, T3>;

declare function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, a: T1, b: T2, c: T3, d: T4): Curry4<F, T1, T2, T3, T4>;

declare type Curry1<F, T1> = F extends (a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Curry2<F, T1, T2> = F extends (a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Curry3<F, T1, T2, T3> = F extends (a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type Curry4<F, T1, T2, T3, T4> = F extends (a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;

declare type CurryFunc = (...arg: any[]) => any;

/**
 * Creates a customized ref with explicit control over its dependency tracking
 * and updates triggering.
 *
 * @param factory - The function that receives the `track` and `trigger` callbacks.
 */
declare function customRef<T>(factory: CustomRefFactory<T>): Ref<T>;

declare type CustomRefFactory<T> = (track: () => void, trigger: () => void) => {
    get: () => T;
    set: (value: T) => void;
};

export declare class CustomShaderMaterial<T extends MaterialConstructor> extends Material {
    uniforms: Uniform;
    private __csm;
    constructor({ baseMaterial, //
        fragmentShader, vertexShader, uniforms, patchMap, cacheKey, silent, ...opts }: iCSMParams<T>);
    /**
     *
     * Update the material with new arguments.
     * TODO: Fix memory leak.
     *
     * @param opts Options to update the material with.
     *
     * @deprecated This method leaks memory.
     */
    update(opts?: iCSMUpdateParams<T>): void;
    /**
     * Returns a new instance of this material with the same options.
     *
     * @returns A clone of this material.
     */
    clone(): this;
    /**
     * Internally calculates the cache key for this instance of CSM.
     * If no specific CSM inputs are provided, the cache key is the same as the default
     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
     *
     * This method is quite expensive owing to the hashing function and string manip.
     *
     * TODO:
     * - Optimize string manip.
     * - Find faster hash function
     *
     * @returns {string} A cache key for this instance of CSM.
     */
    private _getCacheHash;
    /**
     * Does the internal shader generation. Not meant to be called directly.
     *
     * @param fragmentShader
     * @param vertexShader
     * @param uniforms
     */
    private _generateMaterial;
    /**
     * Patches input shader with custom shader. Not meant to be called directly.
     * @param customShader
     * @param shader
     * @param isFrag
     * @returns
     */
    private _patchShader;
    /**
     * Gets the material type as a string. Not meant to be called directly.
     * @returns
     */
    private _getMaterialDefine;
    /**
     * Gets the right patch map for the material. Not meant to be called directly.
     * @returns
     */
    private _getPatchMapForMaterial;
}

/**
 * Cylinder class.
 * @example
 *     const radiusTop = 0.5
 *     const radiusBottom = 0.5
 *     const height = 2
 *     const numSegments = 12
 *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
 *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
 *     world.addBody(cylinderBody)
 */
declare class Cylinder extends ConvexPolyhedron {
    /** The radius of the top of the Cylinder. */
    radiusTop: number;
    /** The radius of the bottom of the Cylinder. */
    radiusBottom: number;
    /** The height of the Cylinder. */
    height: number;
    /** The number of segments to build the cylinder out of. */
    numSegments: number;
    /**
     * @param radiusTop The radius of the top of the Cylinder.
     * @param radiusBottom The radius of the bottom of the Cylinder.
     * @param height The height of the Cylinder.
     * @param numSegments The number of segments to build the cylinder out of.
     */
    constructor(radiusTop?: number, radiusBottom?: number, height?: number, numSegments?: number);
}

export declare type CylinderParameters = {
    radiusTop: number;
    radiusBottom: number;
    height: number;
    segments: number;
};

declare interface Debounce {
    <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "leading" | "both"): (...args: Args) => Result;
    <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailing"): (...args: Args) => Result | undefined;
    <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailingPromise"): (...args: Args) => Promise<Result>;
}

export declare const debounce: Debounce;

export declare function decryptFromBase64(str: string): string;

/**
 * Access property in an object using a string path. Similar to lodash.get
 * @param access - path to access
 * @param tar - target object
 * @param throwOnInvalid - throw error if invalid access or property is undefined. Default is false
 *
 * @example
 * ```js
 * const obj = {a: {b: {c: 1}}}
 * const c = deepAccessObject(['a', 'b', 'c'], obj)
 * console.log(c) // 1
 * ```
 *
 * @category JS Object
 */
export declare function deepAccessObject(access: string | string[], tar: any, throwOnInvalid?: boolean): any;

declare type DeepReadonly<T> = T extends Builtin ? T : T extends Map<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends WeakMap<infer K, infer V> ? WeakMap<DeepReadonly<K>, DeepReadonly<V>> : T extends Set<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends ReadonlySet<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends WeakSet<infer U> ? WeakSet<DeepReadonly<U>> : T extends Promise<infer U> ? Promise<DeepReadonly<U>> : T extends Ref<infer U> ? Readonly<Ref<DeepReadonly<U>>> : T extends {} ? {
    readonly [K in keyof T]: DeepReadonly<T[K]>;
} : Readonly<T>;

/** The default easing function used when no easing is specified. */
export declare let DEFAULT_EASING: string;

declare type DefaultEventDefinition = Dictionary<EventCallback<any[]>>;

declare function defaults<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overlay?: boolean): T & S;

declare type DefaultTextStyle = Pick<TextStyleProps, 'fill' | 'stroke' | 'align' | 'verticalAlign'> & {
    autoStroke?: boolean;
};

export declare class DefaultTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle)[];
}

declare function deferredComputed<T>(getter: () => T): ComputedRef<T>;

export declare const DEG2RAD: number;

export declare function degToRad(degrees: number): number;

declare class Delatin {
    data: number[];
    width: number;
    height: number;
    coords: any[];
    triangles: any[];
    _halfedges: any[];
    _candidates: any[];
    _queueIndices: any[];
    _queue: any[];
    _errors: any[];
    _rms: any[];
    _pending: any[];
    _pendingLen: number;
    _rmsSum: number;
    constructor(data: number[], width: number, height: number);
    run(maxError?: number): void;
    refine(): void;
    getMaxError(): any;
    getRMSD(): number;
    heightAt(x: any, y: any): number;
}

/**
 * Wait for a certain amount of time
 */
export declare class DelayBehavior extends Behavior {
    value: number;
    elapsed: number;
    constructor();
    fromJSON({ value, elapsed }: {
        value: any;
        elapsed?: number;
    }): void;
    /**
     *
     * @param json
     * @return {DelayBehavior}
     */
    static fromJSON(json: {
        value: number;
        elapsed?: number;
    }): DelayBehavior;
    /**
     *
     * @param {number} seconds in seconds
     * @return {DelayBehavior}
     */
    static from(seconds: number): DelayBehavior;
    initialize(ctx: BehaviorContext): void;
    tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
}

export declare function deleteArrItem<T>(arr: T[], item: T): void;

declare type Dep = Set<ReactiveEffect> & TrackedMarkers;

export declare class DependencyError extends Error {
    constructor(classInstance: any, message: any, activeModule: any, dependencyModule?: boolean);
}

export { DepthOfFieldEffect }

export { DepthPass }

export { DepthPickingPass }

export declare class DestoryBehavior extends Behavior {
    constructor();
    static create(): DestoryBehavior;
    tick(timeDelta: number): BehaviorStatus;
}

declare type Dictionary<T> = {
    [key: string]: T;
};

declare const DIFFERENCE: CSGOperation;

/**
 * 扩散的点.
 */
export declare class DiffusedApertureMarker extends AnimateMarkerBase {
    constructor(features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
}

/**
 * 对物体禁用曝光
 */
export declare function disableBloom(object: Object3D, enable?: boolean): void;

/**
 * 对物体禁用曝光、禁用选择、禁用选择
 */
export declare function disableBloomSelectedRayQuery(object: Object3D, enable?: boolean, excludeObjs?: Object3D[]): void;

/**
 * 对物体禁用描边
 */
export declare function disableOutline(object: Object3D, enable?: boolean): void;

/**
 * 对物体拾取时禁用射线查询
 */
export declare function disableRayQuery(object: Object3D, enable?: boolean): void;

/**
 * 对物体禁用选择
 */
export declare function disableSelected(object: Object3D, enable?: boolean): void;

declare function disableUserSelect(dom: HTMLElement): void;

export declare class DispatchEvent {
    type: string;
    cancelBubble: boolean;
    data: Record<string, any>;
    constructor(type: string);
    stopPropagation(): void;
}

/**
 *
 * @param {SignalHandler[]} handlers
 * @param {Array} [args]
 */
export declare function dispatchViaProxy(handlers: any, args: any): void;

declare interface Displayable<Props extends DisplayableProps = DisplayableProps> {
    animate(key?: '', loop?: boolean): Animator_2<this>;
    animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
    getState(stateName: string): DisplayableState;
    ensureState(stateName: string): DisplayableState;
    states: Dictionary<DisplayableState>;
    stateProxy: (stateName: string) => DisplayableState;
}

declare class Displayable<Props extends DisplayableProps = DisplayableProps> extends Element_2<Props> {
    /**
     * Whether the displayable object is visible. when it is true, the displayable object
     * is not drawn, but the mouse event can still trigger the object.
     */
    invisible: boolean;
    z: number;
    z2: number;
    /**
     * The z level determines the displayable object can be drawn in which layer canvas.
     */
    zlevel: number;
    /**
     * If enable culling
     */
    culling: boolean;
    /**
     * Mouse cursor when hovered
     */
    cursor: string;
    /**
     * If hover area is bounding rect
     */
    rectHover: boolean;
    /**
     * For increamental rendering
     */
    incremental: boolean;
    /**
     * Never increase to target size
     */
    ignoreCoarsePointer?: boolean;
    style: Dictionary<any>;
    protected _normalState: DisplayableState;
    protected _rect: BoundingRect;
    protected _paintRect: BoundingRect;
    protected _prevPaintRect: BoundingRect;
    dirtyRectTolerance: number;
    /************* Properties will be inejected in other modules. *******************/
    useHoverLayer?: boolean;
    __hoverStyle?: CommonStyleProps;
    __clipPaths?: Path[];
    __canvasFillGradient: CanvasGradient;
    __canvasStrokeGradient: CanvasGradient;
    __canvasFillPattern: CanvasPattern;
    __canvasStrokePattern: CanvasPattern;
    __svgEl: SVGElement;
    constructor(props?: Props);
    protected _init(props?: Props): void;
    beforeBrush(): void;
    afterBrush(): void;
    innerBeforeBrush(): void;
    innerAfterBrush(): void;
    shouldBePainted(viewWidth: number, viewHeight: number, considerClipPath: boolean, considerAncestors: boolean): boolean;
    /**
     * If displayable element contain coord x, y
     */
    contain(x: number, y: number): boolean;
    traverse<Context>(cb: (this: Context, el: this) => void, context?: Context): void;
    /**
     * If bounding rect of element contain coord x, y
     */
    rectContain(x: number, y: number): boolean;
    getPaintRect(): BoundingRect;
    setPrevPaintRect(paintRect: BoundingRect): void;
    getPrevPaintRect(): BoundingRect;
    /**
     * Alias for animate('style')
     * @param loop
     */
    animateStyle(loop: boolean): Animator_2<this["style"]>;
    updateDuringAnimation(targetKey: string): void;
    attrKV(key: DisplayableKey, value: DisplayablePropertyType): void;
    setStyle(obj: Props['style']): this;
    setStyle<T extends keyof Props['style']>(obj: T, value: Props['style'][T]): this;
    dirtyStyle(notRedraw?: boolean): void;
    dirty(): void;
    /**
     * Is style changed. Used with dirtyStyle.
     */
    styleChanged(): boolean;
    /**
     * Mark style updated. Only useful when style is used for caching. Like in the text.
     */
    styleUpdated(): void;
    /**
     * Create a style object with default values in it's prototype.
     */
    createStyle(obj?: Props['style']): Props["style"];
    /**
     * Replace style property.
     * It will create a new style if given obj is not a valid style object.
     */
    useStyle(obj: Props['style']): void;
    /**
     * Determine if an object is a valid style object.
     * Which means it is created by `createStyle.`
     *
     * A valid style object will have all default values in it's prototype.
     * To avoid get null/undefined values.
     */
    isStyleObject(obj: Props['style']): any;
    protected _innerSaveToNormal(toState: DisplayableState): void;
    protected _applyStateObj(stateName: string, state: DisplayableState, normalState: DisplayableState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
    protected _mergeStates(states: DisplayableState[]): DisplayableState;
    protected _mergeStyle(targetStyle: CommonStyleProps, sourceStyle: CommonStyleProps): CommonStyleProps;
    getAnimationStyleProps(): MapToType<DisplayableProps, boolean>;
    /**
     * The string value of `textPosition` needs to be calculated to a real postion.
     * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
     * by default. See `contain/text.js#calculateTextPosition` for more details.
     * But some coutom shapes like "pin", "flag" have center that is not exactly
     * `[width/2, height/2]`. So we provide this hook to customize the calculation
     * for those shapes. It will be called if the `style.textPosition` is a string.
     * @param out Prepared out object. If not provided, this method should
     *        be responsible for creating one.
     * @param style
     * @param rect {x, y, width, height}
         * @return out The same as the input out.
         *         {
         *             x: number. mandatory.
         *             y: number. mandatory.
         *             textAlign: string. optional. use style.textAlign by default.
         *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
         *         }
         */
     protected static initDefaultProps: void;
    }

    declare type DisplayableKey = keyof DisplayableProps;

    declare type DisplayablePropertyType = PropType<DisplayableProps, DisplayableKey>;

    declare interface DisplayableProps extends ElementProps {
        style?: Dictionary<any>;
        zlevel?: number;
        z?: number;
        z2?: number;
        culling?: boolean;
        cursor?: string;
        rectHover?: boolean;
        progressive?: boolean;
        incremental?: boolean;
        ignoreCoarsePointer?: boolean;
        batch?: boolean;
        invisible?: boolean;
    }

    declare type DisplayableState = Pick<DisplayableProps, DisplayableStatePropNames> & ElementCommonState;

    declare type DisplayableStatePropNames = ElementStatePropNames | 'style' | 'z' | 'z2' | 'invisible';

    /**
     * Dispose render2d instance
     */
    declare function dispose(zr: Render2D): void;

    /**
     * Dispose all render2d instances
     */
    declare function disposeAll(): void;

    export declare function disposeBoundsTree(): void;

    declare function disposeBoundsTree_2(): void;

    /**
     * 销毁材质
     * @param material
     */
    export declare const disposeMaterial: (material: Mesh | Material | Material[]) => any;

    /**
     * 销毁物体对象
     * @param object3D
     */
    export declare function disposeObject3D(object3D: Object3D): boolean;

    declare const dist: typeof distance;

    /** 两个点之间的二维距离 */
    export declare function dist2d(coord1: [number, number], coord2: [number, number]): number;

    /**
     * 计算向量间距离
     */
    declare function distance(v1: VectorArray, v2: VectorArray): number;

    /**
     * Constrains two bodies to be at a constant distance from each others center of mass.
     */
    declare class DistanceConstraint extends Constraint {
        /**
         * The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
         */
        distance: number;
        distanceEquation: ContactEquation;
        /**
         * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB.
         * @param maxForce The maximum force that should be applied to constrain the bodies.
         */
        constructor(bodyA: Body_2, bodyB: Body_2, distance?: number, maxForce?: number);
        /**
         * update
         */
        update(): void;
    }

    /**
     * 向量距离平方
     */
    declare function distanceSquare(v1: VectorArray, v2: VectorArray): number;

    declare const distSquare: typeof distanceSquare;

    /**
     * 向量除法
     */
    declare function div<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

    declare interface DividePath {
        (params: DividePathParams): Path[];
    }

    declare interface DividePathParams {
        path: Path;
        count: number;
    }

    declare const DOLLY_DIRECTION: {
        readonly NONE: 0;
        readonly IN: 1;
        readonly OUT: -1;
    };

    declare type DOLLY_DIRECTION = typeof DOLLY_DIRECTION[keyof typeof DOLLY_DIRECTION];

    export declare class DOM {
        static create(tagName: string, className?: string, container?: HTMLElement): HTMLElement;
        static createNS(namespaceURI: string, tagName: string): Element;
        static isMobile(): boolean;
        static setTransform(el: HTMLElement, value: string): void;
        static remove(node: HTMLElement): void;
        /** 通过html和css内容创建div */
        static createStyledDiv(htmlContent: string, cssString?: string): HTMLDivElement;
    }

    declare type DoneCallback = () => void;

    export declare class DonutEmitter implements EmitterShape {
        type: string;
        radius: number;
        donutRadius: number;
        arc: number;
        thickness: number;
        mode: EmitterMode;
        spread: number;
        speed: ValueGenerator | FunctionValueGenerator;
        constructor(parameters?: DonutEmitterParameters);
        private currentValue;
        update(system: ParticleSystem, delta: number): void;
        initialize(p: Particle, emissionState: EmissionState): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any): DonutEmitter;
        clone(): EmitterShape;
    }

    /**
     * Interface representing the parameters for a donut emitter.
     */
    export declare interface DonutEmitterParameters {
        /**
         * The radius of the donut.
         */
        radius?: number;
        /**
         * The arc of the donut.
         */
        arc?: number;
        /**
         * The thickness of the ring. 1 is a full donut, 0 is a ring with 0 radius.
         */
        thickness?: number;
        /**
         * The radius of the hole in the center of the donut.
         */
        donutRadius?: number;
        /**
         * The mode of the emitter.
         * {@link EmitterMode}
         */
        mode?: EmitterMode;
        /**
         * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
         * {@link EmitterMode}
         */
        spread?: number;
        /**
         * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
         * {@link EmitterMode}
         */
        speed?: ValueGenerator | FunctionValueGenerator;
    }

    /**
     * 向量点乘
     */
    declare function dot(v1: VectorArray, v2: VectorArray): number;

    export { DotScreenEffect }

    /**
     * Download a blob as a file in the browser.
     * @param b - blob to download
     * @param name - name of the file
     * @category Browser
     */
    export declare function downloadBlob(b: Blob | string, name: string, options?: BlobPropertyBag): void;

    /**
     * Download a file in the browser.
     * @param b - file to download
     * @param name - name of the file (optional)
     * @category Browser
     */
    export declare function downloadFile(b: File, name?: string): void;

    declare class DrawLine extends StateNode {
        #private;
        static id: string;
        polylines: PolylinesEntity;
        data: PolylineItemData;
        drawOptions?: Record<string, any>;
        highLightSymbolEntity: SymbolEntity;
        snapSymbolEntity: SymbolEntity;
        snapSymbolData: SymbolItemData[];
        onPointerUp: (info: TLEventHandler) => Promise<void>;
        onPointerMove: (info: TLEventHandler) => Promise<void>;
        onMouseDblClick: (info: TLEventHandler) => void;
        onKeyUp: (info: TLEventHandler) => void;
        onContextMenu: (info: TLEventHandler) => ContextMenu;
        onEnter: (info: any) => void;
        onExit: (info: TLEventType, from: string) => void;
        complete(isDblClick?: boolean): void;
    }

    declare class DrawPoint extends StateNode {
        #private;
        static id: string;
        symbol: SymbolEntity;
        data: SymbolItemData;
        drawOptions?: Record<string, any>;
        highLightSymbolEntity: SymbolEntity;
        snapSymbolEntity: SymbolEntity;
        snapSymbolData: SymbolItemData[];
        onPointerUp: (info: TLEventHandler) => Promise<void>;
        onPointerMove: (info: TLEventHandler) => Promise<void>;
        onKeyUp: (info: TLEventHandler) => void;
        onContextMenu: (info: TLEventHandler) => ContextMenu;
        onEnter: (info: any) => void;
        onExit: (info: TLEventType, from: string) => void;
        complete(isDblClick?: boolean): void;
    }

    declare class DrawPolygon extends StateNode {
        #private;
        static id: string;
        polygons: PolygonsEntity;
        polyEdge: PolylinesEntity;
        data: PolygonItemData;
        drawOptions?: Record<string, any>;
        highLightSymbolEntity: SymbolEntity;
        snapSymbolEntity: SymbolEntity;
        snapSymbolData: SymbolItemData[];
        onPointerUp: (info: TLEventHandler) => Promise<void>;
        onPointerMove: (info: TLEventHandler) => Promise<void>;
        onMouseDblClick: (info: TLEventHandler) => void;
        onKeyUp: (info: TLEventHandler) => void;
        onContextMenu: (info: TLEventHandler) => ContextMenu;
        onEnter: (info: any) => void;
        onExit: (info: TLEventType, from: string) => void;
        complete(isDblClick?: boolean): void;
    }

    export declare class DrawShapeTool extends StateNode {
        static id: string;
        static initial: string;
        static children: () => (typeof DrawLine | typeof DrawPoint | typeof DrawPolygon | typeof Edit | typeof Idle_2)[];
        onExit: () => void;
    }

    declare class Droplet extends Path<DropletProps> {
        shape: DropletShape;
        constructor(opts?: DropletProps);
        getDefaultShape(): DropletShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: DropletShape): void;
    }

    declare interface DropletProps extends PathProps {
        shape?: Partial<DropletShape>;
    }

    declare class DropletShape {
        cx: number;
        cy: number;
        width: number;
        height: number;
    }

    export declare interface DynamicEnvConfig {
        envmap1: Texture;
        envmap2: Texture;
    }

    /** 动态环境切换 */
    export declare class DynamicEnvironment {
        #private;
        app: App;
        fbo: any;
        material: ShaderMaterial;
        quad: FullScreenQuad;
        constructor(app: App, config?: Partial<DynamicEnvConfig>);
        dispose(): void;
        update(): void;
        get texture(): any;
        setWeight(value: number): void;
        setIntensity(value: number): void;
        lerpWeight(value: number, duration: number): void;
        lerpIntensity(value: number, duration: number): void;
    }

    export declare class DynamicInstancedMesh extends InstancedMesh {
        maxCapacity: number;
        constructor(geometry: any, material: any, count: any);
        addInstance(matrix4: any, color: any, computeBoundingSphere?: boolean): number;
        removeInstance(i: any, computeBoundingSphere?: boolean): boolean;
    }

    /**
     * 数组或对象遍历
     */
    declare function each<I extends Dictionary<any> | any[] | readonly any[] | ArrayLike_2<any>, Context>(arr: I, cb: (this: Context, value: I extends (infer T)[] | readonly (infer T)[] | ArrayLike_2<infer T> ? T : I extends Dictionary<any> ? I extends Record<infer K, infer T> ? T : unknown : unknown, index?: I extends any[] | readonly any[] | ArrayLike_2<any> ? number : keyof I & string, // keyof Dictionary will return number | string
    arr?: I) => void, context?: Context): void;

    /** Type representing an easing type, which can be either a predefined easing function or a custom easing function. */
    export declare type Easing = keyof Easings | EasingFunction | 'linear' | 'easeInSine' | 'easeOutSine' | 'easeInOutSine' | 'easeInQuad' | 'easeOutQuad' | 'easeInOutQuad' | 'easeInCubic' | 'easeOutCubic' | 'easeInOutCubic' | 'easeInQuart' | 'easeOutQuart' | 'easeInOutQuart' | 'easeInQuint' | 'easeOutQuint' | 'easeInOutQuint' | 'easeInExpo' | 'easeOutExpo' | 'easeInOutExpo' | 'easeInCirc' | 'easeOutCirc' | 'easeInOutCirc' | 'easeInBack' | 'easeOutBack' | 'easeInOutBack' | 'easeInElastic' | 'easeOutElastic' | 'easeInOutElastic' | 'easeInBounce' | 'easeOutBounce' | 'easeInOutBounce';

    declare type easingFunc = (percent: number) => number;

    declare const easingFuncs: {
        /**
         * @param {number} k
         * @return {number}
         */
        linear(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quadraticIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quadraticOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quadraticInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        cubicIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        cubicOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        cubicInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quarticIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quarticOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quarticInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quinticIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quinticOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        quinticInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        sinusoidalIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        sinusoidalOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        sinusoidalInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        exponentialIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        exponentialOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        exponentialInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        circularIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        circularOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        circularInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        elasticIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        elasticOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        elasticInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        backIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        backOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        backInOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        bounceIn(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        bounceOut(k: number): number;
        /**
         * @param {number} k
         * @return {number}
         */
        bounceInOut(k: number): number;
    };

    /** Type representing an easing function that takes a single numeric parameter and returns a numeric result. */
    export declare type EasingFunction = (x: number) => number;

    /**
     * Class that provides various easing functions for tweening animations.
     * For more info on these easing functions, check https://easings.net.
     */
    export declare class Easings {
        static linear(x: number): number;
        static easeInSine(x: number): number;
        static easeOutSine(x: number): number;
        static easeInOutSine(x: number): number;
        static easeInQuad(x: number): number;
        static easeOutQuad(x: number): number;
        static easeInOutQuad(x: number): number;
        static easeInCubic(x: number): number;
        static easeOutCubic(x: number): number;
        static easeInOutCubic(x: number): number;
        static easeInQuart(x: number): number;
        static easeOutQuart(x: number): number;
        static easeInOutQuart(x: number): number;
        static easeInQuint(x: number): number;
        static easeOutQuint(x: number): number;
        static easeInOutQuint(x: number): number;
        static easeInExpo(x: number): number;
        static easeOutExpo(x: number): number;
        static easeInOutExpo(x: number): number;
        static easeInCirc(x: number): number;
        static easeOutCirc(x: number): number;
        static easeInOutCirc(x: number): number;
        static easeInBack(x: number): number;
        static easeOutBack(x: number): number;
        static easeInOutBack(x: number): number;
        static easeInElastic(x: number): number;
        static easeOutElastic(x: number): number;
        static easeInOutElastic(x: number): number;
        static easeInBounce(x: number): number;
        static easeOutBounce(x: number): number;
        static easeInOutBounce(x: number): number;
    }

    export { EdgeDetectionMode }

    declare class EdgesHelper extends LineSegments {
        constructor(edges?: Line3[]);
        setEdges(edges: Line3[]): void;
    }

    declare class Edit extends StateNode {
        #private;
        static id: string;
        editOptions?: Record<string, any>;
        queryEntities(info: TLEventHandler, ents?: Entity[]): InteractiveObject;
        onPointerDown: (info: TLEventHandler) => void;
        onPointerMove: (info: TLEventHandler) => void;
        onKeyUp: (info: TLEventHandler) => void;
        onContextMenu: (info: TLEventHandler) => void;
        complete(delay?: boolean): void;
        onPointerUp: (info: TLEventHandler) => void;
        onMouseDblClick: (info: TLEventHandler) => void;
        onEnter: (info: TLEventType) => void;
        clearSelection(isGotoChildEdit?: boolean): void;
        onExit: (info: TLEventType, from: string) => void;
    }

    export { Effect }

    /**
     * Registers the given function to track reactive updates.
     *
     * The given function will be run once immediately. Every time any reactive
     * property that's accessed within it gets updated, the function will run again.
     *
     * @param fn - The function that will track reactive updates.
     * @param options - Allows to control the effect's behaviour.
     * @returns A runner that can be used to control the effect after creation.
     */
    declare function effect<T = any>(fn: () => T, options?: ReactiveEffectOptions): ReactiveEffectRunner;

    export { EffectAttribute }

    export { EffectComposer }

    export { EffectPass }

    declare type EffectScheduler = (...args: any[]) => any;

    declare class EffectScope {
        detached: boolean;
        constructor(detached?: boolean);
        get active(): boolean;
        run<T>(fn: () => T): T | undefined;
        stop(fromParent?: boolean): void;
    }

    /**
     * Creates an effect scope object which can capture the reactive effects (i.e.
     * computed and watchers) created within it so that these effects can be
     * disposed together. For detailed use cases of this API, please consult its
     *
     * @param detached - Can be used to create a "detached" effect scope.
     */
    declare function effectScope(detached?: boolean): EffectScope;

    declare interface Element_2<Props extends ElementProps = ElementProps> extends Transformable, Eventful<{
        [key in ElementEventName]: (e: ElementEvent) => void | boolean;
    } & {
        [key in string]: (...args: any) => void | boolean;
    }>, ElementEventHandlerProps {
    }

    declare class Element_2<Props extends ElementProps = ElementProps> {
        id: number;
        /**
         * Element type
         */
        type: string;
        /**
         * Element name
         */
        name: string;
        /**
         * If ignore drawing and events of the element object
         */
        ignore: boolean;
        /**
         * Whether to respond to mouse events.
         */
        silent: boolean;
        /**
         * 是否是 Group
         */
        isGroup: boolean;
        /**
         * Whether it can be dragged.
         */
        draggable: boolean | 'horizontal' | 'vertical';
        /**
         * Whether is it dragging.
         */
        dragging: boolean;
        parent: Group;
        animators: Animator_2<any>[];
        /**
         * If ignore clip from it's parent or hosts.
         * Applied on itself and all it's children.
         *
         * NOTE: It won't affect the clipPath set on the children.
         */
        ignoreClip: boolean;
        /**
         * If element is used as a component of other element.
         */
        __hostTarget: Element_2;
        /**
         * Render2D instance will be assigned when element is associated with render2d
         */
        __zr: Render2dType;
        /**
         * Dirty bits.
         * From which painter will determine if this displayable object needs brush.
         */
        __dirty: number;
        /**
         * If element was painted on the screen
         */
        __isRendered: boolean;
        /**
         * If element has been moved to the hover layer.
         *
         * If so, dirty will only trigger the render2d refresh hover layer
         */
        __inHover: boolean;
        /**
         * path to clip the elements and its children, if it is a group.
         * @see http://www.w3.org/TR/2dcontext/#clipping-region
         */
        private _clipPath?;
        /**
         * Attached text element.
         * `position`, `style.textAlign`, `style.textVerticalAlign`
         * of element will be ignored if textContent.position is set
         */
        private _textContent?;
        /**
         * Text guide line.
         */
        private _textGuide?;
        /**
         * Config of textContent. Inlcuding layout, color, ...etc.
         */
        textConfig?: ElementTextConfig;
        /**
         * Config for guide line calculating.
         *
         * NOTE: This is just a property signature. READ and WRITE are all done in .
         */
        textGuideLineConfig?: ElementTextGuideLineConfig;
        /**
         * Id for mapping animation
         */
        anid: string;
        extra: Dictionary<unknown>;
        currentStates?: string[];
        prevStates?: string[];
        /**
         * Store of element state.
         * '__normal__' key is preserved for default properties.
         */
        states: Dictionary<ElementState>;
        /**
         * Animation config applied on state switching.
         */
        stateTransition: ElementAnimateConfig;
        /**
         * Proxy function for getting state with given stateName.
         * Render2D will first try to get with stateProxy. Then find from states if stateProxy returns nothing
         *
         * targetStates will be given in useStates
         */
        stateProxy?: (stateName: string, targetStates?: string[]) => ElementState;
        protected _normalState: ElementState;
        private _innerTextDefaultStyle;
        constructor(props?: Props);
        protected _init(props?: Props): void;
        /**
         * Drift element
         * @param {number} dx dx on the global space
         * @param {number} dy dy on the global space
         */
        drift(dx: number, dy: number, e?: ElementEvent): void;
        /**
         * Hook before update
         */
        beforeUpdate(): void;
        /**
         * Hook after update
         */
        afterUpdate(): void;
        /**
         * Update each frame
         */
        update(): void;
        updateInnerText(forceUpdate?: boolean): void;
        protected canBeInsideText(): boolean;
        protected getInsideTextFill(): string | undefined;
        protected getInsideTextStroke(textFill: string): string | undefined;
        protected getOutsideFill(): string | undefined;
        protected getOutsideStroke(textFill: string): string;
        traverse<Context>(cb: (this: Context, el: Element_2<Props>) => void, context?: Context): void;
        protected attrKV(key: string, value: unknown): void;
        /**
         * Hide the element
         */
        hide(): void;
        /**
         * Show the element
         */
        show(): void;
        attr(keyOrObj: Props): this;
        attr<T extends keyof Props>(keyOrObj: T, value: Props[T]): this;
        saveCurrentToNormalState(toState: ElementState): void;
        protected _innerSaveToNormal(toState: ElementState): void;
        protected _savePrimaryToNormal(toState: Dictionary<any>, normalState: Dictionary<any>, primaryKeys: readonly string[]): void;
        /**
         * If has any state.
         */
        hasState(): boolean;
        /**
         * Get state object
         */
        getState(name: string): ElementState;
        /**
         * Ensure state exists. If not, will create one and return.
         */
        ensureState(name: string): ElementState;
        /**
         * Clear all states.
         */
        clearStates(noAnimation?: boolean): void;
        /**
         * Use state. State is a collection of properties.
         * Will return current state object if state exists and stateName has been changed.
         *
         * @param stateName State name to be switched to
         * @param keepCurrentState If keep current states.
         *      If not, it will inherit from the normal state.
         */
        useState(stateName: string, keepCurrentStates?: boolean, noAnimation?: boolean, forceUseHoverLayer?: boolean): any;
        /**
         * Apply multiple states.
         * @param states States list.
         */
        useStates(states: string[], noAnimation?: boolean, forceUseHoverLayer?: boolean): void;
        /**
         * Return if el.silent or any ancestor element has silent true.
         */
        isSilent(): boolean;
        /**
         * Update animation targets when reference is changed.
         */
        private _updateAnimationTargets;
        /**
         * Remove state
         * @param state State to remove
         */
        removeState(state: string): void;
        /**
         * Replace exists state.
         * @param oldState
         * @param newState
         * @param forceAdd If still add when even if replaced target not exists.
         */
        replaceState(oldState: string, newState: string, forceAdd: boolean): void;
        /**
         * Toogle state.
         */
        toggleState(state: string, enable: boolean): void;
        protected _mergeStates(states: ElementState[]): ElementState;
        protected _applyStateObj(stateName: string, state: ElementState, normalState: ElementState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
        /**
         * Component is some elements attached on this element for specific purpose.
         * Like clipPath, textContent
         */
        private _attachComponent;
        private _detachComponent;
        /**
         * Get clip path
         */
        getClipPath(): Path<PathProps>;
        /**
         * Set clip path
         *
         * clipPath can't be shared between two elements.
         */
        setClipPath(clipPath: Path): void;
        /**
         * Remove clip path
         */
        removeClipPath(): void;
        /**
         * Get attached text content.
         */
        getTextContent(): ZRText;
        /**
         * Attach text on element
         */
        setTextContent(textEl: ZRText): void;
        /**
         * Set layout of attached text. Will merge with the previous.
         */
        setTextConfig(cfg: ElementTextConfig): void;
        /**
         * Remove text config
         */
        removeTextConfig(): void;
        /**
         * Remove attached text element.
         */
        removeTextContent(): void;
        getTextGuideLine(): Polyline;
        setTextGuideLine(guideLine: Polyline): void;
        removeTextGuideLine(): void;
        /**
         * Mark element needs to be repainted
         */
        markRedraw(): void;
        /**
         * Besides marking elements to be refreshed.
         * It will also invalid all cache and doing recalculate next frame.
         */
        dirty(): void;
        private _toggleHoverLayerFlag;
        /**
         * Add self from render2d instance.
         * Not recursively because it will be invoked when element added to storage.
         */
        addSelfToZr(zr: Render2dType): void;
        /**
         * Remove self from render2d instance.
         * Not recursively because it will be invoked when element added to storage.
         */
        removeSelfFromZr(zr: Render2dType): void;
        /**
         * 动画
         *
         * @param path The key to fetch value from object. Mostly style or shape.
         * @param loop Whether to loop animation.
         * @param allowDiscreteAnimation Whether to allow discrete animation
         * @example:
         *     el.animate('style', false)
         *         .when(1000, {x: 10} )
         *         .done(function(){ // Animation done })
         *         .start()
         */
        animate(key?: string, loop?: boolean, allowDiscreteAnimation?: boolean): Animator_2<any>;
        addAnimator(animator: Animator_2<any>, key: string): void;
        updateDuringAnimation(key: string): void;
        /**
         * 停止动画
         * @param {boolean} forwardToLast If move to last frame before stop
         */
        stopAnimation(scope?: string, forwardToLast?: boolean): this;
        /**
         * @param animationProps A map to specify which property to animate. If not specified, will animate all.
         * @example
         *  // Animate position
         *  el.animateTo({
         *      position: [10, 10]
         *  }, { done: () => { // done } })
         *
         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
         *  el.animateTo({
         *      shape: {
         *          width: 500
         *      },
         *      style: {
         *          fill: 'red'
         *      }
         *      position: [10, 10]
         *  }, {
         *      duration: 100,
         *      delay: 100,
         *      easing: 'cubicOut',
         *      done: () => { // done }
         *  })
         */
        animateTo(target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
        /**
         * Animate from the target state to current state.
         * The params and the value are the same as `this.animateTo`.
         */
        animateFrom(target: Props, cfg: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
        protected _transitionState(stateName: string, target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
        /**
         * Interface of getting the minimum bounding box.
         */
        getBoundingRect(): BoundingRect;
        getPaintRect(): BoundingRect;
        /**
         * The string value of `textPosition` needs to be calculated to a real postion.
         * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
         * by default. See `contain/text.js#calculateTextPosition` for more details.
         * But some coutom shapes like "pin", "flag" have center that is not exactly
         * `[width/2, height/2]`. So we provide this hook to customize the calculation
         * for those shapes. It will be called if the `style.textPosition` is a string.
         * @param {Obejct} [out] Prepared out object. If not provided, this method should
         *        be responsible for creating one.
         * @param {module:render2d/graphic/Style} style
         * @param {Object} rect {x, y, width, height}
         * @return {Obejct} out The same as the input out.
         *         {
         *             x: number. mandatory.
         *             y: number. mandatory.
         *             align: string. optional. use style.textAlign by default.
         *             verticalAlign: string. optional. use style.textVerticalAlign by default.
         *         }
         */
        calculateTextPosition: ElementCalculateTextPosition;
        protected static initDefaultProps: void;
    }

    declare interface ElementAnimateConfig {
        duration?: number;
        delay?: number;
        easing?: AnimationEasing;
        during?: (percent: number) => void;
        done?: Function;
        aborted?: Function;
        scope?: string;
        /**
         * If force animate
         * Prevent stop animation and callback
         * immediently when target values are the same as current values.
         */
        force?: boolean;
        /**
         * If use additive animation.
         */
        additive?: boolean;
        /**
         * If set to final state before animation started.
         * It can be useful if something you want to calcuate depends on the final state of element.
         * Like bounding rect for text layouting.
         *
         * Only available in animateTo
         */
        setToFinal?: boolean;
    }

    declare type ElementCalculateTextPosition = (out: TextPositionCalculationResult, style: ElementTextConfig, rect: RectLike) => TextPositionCalculationResult;

    declare type ElementCommonState = {
        hoverLayer?: boolean;
    };

    declare interface ElementEvent {
        type: ElementEventName;
        event: ZRRawEvent;
        target: Element_2;
        topTarget: Element_2;
        cancelBubble: boolean;
        offsetX: number;
        offsetY: number;
        gestureEvent: string;
        pinchX: number;
        pinchY: number;
        pinchScale: number;
        wheelDelta: number;
        zrByTouch: boolean;
        which: number;
        stop: (this: ElementEvent) => void;
    }

    declare type ElementEventCallback<Ctx, Impl> = (this: CbThis<Ctx, Impl>, e: ElementEvent) => boolean | void;

    declare interface ElementEventHandlerProps {
        onclick: ElementEventCallback<unknown, unknown>;
        ondblclick: ElementEventCallback<unknown, unknown>;
        onmouseover: ElementEventCallback<unknown, unknown>;
        onmouseout: ElementEventCallback<unknown, unknown>;
        onmousemove: ElementEventCallback<unknown, unknown>;
        onmousewheel: ElementEventCallback<unknown, unknown>;
        onmousedown: ElementEventCallback<unknown, unknown>;
        onmouseup: ElementEventCallback<unknown, unknown>;
        oncontextmenu: ElementEventCallback<unknown, unknown>;
        ondrag: ElementEventCallback<unknown, unknown>;
        ondragstart: ElementEventCallback<unknown, unknown>;
        ondragend: ElementEventCallback<unknown, unknown>;
        ondragenter: ElementEventCallback<unknown, unknown>;
        ondragleave: ElementEventCallback<unknown, unknown>;
        ondragover: ElementEventCallback<unknown, unknown>;
        ondrop: ElementEventCallback<unknown, unknown>;
    }

    declare type ElementEventName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseover' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu' | 'drag' | 'dragstart' | 'dragend' | 'dragenter' | 'dragleave' | 'dragover' | 'drop' | 'globalout';

    declare interface ElementProps extends Partial<ElementEventHandlerProps>, Partial<Pick<Transformable, TransformProp>> {
        name?: string;
        ignore?: boolean;
        isGroup?: boolean;
        draggable?: boolean | 'horizontal' | 'vertical';
        silent?: boolean;
        ignoreClip?: boolean;
        globalScaleRatio?: number;
        textConfig?: ElementTextConfig;
        textContent?: ZRText;
        clipPath?: Path;
        drift?: Element_2['drift'];
        extra?: Dictionary<unknown>;
        anid?: string;
    }

    declare type ElementSSRData = zrUtil.HashMap<unknown>;

    declare type ElementSSRDataGetter<T> = (el: Element_2) => zrUtil.HashMap<T>;

    declare type ElementState = Pick<ElementProps, ElementStatePropNames> & ElementCommonState;

    declare type ElementStatePropNames = (typeof PRIMARY_STATES_KEYS)[number] | 'textConfig';

    declare interface ElementTextConfig {
        /**
         * Position relative to the element bounding rect
         * @default 'inside'
         */
        position?: BuiltinTextPosition | (number | string)[];
        /**
         * Rotation of the label.
         */
        rotation?: number;
        /**
         * Rect that text will be positioned.
         * Default to be the rect of element.
         */
        layoutRect?: RectLike;
        /**
         * Offset of the label.
         * The difference of offset and position is that it will be applied
         * in the rotation
         */
        offset?: number[];
        /**
         * Origin or rotation. Which is relative to the bounding box of the attached element.
         * Can be percent value. Relative to the bounding box.
         * If specified center. It will be center of the bounding box.
         *
         * Only available when position and rotation are both set.
         */
        origin?: (number | string)[] | 'center';
        /**
         * Distance to the rect
         * @default 5
         */
        distance?: number;
        /**
         * If use local user space. Which will apply host's transform
         * @default false
         */
        local?: boolean;
        /**
         * `insideFill` is a color string or left empty.
         * If a `textContent` is "inside", its final `fill` will be picked by this priority:
         * `textContent.style.fill` > `textConfig.insideFill` > "auto-calculated-fill"
         * In most cases, "auto-calculated-fill" is white.
         */
        insideFill?: string;
        /**
         * `insideStroke` is a color string or left empty.
         * If a `textContent` is "inside", its final `stroke` will be picked by this priority:
         * `textContent.style.stroke` > `textConfig.insideStroke` > "auto-calculated-stroke"
         *
         * The rule of getting "auto-calculated-stroke":
         * If (A) the `fill` is specified in style (either in `textContent.style` or `textContent.style.rich`)
         * or (B) needed to draw text background (either defined in `textContent.style` or `textContent.style.rich`)
         * "auto-calculated-stroke" will be null.
         * Otherwise, "auto-calculated-stroke" will be the same as `fill` of this element if possible, or null.
         *
         * The reason of (A) is not decisive:
         * 1. If users specify `fill` in style and still use "auto-calculated-stroke", the effect
         * is not good and unexpected in some cases. It not easy and seams uncessary to auto calculate
         * a proper `stroke` for the given `fill`, since they can specify `stroke` themselve.
         * 2. Backward compat.
         */
        insideStroke?: string;
        /**
         * `outsideFill` is a color string or left empty.
         * If a `textContent` is "inside", its final `fill` will be picked by this priority:
         * `textContent.style.fill` > `textConfig.outsideFill` > #000
         */
        outsideFill?: string;
        /**
         * `outsideStroke` is a color string or left empth.
         * If a `textContent` is not "inside", its final `stroke` will be picked by this priority:
         * `textContent.style.stroke` > `textConfig.outsideStroke` > "auto-calculated-stroke"
         *
         * The rule of getting "auto-calculated-stroke":
         * If (A) the `fill` is specified in style (either in `textContent.style` or `textContent.style.rich`)
         * or (B) needed to draw text background (either defined in `textContent.style` or `textContent.style.rich`)
         * "auto-calculated-stroke" will be null.
         * Otherwise, "auto-calculated-stroke" will be a neer white color to distinguish "front end"
         * label with messy background (like other text label, line or other graphic).
         */
        outsideStroke?: string;
        /**
         * Tell render2d I can sure this text is inside or not.
         * In case position is not using builtin `inside` hints.
         */
        inside?: boolean;
    }

    declare interface ElementTextGuideLineConfig {
        /**
         * Anchor for text guide line.
         * Notice: Won't work
         */
        anchor?: Point;
        /**
         * If above the target element.
         */
        showAbove?: boolean;
        /**
         * Candidates of connectors. Used when autoCalculate is true and anchor is not specified.
         */
        candidates?: ('left' | 'top' | 'right' | 'bottom')[];
    }

    declare class Ellipse extends Path<EllipseProps> {
        shape: EllipseShape;
        constructor(opts?: EllipseProps);
        getDefaultShape(): EllipseShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: EllipseShape): void;
    }

    declare interface EllipseProps extends PathProps {
        shape?: Partial<EllipseShape>;
    }

    declare class EllipseShape {
        cx: number;
        cy: number;
        rx: number;
        ry: number;
    }

    /**
     * Find all URLs in svg, download them and replace with the URL in svg with the downloaded data URLs.
     * @param str - string
     * @param downloader - function to download the URLs in svg and return the data URL
     *
     * @category HTML To Image
     */
    export declare function embedUrlRefs(str: string, downloader?: (p: string) => Promise<string>): Promise<string>;

    export declare interface EmissionState {
        burstIndex: number;
        burstWaveIndex: number;
        burstParticleIndex: number;
        burstParticleCount: number;
        isBursting: boolean;
        time: number;
        waitEmiting: number;
        travelDistance: number;
        previousWorldPos?: Vector3;
    }

    declare interface EmissionState_2 {
        time: number;
    }

    /**
     * Emit a sub particle system from particles.
     */
    export declare class EmitSubParticleSystem implements Simulation {
        private particleSystem;
        useVelocityAsBasis: boolean;
        subParticleSystem: ParticleEmitter<Object3DEventMap> | undefined;
        mode: SubParticleEmitMode;
        emitProbability: number;
        type: string;
        private q_;
        private v_;
        private v2_;
        private subEmissions;
        constructor(particleSystem: ParticleSystem, useVelocityAsBasis: boolean, subParticleSystem: ParticleEmitter<Object3DEventMap> | undefined, mode?: SubParticleEmitMode, emitProbability?: number);
        initialize(particle: Particle): void;
        update(particle: Particle, delta: number): void;
        private emit;
        frameUpdate(delta: number): void;
        toJSON(): any;
        static fromJSON(json: any, particleSystem: ParticleSystem): Simulation;
        clone(): Simulation;
        reset(): void;
        private setMatrixFromParticle;
    }

    export declare function EmitterFromJSON(json: ShapeJSON, meta: JsonMetaData): EmitterShape;

    /**
     * Enum representing the emitter modes for particles.
     */
    export declare enum EmitterMode {
        /**
         * Emit particles randomly over the specified duration.
         */
        Random = 0,
        /**
         * Emit particles in a continuous loop.
         */
        Loop = 1,
        /**
         * Emit particles back and forth in a ping-pong manner.
         */
        PingPong = 2,
        /**
         * Emit particles in bursts.
         */
        Burst = 3
    }

    export declare interface EmitterShape {
        type: string;
        initialize(particle: Particle, emissionState: EmissionState): void;
        toJSON(): ShapeJSON;
        update(system: ParticleSystem, delta: number): void;
        clone(): EmitterShape;
    }

    export declare interface EmitterShapeParticlePlugin {
        type: string;
        constructor: Constructable<EmitterShape>;
        params: ParameterPair[];
        loadJSON: (json: any, meta: JsonMetaData) => EmitterShape;
    }

    export declare const EmitterShapes: {
        [key: string]: EmitterShapeParticlePlugin;
    };

    /**
     * 能使材质使用顶点透明度属性
     * @param material
     */
    export declare const enableMaterialVerticeOpacity: (material: Material) => void;

    /** 开启真实渲染 */
    export declare const enableRealisticRender: (renderer: WebGLRenderer) => void;

    /** 开启阴影 */
    export declare const enableShadow: (renderer: WebGLRenderer) => void;

    /** 开启sRGB颜色空间 */
    export declare const enableSRGBColorSpace: (renderer: WebGLRenderer) => void;

    /**
     * Re-enables effect tracking (if it was paused).
     */
    declare function enableTracking(): void;

    export declare function encryptToBase64(str: string): string;

    export declare class Entity extends EntityBase {
        #private;
        static defaultModules: Array<EntityModuleConstructor | [EntityModuleConstructor, any]>;
        /**
         * 实体类型
         */
        entityType: string;
        isEntity: boolean;
        _node: Object3D;
        _pointerEventsRef: Ref<boolean | undefined>;
        options: EntityOptions;
        _childrens: Entity[];
        _ownerScene?: Scene;
        _sceneData?: Record<string, any>;
        _boxHelperObject: BoxHelper;
        /** 位置响应式对象 */
        _positionRef: Vector3;
        /** 旋转响应式对象 */
        _rotationRef: Euler;
        /** 四元数响应式对象 */
        _quaternionRef: Quaternion;
        /** 缩放响应式对象 */
        _scaleRef: Vector3;
        /** 本地矩阵响应式对象 */
        _matrixRef: Matrix4;
        /** 世界矩阵响应式对象 */
        _matrixWorldRef: Matrix4;
        /** 可视响应式对象 */
        _visualRef: Ref<boolean>;
        /** 是否选中 */
        _selectedRef: Ref<boolean>;
        /** 是否描边效果 */
        _outlineRef: Ref<boolean>;
        /** 是否辉光 */
        _bloomRef: Ref<boolean>;
        /** 是否显示包围盒 */
        _boxHelperRef: Ref<boolean>;
        /** 拾取时是否遍历子对象 默认为true*/
        _rayIntersectRecursive?: boolean;
        /** 射线查询类型 默认为1*/
        _rayQueryType?: RayQueryType;
        /** 是否已销毁*/
        _isDisposed?: boolean;
        /** 拾取时实体对象，默认为entity.node */
        rayIntersectObject?: Object3D;
        signal: {
            onBeforeAdd: Signal;
            onAdd: Signal;
            onBeforeRemove: Signal;
            onRemove: Signal;
            onRayIntersect: Signal;
            onMouseUp: Signal;
            onMouseMove: Signal;
            onMouseDown: Signal;
            onMouseClick: Signal;
            onMouseDblClick: Signal;
            onMouseOver: Signal;
            onMouseOut: Signal;
            onMouseEnter: Signal;
            onMouseLeave: Signal;
            onPointerDown: Signal;
            onPointerMove: Signal;
            onPointerUp: Signal;
            /** 鼠标直接按下松开，没有拖动 */
            onPointerDownUp: Signal;
            onPointerCancel: Signal;
            onMouseWheel: Signal;
            onKeyDown: Signal;
            onKeyUp: Signal;
        };
        constructor(options?: EntityOptions);
        /** 创建一个新的实体对象 */
        static create(options?: EntityOptions): Entity;
        /** 基于模块创建一个新的实体对象 */
        static fromModule(mod: EntityModuleConstructor | Array<EntityModuleConstructor | [EntityModuleConstructor, any]>, options?: any): Entity;
        /** 通过一个或多个object3d对象创建一个实体 */
        static fromObject3d: (objs: Object3D | Object3D[]) => Entity;
        /** 通过一个或多个object3d对象和模块创建一个实体 */
        static fromObjectModule: (objs: Object3D | Object3D[], mod: EntityModuleConstructor | Array<EntityModuleConstructor | [EntityModuleConstructor, any]>, options?: any) => Entity;
        /**
         * 通过一个obejct获取所属的实体
         * @param object 物体对象
         * @param canChildEntity 是否获取到子实体。默认false.  false的话表示获取的是最上级的实体对象。true获取的是所属的子实体对象
         */
        static getOwerEntity(object: Object3D, canChildEntity?: boolean): Entity | undefined;
        get isDisposed(): boolean;
        get visibleRef(): Ref<boolean>;
        get visible(): boolean;
        set visible(val: boolean);
        get selectedRef(): Ref<boolean>;
        get selected(): boolean;
        set selected(val: boolean);
        get bloomRef(): Ref<boolean>;
        get bloom(): boolean;
        set bloom(val: boolean);
        get outlineRef(): Ref<boolean>;
        get outline(): boolean;
        set outline(val: boolean);
        get boxHelperRef(): Ref<boolean>;
        get boxHelper(): boolean | BoxHelperOptions;
        set boxHelper(val: boolean | BoxHelperOptions);
        get castShadow(): boolean;
        set castShadow(val: boolean);
        get receiveShadow(): boolean;
        set receiveShadow(val: boolean);
        get frustumCulled(): boolean;
        set frustumCulled(val: boolean);
        get position(): Vector3;
        get scale(): Vector3;
        get rotation(): Euler;
        get quaternion(): Quaternion;
        get matrix(): Matrix4;
        get matrixWorld(): Matrix4;
        get parent(): Entity | undefined;
        set parent(val: Entity | undefined);
        get pointerEvents(): boolean;
        get pointerEventsRef(): Ref<boolean>;
        set pointerEvents(b: boolean);
        get node(): Object3D<Object3DEventMap>;
        set node(obj: Object3D<Object3DEventMap>);
        get rayIntersectRecursive(): boolean;
        set rayIntersectRecursive(b: boolean);
        get rayQueryType(): RayQueryType;
        set rayQueryType(b: RayQueryType);
        onEntityAwake(callback: (app: App) => void): void;
        tween(id?: string): Tween<Entity>;
        addObjects(objs: Object3D | Object3D[]): void;
        removeObjects(objs: Object3D | Object3D[]): void;
        addChildEntity(ent: Entity): void;
        removeChildEntity(ent: Entity): void;
        addTo(target?: App | Entity | Object3D, app?: App): this;
        /**
         * 给一个已加入场景中的对象关联一个实体
         * @param obj 已加入场景中的对象
         * @param splitSubEntity 是否把子对象拆成子实体 （默认false)
         * @param overwriteEntity 当有关联的实体时，重新再生成一个实体相关联 （默认false)
         * @param app 应用对象，默认用当前的
         * @returns
         */
        static attchObject(obj: Object3D, splitSubEntity?: boolean, overwriteEntity?: boolean, app?: App): Entity;
        remove(): void;
        get childrens(): Entity[];
        set childrens(child: Entity[]);
        traverse(callback: (ent: Entity) => any, filter?: (ent: Entity) => boolean): void;
        traverseVisible(callback: (ent: Entity) => any, filter?: (ent: Entity) => boolean): void;
        getObjectByName(name: string): Object3D<Object3DEventMap>;
        getObjectById(id: string): Object3D<Object3DEventMap>;
        getObjectByUuid(uuid: string): Object3D<Object3DEventMap>;
        getObjectsByName(name: string): Object3D<Object3DEventMap>[];
        getObjectByProperty(name: string, value: string): Object3D<Object3DEventMap>;
        getObjectsByProperty(name: string, value: string): Object3D<Object3DEventMap>[];
        getEntityByName(name: string): Entity;
        getEntityById(id: string): Entity;
        getEntityByUuid(uuid: string): Entity;
        getMeshEntityByProperty(name: string, value: string): MeshEntity | undefined;
        getMeshEntityByName(name: string): MeshEntity | undefined;
        getMeshEntityById(id: string): MeshEntity | undefined;
        getMeshEntityByUuid(uuid: string): MeshEntity | undefined;
        getEntitiesByName(name: string): Entity[];
        getEntityByProperty(name: string, value: string): Entity;
        getEntitiesByProperty(name: string, value: string): Entity[];
        getObjectPropertyValueCount(name: string): Map<any, number>;
        getEntitiesByModule(module: EntityModuleConstructor | EntityModuleConstructor[]): Entity[];
        /** 判断实体是否是mesh实体或包含mesh实体模块 */
        isLikeMeshEntity(): boolean;
        /** 获取所有Mesh实体 */
        getMeshEntities(): MeshEntity[];
        /** 获取所有叶子实体 */
        getLeafEntities(): Entity[];
        /** 获取有事件的所有字实体 */
        getPointerEventsEntities(leafEventNode?: boolean): Entity[];
        /**
         * 增加模型边框线
         * @param option
         * @param isHideMesh 是否隐藏mesh本身（默认false)
         */
        addEdges(option?: LineBasicMaterialParameters, isHideMesh?: boolean): void;
        /**
         * 移除模型边框线
         */
        clearEdges(): void;
        /**
         * 替换材质
         */
        replaceMaterial(material: Material | Material[]): void;
        /**
         * 恢复材质
         */
        resetMaterial(): void;
        /**
         * 是否高亮
         */
        isHighlight(): boolean;
        /**
         * 设置高亮
         */
        setHighlight(color?: ColorRepresentation, opacity?: number): void;
        /**
         * 清除高亮
         */
        clearHighlight(): void;
        /**
         * 设置透明度
         * @param opacity  透明度0(完全透明)-1(不透明)
         * @param isAccOpacity 是否累加透明度(ture和之前透明度相乘，false直接设置透明度)
         */
        setOpacity(opacity: number, isAccOpacity?: boolean): void;
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件。默认false不再触发
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
        /**
         * 获取物体的外包盒
         * @param inLocalSpace 局部空间
         * @param mapModeSceneSpace 地图模式下返回场景空间坐标
         */
        getBoundingBox(inLocalSpace?: boolean, mapModeSceneSpace?: boolean): Box3;
        /**
         * 增加一个自定义动作脚本
         * @param func 脚本函数
         * @param id 脚本id
         */
        addAction(func: (context: {
            entity: Entity;
            timeDelta: number;
            elapsed: number;
            [key: string]: any;
        }) => BehaviorStatus | void | undefined, id?: string): () => void;
        /**
         * 移除一个自定义动作脚本
         * @param id 脚本id
         */
        removeAction(id: string): void;
        /**
         * 增加一个自定义动画动作脚本
         * @param func 脚本函数
         * @param id 脚本id
         */
        addAnimationAction(opts: {
            /** 持续时长 */
            duration: number;
            /** easing 默认 linear */
            easing?: Easing;
            /** 是否往返循环 */
            yoyoForever?: boolean;
            /** 往返次数 */
            yoyoTimes?: number;
            /** 重复循环 */
            repeatForever?: boolean;
            /** 重复次数 */
            repeatTimes?: number;
            /** 延迟时长 */
            delay?: number;
        }, func: (context: {
            entity: Entity;
            alpha: number;
            reversed: boolean;
            isComplete: boolean;
            isEnd: boolean;
            isStop: boolean;
            [key: string]: any;
        }) => void, id?: string): {
            stop: () => void;
            animation: typeof animation;
        };
        toJSON(): any;
        static fromJSON(json: Record<string, any>, objects: Map<string, Object3D>): Entity;
        setupUiConfig(): any;
    }

    export declare class EntityBase extends AppObject implements IEntityModuleBase {
        #private;
        options: EntityBaseOptions;
        uuid: string;
        readonly moduleManager: ModuleManager;
        constructor(options?: EntityBaseOptions);
        get modules(): EntityModuleBase[];
        /**
         * 增加模块,如果模块已存在，则返回之前的模型，等同于this.add(xxx)
         * @param type 模块类
         * @param params 参数
         */
        addModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T, params?: U): T;
        /**
         * 增加模块,如果模块已存在，则返回之前的模型，等同于this.addModule(xxx)
         */
        add<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T, params?: U): T;
        /**
         * 获取模块
         * @param type 模型类型
         * @returns
         */
        getModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T): T;
        /**
         * 移除模块
         * @param type 模型类型
         * @returns
         */
        removeModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T): void;
        /**
         * 移除所有模块
         * @returns
         */
        removeAllModules(): void;
        /**
         * 调用模块中的函数
         * @returns
         */
        callModules(methodName: string, ...args: any): void;
    }

    export declare interface EntityBaseOptions {
        app?: App;
        parent?: EntityBase;
    }

    export declare class EntityManagerModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        selectObjects: ShallowReactive<Object3D[]>;
        bloomObjects: ShallowReactive<Object3D[]>;
        outlineObjects: ShallowReactive<Object3D[]>;
        constructor(app?: App);
        getEntities(): Entity[];
        getRayQueryEntities(): any[];
        onAwake(): void;
        onAppAddEntity(ent: Entity): void;
        onAppRemoveEntity(ent: Entity): void;
        addSelectedEntity(ent: Entity): void;
        removeSelectEntity(ent: Entity): void;
        getSelectObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        getSelectObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        addBloomEntity(ent: Entity): void;
        removeBloomEntity(ent: Entity): void;
        getBloomObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        getBloomObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        addOutlineEntity(ent: Entity): void;
        removeOutlineEntity(ent: Entity): void;
        getOutlineObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        getOutlineObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
        setSelectBoomRefreshFlag(): void;
        onAppBeforeUpdate(): void;
        setupUiConfig(): UiObjectConfig;
    }

    export declare class EntityModuleBase extends ModuleBase {
        entity: Entity;
        constructor(entity: Entity);
    }

    export declare type EntityModuleConstructor = new (obj: any) => EntityModuleBase;

    export declare interface EntityOptions extends EntityBaseOptions {
        node?: Object3D;
        pointerEvents?: boolean;
        parent?: EntityBase;
        modules?: Array<EntityModuleConstructor | [EntityModuleConstructor, any]>;
        object3ds?: Object3D | Object3D[];
    }

    /**
     * 实体选中描边模块，默认为地图模式有效。如果需要自定义不同的颜色，可在实体自定义数据中设置 ent.data._outline_config = {...}
     */
    export declare class EntityOutlineModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: EntityOutlineModuleOptions;
        constructor(app?: App, options?: EntityOutlineModuleOptions);
        onAwake(): void;
    }

    export declare interface EntityOutlineModuleOptions extends OutlinesProps {
        enable?: boolean;
    }

    export declare class EntityQueryModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        constructor(app?: App);
        /**
         * 获取查询的射线对象
         */
        getQueryRaycaster(): Raycaster;
        onAwake(): void;
        /**
         * 通过相机查询实体
         */
        queryEntitiesByCamera(option?: EntityQueryOption): InteractiveObject;
        /**
         * 通过射线查询实体
         */
        queryEntitiesByRaycast(ray: Ray, option?: EntityQueryOption): InteractiveObject;
        /**
         * 通过屏幕像素坐标查询实体
         */
        queryEntitiesByScreenPos(x: number, y: number, option?: EntityQueryOption): InteractiveObject;
        /**
         * 通过框选查询实体
         */
        queryEntitiesByBox(startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number): InteractiveObject[];
        /**
         * 通过屏幕坐标获取射线
         */
        getRayByScreenPos(x: number, y: number, camera?: Camera): Ray;
    }

    /**
     * 查询实体参数
     */
    export declare interface EntityQueryOption {
        entities?: Entity[];
        filter?: (ent: Entity) => boolean;
        camera?: Camera;
        raycasterParameters?: RaycasterParameters;
    }

    export declare interface EnvConfigOption {
        /**  取消选中模式(默认clickOtherPosition) none 不主动取消，需要调用代码取消选中;  clickOtherPosition 点击其他位置(不在此实体上面时)取消选中； clickOtherEntity 点击选中其他实体时，取消选中 */
        cancelSelectMode?: "none" | "clickOtherPosition" | "clickOtherEntity";
        /** 取消高亮模式(默认clickOtherPosition) none 不主动取消，需要调用代码取消高亮;  clickOtherPosition 点击其他位置(不在此实体上面时)取消高亮； clickOtherEntity 点击选中其他实体时，取消高亮 */
        cancelHighlight?: "none" | "clickOtherPosition" | "clickOtherEntity";
        /** 高亮颜色 */
        highlightColor?: ColorRepresentation;
        /** 高亮透明度 */
        highlightOpacity?: number;
        /** 弹出框默认背景色 */
        popupBackgroundColor?: string;
        /** 弹出框默认关闭按钮颜色 */
        popupButtonColor?: string;
        /** 包围盒显示设置 */
        boxHelper?: BoxHelperOptions;
        /** 切换场景有动画 */
        activeScreenEnableTransition?: boolean;
        /** 场景退出时模糊时间(毫秒) */
        sceneExitBlurTime?: number;
        /** unProject屏幕坐标转世界坐标时，如果投影方式为undefined时，按不同的快捷键切换不同的投影方式 键值为键组合，如 "ShiftLeft + KeyR" ， "none"表示无按键默认处理情况 */
        unProjectOptions?: Record<string, UnProjectOpts>;
    }

    /** 环境贴图类 */
    export declare class Environment {
        #private;
        fbo: any;
        cubeCamera: any;
        virtualScene: any;
        ignoreObjects: any;
        app: App;
        constructor(app: any, config?: {
            resolution?: number;
            near?: number;
            far?: number;
            scene?: Scene | Object3D[];
            renderOptions?: RenderTargetOptions;
            textureType: TextureDataType;
            ignoreObjects?: Object3D[];
        });
        pause(): void;
        start(): void;
        update(): void;
        add(obj: any): void;
        get texture(): any;
        dispose(): void;
    }

    declare enum EpsgCrsTypes {
        Beijing54 = "Beijing54",
        Xian80 = "Xian80",
        CGCS2000 = "CGCS2000",
        Wgs84 = "Wgs84",
        Merc3857 = "Merc3857",
        NewBeijing54 = "NewBeijing54"
    }

    /**
     * Whether is exactly NaN. Notice isNaN('a') returns true.
     */
    declare function eqNaN(value: any): boolean;

    /**
     * Equation base class.
     *
     * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
     */
    declare class Equation {
        id: number;
        /**
         * Minimum (read: negative max) force to be applied by the constraint.
         */
        minForce: number;
        /**
         * Maximum (read: positive max) force to be applied by the constraint.
         */
        maxForce: number;
        bi: Body_2;
        bj: Body_2;
        si: Shape;
        sj: Shape;
        /**
         * SPOOK parameter
         */
        a: number;
        /**
         * SPOOK parameter
         */
        b: number;
        /**
         * SPOOK parameter
         */
        eps: number;
        jacobianElementA: JacobianElement;
        jacobianElementB: JacobianElement;
        enabled: boolean;
        /**
         * A number, proportional to the force added to the bodies.
         */
        multiplier: number;
        static idCounter: number;
        constructor(bi: Body_2, bj: Body_2, minForce?: number, maxForce?: number);
        /**
         * Recalculates a, b, and eps.
         *
         * The Equation constructor sets typical SPOOK parameters as such:
         * * `stiffness` = 1e7
         * * `relaxation` = 4
         * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
         */
        setSpookParams(stiffness: number, relaxation: number, timeStep: number): void;
        /**
         * Computes the right hand side of the SPOOK equation
         */
        computeB(a: number, b: number, h: number): number;
        /**
         * Computes G*q, where q are the generalized body coordinates
         */
        computeGq(): number;
        /**
         * Computes G*W, where W are the body velocities
         */
        computeGW(): number;
        /**
         * Computes G*Wlambda, where W are the body velocities
         */
        computeGWlambda(): number;
        /**
         * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
         */
        computeGiMf(): number;
        /**
         * Computes G*inv(M)*G'
         */
        computeGiMGt(): number;
        /**
         * Add constraint velocity to the bodies.
         */
        addToWlambda(deltalambda: number): void;
        /**
         * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
         */
        computeC(): number;
    }

    /**
     * Escape a string for use in a regular expression
     * @param str
     *
     * @category Text
     */
    export declare function escapeRegExp(str: string): string;

    declare function estimateBytesUsed(geometry: BufferGeometry): number;

    declare function estimateMemoryInBytes(bvh: MeshBVH): number;

    export declare class EulerGenerator implements RotationGenerator {
        angleX: FunctionValueGenerator | ValueGenerator;
        angleY: FunctionValueGenerator | ValueGenerator;
        angleZ: FunctionValueGenerator | ValueGenerator;
        type: 'rotation';
        eular: Euler;
        constructor(angleX: FunctionValueGenerator | ValueGenerator, angleY: FunctionValueGenerator | ValueGenerator, angleZ: FunctionValueGenerator | ValueGenerator, eulerOrder?: EulerOrder);
        genValue(quat: Quaternion, t?: number): Quaternion;
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): EulerGenerator;
        clone(): RotationGenerator;
    }

    declare class Evaluator {
        attributes: String[];
        useGroups: boolean;
        consolidateMaterials: boolean;
        debug: OperationDebugData;
        evaluate(a: Brush, b: Brush, operation: CSGOperation, targetBrush?: Brush): Brush;
        evaluate(a: Brush, b: Brush, operations: CSGOperation[], targetBrushes: Brush[]): Brush[];
        evaluateHierarchy(root: Operation, target?: Brush): Brush;
    }

    declare type EventCallback<EvtParams = any[]> = EvtParams extends any[] ? (...args: EvtParams) => boolean | void : never;

    /**
     * 事件派发管理
     */
    export declare class EventDispatcher {
        private _events;
        private _eventCount;
        private readonly _dispatchingListeners;
        /**
         * 确定是否存在事件侦听
         * @param event 事件名
         * @returns 返回是否存在相应的事件
         */
        hasEvent(event: string): boolean;
        /**
         * 返回注册的所有事件名.
         * @returns 所有事件名
         */
        eventNames(): string[];
        /**
         * 返回具有指定事件名称的侦听总数.
         * @param event - Event name
         * @returns The count of listeners
         */
        listenerCount(event: string): number;
        /**
         * 触发指定事件名称.
         * @param event - Event name
         * @param data - Data
         * @returns - Whether the dispatching is successful
         */
        dispatch(event: string, ...data: any): boolean;
        /**
         * 增加监听
         * @param event - Event name
         * @param fn - Function
         * @returns This
         */
        on(event: string, fn: Function): EventDispatcher;
        /**
         * 只监听一次.
         * @param event - Event name
         * @param fn - Function
         * @returns This
         */
        once(event: string, fn: Function): EventDispatcher;
        /**
         * 移除监听.
         * @param event - Event name
         * @param fn - Function, If is undefined, delete all corresponding event listeners.
         */
        off(event: string, fn?: Function): EventDispatcher;
        /**
         * 通过事件名移除所有监听.
         * @param event - Event name, delete all events if not passed
         */
        removeAllEventListeners(event?: string): void;
        private _addEventListener;
        private _clearEvent;
    }

    /**
     * Event dispatcher.
     *
     * Event can be defined in EvtDef to enable type check. For example:
     * ```ts
     * interface FooEvents {
     *     // key: event name, value: the first event param in `trigger` and `callback`.
     *     myevent: {
     *        aa: string;
     *        bb: number;
     *     };
     * }
     * class Foo extends Eventful<FooEvents> {
     *     fn() {
     *         // Type check of event name and the first event param is enabled here.
     *         this.trigger('myevent', {aa: 'xx', bb: 3});
     *     }
     * }
     * let foo = new Foo();
     * // Type check of event name and the first event param is enabled here.
     * foo.on('myevent', (eventParam) => { ... });
     * ```
     *
     * @param eventProcessor The object eventProcessor is the scope when
     *        `eventProcessor.xxx` called.
     * @param eventProcessor.normalizeQuery
     *        param: {string|Object} Raw query.
     *        return: {string|Object} Normalized query.
     * @param eventProcessor.filter Event will be dispatched only
     *        if it returns `true`.
     *        param: {string} eventType
     *        param: {string|Object} query
     *        return: {boolean}
     * @param eventProcessor.afterTrigger Called after all handlers called.
     *        param: {string} eventType
     */
    declare class Eventful<EvtDef extends DefaultEventDefinition = DefaultEventDefinition> {
        private _$handlers;
        protected _$eventProcessor: EventProcessor<EvtDef>;
        constructor(eventProcessors?: EventProcessor<EvtDef>);
        on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, handler: WithThisType<EvtDef[EvtNm], CbThis_2<Ctx, this>>, context?: Ctx): this;
        on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, query: EventQuery, handler: WithThisType<EvtDef[EvtNm], CbThis_2<Ctx, this>>, context?: Ctx): this;
        /**
         * Whether any handler has bound.
         */
        isSilent(eventName: keyof EvtDef): boolean;
        /**
         * Unbind a event.
         *
         * @param eventType The event name.
         *        If no `event` input, "off" all listeners.
         * @param handler The event handler.
         *        If no `handler` input, "off" all listeners of the `event`.
         */
        off(eventType?: keyof EvtDef, handler?: Function): this;
        /**
         * Dispatch a event.
         *
         * @param {string} eventType The event name.
         */
        trigger<EvtNm extends keyof EvtDef>(eventType: EvtNm, ...args: Parameters<EvtDef[EvtNm]>): this;
        /**
         * Dispatch a event with context, which is specified at the last parameter.
         *
         * @param {string} type The event name.
         */
        triggerWithContext(type: keyof EvtDef, ...args: any[]): this;
    }

    /** 获取事件的键盘code */
    export declare function eventKeyCode(event?: any): number | undefined;

    /**
     * 事件模块
     */
    export declare class EventModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        constructor(entity: Entity, options?: EventModuleOptions);
        /**
         * 增加事件回调
         * @param options
         * @returns 事件id,可通过removeEvent删除事件
         */
        addEvent(options: EventModuleOptions): number;
        /**
         * 删除事件回调
         * @param options
         * @returns
         */
        removeEvent(eventId?: number): void;
    }

    /**
     * 事件选项
     */
    export declare interface EventModuleOptions {
        onBeforeAdd?: (parent: Entity, self: Entity) => void;
        onAdd?: (parent: Entity, self: Entity) => void;
        onBeforeRemove?: (self: Entity) => void;
        onRemove?: (self: Entity) => void;
        onRayIntersect?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseMove?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseClick?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseDblClick?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseOver?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseOut?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseEnter?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseLeave?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onPointerDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onPointerMove?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onPointerUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onMouseWheel?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onKeyDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
        onKeyUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
        /** 高亮模式是否用外包盒的方式 默认false*/
        highlightUseBoxHelper?: boolean;
        /** 是否点击选中 */
        clickSelect?: boolean;
        /** 取消选中模式(默认inherit)  none 不主动取消，需要调用代码取消选中; inherit 继承，跟随系统设置； clickOtherPosition 点击其他位置(不在此实体上面时)取消选中； clickOtherEntity 点击选中其他实体时，取消选中 */
        cancelSelectMode?: "none" | "inherit" | "clickOtherPosition" | "clickOtherEntity";
        /** 是否点击高亮 */
        clickHighlight?: boolean;
        /** 取消高亮模式(默认inherit) none 不主动取消，需要调用代码取消高亮; inherit 继承，跟随系统设置;  clickOtherPosition 点击其他位置(不在此实体上面时)取消高亮； clickOtherEntity 点击选中其他实体时，取消高亮 */
        cancelHighlight?: "none" | "inherit" | "clickOtherPosition" | "clickOtherEntity";
        /** 悬浮时设置为选中状态 */
        hoverSelect?: boolean;
        /** 悬浮时设置为高亮状态 */
        hoverHighlight?: boolean;
        /** 高亮颜色 */
        highlightColor?: ColorRepresentation;
        /** 高亮透明度 */
        highlightOpacity?: number;
        /** 点击时显示的文本内容  */
        clickHtmlText?: string | ((ent: Entity) => Promise<string>);
        /** 点击时显示的文本内容 */
        hoverHtmlText?: string | ((ent: Entity) => Promise<string>);
        /** 当前工具运行时，响应事件，默认false */
        enableWhenActiveTool?: boolean;
        /** 显示文本时弹出框选项 */
        popupOptions?: PopupOptions;
        /** 显示文本时弹出框锚位于实体的位置 （默认'middle-top' 中间-上面居中 ) */
        popupAnchor?: Anchor3d;
        /** popup弹出时作为实体的子节点，默认true */
        popupAsEntityChild?: boolean;
        /** popup弹出前回调 如果返回 Object3D 将把此Object3d做为popup的父节点 */
        popupCallback?: (entity: Entity, popup: Popup2D, isHover: boolean) => Object3D | Entity | undefined;
        /** 点击回调 */
        clickCallback?: (entity: Entity, isClick: boolean) => void;
        /** 高亮回调 */
        hoverCallback?: (entity: Entity, isHover: boolean) => void;
    }

    declare interface EventProcessor<EvtDef = DefaultEventDefinition> {
        normalizeQuery?: (query: EventQuery) => EventQuery;
        filter?: (eventType: keyof EvtDef, query: EventQuery) => boolean;
        afterTrigger?: (eventType: keyof EvtDef) => void;
    }

    declare type EventQuery = string | Object;

    /**
     * Base class for objects that dispatches events.
     */
    declare class EventTarget_2 {
        private _listeners;
        /**
         * Add an event listener
         * @return The self object, for chainability.
         */
        addEventListener(type: string, listener: Function): EventTarget_2;
        /**
         * Check if an event listener is added
         */
        hasEventListener(type: string, listener: Function): boolean;
        /**
         * Check if any event listener of the given type is added
         */
        hasAnyEventListener(type: string): boolean;
        /**
         * Remove an event listener
         * @return The self object, for chainability.
         */
        removeEventListener(type: string, listener: Function): EventTarget_2;
        /**
         * Emit an event.
         * @return The self object, for chainability.
         */
        dispatchEvent(event: any): EventTarget_2;
    }

    export declare function eventXY(event?: any): Vector2;

    export declare interface ExecutionContext {
        inputs?: NodeValue[];
        outputs?: NodeValue[];
        particle?: IParticle;
        [key: string]: any;
    }

    /**
     * 根据线的坐标扩展左右边 .
     * @param line 线的坐标
     * @param lineWidth 线的总宽度或左右宽数组
     */
    export declare function expandLine(line: [number, number, number?][], lineWidth: number | [number, number][]): {
        offsetPoints: any[];
        leftPoints: any[];
        rightPoints: any[];
        expandPoints: any[];
    };

    /** 对物体进行爆炸分解 */
    export declare const explodeGroup: (group: Object3D) => {
        /** 爆炸分解  */
        explode: (opts?: {
            /** 动画时长 */
            time?: number;
            /** 爆炸分解分解距离 */
            distance?: number;
            /** 允许旋转 */
            enableRotation?: boolean;
            /** 动画类型 */
            easing?: Easing;
        }) => Promise<any>;
        /** 还原 */
        reset: (opts?: {
            /** 动画时长 */
            time?: number;
            /** 允许旋转 */
            enableRotation?: boolean;
            /** 动画类型 */
            easing?: Easing;
        }) => Promise<any>;
    };

    /**
     * Exports a render target to a blob. The type is automatically picked from exr to png based on the render target.
     * @param target - render target to export
     * @param mimeType - mime type to use.
     * If auto (default), then it will be picked based on the render target type.
     * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
     */
    export declare function exportRenderTarget(renderer: WebGLRenderer, target: WebGLMultipleRenderTargets | WebGLRenderTarget, mimeType?: string, textureIndex?: number): Blob;

    /**
     * Given a destination object and optionally many source objects,
     * copy all properties from the source objects into the destination.
     * The last source object given overrides properties from previous
     * source objects.
     *
     * @param dest destination object
     * @param sources sources from which properties are pulled
     * @private
     */
    export declare function extend(dest: Object, ...sources: Object[]): Object;

    declare function extend_2<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S): T & S;

    declare interface ExtendedCanvasRenderingContext2D extends CanvasRenderingContext2D {
        dpr?: number;
    }

    declare class ExtendedTriangle extends Triangle {
        needsUpdate: boolean;
        intersectsTriangle(other: Triangle, target?: Line3): boolean;
        intersectsSphere(sphere: Sphere): boolean;
        closestPointToSegment(segment: Line3, target1?: Vector3, target2?: Vector3): number;
        distanceToPoint(point: Vector3): number;
        distanceToTriangle(tri: Triangle): number;
    }

    /**
     * Create a Path class from path string data
     * @param  str
     * @param  opts Other options
     */
    declare function extendFromString(str: string, defaultOpts?: SVGPathOption): typeof SVGPath;

    declare interface ExtremeInfo {
        nodeCount: number;
        leafNodeCount: number;
        surfaceAreaScore: number;
        depth: {
            min: number;
            max: number;
        };
        tris: {
            min: number;
            max: number;
        };
        splits: [number, number, number];
    }

    /**
     *
     * @param {Object} geojson
     * @param {Object} [opts]
     * @param {number} opts.depth
     * @param {number} [opts.bevelSize = 0]
     * @param {number} [opts.bevelSegments = 2]
     * @param {number} [opts.simplify = 0]
     * @param {boolean} [opts.smoothSide = 'auto']
     * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
     * @param {boolean} [opts.smoothBevel = false]
     * @param {boolean} [opts.excludeBottom = false]
     * @param {boolean} [opts.lineWidth = 1]
     * @param {boolean} [opts.miterLimit = 2]
     * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
     * @param {Array} [opts.translate]
     * @param {Array} [opts.scale]
     * @param {Object} [opts.boundingRect]
     * @return {Object} {polyline: {indices, position, uv, normal}, polygon: {indices, position, uv, normal}}
     */
    export declare function extrudeGeoJSON(geojson: any, opts?: {
        depth?: ((idx: number) => number) | number;
        bevelSize?: number;
        bevelSegments?: number;
        simplify?: number;
        smoothSide?: boolean;
        smoothBevel?: boolean;
        excludeBottom?: boolean;
        /** default 0.9 */
        smoothSideThreshold?: number;
        /** default 1 */
        lineWidth?: number;
        /** default 2 */
        miterLimit?: number;
        fitRect?: {
            x?: number;
            y?: number;
            width?: number;
            height?: number;
        };
        translate?: ArrayLike<number>;
        scale?: ArrayLike<number>;
        isMapMode?: boolean;
        boundingRect?: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
    }): {
        polyline: {
            position: Float32Array;
            indices: Uint16Array | Uint32Array;
            uv: Float32Array;
            normal: Float32Array;
            boundingRect: {
                x: number;
                y: number;
                width: number;
                height: number;
            };
            geometry: BufferGeometry<NormalBufferAttributes>;
        };
        polygon: {
            position: Float32Array;
            indices: Uint16Array | Uint32Array;
            uv: Float32Array;
            normal: Float32Array;
            boundingRect: {
                x: number;
                y: number;
                width: number;
                height: number;
            };
            geometry: BufferGeometry<NormalBufferAttributes>;
        };
    };

    /**
     * 挤出模型
     *
     * @export
     * @class ExtrudeMesh
     * @extends {Mesh<BufferGeometry, Material>}
     */
    export declare class ExtrudeMesh extends Mesh<BufferGeometry, Material> {
        static temp1Vector2: Vector2;
        static temp2Vector2: Vector2;
        static temp3Vector2: Vector2;
        static tempVector3: Vector3;
        static temp1Vector3: Vector3;
        static temp2Vector3: Vector3;
        static temp3Vector3: Vector3;
        static temp1Matrix4: Matrix4;
        static temp2Matrix4: Matrix4;
        static temp3Matrix4: Matrix4;
        constructor(props: ExtrudeMeshProps, material?: Material);
        pointerWidthRadius: Array<{
            vector3: [number, number, number];
            matrix: [
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number
            ];
        }>;
        computerMatrix(vector1: [number, number, number], vector2: [number, number, number], scale: [number, number, number]): Matrix4Tuple;
        /**
         * @计算渐变值 computerGradient([2,1,3], 0.3);
         * @渐变区间 values:number[]
         * @百分比 percentage:number
         */
        computerGradient(values: number[], percentage: number): number;
        computerPointerWidthRadius(paths: Array<ExtrudePath>, closed: boolean): void;
        computerPathLength(points: [number, number, number][]): number;
        setExtrudeMesh(startP: [number, number, number], // 起点位置
        startMatrix4: [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
        ], // 起点位置的矩阵
        endP: [number, number, number], // 终点位置
        endMatrix4: [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
        ], // 终点位置的矩阵
        uvx: number, // uv.x 的起始位置
        shapePath: Array<[number, number]>): {
            geometryPoint: number[];
            uvPoint: number[];
        };
        updateGeometry(props: ExtrudeMeshProps): void;
    }

    /** 挤出 */
    export declare interface ExtrudeMeshProps {
        /** 自动生成路径的 */
        paths: Array<ExtrudePath>;
        /** 被拉伸成模型的平面路径 */
        shapePath: Array<[number, number]>;
        /** 是否闭合路径 */
        closed: boolean;
        isMapMode?: boolean;
    }

    export declare type ExtrudePath = {
        vector3: [number, number, number];
        /** 圆角半径 */
        radius: number;
        /** 圆角分段 */
        segments: number;
        /** 当前位置对shape的缩放 */
        scale: {
            x: number;
            y: number;
        };
        /** 备注名字 */
        name: string;
    };

    /**
     *
     * @param {Array} polygons Polygons array that match GeoJSON MultiPolygon geometry.
     * @param {Object} [opts]
     * @param {number|Function} [opts.depth]
     * @param {number} [opts.bevelSize = 0]
     * @param {number} [opts.bevelSegments = 2]
     * @param {number} [opts.simplify = 0]
     * @param {boolean} [opts.smoothSide = 'auto']
     * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
     * @param {boolean} [opts.smoothBevel = false]
     * @param {boolean} [opts.excludeBottom = false]
     * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
     * @param {Array} [opts.translate]
     * @param {Array} [opts.scale]
     *
     * @return {Object} {indices, position, uv, normal, boundingRect}
     */
    export declare function extrudePolygon(polygons: any[], opts?: {
        depth?: ((idx: number) => number) | number;
        bevelSize?: number;
        bevelSegments?: number;
        simplify?: number;
        smoothSide?: boolean;
        smoothBevel?: boolean;
        excludeBottom?: boolean;
        fitRect?: {
            x?: number;
            y?: number;
            width?: number;
            height?: number;
        };
        translate?: ArrayLike<number>;
        scale?: ArrayLike<number>;
        removeIntersections?: boolean;
        removeIntersectionsHole?: boolean;
        isMapMode?: boolean;
        boundingRect?: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
    }): {
        position: Float32Array;
        indices: Uint16Array | Uint32Array;
        uv: Float32Array;
        normal: Float32Array;
        boundingRect: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        geometry: BufferGeometry<NormalBufferAttributes>;
    };

    /**
     *
     * @param {Array} polylines Polylines array that match GeoJSON MultiLineString geometry.
     * @param {Object} [opts]
     * @param {number} [opts.depth]
     * @param {number} [opts.bevelSize = 0]
     * @param {number} [opts.bevelSegments = 2]
     * @param {number} [opts.simplify = 0]
     * @param {boolean} [opts.smoothSide = 'auto']
     * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
     * @param {boolean} [opts.smoothBevel = false]
     * @param {boolean} [opts.excludeBottom = false]
     * @param {boolean} [opts.lineWidth = 1]
     * @param {boolean} [opts.miterLimit = 2]
     * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
     * @param {Array} [opts.translate]
     * @param {Array} [opts.scale]
     * @param {Object} [opts.boundingRect]
     * @return {Object} {indices, position, uv, normal, boundingRect}
     */
    export declare function extrudePolyline(polylines: any[], opts?: {
        depth?: ((idx: number) => number) | number;
        /** default 0 */
        bevelSize?: number;
        /** default 2 */
        bevelSegments?: number;
        /** default 0 */
        simplify?: number;
        /** default 'auto' */
        smoothSide?: boolean;
        /** default 0.9 */
        smoothSideThreshold?: number;
        /** default false */
        smoothBevel?: boolean;
        /** default false */
        excludeBottom?: boolean;
        /** default 1 */
        lineWidth?: number;
        /** default 2 */
        miterLimit?: number;
        fitRect?: {
            x?: number;
            y?: number;
            width?: number;
            height?: number;
        };
        translate?: ArrayLike<number>;
        scale?: ArrayLike<number>;
        removeIntersections?: boolean;
        isMapMode?: boolean;
        boundingRect?: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
    }): {
        position: Float32Array;
        indices: Uint16Array | Uint32Array;
        uv: Float32Array;
        normal: Float32Array;
        boundingRect: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        geometry: BufferGeometry<NormalBufferAttributes>;
    };

    export declare class FailingBehavior extends Behavior {
        delayTicks: number;
        static typeName: string;
        constructor(delayTicks?: number);
        tick(td: any): BehaviorStatus.Running | BehaviorStatus.Failed;
        static INSTANCE: FailingBehavior;
    }

    /**
     * Map value to color. Faster than lerp methods because color is represented by rgba array.
     * @param normalizedValue A float between 0 and 1.
     * @param colors List of rgba color array
     * @param out Mapped gba color array
     * @return will be null/undefined if input illegal.
     */
    declare function fastLerp(normalizedValue: number, colors: number[][], out?: number[]): number[];

    /**
     * @deprecated
     */
    declare const fastMapToColor: typeof fastLerp;

    export declare interface FBOConfig {
        width: number;
        height: number;
        samples: number;
        options: RenderTargetOptions;
    }

    declare type FBOSettings = {
        /** Defines the count of MSAA samples. Can only be used with WebGL 2. Default: 0 */
        samples?: number;
        /** If set, the scene depth will be rendered into buffer.depthTexture. Default: false */
        depth?: boolean;
    } & RenderTargetOptions;

    /**
     * Feature
     *
     * https://tools.ietf.org/html/rfc7946#section-3.2
     * A Feature object represents a spatially bounded thing.
     * Every Feature object is a GeoJSON object no matter where it occurs in a GeoJSON text.
     */
    declare interface Feature<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
        type: "Feature";
        geometry: G;
        /**
         * A value that uniquely identifies this feature in a
         * https://tools.ietf.org/html/rfc7946#section-3.2.
         */
        id?: Id;
        /**
         * Properties associated with this feature.
         */
        properties: P;
    }

    /**
     * Feature Collection
     *
     * https://tools.ietf.org/html/rfc7946#section-3.3
     * A GeoJSON object with the type 'FeatureCollection' is a FeatureCollection object.
     * A FeatureCollection object has a member with the name 'features'.
     * The value of 'features' is a JSON array. Each element of the array is a Feature object as defined above.
     * It is possible for this array to be empty.
     */
    declare interface FeatureCollection<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
        type: "FeatureCollection";
        features: Array<Feature<G, P>>;
    }

    export declare type FieldType = 'vec3' | 'value' | 'number' | 'range' | 'colorFunc' | 'valueFunc' | 'rotationFunc' | 'radian' | 'mesh' | 'particleSystem' | 'boolean' | 'geometry' | 'emitterMode';

    export declare interface FillExtrusionItemData {
        /** id */
        id?: string;
        /** 坐标 */
        coordinates: [number, number][][] | [number, number][];
        /** 颜色 */
        color?: ColorRepresentation;
        /** 颜色2 顶部的颜色。默认和底部color一样 */
        color2?: ColorRepresentation;
        /** 透明度(0-1) */
        opacity?: number;
        /** 边框线颜色 */
        borderColor?: ColorRepresentation;
        /** 边框颜色2 顶部的线颜色。默认和底部边框线颜色一样 */
        borderColor2?: ColorRepresentation;
        /** 是否显示边框 */
        showBorder?: boolean;
        /** 拉伸参数 */
        extrude?: ExtrudeGeometryOptions;
        /** 是否显示顶点 */
        showVertex?: boolean;
        /** 是否隐藏 */
        hidden?: boolean;
        /** 基准高 */
        baseHeight?: boolean;
        /** 自定义数据 */
        [key: string]: any;
    }

    /**
     * 拉伸实体
     */
    export declare class FillExtrusionsEntity extends Entity {
        constructor(options: FillExtrusionsEntityOptions);
        /**
         * 获取拉伸对象
         */
        getFillExtrusions: () => Mesh;
        /**
         * 获取拉伸边框对象
         */
        getBorderPolyline: () => LineSegments2_2;
        /**
         * 更新样式
         */
        updateStyle: (style: MeshBasicMaterialParameters) => void;
        /**
         * 获取顶点对象
         */
        getVertexSymbol: () => SymbolEntity;
        /**
         * 是否显示顶点
         */
        isShowVertex: () => boolean;
        /**
         * 获取顶点数据
         */
        getVertexData: (isGetAll?: boolean) => SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex: (show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }) => void;
        /**
         * 更新高亮样式
         */
        updateHightStyle: (style: MeshBasicMaterialParameters) => void;
        /**
         * 修改数据
         */
        setData: (data: FillExtrusionItemData[]) => void;
        /**
         * 获取数据
         */
        getData: () => FillExtrusionItemData[];
        /**
         * 通过faceIndex获取
         * @param faceIndex 索引
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
            positionIndex: number;
        } & FillExtrusionItemData;
        /**
         * 刷新高亮数据
         */
        refreshHighlight: () => void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight: (id: string) => boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight: () => void;
        /**
         * 设置每项的拉伸后的深度、颜色、透明度值
         * @returns
         */
        setDepths: (data: {
            index: number;
            depth?: number;
            color2?: ColorRepresentation;
            opacity?: number;
        }[]) => void;
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
    }

    export declare type FillExtrusionsEntityOptions = EntityOptions & FillExtrusionsModuleOption;

    /**
     * 多边形模块,用来绘制批量多边形
     */
    export declare class FillExtrusionsModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        fillExtrusions: Mesh;
        data: FillExtrusionItemData[];
        style: MeshLambertMaterialParameters;
        highlightFillExtrusions: Mesh;
        highlightData: FillExtrusionItemData[];
        highlightIndexMap: Map<string, number>;
        highlightStyle: MeshLambertMaterialParameters;
        facePosIndex: Map<number, {
            polyIndex: number;
            face: [number, number, number];
        }>;
        isXYPlane: boolean;
        borderStyle: LineMaterialParameters_2;
        showBorder: boolean;
        useBvh: boolean;
        borderPolyline: LineSegments2_2;
        vertexEntity: SymbolEntity;
        showVertex: boolean;
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
        constructor(entity: Entity, options?: FillExtrusionsModuleOption);
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            app: App;
            children: ({
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
                value?: undefined;
                onChange?: undefined;
            } | {
                type: string;
                label: string;
                value: boolean;
                onChange: (v: any) => void;
                getValue?: undefined;
                setValue?: undefined;
            })[];
        };
        /**
         * 获取多边形对象
         */
        getFillExtrusions(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
        /**
         * 获取顶点对象
         */
        getVertexSymbol(): SymbolEntity;
        /**
         * 获取多边形边框对象
         */
        getBorderPolyline(): LineSegments2_2;
        /**
         * 更新样式
         */
        updateStyle(style: MeshLambertMaterialParameters): void;
        /**
         * 更新高亮样式
         */
        updateHightStyle(style: MeshLambertMaterialParameters): void;
        /**
         * 修改数据
         */
        setData(data: FillExtrusionItemData[]): void;
        /**
         * 获取数据
         */
        getData(): FillExtrusionItemData[];
        /**
         * 是否显示顶点
         */
        isShowVertex(): boolean;
        /**
         * 获取顶点数据
         */
        getVertexData(isGetAll?: boolean): SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex(show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }): void;
        /**
         * 通过faceIndex获取
         * @param faceIndex 索引
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
            data: FillExtrusionItemData;
            face: [number, number, number];
        } | {
            face: number[];
            /** id */
            id?: string;
            /** 坐标 */
            coordinates: [number, number][] | [number, number][][];
            /** 颜色 */
            color?: ColorRepresentation;
            /** 颜色2 顶部的颜色。默认和底部color一样 */
            color2?: ColorRepresentation;
            /** 透明度(0-1) */
            opacity?: number;
            /** 边框线颜色 */
            borderColor?: ColorRepresentation;
            /** 边框颜色2 顶部的线颜色。默认和底部边框线颜色一样 */
            borderColor2?: ColorRepresentation;
            /** 是否显示边框 */
            showBorder?: boolean;
            /** 拉伸参数 */
            extrude?: ExtrudeGeometryOptions;
            /** 是否显示顶点 */
            showVertex?: boolean;
            /** 是否隐藏 */
            hidden?: boolean;
            /** 基准高 */
            baseHeight?: boolean;
            data?: undefined;
        };
        /**
         * 设置每项的拉伸后的深度、颜色、透明度值
         * @returns
         */
        setDepths(data: {
            index: number;
            depth?: number;
            color2?: ColorRepresentation;
            opacity?: number;
        }[]): void;
        /**
         * 刷新高亮数据
         * @returns
         */
        refreshHighlight(): void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight(id: string): boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight(): void;
    }

    export declare interface FillExtrusionsModuleOption {
        /** 数据 */
        data: FillExtrusionItemData[];
        /** 样式 */
        style?: MeshLambertMaterialParameters;
        /** 高亮样式 */
        highlightStyle?: MeshLambertMaterialParameters;
        /** 边框样式 */
        borderStyle?: LineMaterialParameters_2;
        /** 是否显示边框 */
        showBorder?: boolean;
        /** 数据是否在xy平面，默认为xz 平面 */
        isXYPlane?: boolean;
        /** 是否使用bvh射线查询。默认是 */
        useBvh?: boolean;
        /** 是否显示顶点(全局控制显示) */
        showVertex?: boolean;
        /** 顶点样式 */
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
    }

    /**
     * Array filtering.
     * @return Must be an array.
     */
    declare function filter<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index: number, arr: readonly T[]) => boolean, context?: Context): T[];

    export declare class FilterBehavior extends SequenceBehavior {
        constructor();
        /**
         *
         * @param {Behavior[]} conditions
         * @param {Behavior[]} actions
         * @returns {FilterBehavior}
         */
        static from(conditions: Behavior[], actions?: Behavior[]): FilterBehavior;
        addChild(child: Behavior): void;
        /**
         *
         * @param {Behavior} condition
         */
        addCondition(condition: Behavior): void;
        /**
         *
         * @param {Behavior} action
         */
        addAction(action: Behavior): void;
    }

    export declare interface FilterColorOptions {
        /** 是否反色 */
        inVerseColor?: boolean;
        /** 单色*/
        monochromeColor?: ColorRepresentation;
        /** 亮度 （1 不变； < 1 亮度变暗；  1 变亮度亮）*/
        bright?: number;
        /** 对比度 （1 不变； < 1 对比度减弱  1 对比度增强） */
        contrast?: number;
        /** 饱和度 （1 不变； < 1 饱和度减弱  1 饱和度增强））*/
        saturation?: number;
    }

    export declare type FilteredType<T> = PickType<Partial<TransformedTypes<T>>, AllowedTypes>;

    /**
     * 数组项查找
     */
    declare function find<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index?: number, arr?: readonly T[]) => boolean, context?: Context): T;

    /**
     *
     * @param {SignalHandler[]} handlers
     * @param {function} f
     * @param thisArg
     * @returns {number} index of the handler, or -1 if not found
     */
    export declare function findSignalHandlerIndexByHandle(handlers: any, f: any, thisArg?: any): number;

    /**
     *
     * @param {SignalHandler[]} handlers
     * @param {function} f
     * @param {*} ctx
     * @returns {number} index of the handler, or -1 if not found
     */
    export declare function findSignalHandlerIndexByHandleAndContext(handlers: any, f: any, ctx: any): number;

    declare interface FitToOptions {
        cover: boolean;
        paddingLeft: number;
        paddingRight: number;
        paddingBottom: number;
        paddingTop: number;
    }

    /**
     * 像素空间中输入网格坐标的材质，与相机无关
     */
    export declare class FixedSizeMeshMaterial extends ShaderMaterial {
        constructor({ color, canvasSize, ...params }: {
            color: ColorRepresentation;
            canvasSize: Uniform_2<Vector2>;
        } & MaterialParameters);
    }

    /**
     * 遍历模型，使其扁平化
     * @param model 模型
     * @param debugOutputModelName 不为空时将调试输出模型数组名称
     * @returns
     */
    export declare const flatModel: (model: Object3D | Entity, debugOutputModelName?: string) => Object3D[];

    export declare const FlowMaterial: (new (parameters?: ShaderMaterialParameters & Partial<FlowMaterialProps>, uniforms?: Partial<FlowMaterialProps>) => ShaderMaterial & FlowMaterialProps) & {
        key: string;
    };

    export declare type FlowMaterialProps = {
        /** 颜色 */
        color?: Color;
        /** 纹理开始位置 ，默认(0,0) */
        uvBegin?: Vector2;
        /** 纹理偏移 ，默认(0,0) */
        uvOffset?: Vector2;
        /** 纹理缩放比例  ，默认(1,1) */
        uvScale?: Vector2;
        /** 透明度 */
        opacity?: number;
        /** 时间变量 */
        time?: Vector4 | {
            value: Vector4;
        };
        /** Material side, default: BackSide */
        side?: Side;
        /** Material depthWrite, default: false */
        depthWrite?: boolean;
        /** 纹理 */
        map?: Texture;
        [key: string]: any;
    };

    /**
     * 荧光点.
     */
    export declare class FluorescenceMarker extends AnimateMarkerBase {
        constructor(features: FeatureCollection | {
            position: [number, number, number?];
            text?: string;
        }, options?: AnimateMarkerLayerOption);
        setMarkersWidth(width: number, index?: number): void;
        setMarkersColors(colors: string[], index?: number): void;
        _createMarker(): void;
        private _setFluorescenceWidth;
        private _setFluorescenceColor;
    }

    /**
     * FoF - Short for `Function of` - a generic type for function
     */
    export declare type Fof<TReturn extends any = void, TArgs extends any[] = []> = (...args: TArgs) => TReturn;

    /**
     * Manages the creation of a Signed Distance Field (SDF) font atlas, and performs text layout to
     * generate attributes for rendering text using the atlas.
     */
    export declare class FontManager extends EventDispatcher_2<{
        atlasChange: object;
    }> {
        options: FontManagerOptions;
        private alphabet;
        atlasData: AtlasData;
        constructor(options?: FontManagerOptions);
        update(newChars: string): void;
        layout(text: string): LayoutInfo;
    }

    export declare type FontManagerOptions = {
        fontFamily?: string;
        fontSize?: number;
    };

    declare type FontStyle = 'normal' | 'italic' | 'oblique';

    declare type FontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | number;

    /**
     * Apply a force to particles over their life.
     */
    export declare class ForceOverLife implements Simulation {
        x: FunctionValueGenerator | ValueGenerator;
        y: FunctionValueGenerator | ValueGenerator;
        z: FunctionValueGenerator | ValueGenerator;
        type: string;
        _temp: Vector3;
        ps: IParticleSystem;
        initialize(particle: Particle, particleSystem: ParticleSystem): void;
        constructor(x: FunctionValueGenerator | ValueGenerator, y: FunctionValueGenerator | ValueGenerator, z: FunctionValueGenerator | ValueGenerator);
        update(particle: Particle, delta: number): void;
        toJSON(): any;
        static fromJSON(json: any): Simulation;
        _tempScale: Vector3;
        _tempQ: Quaternion;
        frameUpdate(delta: number): void;
        clone(): Simulation;
        reset(): void;
    }

    /**
     * apply tile number of particle texture by particles' life.
     */
    export declare class FrameOverLife implements Simulation {
        frame: FunctionValueGenerator;
        type: string;
        constructor(frame: FunctionValueGenerator);
        initialize(particle: Particle): void;
        update(particle: Particle, delta: number): void;
        frameUpdate(delta: number): void;
        toJSON(): any;
        static fromJSON(json: any): Simulation;
        clone(): Simulation;
        reset(): void;
    }

    /**
     * Constrains the slipping in a contact along a tangent
     */
    declare class FrictionEquation extends Equation {
        ri: Vec3;
        rj: Vec3;
        t: Vec3;
        /**
         * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
         */
        constructor(bodyA: Body_2, bodyB: Body_2, slipForce: number);
        computeB(h: number): number;
    }

    /**
     * 世界坐标距离长度转几何坐标距离长度.
     * @param dist 距离值
     * @param isMap2dHeightMeter 是否以米为单位，默认false以地图单位
     * @param app 应用
     * @param mapView
     */
    export declare function fromDist(dist: number, isMap2dHeightMeter?: boolean, app?: App, mapView?: MapViewEntity): number;

    /**
     * 世界坐标转几何坐标 .
     */
    export declare function fromWorld(vec3: [number, number, number?], app?: App, mapView?: MapViewEntity): [number, number, number];

    /** 全屏控件 */
    export declare class FullscreenControl implements IControl {
        _app: App;
        _controlContainer: HTMLElement;
        _fullscreen: boolean;
        _fullscreenchange: string;
        _fullscreenButton: HTMLElement;
        _container: HTMLElement;
        constructor(options?: FullscreenControlOptions);
        onAdd(app: App): HTMLElement;
        onRemove(): void;
        _checkFullscreenSupport(): boolean;
        _setupUI(): void;
        _updateTitle(): void;
        _getTitle(): "退出全屏" | "进入全屏";
        _isFullscreen(): boolean;
        _changeIcon(): void;
        _onClickFullscreen(): void;
    }

    export declare interface FullscreenControlOptions {
        container?: HTMLElement;
    }

    export declare class FullScreenQuad {
        camera: OrthographicCamera;
        geometry: PlaneGeometry;
        mesh: Mesh;
        constructor(material: any);
        get material(): Material | Material[];
        set material(value: Material | Material[]);
        dispose(): void;
        render(renderer: any): void;
    }

    declare interface FunctionBind {
        <F extends BindFunc<Ctx>, Ctx>(func: F, ctx: Ctx): Bind1<F, Ctx>;
        <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0]>(func: F, ctx: Ctx, a: T1): Bind2<F, Ctx, T1>;
        <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, ctx: Ctx, a: T1, b: T2): Bind3<F, Ctx, T1, T2>;
        <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3): Bind4<F, Ctx, T1, T2, T3>;
        <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3, d: T4): Bind5<F, Ctx, T1, T2, T3, T4>;
    }

    export declare interface FunctionColorGenerator {
        type: 'function';
        genColor(color: Vector4, t: number): Vector4;
        toJSON(): FunctionJSON;
        clone(): FunctionColorGenerator;
    }

    export declare type FunctionJSON = {
        [a: string]: any;
    };

    export declare interface FunctionValueGenerator {
        type: 'function';
        genValue(t: number): number;
        toJSON(): FunctionJSON;
        clone(): FunctionValueGenerator;
    }

    export { FXAAEffect }

    export declare const genDefaultForNodeValueType: (type: NodeValueType) => any;

    declare function generateRandomTriangleColors(geometry: BufferGeometry): void;

    /**
     * 根据一个object对象生成ui配置参数值
     * @param obj object对象
     * @param propItems 对象中的属性值，可选项
     * @returns
     */
    export declare function generateUiConfig(obj: any, propItems?: ({
        prop?: string;
        label?: string;
        value?: any;
        [key: string]: any;
    } | UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>)[]): UiObjectConfig[];

    export declare function generateUiFolder(label: string, obj: any, params?: any, type?: string): UiObjectConfig;

    export declare function generateUUID(): string;

    export declare function GeneratorFromJSON(json: FunctionJSON): FunctionValueGenerator | ValueGenerator | RotationGenerator;

    /**
     * `GeoBounds` 地理范围.
     */
    export declare class GeoBounds {
        min: GeoPoint;
        max: GeoPoint;
        constructor(min?: GeoPoint, max?: GeoPoint);
        /**
         * 根据数组创建 `GeoBounds`.
         *
         * Example:
         * ```typescript
         * const b = GeoBounds.fromArray([left, bottom, right, top]);
         * ```
         */
        static fromArray(input: [number, number, number, number]): GeoBounds;
        /**
         * 根据数组创建 `GeoBounds`.
         *
         * Example:
         * ```typescript
         * const b = GeoBounds.fromString("[1,2,3,4]");
         * ```
         */
        static fromString(input: string): GeoBounds;
        /**
         * 根据数据范围来生成bounds
         * @param input
         * @return {GeoBounds}
         */
        static fromDataExtent(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoBounds;
        /**
         * 根据中心点和长，宽生成bounds
         * @return {GeoBounds}
         * @param center 中心点
         * @param width 宽
         * @param height 高，不输入时与宽一样
         */
        static fromCenterWH(center: GeoPointLike, width: number, height?: number): GeoBounds;
        /**
         * 设置包围盒范围
         *
         * @param min 最小值
         * @param max 最大值
         */
        set(min: GeoPoint, max: GeoPoint): void;
        /**
         * 得到中心点
         * @return {GeoPoint}
         */
        center(): GeoPoint;
        /**
         * 得到左上角
         * @return {GeoPoint}
         */
        leftTop(): GeoPoint;
        /**
         * 得到左下角
         * @return {GeoPoint}
         */
        leftBottom(): GeoPoint;
        /**
         * 得到右上角
         * @return {GeoPoint}
         */
        rightTop(): GeoPoint;
        /**
         * 得到右下角
         * @return {GeoPoint}
         */
        rightBottom(): GeoPoint;
        /**
         * 生成一个随机点
         * @return {GeoPoint}
         * @param xRatio x轴范围比例 缺省 0.6
         * @param yRatio y轴范围比例 缺省 0.6
         */
        randomPoint(xRatio?: number, yRatio?: number): GeoPoint;
        /**
         * 生成一个随机点序列
         * @return {GeoPoint}
         * @param xRatio x轴范围比例 缺省 0.6
         * @param yRatio y轴范围比例 缺省 0.6
         * @param minPointCount 最少的点数
         * @param maxPointCount 最多的点数
         */
        randomPoints(minPointCount: number, maxPointCount: number, xRatio?: number, yRatio?: number): GeoPoint[];
        /**
         * 生成一个随机geojson点集合
         * @return {GeoPoint}
         * @param xRatio x轴范围比例 缺省 0.6
         * @param yRatio y轴范围比例 缺省 0.6
         * @param count 点的数目
         * @param propertiesCb 属性回调函数
         */
        randomGeoJsonPointCollection(count: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object): GeoJsonGeomertry;
        /**
         * 生成一个随机geojson线集合
         * @return {GeoPoint}
         * @param xRatio x轴范围比例 缺省 0.6
         * @param yRatio y轴范围比例 缺省 0.6
         * @param maxLineCount 最多线的数目
         * @param maxPointCount 每条线最多的点的数目
         * @param propertiesCb 属性回调函数
         * @param minLineCount 最少线的数目（缺省为1)
         * @param minPointCount 每条线最少的点的数目（缺省为2)
         */
        randomGeoJsonLineCollection(maxLineCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minLineCount?: number, minPointCount?: number): GeoJsonGeomertry;
        /**
         * 生成一个随机geojson多边形集合
         * @return {GeoPoint}
         * @param xRatio x轴范围比例 缺省 0.6
         * @param yRatio y轴范围比例 缺省 0.6
         * @param maxPolygonCount 最多多边形的数目
         * @param maxPointCount 每条线最多的点的数目
         * @param propertiesCb 属性回调函数
         * @param minPolygonCount 最少多边形的数目(缺省为1)
         * @param minPointCount 每条线最少的点的数目(缺省为3)
         */
        randomGeoJsonPolygonCollection(maxPolygonCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minPolygonCount?: number, minPointCount?: number): GeoJsonGeomertry;
        /**
         * 返回数组
         *
         * @returns {Array} The coordinates represented as a array of the format `[minx, miny, maxx, maxy]'`.
         *
         */
        toArray(): number[];
        /**
         * 返回点数组，包括四个顶点
         *
         * @returns {Array} The coordinates represented as a array of the format `[[minx,maxy], [maxx,maxy], [maxx,miny], [minx,miny]]'`.
         *
         */
        toPointArray(): Array<[number, number]>;
        /**
         * 返回字符串.
         *
         * @returns {string} The coordinates represented as a string of the format `minx, miny, maxx, maxy'`.
         *
         */
        toString(fixed?: number): string;
        /**
         *  克隆
         *
         */
        clone(): GeoBounds;
        /**
         * 变成正方形，使宽高相等
         * @param isMinValue 是否取宽高的最小值或最大值，默认最大值
         * @return{GeoBounds}
         */
        square(isMinValue?: boolean): GeoBounds;
        /**
         *  获取宽度
         *
         */
        width(): number;
        /**
         *  获取高度
         *
         */
        height(): number;
        /**
         *  按照比例扩大/缩小出一个新的 GeoBounds。
         * @param ratio 比例
         * @param origin 扩大时的基准点，默认为当前 bounds 的中心点
         */
        scale(ratio: number, origin?: GeoPoint | null): GeoBounds;
        /**
         *  按照XY比例扩大/缩小出一个新的 GeoBounds。
         * @param ratioX X比例
         * @param ratioY Y比例
         * @param origin 扩大时的基准点，默认为当前 bounds 的中心点
         */
        scaleXY(ratioX: number, ratioY: number, origin?: GeoPoint | null): GeoBounds;
        /**
         * 位移包围盒
         * @param dx
         * @param dy
         */
        translate(dx: number, dy: number): void;
        /**
         * 更新包围盒
         * @param vertices
         */
        update(vertices: GeoPoint[]): void;
        /**
         * 根据子包围盒更新包围盒
         * @param bounds
         */
        updateByBounds(bounds: GeoBounds[] | GeoBounds): void;
        /**
         * 两包围盒求交集
         * @param b
         */
        intersect(b: GeoBounds): GeoBounds | null;
        /**
         * 求多个包围盒的并集
         * @param bound
         */
        union(bound: GeoBounds): GeoBounds;
        /**
         * 判断与另一个包围盒是否相交
         * @param bound
         */
        isIntersect(bound: GeoBounds): boolean;
        /**
         * 求一个包围盒是否包含另一个包围盒
         * @param bound
         */
        isContains(bound: GeoBounds): boolean;
        /**
         * 查看点是否在包围盒中
         * @param point
         */
        contains(point: GeoPoint): boolean;
        /**
         * Returns the value in the interval that is nearest to `targetValue`.
         *
         * @ignore
         * @param interval        The interval to find the value within.
         * @param targetValue     The value to get nearest to.
         * @param includeInterior If false, the value will either be [[min]] or [[max]].
         *                        If true, the value may be any number between [[min]] and [[max]].
         */
        private closestInterval;
        /**
         * 查找边界框上最近的点并返回该点.
         * @param testPoint       点.
         * @param includeInterior 如果为true，则最近的点可以位于边界框内。如果为false，则最近的点只能位于边界框的外边缘上.
         */
        closestPoint(testPoint: GeoPoint, includeInterior?: boolean): GeoPoint;
    }

    /**
     * new一个GeoBounds实例
     * @param min
     * @param max
     */
    export declare function geoBounds(min?: GeoPoint, max?: GeoPoint): GeoBounds;

    /**
     * GeoJSON
     *
     * All GeoJSON objects
     */
    declare type GeoJsonGeomertry = Feature | FeatureCollection | Geometry | GeometryCollection;

    /**
     * GeoJSON Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3
     * The GeoJSON specification also allows [foreign members](https://tools.ietf.org/html/rfc7946#section-6.1)
     * Developers should use '&' type in TypeScript or extend the interface to add these foreign members.
     */
    declare interface GeoJSONObject {
        /**
         * Specifies the type of GeoJSON object.
         */
        type: string;
        /**
         * Bounding box of the coordinate range of the object's Geometries, Features, or Feature Collections.
         * https://tools.ietf.org/html/rfc7946#section-5
         */
        bbox?: BBox;
    }

    /**
     * Geometry
     *
     * https://tools.ietf.org/html/rfc7946#section-3
     */
    declare interface Geometry extends GeoJSONObject {
        coordinates: Position | Position[] | Position[][] | Position[][][];
    }

    /**
     * GeometryCollection
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.8
     *
     * A GeoJSON object with type 'GeometryCollection' is a Geometry object.
     * A GeometryCollection has a member with the name 'geometries'.
     * The value of 'geometries' is an array.  Each element of this array is a GeoJSON Geometry object.
     * It is possible for this array to be empty.
     */
    declare interface GeometryCollection extends GeometryObject {
        type: "GeometryCollection";
        geometries: Array<GeometryPoint | LineString | Polygon_2 | MultiPoint | MultiLineString | MultiPolygon>;
    }

    /**
     * Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3
     */
    declare interface GeometryObject extends GeoJSONObject {
        type: GeometryTypes;
    }

    /**
     * Point Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.2
     */
    declare interface GeometryPoint extends GeometryObject {
        type: "GeometryPoint";
        coordinates: Position;
    }

    /**
     * GeometryTypes
     *
     * https://tools.ietf.org/html/rfc7946#section-1.4
     * The valid values for the 'type' property of GeoJSON geometry objects.
     */
    declare type GeometryTypes = "GeometryPoint" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";

    /**
     * `GeoPoint` 地理坐标.
     */
    export declare class GeoPoint {
        /**
         * 根据不同的类型创建地理坐标 {@link GeoPoint} .
         *
         * Example:
         * ```typescript
         * const p1 = GeoPoint.convert(new GeoPoint(x, y, z));
         * const p2 = GeoPoint.convert([x, y]);
         * const p3 = GeoPoint.convert([x, y, z]);
         * const p4 = GeoPoint.convert(lng: -73.9749, lat: 40.7736});
         * const p5 = GeoPoint.convert(lon: -73.9749, lat: 40.7736});
         * ```
         *
         * @param input - Either [[GeoPointLike]], {@link GeoPointLike}
         * or {@link GeoPointLike} object literal.
         */
        static convert(input: GeoPointLike): GeoPoint;
        /**
         * 根据字符串创建 `GeoPoint`.
         *
         * Example:
         * ```typescript
         * const b = GeoPoint.fromString("1,2");
         * ```
         */
        static fromString(input: string): GeoPoint;
        /** 坐标X. */
        x: number;
        /** 坐标y. */
        y: number;
        /** 坐标z(可选）. */
        z?: number;
        /**
         *  `GeoPoint` 构造函数
         *
         * @param x - x坐标.
         * @param y - y坐标.
         * @param z - z坐标(可选）.
         */
        constructor(x: number, y: number, z?: number);
        /**
         *  克隆一个坐标
         *
         */
        clone(): GeoPoint;
        private _add;
        /**
         * 返回数组
         *
         * @returns {Array<number>} The coordinates represeted as an array of x and y.
         * ```typescript
         * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
         * ll.toArray(); // = [-73.9749, 40.7736]
         * ```
         */
        toArray(): number[];
        /**
         * 返回字符串.
         * @param fixed
         * @returns {string} The coordinates represented as a string of the format `'x, y, z?'`.
         * ```typescript
         * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
         * ll.toString(); // = "GeoPoint(-73.9749, 40.7736)"
         * ```
         */
        toString(fixed?: number): string;
        /**
         * 后小数点几位取整
         * @param fixed
         * @return {GeoPoint}
         */
        round(fixed?: number): GeoPoint;
        roundStr(fixed?: number): string;
        /**
         * 两个点相加.
         *
         * @param p - 要相加的点.
         */
        add(p: GeoPoint): GeoPoint;
        private _sub;
        /**
         * 两个点相减.
         *
         * @param p - 要相减的点.
         */
        sub(p: GeoPoint): GeoPoint;
        lengthSq(): number;
        private _multByPoint;
        /**
         * 两个点相乘.
         *
         * @param p - 要相乘的点.
         */
        multByPoint(p: GeoPoint): GeoPoint;
        private _divByPoint;
        /**
         * 两个点相除.
         *
         * @param p - 要相除的点.
         */
        divByPoint(p: GeoPoint): GeoPoint;
        dot(p: GeoPoint): number;
        lerp(v: GeoPoint, alpha: number): this;
        private _mult;
        /**
         * 乘一个系数.
         *
         * @param k - 系数.
         */
        mult(k: number): GeoPoint;
        private _div;
        /**
         * 除一个系数.
         *
         * @param k - 系数.
         */
        div(k: number): GeoPoint;
        private _rotate;
        /**
         * 旋转.
         *
         * @param angle - 弧度.
         */
        rotate(angle: number): GeoPoint;
        private _rotateAround;
        /**
         * 绕一个点旋转.
         *
         * @param angle - 弧度.
         * @param p - 围绕的点.
         */
        roateAround(angle: number, p: GeoPoint): GeoPoint;
        private _matMult;
        /**
         * 乘一个矩阵.
         *
         * @param m - 矩阵值.
         */
        matMult(m: number[]): GeoPoint;
        private _unit;
        /**
         * 单位长度.
         *
         */
        unit(): GeoPoint;
        private _perp;
        /**
         * 投影 [x,y] = [-y, x].
         *
         */
        perp(): GeoPoint;
        private _round;
        /**
         * 四舍五入取整.
         *
         */
        roundInt(): GeoPoint;
        /**
         * 长度.
         *
         */
        mag(): number;
        /**
         * 判断是否相等
         * @param other 另外一个点
         * @param dotErr 允许误差的小数点后几位，默认8位
         * @return {boolean}
         */
        equals(other: GeoPoint, dotErr?: number): boolean;
        /**
         * 是否相等（判断z).
         *
         */
        equalsZ(other: GeoPoint): boolean;
        /**
         * 两点之间距离.
         *
         */
        distanceTo(p: GeoPoint): number;
        /**
         * 两点之间距离平方.
         *
         */
        distSqr(p: GeoPoint): number;
        /**
         * 角度.
         *
         */
        angle(): number;
        /**
         * 距一个点的角度
         *
         */
        angleTo(b: GeoPoint): number;
        /**
         * 距一个点的interiorAngle
         *
         */
        angleWith(b: GeoPoint): number;
        /**
         * 距一个点的interiorAngle
         *
         */
        angleWithSep(x: number, y: number): number;
        /**
         * 对一个点围绕一个基点进行缩放旋转平移操作.
         * @param basePt 围绕的基点坐标
         * @param destPt 要平移至的目的地坐标
         * @param scale 缩放比例，默认1.0
         * @param angle 旋转角度，逆时针，默认0
         * @return {GeoPoint}
         *
         */
        transform(basePt: GeoPoint, destPt: GeoPoint, scale?: number, angle?: number): this;
    }

    /**
     * new一个GeoPoint实例
     * @param input
     * @return {GeoPoint}
     */
    export declare function geoPoint(input: GeoPointLike): GeoPoint;

    export declare type GeoPointLike = [number, number] | [number, number, number] | GeoPoint | {
        x: number;
        y: number;
        z?: number;
    } | {
        lng: number;
        lat: number;
    } | {
        lon: number;
        lat: number;
    };

    /**
     * `GeoProjection` 地理坐标投影.
     *
     * Example:
     * ```typescript
     * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
     * const prj = new GeoProjection(mapExtent);
     * const pt = [30, 30];
     * const latlng = prj.toLngLat(pt);
     * const pt_geo = prj.fromLngLat(latlng);
     * const mkt = prj.toMercator(pt);
     * const pt_mkt = prj.fromMercator(mkt);
     * ```
     */
    export declare class GeoProjection extends Projection {
        /** 地图地理范围. */
        mapExtent: GeoBounds;
        private _ratio_x;
        private _ratio_y;
        /**
         *  `GeoBounds` 构造函数
         *
         * @extent extent - 地图地理范围.
         */
        constructor(extent: GeoBounds);
        /**
         *  设置地图范围
         *
         * @extent extent - 地图地理范围.
         */
        setExtent(extent: GeoBounds): void;
        /**
         * 坐标转墨卡托(epsg:3857)
         * @param input 坐标点
         * @return {[number, number]}
         */
        toMercator(input: GeoPointLike): [number, number];
        /**
         * 墨卡托(epsg:3857)转坐标
         * @param input 墨卡托坐标点
         * @return {[number, number]}
         */
        fromMercator(input: GeoPointLike): [number, number];
        /**
         * 地图地理坐标转经纬度
         * @param input 地理坐标点
         * @return {[number, number]}
         */
        toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): [number, number];
        /**
         * 经纬度转地图地理坐标
         * @param input 经纬度坐标点
         * @return {GeoPoint}
         */
        fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
        /**
         * 得到地图范围
         * @return {GeoBounds}
         */
        getMapExtent(): GeoBounds;
        /**
         * 把距离转化为米
         * @param dist
         */
        toMeter(dist: number): number;
        /**
         * 把米转化为距离
         * @param meter
         */
        fromMeter(meter: number): number;
    }

    /**
     * 通过3dtiles的boundingVolume和transform获取经纬度
     * @param box 3dtiles里面boundingVolume.box的值，默认取中心点。也可以直接传一个坐标[number,number,number]
     */
    declare function get3dTilesLngLatHeight(box: number[], matrix?: number[]): [number, number, number];

    export declare const getAlignOfNodeValueType: (type: NodeValueType) => number;

    /**
     * 获取物体的外包盒
     * @param object 物体
     * @param inLocalSpace 局部空间
     * @param app 应用
     * @param mapModeSceneSpace 地图模式下返回场景空间坐标
     */
    export declare function getBoundingBox(object: Object3D, inLocalSpace?: boolean, app?: App, mapModeSceneSpace?: boolean): Box3;

    declare function getBVHExtremes(bvh: MeshBVH): Array<ExtremeInfo>;

    /**
     * Returns the current active effect scope if there is one.
     *
     */
    declare function getCurrentScope(): EffectScope;

    declare function getElementSSRData(el: Element_2): ElementSSRData;

    export declare function getEmptyMeta(res?: any): {
        geometries: any;
        materials: any;
        textures: any;
        images: any;
        shapes: any;
        skeletons: any;
        animations: any;
        extras: any;
        _context: {};
    };

    /** 获取实体所所有的父对象 */
    export declare const getEntityParents: (ent: Entity) => Entity[];

    /** 从hdr贴图中提取envmap */
    export declare const getEnvmapFromHDRTexture: (renderer: WebGLRenderer, texture: Texture) => Texture;

    /**  从场景中提取envmap */
    export declare const getEnvmapFromScene: (renderer: WebGLRenderer, scene: Scene) => Texture;

    /**
     * 根据坐标来获取epsg代号
     * @param coordinate 坐标，如果有带号的坐标x，输入x的前两位，否则可输入投影坐标[x,y]或经纬度[lng,lat]
     * @param crs 投影坐标类型 用来过滤结果， 不填默认全部
     * @param is3DegreeBelt 是否是三度带，用来过滤结果， 不填默认全部
     * @returns
     */
    declare function getEpsgCode(coordinate: number | [number, number], crs?: EpsgCrsTypes, is3DegreeBelt?: boolean): any[];

    /**
     * 根据带号和坐标系来得到proj4的参数
     * @param crs 投影坐标类型
     * @param lon 如果为北京54,西安80，2000坐标，需要传入8位的经度坐标，或者带系前两位。如果是wgs84或3857，则不需要传入
     * @returns {null | {epsg: string, proj: string}}
     */
    declare function getEpsgParam(crs: EpsgCrsTypes, lon?: number): {
        epsg: string;
        proj: string;
    };

    /**
     * Get the filename from a path, similar to PHP's basename()
     * @param url
     *
     * @category Text
     */
    export declare function getFilenameFromPath(url: string): string;

    /**
     * 根据过滤的参数获取颜色变化的矩形
     * @returns
     */
    export declare function getFilterColorMatrix(filter: FilterColorOptions): Matrix4;

    export declare function getFrustum(camera: any, offsetZ?: number): {
        width: number;
        height: number;
    };

    export declare function getFrustumFromHeight(camera: any, height: any, offsetZ?: number): number;

    export declare function getFullscreenTriangle(): BufferGeometry<NormalBufferAttributes>;

    /**
     * Get render2d instance by id
     */
    declare function getInstance(id: number): Render2D;

    declare function getJSONStructure(bvh: MeshBVH): TreeNode;

    /**
     * Find the key of an object with a given value.
     * @param object - object to search
     * @param value - value to search for
     *
     * @category JS Object
     */
    export declare function getKeyByValue(object: Record<string, any>, value: any): string | undefined;

    /**
     * 根据锚获取物体的外包盒的点
     * object 物体或包围盒
     * anchor 锚位置
     * inLocalSpace 局部空间坐标
     */
    export declare function getObjectAnchorPoint(object: Object3D | Box3, anchor: Anchor3d, inLocalSpace?: boolean, app?: App): Vector3;

    /**
     * 获取物体所对应的实体对象
     * @param object 要查找的实体对象
     * @param isRootEntity 是否查找为根节点下面的实体，默认false
     * @returns
     */
    export declare const getObjectOwnerEntity: (object: Object3D, isRootEntity?: boolean) => Entity | undefined;

    export declare const getObjectRefCount: (obj: any) => boolean;

    /**
     * Get value, but if it is a function, call it with args
     * @param s - value or function
     * @param args - arguments to pass to function
     *
     * @category JS Object
     */
    export declare function getOrCall<T>(s: ValOrFunc<T | undefined>, ...args: any[]): T | undefined;

    /** 得到实体拥有的场景对象 */
    export declare function getOwerScene(ent: Entity | Object3D): Scene | undefined;

    export declare function getPhysicsResolver(): PhysicsResolver;

    /**
     * Get property descriptor from object or its prototype chain
     * @param obj
     * @param prop
     *
     * @category JS Object
     */
    export declare function getPropertyDescriptor<T>(obj: T, prop: keyof T): PropertyDescriptor | undefined;

    export declare function getScreenSpaceBox(mesh: any, camera: any): Box2;

    /**
     * Given a THREE.Object3D instance, creates parameters for a CANNON shape.
     */
    export declare const getShapeParameters: (object: Object3D, options?: ShapeOptions) => ShapeParameters | null;

    export declare const getSizeOfNodeValueType: (type: NodeValueType) => number;

    export declare function getSphericalCube(radius: any, segments: any): BoxGeometry;

    declare function getTriangleDefinitions(...triangles: Triangle[]): String[];

    declare function getTriangleHitPointInfo(point: Vector3, geometry: BufferGeometry, triangleIndex: number, target?: HitTriangleInfo): HitTriangleInfo;

    /**
     * Create a typed array from an ArrayBuffer by name
     * @param type - Name of the typed array constructor
     * @param buffer - ArrayBuffer to use
     * @category ArrayBuffer
     */
    export declare function getTypedArray(type: keyof typeof TYPED_ARRAYS, buffer: ArrayBuffer): Float32Array | Uint8Array | Int8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float64Array;

    /**
     * Get URL query parameter. If not found, return default value. Similar to PHP's $_GET
     * @param p - parameter name to get
     * @param def - default value if parameter not found
     *
     * @category URL
     */
    export declare function getUrlQueryParam(p: string, def?: any): any;

    export declare function getValueFromEmitterMode(mode: EmitterMode, currentValue: number, spread: number, emissionState: EmissionState): number;

    export { GlitchEffect }

    export { GlitchMode }

    export declare interface GlLineItemData {
        /** id */
        id?: string;
        /** 坐标 */
        coordinates: [number, number, number][];
        /** 颜色 */
        color?: ColorRepresentation | ColorRepresentation[];
        /** 是否显示顶点 */
        showVertex?: boolean;
        /**  自定义数据 */
        [key: string]: any;
    }

    /**
     * 多段线实体(glline一个像素线宽)
     */
    export declare class GlLinesEntity extends Entity {
        constructor(options: GlLinesEntityOptions);
        /**
         * 获取线对象
         */
        getGlLines: () => Line_2;
        /**
         * 更新样式
         */
        updateStyle: (style: LineDashedMaterialParameters | LineBasicMaterialParameters) => void;
        /**
         * 更新高亮样式
         */
        updateHightStyle: (style: LineDashedMaterialParameters | LineBasicMaterialParameters) => void;
        /**
         * 修改数据
         */
        setData: (data: GlLineItemData[]) => void;
        /**
         * 获取数据
         */
        getData: () => GlLineItemData[];
        /**
         * 获取顶点对象
         */
        getVertexSymbol: () => SymbolEntity;
        /**
         * 是否显示顶点
         */
        isShowVertex: () => boolean;
        /**
         * 获取顶点数据
         */
        getVertexData: (isGetAll?: boolean) => SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex: (show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }) => void;
        /**
         * 通过索引获取数据
         * @param index 索引
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByIndex: (index: number, isRefData?: boolean) => {
            positionIndex: number;
        } & GlLineItemData;
        /**
         * 刷新高亮数据
         */
        refreshHighlight: () => void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight: (id: string) => boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight: () => void;
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
    }

    export declare type GlLinesEntityOptions = EntityOptions & GlLinesModuleOption;

    /**
     * webgl线模块,用来绘制批量线(没有线宽)
     */
    export declare class GlLinesModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        gllines: Line_2;
        data: GlLineItemData[];
        style: LineDashedMaterialParameters | LineBasicMaterialParameters;
        highlightGlLines: Line_2;
        highlightData: GlLineItemData[];
        highlightStyle: LineDashedMaterialParameters | LineBasicMaterialParameters;
        highlightIndexMap: Map<string, number>;
        posIndex: Map<number, {
            lineIndex: number;
            positionIndex: number;
        }>;
        vertexEntity: SymbolEntity;
        showVertex: boolean;
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
        constructor(entity: Entity, options?: GlLinesModuleOption);
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            app: App;
            children: {
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
            }[];
        };
        /**
         * 获取线对象
         */
        getGlLines(): Line_2<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
        /**
         * 获取顶点对象
         */
        getVertexSymbol(): SymbolEntity;
        /**
         * 更新样式
         */
        updateStyle(style: LineDashedMaterialParameters | LineBasicMaterialParameters): void;
        /**
         * 更新高亮样式
         */
        updateHightStyle(style: LineDashedMaterialParameters | LineBasicMaterialParameters): void;
        /**
         * 修改数据
         */
        setData(data: GlLineItemData[]): void;
        /**
         * 是否显示顶点
         */
        isShowVertex(): boolean;
        /**
         * 获取顶点数据
         */
        getVertexData(isGetAll?: boolean): SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex(show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }): void;
        /**
         * 获取数据
         */
        getData(): GlLineItemData[];
        /**
         * 通过Index获取
         * @param index 索引
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByIndex(index: number, isRefData?: boolean): {
            data: GlLineItemData;
            positionIndex: number;
        } | {
            positionIndex: number;
            /** id */
            id?: string;
            /** 坐标 */
            coordinates: [number, number, number][];
            /** 颜色 */
            color?: ColorRepresentation | ColorRepresentation[];
            /** 是否显示顶点 */
            showVertex?: boolean;
            data?: undefined;
        };
        /**
         * 刷新高亮数据
         * @returns
         */
        refreshHighlight(): void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight(id: string): boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight(): void;
    }

    export declare interface GlLinesModuleOption {
        /** 数据 */
        data: GlLineItemData[];
        /** 样式 */
        style?: LineDashedMaterialParameters | LineBasicMaterialParameters;
        /** 高亮样式 */
        highlightStyle?: LineDashedMaterialParameters | LineBasicMaterialParameters;
        /** 是否使用虚线 */
        dashed?: boolean;
        /**  是否显示顶点(全局控制显示) */
        showVertex?: boolean;
        /** 是否隐藏 */
        hidden?: boolean;
        /**  顶点样式 */
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
    }

    /**
     * A template literal tag that does nothing. Useful for syntax highlighting of GLSL code.
     *
     * @example
     * ```js
     * const vertexShader = glsl`
     *    void main() {}
     * `
     * ```
     * @category Template Literals
     */
    export declare const glsl: (strings: any, ...rest: any[]) => string;

    export { GodRaysEffect }

    export declare class Gradient implements FunctionColorGenerator {
        type: 'function';
        color: ContinuousLinearFunction<Vector3>;
        alpha: ContinuousLinearFunction<number>;
        constructor(color?: Array<[Vector3, number]>, alpha?: Array<[number, number]>);
        genColor(color: Vector4, t: number): Vector4;
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): Gradient;
        clone(): FunctionColorGenerator;
    }

    declare class Gradient_2 {
        id?: number;
        type: string;
        colorStops: GradientColorStop[];
        global: boolean;
        constructor(colorStops: GradientColorStop[]);
        addColorStop(offset: number, color: string): void;
    }

    declare interface GradientColorStop {
        offset: number;
        color: string;
    }

    declare interface GradientObject {
        id?: number;
        type: string;
        colorStops: GradientColorStop[];
        global?: boolean;
    }

    export declare class GraphNodeType extends NodeDef {
        nodeGraph: NodeGraph;
        constructor(nodeGraph: NodeGraph);
    }

    /**
     * Apply a gravity force to particles.
     * the gravity force is calculated as:
     * F = G * m1 * m2 / r^2
     */
    export declare class GravityForce implements Simulation {
        center: Vector3;
        magnitude: number;
        type: string;
        temp: Vector3;
        constructor(center: Vector3, magnitude: number);
        initialize(particle: Particle): void;
        update(particle: Particle, delta: number): void;
        frameUpdate(delta: number): void;
        toJSON(): any;
        static fromJSON(json: any): Simulation;
        clone(): Simulation;
        reset(): void;
    }

    export declare const Grid: ({ args, cellColor, sectionColor, cellSize, sectionSize, followCamera, infiniteGrid, fadeDistance, fadeStrength, cellThickness, sectionThickness, axisThickness, side, depthWrite, }?: GridProps) => GridType;

    /**
     * Axis aligned uniform grid broadphase.
     * @todo Needs support for more than just planes and spheres.
     */
    declare class GridBroadphase extends Broadphase {
        /**
         * Number of boxes along x
         */
        nx: number;
        /**
         * Number of boxes along y
         */
        ny: number;
        /**
         * Number of boxes along z
         */
        nz: number;
        /**
         * aabbMin
         */
        aabbMin: Vec3;
        /**
         * aabbMax
         */
        aabbMax: Vec3;
        /**
         * bins
         */
        bins: Body_2[][];
        /**
         * binLengths
         */
        binLengths: number[];
        /**
         * @param nx Number of boxes along x.
         * @param ny Number of boxes along y.
         * @param nz Number of boxes along z.
         */
        constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number);
        /**
         * Get all the collision pairs in the physics world
         */
        collisionPairs(world: World, pairs1: Body_2[], pairs2: Body_2[]): void;
    }

    export declare class GridEmitter implements EmitterShape {
        type: string;
        width: number;
        height: number;
        column: number;
        row: number;
        constructor(parameters?: GridEmitterParameters);
        initialize(p: Particle): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any): GridEmitter;
        clone(): EmitterShape;
        update(system: ParticleSystem, delta: number): void;
    }

    /**
     * Interface representing the parameters for a grid emitter.
     */
    export declare interface GridEmitterParameters {
        /**
         * The width of the grid.
         */
        width?: number;
        /**
         * The height of the grid.
         */
        height?: number;
        /**
         * The number of columns in the grid.
         */
        column?: number;
        /**
         * The number of rows in the grid.
         */
        row?: number;
    }

    export declare class GridHelperModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        grid: GridType;
        gridLineHelper: GridHelper;
        constructor(entity: Entity, options?: GridHelperModuleOptions);
        getVisible(isUseGridLine?: boolean): boolean;
        setVisible(visible: boolean, isUseGridLine?: boolean): void;
        onAppUpdate(time: Time): void;
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface GridHelperModuleOptions extends GridProps {
        polygonOffset?: boolean;
        polygonOffsetFactor?: number;
        polygonOffsetUnits?: number;
        /** 绘制网格线 */
        drawGridLine?: boolean;
        /** 网格线大小 */
        gridLineSize?: number;
        /** 网格线分割数 */
        gridLineDivisions?: number;
        /** 网格线中心线的颜色 */
        gridLineColor1?: Color;
        /** 网格线线条的颜色 */
        gridLineColor2?: Color;
    }

    declare class GridMaterial extends MeshPhongMaterial {
        enableGrid: boolean;
    }

    export declare type GridProps = {
        /** plane-geometry size, default: [100, 100] */
        args?: Array<number>;
        /** Cell size, default: 1 */
        cellSize?: number;
        /** Cell thickness, default: 0.8 */
        cellThickness?: number;
        /** Cell color, default: rgb(50,55,72) */
        cellColor?: Color;
        /** Section size, default: 10 */
        sectionSize?: number;
        /** Section thickness, default: 1 */
        sectionThickness?: number;
        /** axisThickness thickness, default: 1.8 */
        axisThickness?: number;
        /** Section color, default: rgb(73,79,105) */
        sectionColor?: Color;
        /** Follow camera, default: false */
        followCamera?: boolean;
        /** Display the grid infinitely, default: false */
        infiniteGrid?: boolean;
        /** Fade distance, default: 1000 */
        fadeDistance?: number;
        /** Fade strength, default: 1 */
        fadeStrength?: number;
        /** Material side, default: BackSide */
        side?: Side;
        /** Material depthWrite, default: false */
        depthWrite?: boolean;
        /** visible, default: true */
        visible?: boolean;
    };

    export declare type GridType = {
        mesh: Mesh;
        update: (camera: Camera) => void;
    };

    declare class Group extends Element_2<GroupProps> {
        readonly isGroup = true;
        private _children;
        constructor(opts?: GroupProps);
        /**
         * Get children reference.
         */
        childrenRef(): Element_2<ElementProps>[];
        /**
         * Get children copy.
         */
        children(): Element_2<ElementProps>[];
        /**
         * 获取指定 index 的儿子节点
         */
        childAt(idx: number): Element_2;
        /**
         * 获取指定名字的儿子节点
         */
        childOfName(name: string): Element_2;
        childCount(): number;
        /**
         * 添加子节点到最后
         */
        add(child: Element_2): Group;
        /**
         * 添加子节点在 nextSibling 之前
         */
        addBefore(child: Element_2, nextSibling: Element_2): this;
        replace(oldChild: Element_2, newChild: Element_2): this;
        replaceAt(child: Element_2, index: number): this;
        _doAdd(child: Element_2): void;
        /**
         * Remove child
         * @param child
         */
        remove(child: Element_2): this;
        /**
         * Remove all children
         */
        removeAll(): this;
        /**
         * 遍历所有子节点
         */
        eachChild<Context>(cb: (this: Context, el: Element_2, index?: number) => void, context?: Context): this;
        /**
         * Visit all descendants.
         * Return false in callback to stop visit descendants of current node
         */
        traverse<T>(cb: (this: T, el: Element_2) => boolean | void, context?: T): this;
        addSelfToZr(zr: Render2dType): void;
        removeSelfFromZr(zr: Render2dType): void;
        getBoundingRect(includeChildren?: Element_2[]): BoundingRect;
    }

    declare interface GroupLike extends Element_2 {
        childrenRef(): Element_2[];
    }

    declare interface GroupProps extends ElementProps {
    }

    /**
     * Constraint equation Gauss-Seidel solver.
     * @todo The spook parameters should be specified for each constraint, not globally.
     * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
     */
    declare class GSSolver extends Solver {
        /**
         * The number of solver iterations determines quality of the constraints in the world.
         * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
         */
        iterations: number;
        /**
         * When tolerance is reached, the system is assumed to be converged.
         */
        tolerance: number;
        /**
         * @todo remove useless constructor
         */
        constructor();
        /**
         * Solve
         * @return number of iterations performed
         */
        solve(dt: number, world: World): number;
    }

    /**
     * Generate unique id
     */
    declare function guid(): number;

    declare class HalfEdgeHelper extends EdgesHelper {
        constructor(geometry?: BufferGeometry, halfEdges?: HalfEdgeMap);
        setHalfEdges(geometry: BufferGeometry, halfEdges: HalfEdgeMap): void;
    }

    declare class HalfEdgeMap {
        constructor(geometry?: BufferGeometry);
        getSiblingTriangleIndex(triIndex: number, edgeIndex: number): number;
        getSiblingEdgeIndex(triIndex: number, edgeIndex: number): number;
        updateFrom(geomtry: BufferGeometry): void;
    }

    /**
     * 发光的光环.
     */
    export declare class HaloRingMarker extends AnimateMarkerBase {
        constructor(features: FeatureCollection | {
            position: [number, number, number?];
            text?: string;
        }, options?: AnimateMarkerLayerOption);
        setMarkersWidth(width: number, index?: number): void;
        setMarkersColors(colors: string[], index?: number): void;
        _createMarker(): void;
        private _createMakerElement;
    }

    declare class Handler extends Eventful {
        storage: Storage_2;
        painter: PainterBase;
        painterRoot: HTMLElement;
        proxy: HandlerProxyInterface;
        private _hovered;
        private _gestureMgr;
        private _draggingMgr;
        private _pointerSize;
        _downEl: Element_2;
        _upEl: Element_2;
        _downPoint: [number, number];
        constructor(storage: Storage_2, painter: PainterBase, proxy: HandlerProxyInterface, painterRoot: HTMLElement, pointerSize: number);
        setHandlerProxy(proxy: HandlerProxyInterface): void;
        mousemove(event: ZRRawEvent): void;
        mouseout(event: ZRRawEvent): void;
        /**
         * Resize
         */
        resize(): void;
        /**
         * Dispatch event
         */
        dispatch(eventName: HandlerName, eventArgs?: any): void;
        /**
         * Dispose
         */
        dispose(): void;
        /**
         * 设置默认的cursor style
         * @param cursorStyle 例如 crosshair，默认为 'default'
         */
        setCursorStyle(cursorStyle: string): void;
        /**
         * 事件分发代理
         *
         * @private
         * @param {Object} targetInfo {target, topTarget} 目标图形元素
         * @param {string} eventName 事件名称
         * @param {Object} event 事件对象
         */
        dispatchToElement(targetInfo: {
            target?: Element_2;
            topTarget?: Element_2;
        }, eventName: ElementEventName, event: ZRRawEvent): void;
        findHover(x: number, y: number, exclude?: Displayable): HoveredResult;
        processGesture(event: ZRRawEvent, stage?: 'start' | 'end' | 'change'): void;
        click: (event: ZRRawEvent) => void;
        mousedown: (event: ZRRawEvent) => void;
        mouseup: (event: ZRRawEvent) => void;
        mousewheel: (event: ZRRawEvent) => void;
        dblclick: (event: ZRRawEvent) => void;
        contextmenu: (event: ZRRawEvent) => void;
    }

    declare type HandlerName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu';

    declare interface HandlerProxyInterface extends Eventful {
        handler: Handler;
        dispose: () => void;
        setCursor: (cursorStyle?: string) => void;
    }

    /**
     * @constructor
     * @param {Object} obj
     */
    declare class HashMap<T, KEY extends string | number = string | number> {
        data: MapInterface<T, KEY>;
        constructor(obj?: HashMap<T, KEY> | {
            [key in KEY]?: T;
        } | KEY[]);
        hasKey(key: KEY): boolean;
        get(key: KEY): T;
        set(key: KEY, value: T): T;
        each<Context>(cb: (this: Context, value?: T, key?: KEY) => void, context?: Context): void;
        keys(): KEY[];
        removeKey(key: KEY): void;
    }

    declare function hasOwn(own: object, prop: string): boolean;

    declare class Heart extends Path<HeartProps> {
        shape: HeartShape;
        constructor(opts?: HeartProps);
        getDefaultShape(): HeartShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: HeartShape): void;
    }

    declare interface HeartProps extends PathProps {
        shape?: Partial<HeartShape>;
    }

    declare class HeartShape {
        cx: number;
        cy: number;
        width: number;
        height: number;
    }

    /** 热力图 */
    export declare class Heatmap {
        #private;
        options: HeatmapOptions;
        heatmap: any;
        mesh: Mesh;
        h337: any;
        size: [number, number];
        bounds: GeoBounds;
        texture: Texture;
        constructor(options: HeatmapOptions);
        /** 创建 */
        create(): Promise<Mesh<PlaneGeometry, MeshBasicMaterial | ShaderMaterial, Object3DEventMap>>;
        /** 设置数据 */
        setData(opts: {
            /** 边界范围 [[minx, minz],[maxx, maxz]]*/
            bounds?: [number, number][];
            boundScale?: number;
            /** 数据项 */
            data: {
                /** 点坐标 x,z*/
                point: [number, number];
                /** 值 */
                value: number;
            }[];
            max?: number;
            min?: number;
            /** 裁剪多边形 */
            clipPolygon?: [number, number][];
        }): void;
        /** 通过uv值获取所在的值 */
        getValueByUV(uv: [number, number]): any;
        /** 通过坐标值获取所在的值 */
        getValueByCoord(pt: [number, number]): any;
    }

    /** 热力图参数 */
    export declare interface HeatmapOptions {
        /** 3d热力图模式 */
        mode3D?: boolean;
        /** 3d热力图时高度比例 默认10 */
        heightRatio?: number;
        /** 3d热力图平面分割数 默认50 */
        segment?: number;
        /** 边界范围 [[minx, minz],[maxx, maxz]]*/
        bounds?: [[number, number], [number, number]];
        /** 裁剪多边形 */
        clipPolygon?: [number, number][];
        boundScale?: number;
        /** 数据项 */
        data: {
            /** 点坐标 x,z*/
            point: [number, number];
            /** 值 */
            value: number;
        }[];
        max?: number;
        min?: number;
        /** 画布大小 */
        canvasSize?: number;
        /** 样式 */
        style?: {
            /**
             * A background color string in form of hexcode, color name, or rgb(a)
             */
            backgroundColor?: string;
            /**
             * The blur factor that will be applied to all datapoints. The higher the
             * blur factor is, the smoother the gradients will be
             * Default value: 0.85
             */
            blur?: number;
            /**
             * An object that represents the gradient.
             * Syntax: {[key: number in range [0,1]]: color}
             * Default value: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"}
             */
            gradient?: {
                [key: string]: string;
            };
            /**
             * The maximal opacity the highest value in the heatmap will have. (will be
             * overridden if opacity set)
             * Default value: 0.6
             */
            maxOpacity?: number;
            /**
             * The minimum opacity the lowest value in the heatmap will have (will be
             * overridden if opacity set)
             */
            minOpacity?: number;
            /**
             * A global opacity for the whole heatmap. This overrides maxOpacity and
             * minOpacity if set
             * Default value: 0.6
             */
            opacity?: number;
            /**
             * The radius each datapoint will have (if not specified on the datapoint
             * itself)
             * Default value: 40
             */
            radius?: number;
            /**
             * Scales the radius based on map zoom.
             */
            scaleRadius?: boolean;
        };
    }

    /**
     * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
     * @todo Should be possible to use along all axes, not just y
     * @todo should be possible to scale along all axes
     * @todo Refactor elementSize to elementSizeX and elementSizeY
     *
     * @example
     *     // Generate some height data (y-values).
     *     const data = []
     *     for (let i = 0; i < 1000; i++) {
     *         const y = 0.5 * Math.cos(0.2 * i)
     *         data.push(y)
     *     }
     *
     *     // Create the heightfield shape
     *     const heightfieldShape = new CANNON.Heightfield(data, {
     *         elementSize: 1 // Distance between the data points in X and Y directions
     *     })
     *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })
     *     world.addBody(heightfieldBody)
     */
    declare class Heightfield extends Shape {
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         */
        data: number[][];
        /**
         * Max value of the data points in the data array.
         */
        maxValue: number | null;
        /**
         * Minimum value of the data points in the data array.
         */
        minValue: number | null;
        /**
         * World spacing between the data points in X and Y direction.
         * @todo elementSizeX and Y
         * @default 1
         */
        elementSize: number;
        /**
         * @default true
         */
        cacheEnabled: boolean;
        pillarConvex: ConvexPolyhedron;
        pillarOffset: Vec3;
        private _cachedPillars;
        /**
         * @param data An array of numbers, or height values, that are spread out along the x axis.
         */
        constructor(data: number[][], options?: {
            /**
             * Max value of the data points in the data array.
             * Will be computed automatically if not given.
             */
            maxValue?: number | null;
            /**
             * Minimum value of the data points in the data array.
             * Will be computed automatically if not given.
             */
            minValue?: number | null;
            /**
             * World spacing between the data points in X direction.
             */
            elementSize?: number;
        });
        /**
         * Call whenever you change the data array.
         */
        update(): void;
        /**
         * Update the `minValue` property
         */
        updateMinValue(): void;
        /**
         * Update the `maxValue` property
         */
        updateMaxValue(): void;
        /**
         * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
         */
        setHeightValueAtIndex(xi: number, yi: number, value: number): void;
        /**
         * Get max/min in a rectangle in the matrix data
         * @param result An array to store the results in.
         * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
         */
        getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result?: number[]): void;
        /**
         * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
         * @param result Two-element array
         * @param clamp If the position should be clamped to the heightfield edge.
         */
        getIndexOfPosition(x: number, y: number, result: number[], clamp: boolean): boolean;
        getTriangleAt(x: number, y: number, edgeClamp: boolean, a: Vec3, b: Vec3, c: Vec3): boolean;
        getNormalAt(x: number, y: number, edgeClamp: boolean, result: Vec3): void;
        /**
         * Get an AABB of a square in the heightfield
         * @param xi
         * @param yi
         * @param result
         */
        getAabbAtIndex(xi: number, yi: number, { lowerBound, upperBound }: AABB): void;
        /**
         * Get the height in the heightfield at a given position
         */
        getHeightAt(x: number, y: number, edgeClamp: boolean): number;
        getCacheConvexTrianglePillarKey(xi: number, yi: number, getUpperTriangle: boolean): string;
        getCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): HeightfieldPillar;
        setCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean, convex: ConvexPolyhedron, offset: Vec3): void;
        clearCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;
        /**
         * Get a triangle from the heightfield
         */
        getTriangle(xi: number, yi: number, upper: boolean, a: Vec3, b: Vec3, c: Vec3): void;
        /**
         * Get a triangle in the terrain in the form of a triangular convex shape.
         */
        getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;
        calculateLocalInertia(mass: number, target?: Vec3): Vec3;
        volume(): number;
        calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
        updateBoundingSphereRadius(): void;
        /**
         * Sets the height values from an image. Currently only supported in browser.
         */
        setHeightsFromImage(image: HTMLImageElement, scale: Vec3): void;
    }

    declare type HeightfieldOptions = ConstructorParameters<typeof Heightfield>[1];

    declare type HeightfieldPillar = {
        convex: any;
        offset: any;
    };

    export declare class HemisphereEmitter implements EmitterShape {
        type: string;
        radius: number;
        arc: number;
        thickness: number;
        mode: EmitterMode;
        spread: number;
        speed: ValueGenerator | FunctionValueGenerator;
        constructor(parameters?: HemisphereEmitterParameters);
        private currentValue;
        update(system: ParticleSystem, delta: number): void;
        initialize(p: Particle, emissionState: EmissionState): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any): HemisphereEmitter;
        clone(): EmitterShape;
    }

    /**
     * Interface representing the parameters for a hemisphere emitter.
     */
    export declare interface HemisphereEmitterParameters {
        /**
         * The radius of the hemisphere.
         */
        radius?: number;
        /**
         * The arc of the hemisphere.
         */
        arc?: number;
        /**
         * The thickness of the hemisphere. 1 is a full hemisphere, 0 is a thin shell.
         */
        thickness?: number;
        /**
         * The mode of the emitter.
         * {@link EmitterMode}
         */
        mode?: EmitterMode;
        /**
         * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
         * {@link EmitterMode}
         */
        spread?: number;
        /**
         * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
         * {@link EmitterMode}
         */
        speed?: ValueGenerator | FunctionValueGenerator;
    }

    /**
     * 高亮材质
     * @param props
     */
    export declare const highlightMaterial: (opts: HighlightMaterialOption) => any;

    export declare interface HighlightMaterialOption {
        material: Material | Material[];
        highlightOpacity?: IUniformN;
        highlightColor: IUniformColor;
    }

    /**
     * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
     */
    declare class HingeConstraint extends PointToPointConstraint {
        /**
         * Rotation axis, defined locally in bodyA.
         */
        axisA: Vec3;
        /**
         * Rotation axis, defined locally in bodyB.
         */
        axisB: Vec3;
        rotationalEquation1: RotationalEquation;
        rotationalEquation2: RotationalEquation;
        motorEquation: RotationalMotorEquation;
        constructor(bodyA: Body_2, bodyB: Body_2, options?: {
            /**
             * A point defined locally in bodyA. This defines the offset of axisA.
             */
            pivotA?: Vec3;
            /**
             * A point defined locally in bodyB. This defines the offset of axisB.
             */
            pivotB?: Vec3;
            /**
             * An axis that bodyA can rotate around, defined locally in bodyA.
             */
            axisA?: Vec3;
            /**
             * An axis that bodyB can rotate around, defined locally in bodyB.
             */
            axisB?: Vec3;
            /**
             * Wheter to collide the connected bodies or not.
             * @default false
             */
            collideConnected?: boolean;
            /**
             * The maximum force that should be applied to constrain the bodies.
             * @default 1e6
             */
            maxForce?: number;
        });
        /**
         * enableMotor
         */
        enableMotor(): void;
        /**
         * disableMotor
         */
        disableMotor(): void;
        /**
         * setMotorSpeed
         */
        setMotorSpeed(speed: number): void;
        /**
         * setMotorMaxForce
         */
        setMotorMaxForce(maxForce: number): void;
        /**
         * update
         */
        update(): void;
    }

    declare type HingeConstraintOptions = ConstructorParameters<typeof HingeConstraint>[2];

    declare interface HitPointInfo {
        point: Vector3;
        distance: number;
        faceIndex: number;
    }

    declare interface HitTriangleInfo {
        face: {
            a: number;
            b: number;
            c: number;
            materialIndex: number;
            normal: Vector3;
        };
        uv: Vector2;
    }

    declare const HOLLOW_INTERSECTION: CSGOperation;

    declare const HOLLOW_SUBTRACTION: CSGOperation;

    export declare class HolographicMaterial extends ShaderMaterial {
        /**
         * Create a HolographicMaterial.
         *
         * @param {Object} parameters - The parameters to configure the material.
         * @param {number} [parameters.time=0.0] - The time uniform representing animation time.
         * @param {number} [parameters.fresnelOpacity=1.0] - The opacity for the fresnel effect.
         * @param {number} [parameters.fresnelAmount=1.0] - The strength of the fresnel effect.
         * @param {number} [parameters.scanlineSize=15.0] - The size of the scanline effect.
         * @param {number} [parameters.hologramBrightness=1.0] - The brightness of the hologram.
         * @param {number} [parameters.signalSpeed=1.0] - The speed of the signal effect.
         * @param {Color} [parameters.hologramColor=new Color('#00d5ff')] - The color of the hologram.
         * @param {boolean} [parameters.enableBlinking=true] - Enable/disable blinking effect.
         * @param {boolean} [parameters.blinkFresnelOnly=false] - Enable blinking only on the fresnel effect.
         * @param {number} [parameters.hologramOpacity=1.0] - The opacity of the hologram.
         * @param {number} [parameters.blendMode=NormalBlending] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
         * @param {number} [parameters.side=FrontSide] - The rendering side. Use `THREE.FrontSide`, `THREE.BackSide`, or `THREE.DoubleSide`.
         * @param {Boolean} [parameters.depthTest=true] - Enable or disable depthTest.
         */
        constructor(app: App, parameters?: {
            /** The time uniform representing animation time. default 0 */
            time?: number;
            /** The opacity for the fresnel effect. default 1 */
            fresnelOpacity?: number;
            /** The strength of the fresnel effect. default 1 */
            fresnelAmount?: number;
            /** The size of the scanline effect. default 15 */
            scanlineSize?: number;
            /** The brightness of the hologram. default 1 */
            hologramBrightness?: number;
            /** The speed of the signal effect. default 1 */
            signalSpeed?: number;
            /**  The color of the hologram. default new Color('#00d5ff') */
            hologramColor?: ColorRepresentation;
            /** Enable/disable blinking effect. default true */
            enableBlinking?: boolean;
            /** Enable blinking only on the fresnel effect.. default false */
            blinkFresnelOnly?: boolean;
            /** The opacity of the hologram. default 1 */
            hologramOpacity?: number;
            /** The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`. default NormalBlending */
            blendMode?: Blending;
            /** The rendering side. Use `THREE.FrontSide`, `THREE.BackSide`, or `THREE.DoubleSide`.. default FrontSide */
            side?: Side;
            /** Enable or disable depthTest.. default true */
            depthTest?: boolean;
        });
    }

    declare class HoveredResult {
        x: number;
        y: number;
        target: Displayable;
        topTarget: Displayable;
        constructor(x?: number, y?: number);
    }

    /**
     * A template literal tag that does nothing. Useful for syntax highlighting of HTML code.
     *
     * @example
     * ```js
     * const vertexShader = html`
     *    <div class="my-class">
     *        <p>Some text</p>
     *    </div>
     * `
     * ```
     * @category Template Literals
     */
    export declare const html: (strings: any, ...rest: any[]) => string;

    /**
     * Renders an HTML string to a canvas. This is done by first embedding HTML into a svg and then rendering the svg to a canvas.
     * @param html - HTML string
     * @param style - CSS string
     * @param options - options for rendering the canvas
     * @returns HTML canvas element
     *
     * @category HTML To Image
     */
    export declare function htmlToCanvas(html: string | Node, style: string, options: ImageCanvasOptions): Promise<HTMLCanvasElement>;

    /**
     * Renders an HTML string to a png. This is done by first embedding HTML into a svg and then rendering the svg to a png.
     * @param html
     * @param style
     * @param options
     * @returns png as data url
     *
     * @category HTML To Image
     */
    export declare function htmlToPng(html: string, style: string, options: ImageCanvasOptions): Promise<string>;

    /**
     * Embeds an HTML string into a svg tag and converts to svg string or svg as data url
     * @param html - HTML string
     * @param style - CSS string
     * @param width - width of the svg
     * @param height - height of the svg
     * @param toDataUrl - if true, returns a data url, otherwise returns the svg string
     * @returns svg string or svg as data url
     *
     * @category HTML To Image
     */
    export declare function htmlToSvg(html: string, style: string, { width, height }: {
        width: number;
        height: number;
    }, toDataUrl?: boolean): string;

    export declare const httpHelper: {
        configure: (opts: Partial<Config>) => void;
        event: {
            READY_STATE_CHANGE: string;
            LOAD_START: string;
            PROGRESS: string;
            ABORT: string;
            ERROR: string;
            LOAD: string;
            TIMEOUT: string;
            LOAD_END: string;
        };
        methods: Methods;
        rqeust: (args: Partial<Config>) => Promise<any>;
        get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
        put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        del: (url: string, args?: Partial<Config>) => Promise<any>;
        options: (url: string, args?: Partial<Config>) => Promise<any>;
    };

    export declare class HyperbolicHelicoidGeometry extends ParametricGeometry {
        constructor(slices?: number, stacks?: number);
    }

    export declare interface IAppModuleBase extends IModuleBase {
        onAppBeforeUpdate?: (time: Time) => any;
        onAppUpdate?: (time: Time) => any;
        onAppAfterUpdate?: (time: Time) => any;
        onAppBeforeRender?: (time: Time) => any;
        onAppRender?: (time: Time) => any;
        onAppAfterRender?: (time: Time) => any;
        onAppBeforeAddEntity?: (obj: Entity) => any;
        onAppAddEntity?: (obj: Entity) => any;
        onAppBeforeRemoveObject?: (obj: Object3D) => any;
        onAppRemoveObject?: (obj: Object3D) => any;
        onAppBeforeRemoveEntity?: (ent: Entity) => any;
        onAppRemoveEntity?: (ent: Entity) => any;
    }

    export declare interface ICameraModule {
        /**是否显示视角显示器 */
        viewHelperEnable: boolean;
        /**
         * 设置相机朝向
         * @param position 相机位置
         * @param lookAt 朝向
         * @param options 选项
         */
        setCameraLookAt: (position: Vector3, lookAt: Vector3, options?: boolean | Record<string, any>) => void;
    }

    export declare interface ICommand {
        app: App;
        /** 命令所在的场景 */
        owerScene?: Scene;
        /** 是否自动执行。默认是 */
        autoExecute?: boolean;
        callbacks?: ICommandCallback;
        execute(): void;
        undo(): void;
        redo(): void;
    }

    export declare interface ICommandCallback {
        onExecute(): void;
        onUndo(): void;
        onRedo(): void;
    }

    export declare interface ICommandModule {
        readonly commandHistory: CommandHistory;
        /** 清空命令 */
        clearCommands: () => void;
        /** 执行命令，自动执行 */
        executeCommand: (cmd: ICommand) => void;
        /** 执行所有命令，自动执行 */
        executeAllCommands: (cmds: ICommand[]) => void;
        /** 执行多个命令，自动执行 */
        executeManyCommands: (...cmds: ICommand[]) => void;
        /** 增加命令，不会自动执行 */
        addCommand: (cmd: ICommand) => void;
        /** 增加所有命令，不会自动执行 */
        addAllCommands: (cmds: ICommand[]) => void;
        /** 增加多个命令，不会自动执行 */
        addManyCommands: (...cmds: ICommand[]) => void;
        /** 撤销 */
        undo: () => any;
        /** 还原 */
        redo: () => any;
    }

    /**
     * 组合新地图参数
     */
    export declare interface IComposeNewMap {
        /** 地图ID. */
        mapid: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 地图裁剪范围，范围如[x1,y1,x2,y2]， 为空的话，表示不裁剪 */
        clipbounds?: [number, number, number, number];
        /** 选择是包含还是相交（默认false表示包含，true相交） */
        selByCrossing?: boolean;
        /** 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正*/
        fourParameter?: [number, number, number, number];
        /** 是否用上面的四参数进行反算，默认false*/
        isInverseFourParamter?: boolean;
        /** 要显示的图层名称，为空的时候，表示全部图层 */
        layers?: string[];
        /** 生新成图的图层名称前缀，如果设置为null将不会有默认的图层前缀。如果没有前缀，不同的图有图层重名时，如果设置了随层属性有可能会导致绘制的不一样 */
        layerPrefix?: string;
        /** 生新成图的图层名称后缀 */
        layerSuffix?: string;
        /** 保存的文件名称，为空的时候，自根据参数自动生成 */
        savefilename?: string;
        /** 生成后清理图形数据以减少dwg文件大小 */
        purge?: boolean;
        /** 导出的CAD版本号。如果为*表示为当前CAD图的版本 */
        cadVersion?: string | "*" | "cad2000" | "cad2004" | "cad2007" | "cad2010" | "cad2013" | "cad2018";
    }

    /**
     * 条件查询实体参数
     */
    export declare interface IConditionQueryFeatures extends IQueryBaseFeatures {
        /** 条件. */
        condition: string;
        /** 范围. */
        bounds?: [number, number, number, number];
        /** 记录开始位置. */
        beginpos?: number;
        /** 是否返回几何数据,为了性能问题，realgeom为false时，如果返回条数大于1.只会返回每个实体的外包矩形，如果条数为1的话，会返回此实体的真实geojson；realgeom为true时每条都会返回实体的geojson */
        includegeom?: boolean;
        /** 是否返回真实实体几何geojson.与 includegeom参数，结合使用。参考includegeom的用法*/
        realgeom?: boolean;
        /** 是否为包含关系, true为包含关系,false为相交关系，默认false. (传入了bounds进行范围查询时有效)*/
        isContains?: boolean;
    }

    export declare type IControl = {
        onAdd(app: App): HTMLElement;
        onRemove(app: App): void;
        getDefaultPosition?: () => ControlPosition | string;
    };

    export declare interface ICoordSystemModule {
        /**
         * 屏幕坐标转世界坐标
         * @param x
         * @param y
         * @param opts (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面)  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
         */
        unproject: (x: number | Vector2, y?: number, opts?: UnProjectOpts) => Vector3 | undefined;
        /**
         * 屏幕坐标转世界坐标（同 unproject 函数，不同的地方是他支持通过后期处理的深度进行转换，是异步执行的）
         * @param x  屏幕坐标x
         * @param y 屏幕坐标y
         * @param opts (false 不用场景数据, true用场景数据) "depth" 后期处理的深度进行转换，  深度值 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面(默认xz平面) 或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组 或同时指定包含或过滤的实体
         * @param retIntersectObject 如果需要返回与哪个实体相交而转化的世界坐标，可传入一个object对象
         */
        unprojectAsync: (x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}) => Promise<Vector3 | undefined>;
        /**
         * 世界坐标转屏幕坐标
         */
        project: (x: number | Vector3, y?: number, z?: number) => Vector2;
        /**
         * 屏幕坐标转NDC坐标
         */
        screenToNdc: (x: number | Vector2, y?: number) => Vector2;
        /**
         * NDC坐标转屏幕坐标
         */
        ndcToScreen: (x: number | Vector2, y?: number) => Vector2;
        /**
         * 设置的中心点坐标
         */
        centerOrigin: Vector3 | undefined;
        /**
         * 开始缩放比例，x,y,z方向都同比例缩放，默认1
         */
        scaleOrigin: number | undefined;
    }

    /**
     * 获取创建实体的几何数据
     */
    export declare interface ICreateEntitiesGeomData {
        /** 文件文档. */
        filedoc: string;
        /** 图形范围.如果不填的话，则使用全图范围 */
        mapBounds?: [number, number, number, number];
        /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
        renderAccuracy?: number;
        /** 返回的数据中排除属性数据( 默认true) */
        excludeAttribute?: boolean;
        /** 返回的数据是否启用zip压缩( 默认true) */
        useZip?: boolean;
    }

    export declare interface iCSMInternals<T extends MaterialConstructor> {
        patchMap: iCSMPatchMap;
        fragmentShader: string;
        vertexShader: string;
        cacheKey: (() => string) | undefined;
        baseMaterial: T | InstanceType<T>;
        instanceID: string;
        type: string;
        isAlreadyExtended: boolean;
        cacheHash: string;
        silent?: boolean;
    }

    export declare type iCSMParams<T extends MaterialConstructor> = {
        baseMaterial: T | InstanceType<T>;
        vertexShader?: string;
        fragmentShader?: string;
        cacheKey?: () => string;
        patchMap?: iCSMPatchMap;
        silent?: boolean;
        uniforms?: {
            [key: string]: IUniform<any>;
        };
    } & (MaterialParams<T> extends undefined ? any : MaterialParams<T>);

    export declare interface iCSMPatchMap {
        [keyword: string]: {
            [toReplace: string]: string;
        };
    }

    export declare interface iCSMShader {
        defines: string;
        header: string;
        main: string;
    }

    export declare type iCSMUpdateParams<T extends MaterialConstructor> = Partial<Omit<iCSMParams<T>, 'baseMaterial'>>;

    export declare interface ICSS2DRendererModule {
        /**渲染器 */
        readonly css2dRenderer: CSS2DRenderer;
        /**获取所有的marker2d */
        getMarker2Ds: () => Marker2D[];
        /**获取所有的popup2d */
        getPopup2Ds: () => Popup2D[];
        /** 全局的popup对象 */
        readonly popup2d: Popup2D;
    }

    export declare interface ICSS3DRendererModule {
        /**css3d渲染器 */
        readonly css3dRenderer: CSS3DRenderer;
        /**能遮挡的css3d渲染器 */
        readonly css3dOccludeRenderer: CSS3DRenderer;
        /** 设置3d物体能否被场景遮挡 */
        setCss3dObjectCanOcclude: (object: CSS3DObject, canOcclude?: boolean) => void;
    }

    /**
     * Id
     *
     * https://tools.ietf.org/html/rfc7946#section-3.2
     * If a Feature has a commonly used identifier, that identifier SHOULD be included as a member of
     * the Feature object with the name 'id', and the value of this member is either a JSON string or number.
     */
    declare type Id = string | number;

    /**
     * 清空地图缓存接口
     */
    export declare interface IDeleteCache {
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本, 如清空所有版本缓存，输入"*"号). */
        version?: string;
        /** 匹配的键值. */
        key?: string;
    }

    /**
     * 删除地图样式接口
     */
    export declare interface IDeleteStyle {
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本, 如删除所有版本，输入"*"号). */
        version?: string;
        /** 样式名称.如删除所有样式，输入"*"号； 删除所有系统产生的样式，输入 "a*"；内存打开的样式,输入"m*";几何打开的样式输入 "s*"*/
        styleid: string;
        /** 是否只清空数据, false 删除表和数据; true 只删除数据. */
        onlycleardata: boolean;
    }

    /**
     * 设置矩阵为单位矩阵
     */
    declare function identity(out: MatrixArray): MatrixArray;

    /**
     * Disposable interface for objects that can be disposed. Has a single method `dispose`
     */
    export declare interface IDisposable {
        dispose(): void;
    }

    declare class Idle extends StateNode {
        static id: string;
    }

    declare class Idle_2 extends StateNode {
        static id: string;
        onPointerDown: (info: TLEventHandler) => void;
        onEnter: () => void;
    }

    declare class Idle_3 extends StateNode {
        static id: string;
        info: TransformEnterOptions;
        onPointerDownUp: (info: TLEventHandler) => void;
        onEnter: (info: TransformEnterOptions) => void;
        onKeyUp: (info: TLEventHandler) => void;
    }

    declare class Idle_4 extends StateNode {
        static id: string;
        info: PickEnterOptions;
        onPointerDownUp: (info: TLEventHandler) => void;
        onEnter: (info: PickEnterOptions) => void;
        onKeyUp: (info: TLEventHandler) => void;
    }

    export declare interface IDrawEditEnterOptions {
        /** 允许编辑的实体，默认绘制了的所有实体 */
        queryEntities?: Entity[];
        /** 进入时的编辑实体 */
        editEntity?: Entity;
        /** 编辑实体的索引 */
        editIndex?: number;
        /** 点击编辑时不显示顶点，默认false */
        editShowVertex?: boolean;
        /** 平移时使用TransformControl控件，默认(false,需要按shift点击才显示) */
        useTransformControl?: boolean;
        /** 顶点平移时使用TransformControl控件，默认(false,需要按shift点击才显示) */
        useVertTransformControl?: boolean;
        /** 双击退出编辑，默认是 */
        dblClickExitEdit?: boolean;
        /** 要编辑的绘图图层名称 默认为 draw */
        drawLayerName?: string;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 开始选择一个实体 返回true将不允许选中编辑*/
        onBeforeSelectEntity?: (info: InteractiveObject) => boolean;
        /** 开始编辑一个实体 */
        onBeginEditEntity?: (entity: Entity, entIndex?: number, faceIndex?: number) => void;
        /** 取消编辑一个实体 */
        onUnEditEntity?: (entity: Entity, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
        /** 准备删除一个实体，如果返回为true将不会删除 */
        onBeforeDeleteEntity?: (entity: Entity, data: any) => boolean;
        /** 删除一个实体 */
        onDeleteEntity?: (entity: Entity, data: any, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
        /** 准备移动一个实体，如果返回为true将不会移动 */
        onBeforeMoveEntity?: (entity: Entity, data: any, offset: {
            dx: number;
            dy: number;
            dz: number;
        }) => boolean;
        /** 移动一个实体 */
        onMoveEntity?: (entity: Entity, data: any, offset: {
            dx: number;
            dy: number;
            dz: number;
        }, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
        /** 准备移动一个顶点，如果返回为true将不会移动 */
        onBeforeMoveVertex?: (entity: Entity, data: any, newPoint: Vector3, entIndex: number, ptIndex: number) => boolean;
        /** 移动一个顶点 */
        onMoveVertex?: (entity: Entity, data: any, newPoint: Vector3, entIndex: number, ptIndex: number, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
        /** 完成回调 */
        onComplete?: (info: TLEventType, from: string) => void;
        /** 键盘事件 */
        onKeyUp?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
        /** 右键上下文菜单回调 */
        onContextMenu?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
        }) => void;
    }

    export declare interface IDrawLineEnterOptions {
        /** 颜色 */
        color?: ColorRepresentation;
        /** 透明度(0-1) */
        opacity?: number;
        /**  是否显示顶点 */
        showVertex?: boolean;
        /** 是否是虚线 */
        dashed?: boolean;
        /** 线宽 */
        lineWidth?: number;
        /** 虚线偏移量 */
        dashOffset?: number;
        /** 虚线缩放量 */
        dashScale?: number;
        /** 虚线尺寸 */
        dashSize?: number;
        /** 间隙尺寸 */
        gapSize?: number;
        /** 是否加入应用中，默认false */
        isAddToApp?: boolean;
        /** 是否捕捉,默认是 */
        isSnap?: boolean;
        /** 是否捕捉绘制的点,默认是 */
        snapDrawPoint?: boolean;
        /** 自定义要加的捕捉的数据 */
        snapData?: [number, number, number][];
        /** 当达到这么多点的个数时自动完成退出 */
        pointMaxCount?: number;
        /** 是否自动闭合 */
        isClosed?: boolean;
        /** 同unproject的第三个参数 (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组  或同时指定包含或过滤的实体 depth 使用深度*/
        unprojectOpts?: UnProjectOpts | "depth";
        /** 右键时是否弹出默认的屏幕空间至世界坐标的投影右键菜单设置 默认 true*/
        disableUnProjectMenu?: boolean;
        /** 要绘制的绘图图层名称 默认为 draw */
        drawLayerName?: string;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 按回车键完成 默认是 */
        enterKeyComplete?: boolean;
        /** 按esc键取消 默认是 */
        escKeyCancel?: boolean;
        /** 退出时直接退出至缺省工具，默认false */
        isExitToDefaultTool?: boolean;
        /** 按delete键删除上一个点 默认是 */
        deleteKeyDelPoint?: boolean;
        /** 键盘事件 */
        onKeyUp?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
            delPoint: () => void;
            /** 当前数据 */
            data: PolylineItemData;
            /** 当前实体 */
            polylines: PolylinesEntity;
        }) => void;
        /** 右键上下文菜单回调 */
        onContextMenu?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
            delPoint: () => void;
            /** 当前数据 */
            data: PolylineItemData;
            /** 当前实体 */
            polylines: PolylinesEntity;
        }) => void;
        /** 坐标更新前回调 */
        beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
        /** 更新坐标回调 */
        updateCoordinate?: (point: Vector3, isMoveing: boolean, data: PolylineItemData, polylines?: PolylinesEntity) => void;
        /** 完成回调 */
        onComplete?: (isCancel: boolean, data: PolylineItemData) => void;
    }

    export declare interface IDrawPointEnterOptions {
        /** 顶点颜色 */
        color?: ColorRepresentation;
        /** 顶点边框颜色 */
        borderColor?: ColorRepresentation;
        /** 点大小 */
        size?: number;
        /** 是否加入应用中，默认false */
        isAddToApp?: boolean;
        /** 是否捕捉,默认是 */
        isSnap?: boolean;
        /** 是否捕捉绘制的点,默认是 */
        snapDrawPoint?: boolean;
        /** 自定义要加的捕捉的数据 */
        snapData?: [number, number, number][];
        /** 同unproject的第三个参数 (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组  或同时指定包含或过滤的实体 depth 使用深度*/
        unprojectOpts?: UnProjectOpts | "depth";
        /** 右键时是否弹出默认的屏幕空间至世界坐标的投影右键菜单设置 默认 true*/
        disableUnProjectMenu?: boolean;
        /** 要绘制的绘图图层名称 默认为 draw */
        drawLayerName?: string;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 按esc键取消 默认是 */
        escKeyCancel?: boolean;
        /** 退出时直接退出至缺省工具，默认false */
        isExitToDefaultTool?: boolean;
        /** 键盘事件 */
        onKeyUp?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
            /** 当前数据 */
            data: SymbolItemData;
            /** 当前实体 */
            symbol: SymbolEntity;
        }) => void;
        /** 右键上下文菜单回调 */
        onContextMenu?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
            /** 当前数据 */
            data: SymbolItemData;
            /** 当前实体 */
            symbol: SymbolEntity;
        }) => void;
        /** 坐标更新前回调 */
        beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
        /** 更新坐标回调 */
        updateCoordinate?: (point: Vector3, isMoveing: boolean, data: SymbolItemData, symbol?: SymbolEntity) => void;
        /** 完成回调 */
        onComplete?: (isCancel: boolean, data: SymbolItemData) => void; /** 增加完数据回调 返回false的话，将不加入地图中*/
        /** 增加数据回调，如果返回false,将不会加入地图中 */
        onAddData?: (data: SymbolItemData) => boolean;
    }

    export declare interface IDrawPolygonEnterOptions {
        /** 颜色 */
        color?: ColorRepresentation;
        /** 透明度(0-1) */
        opacity?: number;
        /** 颜色 */
        borderColor?: ColorRepresentation;
        /**  是否显示顶点 */
        showVertex?: boolean;
        /** 是否是虚线 */
        dashed?: boolean;
        /** 是否加入应用中，默认false */
        isAddToApp?: boolean;
        /** 是否捕捉,默认是 */
        isSnap?: boolean;
        /** 是否捕捉绘制的点,默认是 */
        snapDrawPoint?: boolean;
        /** 自定义要加的捕捉的数据 */
        snapData?: [number, number, number][];
        /** 当达到这么多点的个数时自动完成退出 */
        pointMaxCount?: number;
        /** 绘制时显示边框线，默认是 */
        showEdge?: boolean;
        /** 绘制边框线时样式 */
        edgeStyle?: PolylineItemData;
        /** 同unproject的第三个参数 (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组  或同时指定包含或过滤的实体 depth 使用深度*/
        unprojectOpts?: UnProjectOpts | "depth";
        /** 右键时是否弹出默认的屏幕空间至世界坐标的投影右键菜单设置 默认 true*/
        disableUnProjectMenu?: boolean;
        /** 要绘制的绘图图层名称 默认为 draw */
        drawLayerName?: string;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 按回车键完成 默认是 */
        enterKeyComplete?: boolean;
        /** 按esc键取消 默认是 */
        escKeyCancel?: boolean;
        /** 退出时直接退出至缺省工具，默认false */
        isExitToDefaultTool?: boolean;
        /** 按delete键删除上一个点 默认是 */
        deleteKeyDelPoint?: boolean;
        /** 键盘事件 */
        onKeyUp?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => void;
            delPoint: () => void;
            /** 当前数据 */
            data: PolygonItemData;
            /** 当前实体 */
            polygon: PolygonsEntity;
        }) => void;
        /** 右键上下文菜单回调 */
        onContextMenu?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: () => void;
            /** 如需要取消时调用 */
            cancel: () => void;
            addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => void;
            delPoint: () => void;
            /** 当前数据 */
            data: PolygonItemData;
            /** 当前实体 */
            polygon: PolygonsEntity;
        }) => void;
        /** 坐标更新前回调 */
        beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
        /** 更新坐标回调 */
        updateCoordinate?: (point: Vector3, isMoveing: boolean, data: PolygonItemData, polygon?: PolygonsEntity) => void;
        /** 完成回调 */
        onComplete?: (isCancel: boolean, data: PolygonItemData) => void;
    }

    export declare interface IEntityManagerModule {
        getEntities: () => Entity[];
        getRayQueryEntities: () => Entity[];
        addSelectedEntity: (ent: Entity) => {};
        removeSelectEntity: (ent: Entity) => {};
        getSelectObjects: () => Object3D[];
        getSelectObjectsRef: () => ShallowReactive<Object3D[]>;
        addBloomEntity: (ent: Entity) => {};
        removeBloomEntity: (ent: Entity) => {};
        getBloomObjects: () => Object3D[];
        getBloomObjectsRef: () => ShallowReactive<Object3D[]>;
        addOutlineEntity: (ent: Entity) => {};
        removeOutlineEntity: (ent: Entity) => {};
        getOutlineObjects: () => Object3D[];
        getOutlineObjectsRef: () => ShallowReactive<Object3D[]>;
        setSelectBoomRefreshFlag: () => void;
    }

    export declare interface IEntityModuleBase extends IAppModuleBase {
        onBeforeAdd?: () => any;
        onAdd?: () => any;
        onBeforeRemove?: () => any;
        onRemove?: () => any;
        onRayIntersect?: (ray: Raycaster) => Intersection[];
        onMouseUp?: (event: InteractiveEvent) => any;
        onMouseMove?: (event: InteractiveEvent) => any;
        onMouseDown?: (event: InteractiveEvent) => any;
        onMouseClick?: (event: InteractiveEvent) => any;
        onMouseDblClick?: (event: InteractiveEvent) => any;
        onMouseOver?: (event: InteractiveEvent) => any;
        onMouseOut?: (event: InteractiveEvent) => any;
        onMouseEnter?: (event: InteractiveEvent) => any;
        onMouseLeave?: (event: InteractiveEvent) => any;
        onPointerDown?: (event: InteractiveEvent) => any;
        onPointerMove?: (event: InteractiveEvent) => any;
        onPointerUp?: (event: InteractiveEvent) => any;
        /** 鼠标直接按下松开，没有拖动 */
        onPointerDownUp?: (event: InteractiveEvent) => any;
        onPointerCancel?: (event: InteractiveEvent) => any;
        onMouseWheel?: (event: InteractiveEvent) => any;
        onKeyDown?: (event: InteractiveEvent) => any;
        onKeyUp?: (event: InteractiveEvent) => any;
        setupUiConfig?: () => UiObjectConfig;
    }

    export declare interface IEntityQueryModule {
        /**
         * 通过相机查询实体
         */
        queryEntitiesByCamera: (option?: EntityQueryOption) => InteractiveObject;
        /**
         * 通过射线查询实体
         */
        queryEntitiesByRaycast: (ray: Ray, option?: EntityQueryOption) => InteractiveObject;
        /**
         * 通过屏幕像素坐标查询实体
         */
        queryEntitiesByScreenPos: (x: number, y: number, option?: EntityQueryOption) => InteractiveObject;
        /**
         * 通过框选查询实体
         */
        queryEntitiesByBox: (startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number) => InteractiveObject[];
        /**
         * 通过屏幕坐标获取射线
         */
        getRayByScreenPos: (x: number, y: number, camera?: Camera) => Ray;
        /**
         * 获取查询的射线对象
         */
        getQueryRaycaster: () => Raycaster;
    }

    /**
     * A simple event interface with typed event types.
     */
    export declare interface IEvent<T> {
        type: T;
        target?: any;
        [attachment: string]: any;
    }

    /**
     * A simple event dispatcher interface with {@link IEvent} as event type.
     */
    export declare interface IEventDispatcher<T> {
        /**
         * Adds a listener to an event type.
         * @param type The type of event to listen to.
         * @param listener The function that gets called when the event is fired.
         */
        addEventListener(type: T, listener: (event: IEvent<T>) => void): void;
        /**
         * Checks if listener is added to an event type.
         * @param type The type of event to listen to.
         * @param listener The function that gets called when the event is fired.
         */
        hasEventListener(type: T, listener: (event: IEvent<T>) => void): boolean;
        /**
         * Removes a listener from an event type.
         * @param type The type of the listener that gets removed.
         * @param listener The listener function that gets removed.
         */
        removeEventListener(type: T, listener: (event: IEvent<T>) => void): void;
        /**
         * Fire an event type.
         * @param event.type The type of event that gets fired.
         */
        dispatchEvent(event: IEvent<T>): void;
    }

    /**
     * 导出布局空间为dwg图
     */
    export declare interface IExportLayout {
        /** 地图ID. */
        mapid: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 布局索引，layoutIndex和layoutName只要输入一个就行，layoutIndex优先。如果都为空，则使用dwg当前的布局空间. */
        layoutIndex?: string;
        /** 布局名称. layoutIndex和layoutName只要输入一个就行，layoutIndex优先。如果都为空，则使用dwg当前的布局空间. */
        layoutName?: string;
    }

    /**
     * 表达式查询实体参数
     */
    export declare interface IExprQueryFeatures extends IQueryBaseFeatures {
        /** 表达式. */
        expr: string;
        /** 记录开始位置. */
        beginpos?: number;
    }

    declare type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;

    export declare class IgnoreFailureBehavior extends AbstractDecoratorBehavior {
        IgnoreFailureBehavior(): void;
        /**
         *
         * @param {Behavior} source
         * @return {IgnoreFailureBehavior}
         */
        static from(source: Behavior): IgnoreFailureBehavior;
        tick(timeDelta: number): BehaviorStatus.Initial | BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Suspended | BehaviorStatus.Invalid;
    }

    export declare interface IHasDataEntity extends Entity {
        setData(data: any): void;
        getData(): any;
    }

    export declare interface IHasUpdate {
        update(): void;
    }

    export declare interface IInputModule {
        addPointerEventsObject: (entity: Entity) => {};
        removePointerEventsObject: (entity: Entity) => {};
        /**
         * 设置地图右键上下文菜单，运行时将触发 上下文菜单将要打开`contextMenuPreOpen`, 上下文菜单已打开`contextMenuOpened`, 上下文菜单打开无内容`contextMenuNoContent`事件
         * @param menu 获取菜单的函数
         * @param key 多次调用setMenu时，同样的key会覆盖之前的事件函数；有多个key时，调用次序为key的字母次序倒序；多次调用时，直到函数返回一个非null的ContextMenu为止
         */
        setMenu: (menu?: (event: InteractiveEvent | any, object?: InteractiveObject) => ContextMenu | null, key?: string) => void;
        Input: {
            /** 获取键是否开始按下 exam: getKeyDown("KeyW") */
            getKeyDown: (keyCode: string) => boolean;
            /** 获取键是否按住 如 Space Enter ShiftLeft */
            getKeyPressed: (keyCode: string) => boolean;
            /** 获取键是否松开 */
            getKeyUp: (keyCode: string) => boolean;
            x: () => number;
            y: () => number;
            movementX: () => number;
            movementY: () => number;
            isMoving: () => boolean;
            isDragging: () => boolean;
            isLeftButtonDown: () => boolean;
            isLeftButtonPressed: () => boolean;
            isLeftButtonUp: () => boolean;
            isRightButtonDown: () => boolean;
            isRightButtonPressed: () => boolean;
            isRightButtonUp: () => boolean;
            isMidButtonDown: () => boolean;
            isMidButtonPressed: () => boolean;
            isMidButtonUp: () => boolean;
            enabled: () => boolean;
            setEnable: (b: boolean) => {};
            /** 是否可用的响应式对象 */
            enabledRef: () => Ref<boolean>;
            /** 当前离鼠标最近的物体实体 */
            closestObject: () => InteractiveObject | undefined | null;
        };
    }

    /**
     * Interface for objects that can be serialized to JSON, with to and from JSON methods
     */
    export declare interface IJSONSerializable<T = any, TM = any> {
        toJSON(meta?: TM): T;
        fromJSON(data: T, meta?: TM): this | null | Promise<this | null>;
    }

    /**
     * 加载模型文件选项
     */
    export declare interface ILoadModelOption {
        /** 文件类型，默认通过文件后缀自动判断 */
        fileType?: string;
        /** 是否使用缓存(默认否)，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象 */
        useCache?: boolean;
        /** 指定模型新的位置 */
        position?: [number, number, number] | Vector3;
        /** 位置对齐 */
        anchor?: Anchor3d;
        /** 当需要对齐时，模型的中心点位置 ，不设置将根据范围中心点计算*/
        modelCenter?: Vector3;
        /** 位置偏移 */
        offset?: [number, number, number] | Vector3;
        /** 指定模型大小值 */
        size?: number;
        /** 缩放，如有size时，以size计算出的缩放为主 */
        scale?: [number, number, number] | Vector3 | number;
        /** 旋转 */
        rotation?: [number, number, number] | Vector3;
        /** 是否按组拆分成一个个子字体 */
        splitSubEntity?: boolean;
        /** 如果满足条件时(根节点为group，下面只有一个子节点并且是mesh对象)是否自动转为mesh实体 （默认false) splitSubEntity为false时有效 */
        autoAsMeshEntity?: boolean;
        /** 加载完回调 */
        onLoad?: (data: any) => any;
        /** 自动转成实体对象，默认是 */
        toEntity?: boolean;
        /** 地图模式下自动绕x轴旋转90度 （因为地图模式下是xy平面，而模型一般是xz平面绘制) */
        isMapMode?: boolean;
        /** toEntity 为true时，做为一个group对象加入模型 */
        asEntityGroup?: boolean;
    }

    /**
     * Convert an image {@link ImageBitmap} or {@link CanvasImageSource} to a base64 data url.
     * @param bitmap - image to convert
     * @param maxWidth - maximum width of the image (default: 8192). Images larger than this will be scaled down. This is because strings can get too long.
     * @param detachBitmap - detach the bitmap after conversion (default: false). This will free up bitmap memory if you don't need it anymore.
     *
     * See also {@link imageUrlToImageData}
     *
     * @category Images
     */
    export declare function imageBitmapToBase64(bitmap: ImageBitmap | CanvasImageSource, maxWidth?: number, detachBitmap?: boolean): string;

    /**
     * Options for {@link imageToCanvas}.
     */
    export declare interface ImageCanvasOptions {
        width: number;
        height: number;
        backgroundColor?: string;
        scale?: number;
    }

    /**
     * Converts an {@link ImageData} to a canvas. This creates a new canvas element and draws the image data on it.
     * Image Data can be created from image pixels like from gl.readPixels
     * This can be used to convert a WebGL texture/render target to a canvas/data url.
     * Note: if the output is flipped, use {@link canvasFlipY} after this, like `canvasFlipY(imageDataToCanvas(imageData))`
     * @param data - image data to convert
     */
    export declare function imageDataToCanvas(data: ImageData): HTMLCanvasElement;

    declare type ImageLike = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;

    declare interface ImagePatternObject extends PatternObjectBase {
        image: ImageLike | string;
        repeat?: ImagePatternRepeat;
        /**
         * Width and height of image.
         * `imageWidth` and `imageHeight` are only used in svg-ssr renderer.
         * Because we can't get the size of image in svg-ssr renderer.
         * They need to be give explictly.
         */
        imageWidth?: number;
        imageHeight?: number;
    }

    declare type ImagePatternRepeat = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';

    declare interface ImageProps extends DisplayableProps {
        style?: ImageStyleProps;
        onload?: (image: ImageLike) => void;
    }

    declare type ImageState = Pick<ImageProps, DisplayableStatePropNames> & ElementCommonState;

    declare interface ImageStyleProps extends CommonStyleProps {
        image?: string | ImageLike;
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        sx?: number;
        sy?: number;
        sWidth?: number;
        sHeight?: number;
    }

    /**
     * Converts an HTML image to a canvas. This creates a new canvas element and draws the image on it.
     * @param image - image to convert
     * @param backgroundColor - background color of the canvas
     * @param scale - scale of the canvas
     * @param width - width of the canvas
     * @param height - height of the canvas
     * @returns a new canvas element
     *
     * @category Images
     */
    export declare function imageToCanvas(image: HTMLImageElement, { backgroundColor, scale, width, height }: ImageCanvasOptions): HTMLCanvasElement;

    /**
     * Downloads/parse the image from an url/data url and draw to an {@link ImageData} object.
     * @param url - url or data url of the image
     * @returns ImageData object
     *
     * See also {@link imageBitmapToBase64}
     *
     * @category Images
     */
    export declare function imageUrlToImageData(url: string): Promise<ImageData>;

    /**
     * 比较地图不同
     */
    export declare interface IMapDiff {
        /** 地图一ID. */
        mapid1: string;
        /** 地图一版本(为空时采用当前打开的地图版本). */
        version1?: string;
        /** 地图一样式图层. */
        layer1?: string;
        /** 地图二ID. */
        mapid2: string;
        /** 地图二版本(为空时采用当前打开的地图版本). */
        version2?: string;
        /** 地图二样式图层. */
        layer2?: string;
        /** 不比较新增部分. */
        noCompareNew?: boolean;
        /** 不比较删除部分. */
        noCompareDelete?: boolean;
        /** 比较大小. */
        size?: number;
        /** 比较单元大小. */
        cellsize?: number;
        /** 不同的像素最小值. */
        diffMinPixel?: number;
        /** 不同的透明最小值. */
        diffMinAlpha?: number;
        /** 不同的颜色最小值. */
        diffMinColor?: number;
    }

    /**
     * 地图图层
     */
    export declare interface IMapLayer {
        /** 图层名称. */
        name: string;
        /** 颜色. */
        color: string;
        /** 图层索引. */
        index: number;
        /** 是否冻结. */
        isFrozen: boolean;
        /** 是否锁定. */
        isLocked: boolean;
        /** 图层是否关闭. */
        isOff: boolean;
        /** 线宽. */
        lineWeight: number;
        /** 线型. */
        linetype: number;
    }

    /**
     * 地图样式参数参数
     */
    export declare interface IMapStyleParam {
        /** 样式名称. */
        name?: string;
        /** 要开的图层索引列表，格式如[0,1,3]. */
        layeron?: string | number[];
        /** 要关的图层索引列表，格式如[2,4]. layeron与layeroff只要输入一个即可*/
        layeroff?: string | number[];
        /** 地图裁剪范围，范围如[x1,y1,x2,y2].如果只需入了数值的话，表示是缩放倍数 */
        clipbounds?: [number, number, number, number] | number;
        /** 颜色. */
        backcolor?: number;
        /** 线宽，格式如[1，1，1，1，0].表式第1，2，3，4级线宽开，第5级线宽关，大于第5级的，以最后设置的级别状态为主，所以也是关。如为空，则和原图线宽显示状态相同 */
        lineweight?: string | number[];
        /** 表达式. */
        expression?: string;
    }

    /**
     * 目标匹配
     */
    export declare interface IMatchObject {
        /** 地图ID. */
        mapid: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 图层样式名.为空时，将由选择的实体的图层来决定 */
        layer?: string;
        /** 目标匹配的地图范围，默认为全图的数据范围. */
        mapBounds?: string;
        /** 目标匹配的实体objectid数组，用||隔开. */
        objectIds?: string;
        /** 目标匹配的实体范围 */
        objectBounds: string;
        /** 目标匹配的地图打开的图层 */
        layeron?: string;
        /** 匹配时的图像尺寸，默认10000 */
        size?: number;
        /** 方法. 默认 matchPattern */
        method?: "matchTemplate" | "matchPattern";
        /** 允许返回的最大条数. 默认 200 */
        maxCount?: number;
        /** 分数，小于此分类将不显示 (0 -1)，默认 0.6 . */
        score?: number;
        /** 金字塔大小 范围(64-2048).默认256， 方法为matchPattern有效*/
        minReduceArea?: number;
        /** 允许重叠 (默认false). */
        canOverlap?: boolean;
        /** 重叠比例 范围(0-0.8)，默认 0.3. */
        maxOverlap?: number;
        /** 角度范围(-180, 180)有旋转的时候需要。方法为matchPattern有效. 默认180*/
        toleranceAngle?: number;
        /** 是否使用角度区间范围,默认false. 方法为matchPattern有效*/
        useToleranceRange?: boolean;
        /** 角度区间1开始角度. 方法为matchPattern有效*/
        tolerance1?: number;
        /** 角度区间1结束角度. 方法为matchPattern有效*/
        tolerance2?: number;
        /** 角度区间2开始角度. 方法为matchPattern有效*/
        tolerance3?: number;
        /** 角度区间2结束角度. 方法为matchPattern有效*/
        tolerance4?: number;
    }

    export declare const iMaterialUI: {
        base: (material: any) => UiObjectConfig[];
        blending: (material: any) => UiObjectConfig;
        polygonOffset: (material: any) => UiObjectConfig;
        aoLightMap: (material: any) => UiObjectConfig;
        misc: (material: any) => UiObjectConfig[];
        roughMetal: (material: any) => UiObjectConfig;
        bumpNormal: (material: any) => UiObjectConfig;
        emission: (material: any) => UiObjectConfig;
        transmission: (material: any) => UiObjectConfig;
        clearcoat: (material: any) => UiObjectConfig;
        iridescence: (material: any) => UiObjectConfig;
        sheen: (material: any) => UiObjectConfig;
    };

    export declare interface IModuleBase {
        onAwake?: (app?: any) => any;
        onEnable?: () => any;
        onDisable?: () => any;
        onDestroy?: () => any;
        [key: string]: any;
    }

    /**
     * Returns true if the array includes all the elements of the sub array
     * @param arr
     * @param subArr
     */
    export declare function includesAll(arr: any[], subArr: IterableIterator<any>): boolean;

    declare class IncrementalDisplayable extends Displayable {
        notClear: boolean;
        incremental: boolean;
        private _displayables;
        private _temporaryDisplayables;
        private _cursor;
        traverse<T>(cb: (this: T, el: this) => void, context: T): void;
        useStyle(): void;
        getCursor(): number;
        innerAfterBrush(): void;
        clearDisplaybles(): void;
        clearTemporalDisplayables(): void;
        addDisplayable(displayable: Displayable, notPersistent?: boolean): void;
        addDisplayables(displayables: Displayable[], notPersistent?: boolean): void;
        getDisplayables(): Displayable[];
        getTemporalDisplayables(): Displayable[];
        eachPendingDisplayable(cb: (displayable: Displayable) => void): void;
        update(): void;
        getBoundingRect(): BoundingRect;
        contain(x: number, y: number): boolean;
    }

    /**
     * 查询数组中元素的index
     */
    declare function indexOf<T>(array: T[] | readonly T[] | ArrayLike_2<T>, value: T): number;

    declare interface IndividualDelay {
        (index: number, count: number, fromPath: Path, toPath: Path): number;
    }

    export declare function infinityToMaxNumber(value: number): number;

    /**
     * 构造类继承关系
     *
     * @param clazz 源类
     * @param baseClazz 基类
     */
    declare function inherits(clazz: Function, baseClazz: Function): void;

    /**
     * Initializing a render2d instance
     *
     * @param dom Not necessary if using SSR painter like svg-ssr
     */
    declare function init(dom?: HTMLElement | null, opts?: Render2DInitOpt): Render2D;

    declare class InputImpl {
        manager: InteractionManager;
        constructor(manager?: InteractionManager);
        getKeyDown(keyCode: any): boolean;
        getKeyPressed(keyCode: any): boolean;
        getKeyUp(keyCode: any): boolean;
        x(): number;
        y(): number;
        movementX(): number;
        movementY(): number;
        isMoving(): boolean;
        isDragging(): boolean;
        isLeftButtonDown(): boolean;
        isLeftButtonPressed(): boolean;
        isLeftButtonUp(): boolean;
        isRightButtonDown(): boolean;
        isRightButtonPressed(): boolean;
        isRightButtonUp(): boolean;
        isMidButtonDown(): boolean;
        isMidButtonPressed(): boolean;
        isMidButtonUp(): boolean;
        enabled(): boolean;
        setEnable(b: any): any;
        enabledRef(): Ref<boolean>;
        closestObject(): InteractiveObject;
    }

    export declare class InputModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: InputModuleOptions;
        manager: InteractionManager;
        constructor(app?: App, options?: InputModuleOptions);
        setupUiConfig(): UiObjectConfig;
        addPointerEventsObject(entity: Entity): void;
        removePointerEventsObject(entity: Entity): void;
        onAwake(): void;
        get Input(): InputImpl;
        onAppAfterRender(): void;
        onAppAddEntity(ent: Entity): void;
        onAppRemoveEntity(ent: Entity): void;
        /**
         * 设置地图右键上下文菜单，运行时将触发 上下文菜单将要打开`contextMenuPreOpen`, 上下文菜单已打开`contextMenuOpened`, 上下文菜单打开无内容`contextMenuNoContent`事件
         * @param menu 获取菜单的函数
         * @param key 多次调用setMenu时，同样的key会覆盖之前的事件函数；有多个key时，调用次序为key的字母次序倒序；多次调用时，直到函数返回一个非null的ContextMenu为止
         */
        setMenu(menu?: (event: InteractiveEvent, object?: InteractiveObject) => ContextMenu | null | undefined, key?: string): void;
    }

    export declare interface InputModuleOptions {
        bindEventsOnBodyElement?: boolean;
        clickTolerance?: number;
        /** 用于交互的地图对象 */
        interactiveMapObject?: any;
        /** 禁止向地图往下传递事件的class名称 默认包含 mapstopprop*/
        stopPropagationClassList?: string[];
        /** 移动端长按3000ms，发送上下文菜单事件，如设置为0，则取消  */
        longTouchMillSecond?: number;
    }

    /**
     * 实例化mesh实体
     */
    export declare class InstancedMeshEntity extends Entity {
        /**
         * 增加实例化对象，如果id为空，则自动增加，如存在，则修改
         */
        addInstance: (opts: {
            id: string;
            position?: Vector3;
            rotation?: Vector3;
            scale?: number | Vector3;
            color?: Color;
            computeBoundingSphere?: boolean;
        }) => string;
        /**
         * 根据id设置实例化对象属性，如不存在，则新增，如果id为空，则自动增加
         */
        setInstance: (opts: {
            id: string;
            position?: Vector3 | null;
            rotation?: Vector3 | null;
            scale?: number | Vector3 | null;
            color?: Color | null;
            computeBoundingSphere?: boolean;
        }) => string;
        /**
         * 根据一个id删除实例化对象
         */
        removeInstance: (id: string, computeBoundingSphere?: boolean) => void;
        /**
         * 获取实体化mesh列表
         */
        getInstancedMeshList: () => DynamicInstancedMesh[];
        /**
         * 获取实体化的组对象
         */
        getGroup: () => Object3D;
        /**
         * 通过id获取索引
         */
        getIdByIndex: (index: number) => string;
        /**
         * 通过索引获取id
         */
        getIndexById: (id: string) => number;
        /**
         * 设置实例高亮与否
         * @param id id
         * @param highlightColor 高亮颜色，如果为null，则表示取消高亮
         * @returns
         */
        setInstanceHighlight: (id: string, highlightColor?: ColorRepresentation) => void;
        /**
         * 实例是否高亮
         * @param id id
         * @returns
         */
        isInstanceHighlight: (id: string) => boolean;
        /**
         * 清除所有实例高亮
         * @param id id
         */
        clearInstanceHighlight: () => void;
        /**
         * 获取实例属性
         * @param id id
         * @returns
         */
        getInstanceAttr: (id: string, key: string) => void;
        /**
         * 设置实例属性
         * @param id id
         * @returns
         */
        setInstanceAttr: (id: string, key: string, value: any) => void;
        /**
         * 获取实例的外包盒
         * @param id id
         * @returns
         */
        getInstanceBox3: (id: string) => Box3 | null;
        /**
         * 设置实例选择与否
         */
        setInstanceSelected: (id: string, isSelected?: boolean) => void;
        /**
         * 实例是否选中
         * @param id id
         */
        isInstanceSelected: (id: string) => boolean;
        /**
         * 清除所有实例选择
         * @param id id
         * @returns
         */
        clearInstanceSelected: () => void;
        /**
         * 设置实例辉光与否
         */
        setInstanceBloom: (id: string, isSelected?: boolean) => void;
        /**
         * 实例是否辉光
         * @param id id
         */
        isInstanceBloom: (id: string) => boolean;
        /**
         * 清除所有实例辉光
         * @param id id
         * @returns
         */
        clearInstanceBloom: () => void;
        /**
         * 设置实例描边与否
         */
        setInstanceOutline: (id: string, isSelected?: boolean) => void;
        /**
         * 实例是否描边
         * @param id id
         */
        isInstanceOutline: (id: string) => boolean;
        /**
         * 清除所有实例描边
         * @returns
         */
        clearInstanceOutline: () => void;
        constructor(options: InstancedMeshEntityOptions);
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
    }

    export declare type InstancedMeshEntityOptions = EntityOptions & InstancedMeshModuleOption;

    /**
     * 实例化mesh模块
     */
    export declare class InstancedMeshModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        meshList: Mesh[];
        uuidList: string[];
        matrixWorldList: Matrix4[];
        instancedMeshList: DynamicInstancedMesh[];
        instConfig: Record<string, {
            position?: Vector3;
            rotation?: Vector3;
            scale?: number | Vector3;
            color?: Color;
            isSelected?: boolean;
            isBloom?: boolean;
            isHighlight?: boolean;
            isOutline?: boolean;
        }>;
        idIndexMap: BidirectionalMap;
        onInstanceTransformChangedSignal: Signal;
        constructor(entity: Entity, options?: InstancedMeshModuleOption);
        /**
         * 增加实例化对象，如果id为空，则自动增加，如存在，则修改
         * @returns
         */
        addInstance(opts: {
            id: string;
            position?: Vector3;
            rotation?: Vector3;
            scale?: number | Vector3;
            color?: Color;
            computeBoundingSphere?: boolean;
        }): any;
        /**
         * 根据id设置实例化对象属性，如不存在，则新增，如果id为空，则自动增加
         * @returns
         */
        setInstance(opts: {
            id: string;
            position?: Vector3 | null;
            rotation?: Vector3 | null;
            scale?: number | Vector3 | null;
            color?: Color | null;
            computeBoundingSphere?: boolean;
        }): any;
        /**
         * 根据一个id删除实例化对象
         * @returns
         */
        removeInstance(id: string, computeBoundingSphere?: boolean): void;
        /**
         * 获取实体化mesh列表
         * @returns
         */
        getInstancedMeshList(): DynamicInstancedMesh[];
        /**
         * 获取实体化的组对象
         * @returns
         */
        getGroup(): Group_2<Object3DEventMap>;
        /**
         * 通过id获取索引
         * @returns
         */
        getIdByIndex(index: number): string;
        /**
         * 通过索引获取id
         * @returns
         */
        getIndexById(id: string): number;
        /**
         * 设置实例选择与否
         * @param id id
         * @returns
         */
        setInstanceSelected(id: string, isSelected?: boolean): void;
        /**
         * 实例是否选中
         * @param id id
         * @returns
         */
        isInstanceSelected(id: string): any;
        /**
         * 清除所有实例选择
         * @returns
         */
        clearInstanceSelected(): void;
        /**
         * 设置实例辉光与否
         * @param id id
         * @returns
         */
        setInstanceBloom(id: string, isBloom?: boolean): void;
        /**
         * 设置实例描边与否
         * @param id id
         * @returns
         */
        setInstanceOutline(id: string, isOutline?: boolean): void;
        /**
         * 清除所有实例描边
         * @param id id
         * @returns
         */
        clearInstanceOutline(): void;
        /**
         * 实例是否辉光
         * @param id id
         * @returns
         */
        isInstanceBloom(id: string): any;
        /**
         * 实例是否描边
         * @param id id
         * @returns
         */
        isInstanceOutline(id: string): any;
        /**
         * 清除所有实例辉光
         * @returns
         */
        clearInstanceBloom(): void;
        /**
         * 设置实例高亮与否
         * @param id id
         * @param highlightColor 高亮颜色，如果为null，则表示取消高亮
         * @returns
         */
        setInstanceHighlight(id: string, highlightColor?: ColorRepresentation): void;
        /**
         * 实例是否高亮
         * @param id id
         * @returns
         */
        isInstanceHighlight(id: string): any;
        /**
         * 清除所有实例高亮
         * @returns
         */
        clearInstanceHighlight(): void;
        /**
         * 获取实例属性
         * @param id id
         * @returns
         */
        getInstanceAttr(id: string, key: string): any;
        /**
         * 设置实例属性
         * @param id id
         * @returns
         */
        setInstanceAttr(id: string, key: string, value: any): void;
        /**
         * 获取实例的外包盒
         * @param id id
         * @returns
         */
        getInstanceBox3(id: string): Box3;
    }

    export declare interface InstancedMeshModuleOption {
        mesh: Mesh | Group_2;
        maxCapacity?: number;
        instances: {
            id?: string;
            position?: Vector3;
            rotation?: Vector3;
            scale?: number | Vector3;
            color?: Color;
            [key: string]: any;
        }[];
    }

    declare class InteractionManager {
        #private;
        renderer: Renderer;
        camera: Camera;
        domElement: HTMLElement;
        cameraControl: CameraControls;
        app: App;
        interactiveMapObject: any;
        bindEventsOnBodyElement: boolean;
        autoAdd: boolean;
        mouse: Vector2;
        supportsPointerEvents: boolean;
        allInteractiveObjects: InteractiveObject[];
        interactiveObjects: InteractiveObject[];
        closestObject: InteractiveObject | null;
        raycaster: Raycaster;
        treatTouchEventsAsMouseEvents: boolean;
        upKeys: Record<string, boolean>;
        downKeys: Record<string, boolean>;
        pressedKeys: Record<string, boolean>;
        constructor(app: App, renderer: Renderer, camera: Camera, domElement: HTMLElement, interactiveMapObject?: any, cameraControl?: CameraControls, options?: InteractionManagerOptions);
        dispose: () => void;
        add: (object: Entity) => void;
        remove: (object: Entity) => void;
        updateInteractiveObjects(): void;
        _onRemoveScene(scene: any): void;
        update: () => void;
        onDocumentMouseMove: (mouseEvent: MouseEvent) => void;
        onDocumentPointerMove: (pointerEvent: PointerEvent) => void;
        onTouchMove: (touchEvent: TouchEvent) => void;
        onMouseClick: (mouseEvent: MouseEvent) => void;
        onMouseDblClick: (mouseEvent: MouseEvent) => void;
        onMouseDown: (mouseEvent: MouseEvent) => void;
        onContextMenu: (mouseEvent: MouseEvent) => void;
        onPointerDown: (pointerEvent: PointerEvent) => void;
        onPointerCancel: (pointerEvent: PointerEvent) => void;
        onTouchStart: (touchEvent: TouchEvent) => void;
        onMouseUp: (mouseEvent: MouseEvent) => void;
        onMouseWheel: (mouseEvent: MouseEvent) => void;
        onKeyDown: (keyboradEvent: KeyboardEvent) => void;
        onKeyUp: (keyboradEvent: KeyboardEvent) => void;
        onPointerUp: (pointerEvent: PointerEvent) => void;
        onTouchEnd: (touchEvent: TouchEvent) => void;
        dispatch: (object: InteractiveObject, event: InteractiveEvent) => void;
        sendEvent(object: InteractiveObject, event: InteractiveEvent): void;
        mapPositionToPoint: (point: Vector2, x: number, y: number) => void;
        setMouseMovement(evt: any): void;
        resetMouseMovement(): void;
        get x(): number;
        get y(): number;
        get movementX(): number;
        get movementY(): number;
        get isMoving(): boolean;
        get isDragging(): boolean;
        get isLeftButtonDown(): boolean;
        get isLeftButtonPressed(): boolean;
        get isLeftButtonUp(): boolean;
        get isRightButtonDown(): boolean;
        get isRightButtonPressed(): boolean;
        get isRightButtonUp(): boolean;
        get isMidButtonDown(): boolean;
        get isMidButtonPressed(): boolean;
        get isMidButtonUp(): boolean;
        get buttonDown(): any;
        get buttonPressed(): boolean;
        get buttonUp(): any;
        get enabled(): boolean;
        set enabled(value: boolean);
        get enabledRef(): Ref<boolean>;
    }

    declare class InteractionManagerOptions {
        bindEventsOnBodyElement: boolean;
        clickTolerance?: number;
        /** 禁止向地图往下传递事件的class名称 默认包含 mapstopprop*/
        stopPropagationClassList?: string[];
        /** 移动端长按3000ms，发送上下文菜单事件，如设置为0，则取消  */
        longTouchMillSecond?: number;
        constructor(options: {
            bindEventsOnBodyElement?: boolean | undefined;
            clickTolerance?: number;
            stopPropagationClassList?: string[];
        });
    }

    export declare class InteractiveEvent {
        type: string;
        cancelBubble: boolean;
        originalEvent: Event | null | MouseEvent;
        /** 地图原始事件 */
        originMapEvent?: {
            lngLat: {
                lng: number;
                lat: number;
            };
            originalEvent: Event | null;
            point: {
                x: number;
                y: number;
            };
            target: any;
            type: string;
        };
        coords: Vector2;
        distance: number;
        intersected: boolean;
        entity: Entity;
        intersection?: Intersection;
        [key: string]: any;
        constructor(type: string, originalEvent?: Event | null, originMapEvent?: any);
        stopPropagation(): void;
    }

    export declare class InteractiveObject {
        target: Entity;
        intersected?: boolean;
        wasIntersected?: boolean;
        distance?: number;
        intersection?: Intersection;
        constructor(target: Entity);
    }

    declare function interleaveAttributes(attributes: BufferAttribute[]): InterleavedBufferAttribute;

    /**
     * 通过比例(0-1)的值，得到坐标序列的点坐标的值
     * @param points 坐标序列
     * @param ratio 比例
     * @param options 选项
     */
    export declare function interpolatePointsByRatio(points: Array<[number, number, number]>, ratio: number, options?: {
        nextPoint?: [number, number, number];
        remainingPoints?: [number, number, number][];
        curRetIndex?: number;
        distance?: number;
        segmentDist?: number[];
    }): [number, number, number][];

    /** 插值类 */
    export declare class Interpolation {
        options: InterpolationOptions;
        variogram: any;
        constructor(options: InterpolationOptions);
        invDist(x: number, y: number, z: number): number;
        /** 预测值 */
        predict(x: number, y: number, z: number): number;
        /** 预测多个值 */
        predicts(data: {
            x: number;
            y: number;
            z: number;
        }[]): number[];
        variance(x: number, y: number, z: number): number;
        /**
         * search array max value
         * @param source
         */
        max(source: number[]): number;
        /**
         * search array min value
         * @param source
         */
        min(source: number[]): number;
        /**
         * get mean value from array number
         * @param source
         */
        mean(source: number[]): number;
        /**
         * fill array with number
         * @param source
         * @param n
         */
        rep(source: number, n: number): number[];
        matrixDiag(c: number, n: number): number[];
        matrixTranspose(X: any[], n: number, m: number): any[];
        matrixAdd(X: number[], Y: number[], n: number, m: number): number[];
        matrixMultiply(X: number[], Y: number[], n: number, m: number, p: number): number[];
        matrixChol(X: number[], n: number): boolean;
        matrixChol2inv(X: number[], n: number): void;
        matrixSolve(X: number[], n: number): boolean;
        variogramGaussian(h: number, nugget: number, range: number, sill: number, A: number): number;
        variogramExponential(h: number, nugget: number, range: number, sill: number, A: number): number;
        variogramSpherical(h: number, nugget: number, range: number, sill: number): number;
        variogramCircle(h: number, nugget: number, range: number, sill: number): number;
        variogramLinear(h: number, nugget: number, range: number, sill: number): number;
        train(t: number[], x: number[], y: number[], z: number[], model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear", sigma2?: any, alpha?: number): {
            t: number[];
            x: number[];
            y: number[];
            z: number[];
            nugget: number;
            range: number;
            sill: number;
            A: number;
            n: number;
            model: (h: number, nugget: number, range: number, sill: number, A: number) => number;
            K: any[];
            M: any[];
        };
        _predict(x: number, y: number, z: number, variogram: {
            n: number;
            model: (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any) => void;
            x: number[];
            y: number[];
            z: number[];
            nugget: any;
            range: any;
            sill: any;
            A: any;
            M: number[];
        }): number;
        _variance(x: number, y: number, z: number, variogram: {
            n: number;
            model: {
                (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any): void;
                (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any): number;
            };
            x: number[];
            y: number[];
            z: number[];
            nugget: any;
            range: any;
            sill: any;
            A: any;
            K: number[];
        }): any;
    }

    export declare interface InterpolationOptions {
        /** 值数组 */
        t: number[];
        /** x数组 */
        x: number[];
        /** y数组 */
        y: number[];
        /** z数组 */
        z: number[];
        /** 使用反距离权重插值法 */
        useInvDistWeight?: boolean;
        /** 反距离幂指数，用于控制距离和权重之间的关系 缺省值2 */
        power?: number;
        /** 模型 */
        model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
        /** sigma2是σ²，对应高斯过程的方差参数，也就是这组数据z的距离，方差参数σ²的似然性反映了高斯过程中的误差，并应手动设置。一般设置为 0 ，其他数值设了可能会出空白图 */
        sigma2?: number;
        /** Alpha α对应方差函数的先验值，此参数可能控制钻孔扩散范围,越小范围越大,少量点效果明显，但点多了且分布均匀以后改变该数字即基本无效果了，默认设置为100 */
        alpha?: number;
    }

    export declare class Interpreter extends BaseCompiler {
        constructor();
        private executeCompiledGraph;
        run(graph: NodeGraph, context: ExecutionContext): void;
        build(graph: NodeGraph, context: ExecutionContext): string;
    }

    declare const INTERSECTED: ShapecastIntersection;

    declare const INTERSECTION: CSGOperation;

    export declare class IntervalValue implements ValueGenerator {
        a: number;
        b: number;
        constructor(a: number, b: number);
        genValue(): number;
        type: 'value';
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): IntervalValue;
        clone(): ValueGenerator;
    }

    /**
     * 求逆矩阵
     */
    declare function invert(out: MatrixArray, a: MatrixArray): MatrixArray | null;

    /**
     * Inverts result of the source behavior, success becomes failure, failure becomes success
     */
    export declare class InvertStatusBehavior extends AbstractDecoratorBehavior {
        /**
         *
         * @param {Behavior} source
         */
        constructor(source: Behavior);
        /**
         *
         * @param {Behavior} source
         * @return {InvertStatusBehavior}
         */
        static from(source: Behavior): InvertStatusBehavior;
        tick(timeDelta: number): BehaviorStatus;
    }

    /**
     * 地图打开参数
     */
    export declare interface IOpenMapBaseParam {
        /** 地图ID. */
        mapid: string;
        /** 地图打开方式(缺省: GeomRender) . */
        mapopenway?: MapOpenWay;
        /** 文件唯一ID. 地图ID第一次打开时，需传递fileid */
        fileid?: string;
        /** 文件文档. */
        filedoc?: string;
        /** 文件名称. */
        filename?: string;
        /** 上传时的文件名. */
        uploadname?: string;
        /** 秘钥(第一次上传打开图时有效，表示此图需要密码保护). */
        secretKey?: string;
        /** 访问权限的key，权限小于secretKey，不能对图进行删除等操作. */
        accessKey?: string;
        /** 要求输入密码回调. */
        cbInputPassword?: (param: {
            mapid: string;
            isPasswordError: boolean;
            tryPasswordCount: number;
            result: any;
        }) => Promise<string>;
        /** 地图来源参数. */
        mapfrom?: string;
        /** 地图依赖项. */
        mapdependencies?: string;
        /** 地图来源参数(这是子项的设置，与mapfrom不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapfrom一样的话，则为空 */
        subfrom?: string;
        /** 地图依赖项(这是子项的设置，与mapdependencies不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapdependencies一样的话，则为空  */
        subdependencies?: string;
        /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
        renderAccuracy?: number;
        /** 样式. */
        style?: IMapStyleParam;
        /** 不使用缺省的字体文件，将使用缺省的型文件来代替字体文件. */
        notUseDefaultTtfFont?: boolean;
        /** 不使用缺省的型文字文件，将使用缺省的字体来代替型文件. */
        notUseDefaultShxFont?: boolean;
        /** 不自动替换线型. */
        notReplaceLineType?: boolean;
        /** 字符替换规则. openMap返回的字段findFonts为系统查找的字体替换规则。如需修改默认的话，请传入替换的字体规则，如fontReplaceRule: {"tssdeng.shx_1": "_default_.ttc"}*/
        fontReplaceRule?: Record<string, string> | string;
        /** 图像左上角坐标x 第一次打开图像类型时有效*/
        imageLeft?: number;
        /** 图像左上角坐标y 第一次打开图像类型时有效*/
        imageTop?: number;
        /** 图像分辨率 第一次打开图像类型时有效, 一个像素单位代表多少地理长度，计算公式为 真实坐标长度 / 图像像素宽 */
        imageResolution?: number;
        /** 判断是否打开或更新成功重试间隔（秒）。默认 5s 一次 */
        openFinishTryInterval?: number;
        /** 判断是否打开或更新成功重试最大次数。默认 120 次 */
        openFinishMaxTryCount?: number;
        /** 新建地图有fileDoc时有效 */
        cadVersion?: string;
        /** 使用post方式打开 (默认使用get)*/
        httpUsePost?: boolean;
    }

    /**
     * 地图打开参数
     */
    export declare interface IOpenMapParam extends IOpenMapBaseParam {
        /** 版本号(缺省: "" ). */
        version?: string;
        /** 图层名称，组合图层用英文逗号分开 */
        layer?: string;
        /** 布局索引 (从1开始)，默认为0，表示是模型空间 */
        layoutIndex?: number;
    }

    /**
     * 地图打开返回成功参数
     */
    export declare interface IOpenMapResponse {
        /** 地图ID. */
        mapid?: string;
        /** 版本号(缺省: "" ). */
        version?: string;
        /** 图层名称 */
        layer?: string;
        /** 地图打开方式(缺省: GeomRender) . */
        mapopenway?: MapOpenWay;
        /** DbID. */
        dbid?: string;
        /** 文件唯一ID. */
        fileid?: string;
        /** 文件名称. */
        filename?: string;
        /** 地图范围(如果通过clipBounds打开，则是clipBounds的范围). */
        bounds?: GeoBounds;
        /** 地图范围(地图的范围，如果没有通过clipBounds打开,则为空). */
        mapBounds?: GeoBounds;
        /** 数据库地图范围*/
        dbBounds?: GeoBounds;
        /** 图形中有数据的范围（此范围是非精确值，精确的数据范围需调用cmdGetDrawBounds去获取）*/
        drawBounds?: GeoBounds;
        /** 图层样式. */
        styles?: any;
        /** 图层列表. */
        layers?: any;
        /** 地图类型. 为空时表示是cad类型，image表示是图像 */
        maptype?: string;
        /** 状态. */
        status?: string;
        /** 暗黑模式(背景色为黑时). */
        darkMode?: boolean;
        /** 类型. */
        type?: string;
        /** ucs基点坐标. */
        ucsorg?: string;
        /** 上传的文件名. */
        uploadname?: string;
        /** 描述. */
        description?: string;
        /** 默认是否显示线宽. */
        lineWidthDisplay?: boolean;
        /** 所有布局. */
        layouts?: string[];
        /** 地图来源参数. */
        mapfrom?: string;
        /** 地图依赖项. */
        mapdependencies?: string;
        /** 地图来源参数(这是子项的设置，与mapfrom不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapfrom一样的话，则为空 */
        subfrom?: string;
        /** 地图依赖项(这是子项的设置，与mapdependencies不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapdependencies一样的话，则为空  */
        subdependencies?: string;
        /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
        renderAccuracy?: number;
        /** 初始视图缩放倍数，bounds * initViewScale = dbBounds */
        initViewScale?: number;
        /** 初始视图. */
        view?: {
            /** 初始视图中心点. */
            center?: [number, number];
            /** 初始视图级别. */
            zoom?: number;
            /** 初始视图方位角. */
            bearing?: number;
        };
        /** 图像类型时最大级别 */
        maxzoom?: number;
        /** 图像类型时图像像素宽 */
        imageWidth?: number;
        /** 图像类型时图像像素高 */
        imageHeight?: number;
        /** 图像左上角坐标x */
        imageLeft?: number;
        /** 图像左上角坐标y */
        imageTop?: number;
        /** 图像分辨率  一个像素单位代表多少地理长度，计算公式为 真实坐标长度 / 图像像素宽 */
        imageResolution?: number;
    }

    export declare interface IOrbitControlModule {
        /** 相机控制器 */
        readonly cameraControl: CameraControls;
        /** 是否启用相机控制器 */
        enableCameraControl: boolean;
        /** 相机控制器响应式对象 */
        enableCameraControlRef: Ref<boolean>;
        /** 当相机禁止时还允许滚轮进行缩放操作 */
        enableWheelWhenCtrlDisabled: boolean;
    }

    export declare interface IParticle {
        /**
         * Position of the particle.
         * @type {Vector3}
         */
        position: Vector3;
        /**
         * Velocity of the particle.
         * @type {Vector3}
         */
        velocity: Vector3;
        /**
         * Age of the particle.
         * @type {number}
         */
        age: number;
        /**
         * Life duration of the particle.
         * @type {number}
         */
        life: number;
        /**
         * Size of the particle.
         * @type {number}
         */
        size: number;
        /**
         * Rotation of the particle.
         * @type {number | Quaternion}
         */
        rotation?: number | Quaternion;
        /**
         * UV tile index.
         * @type {number}
         */
        uvTile: number;
        /**
         * Color of the particle.
         * @type {Vector4}
         */
        color: Vector4;
        /**
         * Indicates if the particle has died.
         * @type {boolean}
         */
        get died(): boolean;
    }

    export declare interface IParticleRenderModule {
        readonly particleRenderer: BatchedRenderer;
        /**
         *  增加粒子系统
         * @param system   粒子系统参数
         * @param parent  parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中
         * @param disposeWhenEnd 当结束时自动删除，默认为true
         * @returns
         */
        addParticleSystem: (system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean) => void;
        /** 增加粒子 */
        addParticle: (opts: {
            /** 粒子系统参数 */
            system: ParticleSystemParameters;
            /** 粒子模拟行为  */
            simulations?: Simulation | Simulation[];
            /** 名称  */
            name?: string;
            /** 位置  */
            position?: Vector3 | [number, number, number];
            /** 旋转 */
            rotation?: Vector3 | [number, number, number];
            /** 缩放 */
            scale?: Vector3 | [number, number, number] | number;
            /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
            parent?: Object3D;
            /** 当结束时自动删除，默认为true */
            disposeWhenEnd?: boolean;
        }) => ParticleEmitter<Object3DEventMap>;
        /** 从文件加载粒子场景 */
        loadParticle: (url: string, opts?: {
            /** 粒子系统参数 */
            system?: ParticleSystemParameters;
            /** 粒子模拟行为  */
            simulations?: Simulation | Simulation[];
            /** 名称  */
            name?: string;
            /** 位置  */
            position?: Vector3 | [number, number, number];
            /** 旋转 */
            rotation?: Vector3 | [number, number, number];
            /** 缩放 */
            scale?: Vector3 | [number, number, number] | number;
            /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
            parent?: Object3D;
            /** 加载完json的回调 可对json进行修改 */
            onData?: (data: any) => any;
            /** 加载粒子系统前回调 */
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
            /** 当结束时自动删除，默认为true */
            disposeWhenEnd?: boolean;
            crossOrigin?: string;
            withCredentials?: boolean;
            urlPath?: string;
            resourcePath?: string;
            requestHeader?: {
                [header: string]: string;
            };
        }) => Promise<ParticleEmitter<Object3DEventMap>>;
        /** 从JSON字符串加载粒子场景 */
        loadParticleFromJson: (json: string | JSON, opts?: {
            /** 粒子系统参数 */
            system?: ParticleSystemParameters;
            /** 粒子模拟行为  */
            simulations?: Simulation | Simulation[];
            /** 名称 */
            name?: string;
            /** 位置  */
            position?: Vector3 | [number, number, number];
            /** 旋转 */
            rotation?: Vector3 | [number, number, number];
            /** 缩放 */
            scale?: Vector3 | [number, number, number] | number;
            /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
            parent?: Object3D;
            /** 当结束时自动删除，默认为true */
            disposeWhenEnd?: boolean;
            /** 加载粒子系统前回调 */
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
            /** 加载数据完成回调 */
            onData?: (data: any) => any;
        }) => ParticleEmitter<Object3DEventMap>;
        /** 从资源加载粒子场景 */
        loadParticleFromRes(obj: Object3D, opts?: {
            /** 粒子系统参数 */
            system?: ParticleSystemParameters;
            /** 粒子模拟行为  */
            simulations?: Simulation | Simulation[];
            /** 名称  */
            name?: string;
            /** 位置  */
            position?: Vector3 | [number, number, number];
            /** 旋转 */
            rotation?: Vector3 | [number, number, number];
            /** 缩放 */
            scale?: Vector3 | [number, number, number] | number;
            /** parent 为null时，将不加入场景，如不填或undefined，则加入场景，如指定parent，则加至此parent节点中 */
            parent?: Object3D;
            /** 当结束时自动删除，默认为true */
            disposeWhenEnd?: boolean;
            /** 加载粒子系统前回调 */
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        }): ParticleEmitter<Object3DEventMap>;
        removeParticle(obj: ParticleEmitter<Object3DEventMap>): any;
    }

    export declare interface IParticleSystem {
        /**
         * Whether the system is in world space.
         * @type {boolean}
         */
        worldSpace: boolean;
        /**
         * Number of particles.
         * @type {number}
         */
        particleNum: number;
        /**
         * Duration of the system.
         * @type {number}
         */
        duration: number;
        /**
         * Whether the system is looping.
         * @type {boolean}
         */
        looping: boolean;
        /**
         * Array of particles.
         * @type {Array<IParticle>}
         */
        particles: Array<IParticle>;
        /**
         * Emitter for the particles.
         * @type {ParticleEmitter<any>}
         */
        emitter: ParticleEmitter<any>;
        /**
         * Optional renderer.
         * @type {BatchedRenderer}
         */
        _renderer?: BatchedRenderer;
        instancingGeometry: BufferGeometry;
        rendererEmitterSettings: RendererEmitterSettings;
        getRendererSettings(): VFXBatchSettings;
        paused: boolean;
        pause(): void;
        play(): void;
        restart(): void;
        clone(): IParticleSystem;
        toJSON(metaData: any, options: SerializationOptions): any;
        signal: {
            onRestart: Signal;
            onPlay: Signal;
            onPause: Signal;
            onEnd: Signal;
        };
        dispose(): void;
    }

    export declare interface IPhysicsManagerModule {
        /** 是否能用物理引擎 */
        physicsEnable: boolean;
        /** 得到物理引擎世界对象 */
        readonly physicsWorld: World;
        /** 得到物理引擎对象 */
        readonly physicsEngine: typeof CANNON;
        /** 启动物体引擎 */
        enablePhysicsEngine(): Promise<typeof CANNON>;
        /** 增加物理碰撞体 */
        addPhysicsBody(phyObject: MeshPhysicsObjectParams): MeshPhysicsObjectParams;
        /** 通过实体或对象移除物理刚体 */
        removePhysicsObject(object: Object3D | Entity): any;
        /** 增加一个物理地面 */
        addPhysicsGround(): CANNON.Plane;
        /** 设置物理引擎调试 */
        setPhysicsDebugger(enable: boolean): void;
    }

    export declare interface IPickModule {
        /**
         * 当前应该是否处于自由状态
         */
        isFreeStatus: boolean;
        /**
         * 自由状态响应式对象
         */
        isFreeStatusRef: Ref<boolean>;
        /**
         * 拾取一个点
         */
        pickPoint: (opts?: PickPointOptions) => Promise<{
            cancel: boolean;
            point?: Vector3;
            reason?: string;
            intersectObject?: any;
            event?: InteractiveEvent;
        }>;
        /**
         * 拾取实体
         */
        pickEntity: (opts?: PickEntityOptions) => Promise<{
            cancel: boolean;
            entities: Entity[];
            reason?: string;
            clearHighlight: Function;
        }>;
        /**
         * 绘制一个选择框
         */
        drawSelectBox: (style?: Record<string, any>) => Promise<{
            cancel: boolean;
            reason?: string;
        } | [Vector2, Vector2]>;
        /**
         * 绘制一个点，获取点坐标
         */
        actionDrawPoint: (opts?: IDrawPointEnterOptions) => Promise<{
            isCancel?: boolean;
            data: SymbolItemData;
        }>;
        /**
         * 绘制一条线，获取线坐标
         */
        actionDrawLineSting: (opts?: IDrawLineEnterOptions) => Promise<{
            isCancel?: boolean;
            data: PolylineItemData;
        }>;
        /**
         * 绘制一个多边形，获取多边形坐标
         */
        actionDrawPolygon: (opts?: IDrawPolygonEnterOptions) => Promise<{
            isCancel?: boolean;
            data: PolygonItemData;
        }>;
        actionDrawEdit: (opts?: IDrawEditEnterOptions) => Promise<{}>;
        /** 选中一个实体对象 */
        actionPickSelect: (opts?: PickEnterOptions) => Promise<{
            isCancel: boolean;
            info?: TLEventHandler;
            select?: InteractiveObject;
        }>;
        /** 通过图层名称获取当前绘图层的实体 */
        getDrawLayer: (layerName?: string, noCreateStyle?: Record<string, any>) => {
            symbol: () => SymbolEntity | undefined;
            polylines: () => PolylinesEntity | undefined;
            polygons: () => PolygonsEntity | undefined;
            addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
            addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
            addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
            updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
            updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
            updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
            deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
            deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
            deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
        };
    }

    /**
     * 点查询实体参数
     */
    export declare interface IPointQueryFeatures extends IQueryBaseFeatures {
        /** 查询的坐标X. */
        x: number;
        /** 查询的坐标Y. */
        y: number;
        /** 像素大小. */
        pixelsize?: number;
        /** 条件. */
        condition?: string;
        /** 返回最大的几何字节数. */
        maxGeomBytesSize?: number;
        /** 当前一个像素表示多少几何长度，如果输入了此值，则为此值为主，否则，根据输入的zoom值后台自动计算. */
        pixelToGeoLength?: number;
    }

    export declare interface IPostProcessModule {
        /**效果合成器 */
        readonly composer: EffectComposer_2;
        /**效果合成器是否可用 */
        isComposerEnable: () => boolean;
        /** 设置效果合成器是否可用 */
        setComposerEnable: (b: boolean) => void;
        /** 给效果合成器增加渲染通道 */
        addEffectRenderPass(pass: Pass_2, orderIndex?: number): any;
        /** 给效果合成器移除渲染通道 */
        removeEffectRenderPass(pass: Pass_2): any;
        /** 刷新渲染通道 foreceUpdate是否强制更新*/
        refreshEffectRenderPass(foreceUpdate?: boolean): any;
        /** 根据屏幕坐标获取深度值 */
        getDepth: (x: number, y: number) => Promise<number>;
        /** OutlineEffect */
        readonly outlineEffect: OutlineEffect_2;
        /** bloomEffect */
        readonly bloomEffect: BloomEffect_2;
        /** selectedEffect */
        readonly selectedEffect: OutlineEffect_2;
    }

    /**
     * 查询实体参数
     */
    export declare interface IQueryBaseFeatures {
        /** 当前级别. */
        zoom?: number;
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 图层名称（为空时采用当前打开的地图图层名称). */
        layer?: string;
        /** 返回最多的记录条数. */
        limit?: number;
        /** 是返回的字段列表，多个之是用逗号,分开,如. "name,objectid" */
        fields?: string;
        /** 是否为几何图形查询. */
        geom?: boolean;
        /** GeoJSON几何数据简化墨托卡距离，默认为零，不简化。例如允许10级别以上一个像素级别的误差，可用 map.pixelToGeoLength(1, 10) * vjmap.Projection.EQUATORIAL_SEMIPERIMETER * 2 / map.getGeoBounds(1.0).width() */
        simplifyTolerance?: boolean;
        /** 启动cache(内存打开的图形有效). */
        useCache?: boolean;
        /** 查询返回的坐标默认为墨卡托坐标，返回会程序会自动转化为cad坐标，如果要直接返回cad地图坐标，需要把toMapCoordinate设置为true. */
        toMapCoordinate?: boolean;
    }

    export declare interface IRectCollide {
        getBoundingRect: () => {
            /** 像素左上角x */
            x1: number;
            /** 像素左上角y */
            y1: number;
            /** 像素右上角x */
            x2: number;
            /** 像素右上角y */
            y2: number;
            /** 像素旋转中心点x */
            cx: number;
            /** 像素旋转中心点y */
            cy: number;
            /** 旋转角度(0-360) */
            rotation: number;
            /** 坐标位置 */
            position: Vector3;
            /** 排序index(越大越在上面) */
            zIndex?: number;
            /** 同一个id会一起显示和隐藏 */
            id?: string;
            /** 组名 会对同一个组名内的进行碰撞检测 */
            groupName?: string;
            /** 显示隐藏对象回调函数  */
            setVisible: (b: boolean) => any;
        } | null;
    }

    export declare interface IRectCollideModule {
        /** 增加碰撞检测的对象 */
        addCollideRectObject: (item: IRectCollide) => void;
        /** 移除碰撞检测的对象 */
        removeCollideRectObject: (item: IRectCollide) => void;
        /** 更新碰撞检测 */
        updateCollideRect: () => void;
        /** 设置更新碰撞检测为脏数据，使其重新检测 */
        setCollideRectDirty: () => void;
    }

    /**
     * 矩形查询实体参数
     */
    export declare interface IRectQueryFeatures extends IQueryBaseFeatures {
        /** 查询的坐标X1. (如果x1,y1,x2,y2同时不输的话，表示是查询整个图的范围 */
        x1?: number;
        /** 查询的坐标Y1. */
        y1?: number;
        /** 查询的坐标X2. */
        x2?: number;
        /** 查询的坐标Y2. */
        y2?: number;
        /** 条件. */
        condition?: string;
        /** 返回最大的几何字节数. */
        maxGeomBytesSize?: number;
    }

    export declare interface IRequest {
        get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
        put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
        del: (url: string, args?: Partial<Config>) => Promise<any>;
        options: (url: string, args?: Partial<Config>) => Promise<any>;
    }

    export declare function isAltKeyDown(event?: any): boolean;

    declare function isArray(value: any): value is any[];

    /**
     * Consider typed array.
     * @param data
     */
    declare function isArrayLike(data: any): data is ArrayLike_2<any>;

    declare function isBuiltInObject(value: any): boolean;

    export declare interface ISceneModule {
        /** 增加场景 */
        addScene: (scene?: Scene, camera?: CameraOptions) => Scene;
        /** 切换场景 */
        activeScene: (_scene: Scene) => Promise<void>;
        /** 设置场景，（将删除之前场景，增加此场景此把此场景设置为当前场景） */
        setScene: (scene?: Scene, camera?: CameraOptions) => Promise<Scene>;
        /** 移除场景 */
        removeScene: (_scene: Scene) => Promise<void>;
        /** 初始化场景 */
        initScene(scene: Scene): any;
        /** 清空所有场景 */
        clearScenes(): any;
        /** 场景实体 */
        readonly sceneEntity: Entity;
        /** 增加缺省灯光 */
        addDefaultLights: (scene?: Scene) => {};
        /** 获取场景的统计数据 */
        getSceneStatData: () => {
            /** 物体对象数 */
            objects: number;
            /** 顶点数 */
            vertices: number;
            /** 三角形数 */
            triangles: number;
        };
        /** 环境变量 */
        readonly envConfig: EnvConfigOption & {
            [key: string]: any;
        };
        /** 设置环境变量 */
        setEnvConfig: (key: keyof EnvConfigOption, value: any) => void;
        /** 设置场景背景及环境参数 */
        setBackgroundEnvironment: (options?: BackgroundEnvironmentOptions) => Promise<void>;
        /** 获取焦点 */
        setFocus: () => void;
        /** 加载资源数组 */
        loadResources: (_resources: ResourceItem[], options?: loadResourcesOptions) => Promise<RosourceItemsReturnType>;
        /** 获取通过loadResources已加载的资源 */
        getLoadedResources: () => RosourceItemsReturnType;
    }

    declare function isCombineMorphing(path: Element_2): path is CombineMorphingPath;

    export declare function isCtrlKeyDown(event?: any): boolean;

    export declare function isDeleteKey(event?: any): boolean;

    declare function isDom(value: any): value is HTMLElement;

    export declare function isEnterKey(event?: any): boolean;

    export declare function isEscKey(event?: any): boolean;

    declare function isFunction(value: any): value is Function;

    /**
     * A {@link GeoPointLike} object, an array of two numbers representing longitude and latitude,
     * or an object with `lng` and `lat` or `lon` and `lat` properties.
     *
     * Example:
     * ```typescript
     * const center = { lat: 53.3, lng: 13.4 };
     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
     * ```
     */
    export declare function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike;

    declare function isGradientObject(value: any): value is GradientObject;

    declare function isImagePatternObject(value: any): value is ImagePatternObject;

    export declare function isLeftButton(event?: any): boolean;

    /**
     * 获取图片切片缓存级别
     */
    export declare interface ISliceCacheZoom {
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 图层名称（为空时采用当前打开的地图图层名称) */
        layer?: string;
        /** 是否是矢量切片，如果否则为栅格瓦片切片 */
        ismvt: boolean;
    }

    /**
     * 对图层进行切片
     */
    export declare interface ISliceLayer {
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 图层名称（为空时采用当前打开的地图图层名称).如果为数组时，表示对多个图层进行切片 */
        layer: string | string[];
        /** 级别（切的第几级）, 如果为数组时，layer也必须是数组，一一对应 */
        zoom: number | number[];
        /** 是否是矢量切片，如果否则为栅格瓦片切片. 如果为数组时，layer也必须是数组，一一对应 */
        ismvt: boolean | boolean[];
        /** 是否取消对此图层的切片（正在切时有效）. */
        iscancel?: boolean;
        /** 是否取消所有的切片（正在切时有效）. */
        isAllCancel?: boolean;
        /** 批处理的条数（默认10000）. */
        batchNum?: number;
        /** 空闲一次批处理等待时间（默认1ms）. */
        idleBatchSleepMs?: number;
        /** 繁忙时一次批处理等待时间（默认10000ms）. */
        busyBatchSleepMs?: number;
    }

    export declare const isMapMode: (app?: App) => boolean;

    export declare function isMiddleButton(event?: any): boolean;

    declare function isMorphing(el: Element_2): boolean;

    declare function isNumber(value: any): value is number;

    declare function isObject<T = unknown>(value: T): value is (object & T);

    /**
     * 物体是否在相机后面
     */
    export declare function isObjectBehindCamera(el: Object3D, camera: Camera, isMapMode?: boolean): boolean;

    /**
     * 物体是否被遮挡
     */
    export declare function isObjectOcclude(el: Object3D, camera: Camera, raycaster: Raycaster, occlude: Object3D[]): boolean;

    declare class Isogon extends Path<IsogonProps> {
        shape: IsogonShape;
        constructor(opts?: IsogonProps);
        getDefaultShape(): IsogonShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: IsogonShape): void;
    }

    declare interface IsogonProps extends PathProps {
        shape?: Partial<IsogonShape>;
    }

    declare class IsogonShape {
        x: number;
        y: number;
        r: number;
        n: number;
    }

    /**
     * 判断点是否在多边形内。
     * @param pos 点
     * @param polygon 多边形坐标
     * @return {boolean}
     */
    export declare const isPointInPolygon: (pos: GeoPoint, polygon: GeoPoint[]) => boolean;

    declare function isPrimitive(obj: any): boolean;

    /**
     * Check if property is writable in object or its prototype chain
     * @param object - object to check
     * @param prop - property to check
     * @param allowWritable - allow writable properties without setter
     * @param allowAny - allow any property (even if it doesn't exist)
     *
     * @category JS Object
     */
    export declare function isPropertyWritable<T>(object: T, prop: keyof T, allowWritable?: boolean, allowAny?: boolean): boolean;

    /**
     * Checks if an object is a proxy created by {@link reactive},
     * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.
     *
     * @param value - The value to check.
     */
    declare function isProxy(value: unknown): boolean;

    /**
     * Checks if an object is a proxy created by {@link reactive()} or
     * {@link shallowReactive()} (or {@link ref()} in some cases).
     *
     * @example
     * ```js
     * isReactive(reactive({}))            // => true
     * isReactive(readonly(reactive({})))  // => true
     * isReactive(ref({}).value)           // => true
     * isReactive(readonly(ref({})).value) // => true
     * isReactive(ref(true))               // => false
     * isReactive(shallowRef({}).value)    // => false
     * isReactive(shallowReactive({}))     // => true
     * ```
     *
     * @param value - The value to check.
     */
    declare function isReactive(value: unknown): boolean;

    /**
     * Checks whether the passed value is a readonly object. The properties of a
     * readonly object can change, but they can't be assigned directly via the
     * passed object.
     *
     * The proxies created by {@link readonly()} and {@link shallowReadonly()} are
     * both considered readonly, as is a computed ref without a set function.
     *
     * @param value - The value to check.
     */
    declare function isReadonly(value: unknown): boolean;

    /**
     * Checks if a value is a ref object.
     *
     * @param r - The value to inspect.
     */
    declare function isRef<T>(r: Ref<T> | unknown): r is Ref<T>;

    declare function isRegExp(value: unknown): value is RegExp;

    export declare function isRightButton(event?: any): boolean;

    declare function isShallow(value: unknown): boolean;

    export declare function isShiftKeyDown(event?: any): boolean;

    declare function isString(value: any): value is string;

    declare function isStringSafe(value: any): value is string;

    export declare interface IStatModule {
        /** 是否显示统计 */
        showStat: boolean;
    }

    declare function isTypedArray(value: any): boolean;

    /**
     * Check if the browser supports exporting to webp, with the canvas.toDataURL('image/webp') method.
     */
    export declare function isWebpExportSupported(): boolean;

    declare type IterableCollections = Map<any, any> | Set<any>;

    declare const ITERATE_KEY: unique symbol;

    /**
     * 地图瓦片参数
     */
    export declare interface ITileUrlParam {
        /** 地图ID. */
        mapid?: string;
        /** 版本号. */
        version?: string;
        /** 图层名称. */
        layer?: string;
        /** 文件唯一ID. */
        fileid?: string;
    }

    export declare interface IToolStateModule {
        readonly rootState: StateNode;
        getStatePath: () => string;
        stateIsIn: (path: string) => boolean;
        stateInAny: (...paths: string[]) => boolean;
        setCurrentTool: (id?: string, info?: Record<string, any>) => App;
        getCurrentTool: () => StateNode;
        getCurrentToolId: () => string;
        getStateDescendant: <T extends StateNode>(path: string) => T | undefined;
        addTool: (Tool: TLStateNodeConstructor) => void;
        removeTool: (Tool: TLStateNodeConstructor) => void;
        /**
         * 判断当前是否有工具处于运行中
         */
        isInActiveTool: () => boolean;
        /**
         * 是否正在交互
         */
        isInteracting(): boolean;
        /**
         *  对一个物体进行变换控制器操作
         */
        transformObject: (options: TransformEnterOptions) => Promise<StateNode>;
    }

    export declare interface IUiConfigContainer<TValue = any, TType extends string = string> {
        uiConfig?: UiObjectConfig<TValue, TType>;
    }

    export declare interface IUiModule {
        /**
         * 增加控件 (会调用 `control.onAdd(this)` ).
         *
         * @param control 需要增加的控件.
         * @param {string} [position] 位置. 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
         */
        addControl: (control: IControl, position?: ControlPosition) => App;
        /**
         * 移除控件.
         *
         * @param {IControl} control 要移除的控件.

         */
        removeControl: (control: IControl) => App;
        /**
         * 是否有控件.
         *
         * @param {IControl} control 要查询的控件.
         */
        hasControl: (control: IControl) => void;
        /**
         * 设置光标
         * @param cur 光标名称
         */
        setCursor: (cur: string) => void;
        /**
         * 获取配置面板
         */
        getConfigPane: (opts?: {
            /** 是否清空，默认是 */
            isReset?: boolean;
            /** 标题 */
            title?: string;
            /** 样式 */
            style?: Partial<CSSStyleDeclaration>;
        }) => Promise<{
            configPane: any;
            rootPane: any;
            element: HTMLElement;
            isInit: boolean;
            setVisible: (b: boolean) => void;
            isVisible: () => boolean;
            reset: () => void;
            appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
            renderUiConfig: (uiConfig: UiObjectConfig) => void;
            renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
        }>;
        /**
         * 信息弹窗提示
         * text（必填）：需要输出的文本
         * type（可选）：输出类型 默认是 "log"
         * time（可选）：停留时间 默认是 2500
         */
        logInfo: (text: string, type?: logInfoType | number, time?: number) => void;
    }

    export declare interface IUniformB {
        value: boolean;
    }

    export declare interface IUniformColor {
        value: Color;
    }

    export declare interface IUniformN {
        value: number;
    }

    export declare interface IUniformNArray {
        value: number[];
    }

    export declare interface IUniformTexture {
        value: Texture | null;
    }

    export declare interface IUniformV2 {
        value: Vector2;
    }

    export declare interface IUniformV3 {
        value: Vector3;
    }

    export declare interface IUniformV3Array {
        value: Vector3[];
    }

    /**
     * 更新地图参数
     */
    export declare interface IUpdateMapParam extends IOpenMapBaseParam {
        /** 是否删除老版本(缺省: false ). */
        deleteOldVersion?: boolean;
    }

    /**
     * 更新样式接口
     */
    export declare interface IUpdateStyle {
        /** 地图ID(为空时采用当前打开的mapid). */
        mapid?: string;
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string;
        /** 样式名称. */
        name?: string;
        /** 要开的图层索引列表，格式如[0,1,3]. */
        layeron?: string | number[];
        /** 要关的图层索引列表，格式如[2,4]. layeron与layeroff只要输入一个即可*/
        layeroff?: string | number[];
        /** 地图裁剪范围，范围如[x1,y1,x2,y2].如果只有数字的话，表示是缩放系数 */
        clipbounds?: [number, number, number, number] | number;
        /** 颜色. */
        backcolor?: number;
        /** 线宽，格式如[1，1，1，1，0].表式第1，2，3，4级线宽开，第5级线宽关，大于第5级的，以最后设置的级别状态为主，所以也是关。如为空，则和原图线宽显示状态相同 */
        lineweight?: string | number[];
        /** 表达式. */
        expression?: string;
    }

    export declare interface IWebGLRendererModule {
        /** 渲染器 */
        readonly renderer: WebGLRenderer;
        /** 获取渲染截图 */
        getScreenshot: (params?: Screenshot) => Promise<Blob | null | undefined>;
        /** 地图模式 */
        readonly isMapMode: boolean;
        readonly commonUniforms: {
            time: {
                value: Vector4;
            };
            resolution: {
                value: Vector2;
            };
        };
    }

    /**
     * wms服务url地址接口
     */
    export declare interface IWmsTileUrl {
        /** 地图ID(为空时采用当前打开的mapid)， 为数组时表时同时请求多个. */
        mapid?: string | string[];
        /** 地图版本(为空时采用当前打开的地图版本). */
        version?: string | string[];
        /** 图层名称（为空时采用当前打开的地图图层名称). */
        layers?: string | string[];
        /** 范围，缺省{bbox-epsg-3857}. (如果要获取地图cad一个范围的wms数据无需任何坐标转换，将此范围填cad范围,srs,crs,mapbounds填为空).*/
        bbox?: string;
        /** 当前坐标系,缺省(EPSG:3857). */
        srs?: string;
        /** cad图的坐标系，为空的时候由元数据坐标系决定. 也可直接输入proj4字符串*/
        crs?: string | string[];
        /** 地理真实范围，如有值时,srs将不起作用 */
        mapbounds?: string;
        /** 宽. */
        width?: number;
        /** 高. */
        height?: number;
        /** 是否透明. */
        transparent?: boolean;
        /** 不透明时的背景颜色，默认为白色。格式必须为rgb(r,g,b)或rgba(r,g,b,a),a不透明应该是255. */
        backgroundColor?: string;
        /** 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正*/
        fourParameter?: string | string[];
        /** 是否用上面的四参数进行反算，默认false*/
        isInverseFourParamter?: boolean | boolean[];
        /** 是否是矢量瓦片. */
        mvt?: boolean;
        /** 是否考虑旋转，在不同坐标系中转换是需要考虑。默认自动考虑是否需要旋转. */
        useImageRotate?: boolean;
        /** 旋转时图像处理算法. 1或2,默认自动选择（旋转时有用）*/
        imageProcessAlg?: number;
        /** 当前互联网底图地图类型 WGS84(84坐标，如天地图，osm), GCJ02(火星坐标，如高德，腾讯地图)， BD09LL(百度经纬度坐标，如百度地图)， BD09MC(百度墨卡托米制坐标，如百度地图)*/
        webMapType?: "WGS84" | "GCJ02" | "BD09LL" | "BD09MC";
    }

    /**
     * 工作区（工作区主要用来对图纸进行分类管理。不同工作区的图纸存在的位置不同，查看不同工作区的图纸，需要切换到相应工作区才能查看）
     */
    export declare interface IWorkspace {
        /** 工作区名称(英文名称，不要有特殊字符，用于做为键值和路由). */
        name: string;
        /** 工作区别名(可以是中文). */
        alias?: string;
        /** 工作区目录，如果是相对于工作区路径的一个路径或绝对路径，如为空的话，则用工作区名称做为工作目录. */
        workDir?: string;
        /** 是否公开（不公开的话，无法通过获取工作区功能来获取到此工作区信息）. */
        isPublic?: boolean;
    }

    /**
     * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
     */
    declare class JacobianElement {
        /**
         * spatial
         */
        spatial: Vec3;
        /**
         * rotational
         */
        rotational: Vec3;
        constructor();
        /**
         * Multiply with other JacobianElement
         */
        multiplyElement(element: JacobianElement): number;
        /**
         * Multiply with two vectors
         */
        multiplyVectors(spatial: Vec3, rotational: Vec3): number;
    }

    export declare interface JsonMetaData {
        textures: {
            [uuid: string]: Texture;
        };
        geometries: {
            [uuid: string]: BufferGeometry;
        };
    }

    export { KawaseBlurPass }

    export { KernelSize }

    declare type Keyframe_2 = {
        time: number;
        value: unknown;
        percent: number;
        rawValue: unknown;
        easing?: AnimationEasing;
        easingFunc?: (percent: number) => number;
        additiveValue?: unknown;
    };

    declare type KeyOfDistributive<T> = T extends unknown ? keyof T : never;

    /**
     * Get all object keys
     *
     * Will return an empty array if obj is null/undefined
     */
    declare function keys<T extends object>(obj: T): (KeyOfDistributive<T> & string)[];

    export declare class Label extends Object3D {
        #private;
        labelPool: LabelPool;
        text: string;
        mesh: InstancedMesh;
        geometry: InstancedBufferGeometry;
        material: LabelMaterial;
        pickingMaterial: LabelMaterial;
        instanceAttrData: Float32Array;
        instanceAttrBuffer: InstancedInterleavedBuffer;
        instanceBoxPosition: InterleavedBufferAttribute;
        instanceCharPosition: InterleavedBufferAttribute;
        instanceUv: InterleavedBufferAttribute;
        instanceBoxSize: InterleavedBufferAttribute;
        instanceCharSize: InterleavedBufferAttribute;
        lineHeight: number;
        constructor(labelPool: LabelPool);
        private _handleAtlasChange;
        dispose(): void;
        private reallocateAttributeBufferIfNeeded;
        setText(text: string): void;
        private _needsUpdateLayout;
        private _updateLayoutIfNeeded;
        /** Values should be in working (linear-srgb) color space */
        setColor(r: number, g: number, b: number, a?: number): void;
        /** Values should be in working (linear-srgb) color space */
        setBackgroundColor(r: number, g: number, b: number, a?: number): void;
        setBillboard(billboard: boolean): void;
        /**
         * Enable or disable size attenuation. Setting this to `false` also requires that billboarding is
         * enabled.
         */
        setSizeAttenuation(sizeAttenuation: boolean): void;
        setAnchorPoint(x: number, y: number): void;
        setLineHeight(lineHeight: number): void;
    }

    export declare class LabelMaterial extends RawShaderMaterial {
        picking: boolean;
        constructor(params: {
            atlasTexture?: Texture;
            picking?: boolean;
        });
    }

    export declare interface LabelOptions {
        /** 位置  */
        position?: Vector3;
        /** 文字内容 */
        text: string;
        /** 颜色 */
        color?: ColorRepresentation;
        /** 背景色 */
        backgroundColor?: ColorRepresentation;
        /** 背景透明度 */
        backgroundOpacity?: number;
        /** 是否为公告板模式 */
        billboard?: boolean;
        /** 锚点 */
        anchorPoint?: [number, number];
        /** 高度 */
        lineHeight?: number;
        /** 大小是否会受相机影响 */
        sizeAttenuation?: boolean;
        /** 背景是否透明 */
        transparent?: boolean;
        /** 文本池 */
        labelPool?: LabelPool;
    }

    export declare class LabelPool extends EventDispatcher_2<{
        scaleFactorChange: object;
        atlasChange: object;
    }> {
        atlasTexture: DataTexture;
        private availableLabels;
        private disposed;
        static QUAD_POINTS: Vector3Tuple[];
        static QUAD_POSITIONS: BufferAttribute;
        static QUAD_UVS: BufferAttribute;
        fontManager: FontManager;
        scaleFactor: number;
        setScaleFactor(scaleFactor: number): void;
        constructor(options?: FontManagerOptions);
        updateAtlas(text: string): void;
        private _updateAtlasTexture;
        acquire(): Label;
        release(label: Label): void;
        dispose(): void;
    }

    declare interface LayerConfig {
        clearColor?: string | GradientObject | ImagePatternObject;
        motionBlur?: boolean;
        lastFrameAlpha?: number;
    }

    export declare type LayoutInfo = {
        width: number;
        height: number;
        chars: CharLayoutInfo[];
    };

    /**
     * 向量长度
     */
    declare function len(v: VectorArray): number;

    declare const length_2: typeof len;

    declare const lengthSquare: typeof lenSquare;

    /**
     * 向量长度平方
     */
    declare function lenSquare(v: VectorArray): number;

    /** 比例插值 */
    export declare function lerp(x: number, y: number, t: number): number;

    /**
     * 插值两个点
     */
    declare function lerp_2<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, t: number): T;

    /**
     * @param normalizedValue A float between 0 and 1.
     * @param colors Color list.
     * @param fullOutput Default false.
     * @return Result color. If fullOutput,
     return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
     */
    declare function lerp_3(normalizedValue: number, colors: string[], fullOutput: boolean): LerpFullOutput;

    declare function lerp_3(normalizedValue: number, colors: string[]): string;

    export declare function lerpCameras(camera1: any, camera2: any, alpha: any): void;

    /**
     * 给定坐标数组，和要插值的距离比例计算出比例所在的坐标值
     * @param coordinates 坐标数组
     * @param t 比例值0-1
     * @returns
     */
    export declare function lerpCoordinates(coordinates: Vector3[] | [number, number, number][], t: number): Vector3;

    /** 欧拉角比例插值 */
    export declare function lerpEuler(e1: Euler, e2: Euler, t: number): Euler;

    declare type LerpFullOutput = {
        color: string;
        leftIndex: number;
        rightIndex: number;
        value: number;
    };

    declare function lift(color: string, level: number): string;

    declare function liftColor(color: GradientObject): GradientObject;

    declare function liftColor(color: string): string;

    /**
     * Limit the speed of particles over their life.
     */
    export declare class LimitSpeedOverLife implements Simulation {
        speed: FunctionValueGenerator;
        dampen: number;
        type: string;
        initialize(particle: Particle): void;
        constructor(speed: FunctionValueGenerator, dampen: number);
        update(particle: Particle, delta: number): void;
        toJSON(): any;
        static fromJSON(json: any): Simulation;
        frameUpdate(delta: number): void;
        clone(): Simulation;
        reset(): void;
    }

    declare class Line extends Path<LineProps> {
        shape: LineShape;
        constructor(opts?: LineProps);
        getDefaultStyle(): {
            stroke: string;
            fill: string;
        };
        getDefaultShape(): LineShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: LineShape): void;
        /**
         * Get point at percent
         */
        pointAt(p: number): VectorArray;
    }

    export declare class Line2 extends LineSegments2 {
        constructor(geometry?: LineGeometry, material?: LineMaterial);
    }

    /**
     * x, y, x2, y2 are all percent from 0 to 1 when globalCoord is false
     */
    declare class LinearGradient extends Gradient_2 {
        type: 'linear';
        x: number;
        y: number;
        x2: number;
        y2: number;
        constructor(x: number, y: number, x2: number, y2: number, colorStops?: GradientColorStop[], globalCoord?: boolean);
    }

    declare interface LinearGradientObject extends GradientObject {
        type: 'linear';
        x: number;
        y: number;
        x2: number;
        y2: number;
    }

    /**
     * Converts a single color channel from the linear color space to sRGB.
     * @param c - The color channel to be converted.
     * @category Color
     */
    export declare function LinearToSRGB(c: number): number;

    export declare function lineDistance(points: [number, number, number][] | Vector3[]): number;

    export declare class LineGeometry extends LineSegmentsGeometry {
        constructor();
        setPositions(array: any): this;
        setColors(array: any): this;
        setLinewidths(array: number[]): this;
        setLineOpacitys(array: number[]): this;
        setDashArguments(array: number[]): this;
        fromLine(line: any): this;
    }

    export declare function lineIntersection(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, out?: number[], writeOffset?: number): number;

    export declare class LineMaterial extends ShaderMaterial {
        constructor(parameters: any);
        get color(): any;
        set color(value: any);
        get worldUnits(): boolean;
        set worldUnits(value: boolean);
        get linewidth(): any;
        set linewidth(value: any);
        get dashed(): boolean;
        set dashed(value: boolean);
        get dashScale(): any;
        set dashScale(value: any);
        get dashSize(): any;
        set dashSize(value: any);
        get dashOffset(): any;
        set dashOffset(value: any);
        get gapSize(): any;
        set gapSize(value: any);
        get opacity(): any;
        set opacity(value: any);
        get resolution(): any;
        set resolution(value: any);
        get alphaToCoverage(): boolean;
        set alphaToCoverage(value: boolean);
    }

    export declare type LineMaterialParameters = {
        worldUnits?: boolean;
        color?: number;
        linewidth?: number;
        dashed?: boolean;
        dashScale?: number;
        dashSize?: number;
        dashOffset?: number;
        gapSize?: number;
        resolution?: Vector2;
    } & ShaderMaterialParameters;

    declare interface LineProps extends PathProps {
        shape?: Partial<LineShape>;
    }

    export declare class LineSegments2 extends Mesh {
        constructor(geometry?: LineSegmentsGeometry, material?: LineMaterial);
        computeLineDistances(): this;
        raycast(raycaster: any, intersects: any): void;
    }

    export declare class LineSegmentsGeometry extends InstancedBufferGeometry {
        constructor();
        applyMatrix4(matrix: any): this;
        setPositions(array: any): this;
        setColors(array: any): this;
        setLinewidths(linewidthArray: Float32Array | number[]): this;
        setLineOpacitys(lineOpacityArray: Float32Array | number[]): this;
        /**
         * 设置dash相关的参数
         * @param dashArgsArr
         */
        setDashArguments(dashArgsArr: Float32Array | number[]): this;
        fromWireframeGeometry(geometry: any): this;
        fromEdgesGeometry(geometry: any): this;
        fromMesh(mesh: any): this;
        fromLineSegments(lineSegments: any): this;
        computeBoundingBox(): void;
        computeBoundingSphere(): void;
        toJSON(): void;
        applyMatrix(matrix: any): this;
    }

    declare class LineShape {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        percent: number;
    }

    /**
     * 切分线段
     * @param cs 要切分的线段坐标
     * @param lineChunkLength 要切分的段数，默认10
     */
    export declare function lineSlice(cs: Array<[number, number, number]>, lineChunkLength?: number): any[];

    /**
     * 线被另外一条线分开多条线段，返回新的线段
     * @param line
     * @param splitLine
     * @param dotErr 允许误差的小数点后几位，默认6位
     * @return {any[] | GeoPoint[][]}
     */
    export declare function lineSplit(line: GeoPoint[], splitLine: GeoPoint[], dotErr?: number): GeoPoint[][];

    /**
     * LineString Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.4
     */
    declare interface LineString extends GeometryObject {
        type: "LineString";
        coordinates: Position[];
    }

    declare class LinkedList<T> {
        length: number;
        head: LinkedListNode<T> | null;
        tail: LinkedListNode<T> | null;
        constructor();
        isEmpty(): boolean;
        clear(): void;
        front(): T | null;
        back(): T | null;
        /**
         * remove at head in O(1)
         */
        dequeue(): T | undefined;
        /**
         * remove at tail in O(1)
         */
        pop(): T | undefined;
        /**
         * add at head in O(1)
         */
        queue(data: T): void;
        /**
         * add at tail in O(1)
         */
        push(data: T): void;
        insertBefore(node: LinkedListNode<T>, data: T): void;
        remove(data: T): void;
        /**
         * Returns an iterator over the values
         */
        values(): Generator<T, void, unknown>;
    }

    declare class LinkedListNode<T> {
        data: T;
        next: LinkedListNode<T> | null;
        prev: LinkedListNode<T> | null;
        constructor(data: T);
        hasPrev(): boolean;
        hasNext(): boolean;
    }

    export declare interface LoadDetail {
        url: string;
        progress: number;
        error: boolean;
        message: string;
    }

    export declare class LoaderManager {
        private readonly resourceMap;
        private loaderMap;
        private readonly loadDetailMap;
        private path;
        private loaderUrlPath;
        signal: {
            beforeLoad: Signal;
            loading: Signal;
            detailLoading: Signal;
            detailLoaded: Signal;
            loaded: Signal;
        };
        imageLoader: ImageLoader;
        videoLoader: VideoLoader;
        gltfLoader: GLTFLoader;
        objLoader: OBJLoader;
        mtlLoader: MTLLoader;
        videlLoader: VideoLoader;
        hdrLoader: RGBELoader;
        fbxLoader: FBXLoader;
        ddsLoader: DDSLoader;
        dracoLoader: DRACOLoader;
        ktx2Loader: KTX2Loader;
        svgLoader: SVGLoader;
        fileLoader: FileLoader;
        particleLoader: ParticleLoader;
        constructor(parameters?: LoaderManagerOptions);
        /**
         * 设置统一资源路径前缀
         * @param path
         * @returns
         */
        setPath(path: string): this;
        /**
         * 设置请求头
         * @param headers
         * @returns this
         */
        setRequestHeader(headers: Record<string, string>): this;
        /**
         * 设置响应类型
         * @param responseType
         * @returns this
         */
        setResponseType(responseType: string): this;
        /**
         * 获取加载器
         * @param ext 资源类型
         * @returns
         */
        getLoader(ext: string): Loader | null;
        /**
         * 加载资源
         * @param urls
         * @param useCache 是否使用缓存，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
         * @returns this
         */
        load(urls: LoadUnit[] | LoadUnit, useCache: boolean, onLoad: (resource: any) => void, onProgress?: (event: ProgressEvent | ProgressEvent[]) => void, onError?: (event: ErrorEvent | string | string[] | ErrorEvent[]) => void, fileType?: string[] | string): this;
        /**
         * 注册loader
         * @param ext 文件格式: jpg
         * @param loader extend THREE.Loader
         * @returns this
         */
        register(ext: string, loader: Loader): this;
        hasLoaded(url: string): boolean;
        /**
         * 获取url的资源
         * @param url
         * @returns
         */
        getResource(url: string): any;
        /**
         * 获取url的资源状态
         * @param url
         * @returns
         */
        getResourceStatus(url: string): ResStatus;
        /**
         * 获取详细资源信息
         * @returns
         */
        getLoadDetail(url: string): LoadDetail;
        /**
         * 获取详细资源信息
         * @returns
         */
        getLoadDetailMap(): {
            [key: string]: LoadDetail;
        };
        setLoaderPath(urlPath: string): void;
        /**
         * 清空缓存
         * @returns
         */
        dispose(): this;
        /**
         * 加载扩展的loader库
         */
        loadExtensionLoader(): Promise<void>;
        /**
         * 加载扩展的IfcLoader库
         */
        loadExtensionIfcLoader(options?: {
            setupOptionalCategoriesOpts?: Record<string, any>;
            applyWebIfcConfigOpts?: Record<string, any>;
        }): Promise<void>;
    }

    export declare interface LoaderManagerOptions {
        /**加载器拓展 */
        loaderExtends: {
            [key: string]: Loader;
        };
    }

    /**
     * 加载图片
     */
    export declare const loadImage: (src: string) => Promise<HTMLImageElement>;

    export declare const LoadManager: LoaderManager;

    export declare function loadParticlePlugin(plugin: ParticlePlugin): void;

    /** 启用物理引擎 */
    export declare function loadPhysicsEngine(): Promise<typeof CANNON>;

    /** 加载3dtiles插件库 */
    export declare const loadPlugin3dtiles: () => Promise<typeof vjmap3d_2.Tiles3dPluginType>;

    /** 加载algorithm插件库 */
    export declare const loadPluginAlgorithm: () => Promise<typeof vjmap3d_2.AlgorithmPluginType>;

    export declare interface LoadPluginOpts {
        /** 是否是绝对位置 */
        isAbsPath?: boolean;
        /** 用于运行 JavaScript 的策略。可以是`inject`、`eval` 或`href`。默认自动检测. */
        strategy?: "inject" | "eval" | `href`;
        /** 用于注入资源的位置的 `document.querySelector` 参数。*/
        injectLocation?: string;
        /** 异步加载脚本 */
        async?: boolean;
        /** 沙箱运行时设置globalThis为undefined */
        globalThisUndefined?: boolean;
        /** globalThis为undefined时有效，进行替换 */
        globalThisReplace?: boolean;
        /** 沙箱运行时上下文 */
        context?: any;
        /** 请求配置参数 */
        reqConfig?: Partial<Config>;
    }

    export declare interface loadResourcesOptions {
        /** 是否显示loading界面   默认true*/
        showLoading?: boolean;
        /** 是否显示背景   默认 true*/
        showShadertoy?: boolean;
        /** 是否html的div进度要  默认false */
        showHtml?: boolean;
        /** 材质参数选顶 */
        shadertoyMaterial?: Partial<ShadertoyMaterialParameters> & {
            hsbOffsetDelta?: [number, number, number];
            hsbOffsetMax?: [number, number, number];
        };
        /** 背景随进度透明度变小  */
        ShadertoyProgressOpacity?: boolean;
        /** 显示webgl进度条标签  默认 false */
        showGlLabel?: boolean;
        /** 显示div进度条标签  默认 true */
        showDivLabel?: boolean;
        /** 标签选项  text默认为 loading... {{percentage}} */
        labelOptions?: Partial<LabelOptions> & {
            /** 文字像素位置 */
            position?: [number, number];
            /** 文字像素高度 */
            height?: number;
        };
        /** 禁用相机控件 默认false */
        enableCameraControl?: boolean;
        /** 进度条回调 */
        progressCb?: (percentage: number, error?: any) => void;
        /** 使用html div做为进度条 */
        html?: {
            /** div的内容 */
            div: string;
            /** css的内容 */
            css?: string;
            /** 进度文本div 类别 */
            textDivClassName?: string;
        };
        /** 自动隐藏场景中其他实体 默认true */
        autoHiddenSceneObjects?: boolean;
    }

    export declare type LoadUnit = string | {
        url: string;
        ext: string;
    };

    /**
     * Lock constraint. Will remove all degrees of freedom between the bodies.
     */
    declare class LockConstraint extends PointToPointConstraint {
        xA: Vec3;
        xB: Vec3;
        yA: Vec3;
        yB: Vec3;
        zA: Vec3;
        zB: Vec3;
        rotationalEquation1: RotationalEquation;
        rotationalEquation2: RotationalEquation;
        rotationalEquation3: RotationalEquation;
        motorEquation?: RotationalMotorEquation;
        constructor(bodyA: Body_2, bodyB: Body_2, options?: {
            /**
             * The maximum force that should be applied to constrain the bodies.
             * @default 1e6
             */
            maxForce?: number;
        });
        /**
         * update
         */
        update(): void;
    }

    declare type LockConstraintOptions = ConstructorParameters<typeof LockConstraint>[2];

    /**
     * LOD control objects define how the map tiles are subsivided or simplified.
     */
    export declare interface LODControl {
        /**
         * Update LOD of the MapView and Camera position on the world.
         *
         * @param view - Map view for wich the LOD will be updated.
         * @param camera - Camera used to view the scene.
         * @param renderer - Renderer object.
         * @param scene - Scene that compose the mapview.
         */
        updateLOD(view: MapView, camera: Camera, renderer: WebGLRenderer, scene: Object3D): void;
    }

    /**
     * Use random raycasting to randomly pick n objects to be tested on screen space.
     *
     * Overall the fastest solution but does not include out of screen objects.
     */
    export declare class LODRaycast implements LODControl {
        /**
         * Number of rays used to test nodes and subdivide the map.
         *
         * N rays are cast each frame dependeing on this value to check distance to the visible map nodes. A single ray should be enough for must scenarios.
         */
        subdivisionRays: number;
        /**
         * Threshold to subdivide the map tiles.
         *
         * Lower value will subdivide earlier (less zoom required to subdivide).
         */
        thresholdUp: number;
        /**
         * Threshold to simplify the map tiles.
         *
         * Higher value will simplify earlier.
         */
        thresholdDown: number;
        /**
         * Raycaster object used to cast rays into the world and check for hits.
         */
        raycaster: Raycaster;
        /**
         * Normalized mouse coordinates.
         */
        mouse: Vector2;
        /**
         * Consider the distance powered to level of the node.
         */
        powerDistance: boolean;
        /**
         * Consider the scale of the node when calculating the distance.
         *
         * If distance is not considered threshold values should be absolute distances.
         */
        scaleDistance: boolean;
        updateLOD(view: MapView, camera: Camera, renderer: WebGLRenderer, scene: Object3D): void;
    }

    declare function logError(...args: any[]): void;

    export declare const Logger: {
        debug: (message?: any, ...optionalParams: any[]) => void;
        info: (message?: any, ...optionalParams: any[]) => void;
        warn: (message?: any, ...optionalParams: any[]) => void;
        error: (message?: any, ...optionalParams: any[]) => void;
        isEnabled: boolean;
        /** Turn on log */
        enable(): void;
        /** Turn off log */
        disable(): void;
    };

    export declare type logInfoType = "log" | "warn" | "error" | "info" | "success";

    /**
     * Prints given message into the console
     */
    export declare class LogMessageBehavior extends Behavior {
        message: string;
        constructor(message?: string);
        /**
         *
         * @param {String} message
         * @return {LogMessageBehavior}
         */
        static from(message: string): LogMessageBehavior;
        tick(timeDelta: number): BehaviorStatus;
    }

    declare function logTriangleDefinitions(...triangles: Triangle[]): void;

    /**
     * Find the longest common prefix in an array of strings
     * https://stackoverflow.com/questions/68702774/longest-common-prefix-in-javascript
     * @param words
     */
    export declare function longestCommonPrefix(words: string[]): string;

    /**
     * Calculate luminance. It will include alpha.
     */
    declare function lum(color: string, backgroundLum: number): number;

    export declare function makeBasicMaterialUiConfig(mat: MeshBasicMaterial): UiObjectConfig;

    export declare function makeCameraUiConfig(camera: Camera): UiObjectConfig;

    /**
     * Returns a data url for a 16x16 svg rectangle with the given color.
     * @param c - color
     *
     * @category SVGs
     */
    export declare const makeColorSvg: (c: string) => string;

    /**
     * Returns a data url for a 16x16 svg circle with the given color.
     * @param c - color
     *
     * @category SVGs
     */
    export declare const makeColorSvgCircle: (c: string) => string;

    export declare function makeGeomertyUiConfig(geom: BufferGeometry): UiObjectConfig;

    export declare function makeLightUiConfig(light: Light): UiObjectConfig | undefined;

    export declare function makeMaterialUiConfig(mat: Material, object?: Object3D): UiObjectConfig;

    export declare function makeObject3DUiConfig(obj: Object3D, isMesh?: boolean): UiObjectConfig;

    export declare function makePhongMaterialUiConfig(mat: MeshPhongMaterial): UiObjectConfig;

    export declare function makePhysicalMaterialUiConfig(mat: MeshPhysicalMaterial): UiObjectConfig;

    export declare function makeSamplerUi(mat: any, map: any): UiObjectConfig<any, string, any>;

    /**
     * Returns a data url for a svg with the given text.
     * @param text
     *
     * @category SVGs
     */
    export declare const makeTextSvg: (text: string) => string;

    /**
     * Array mapping.
     * @typeparam T Type in Array
     * @typeparam R Type Returned
     * @return Must be an array.
     */
    declare function map<T, R, Context>(arr: readonly T[], cb: (this: Context, val: T, index?: number, arr?: readonly T[]) => R, context?: Context): R[];

    export declare class map2dUtils {
        static WorldResolution: number;
        static makePerspectiveMatrix(fovy: any, aspect: any, near: any, far: any): Matrix4;
        static makeOrthographicMatrix(left: any, right: any, top: any, bottom: any, near: any, far: any): Matrix4;
        /** 2d经纬度坐标转3d中世界坐标 */
        static projectToWorld(coords: [number, number, number?]): Vector3;
        /** 根据纬度获取该纬度每米分辨值 */
        static projectedUnitsPerMeter(latitude: any): number;
        /** 获取摩卡托坐标z值 */
        static mercatorZfromAltitude(altitude: any, lat: any): number;
        /** 把3d中世界坐标转2d经纬度坐标 */
        static unprojectFromWorld(world: {
            x: number;
            y: number;
            z: number;
        } | Vector3): number[];
        /**
         * 定位到三维场景中的一个实体
         */
        static fitToObject(map: any, object: Sphere | Object3D, opts?: Record<string, any>): void;
        /** 三维场景中的场景坐标转世界坐标 */
        static scene2World(pt: Vector3, app?: App): Vector3;
        /** 三维场景中的场景坐标转世界坐标 */
        static world2Scene(pt: Vector3, app?: App): Vector3;
    }

    /**
     * Represents a height map tile node that can be subdivided into other height nodes.
     *
     * Its important to update match the height of the tile with the neighbors nodes edge heights to ensure proper continuity of the surface.
     *
     * The height node is designed to use MapBox elevation tile encoded data as described in https://www.mapbox.com/help/access-elevation-data/
     */
    export declare class MapHeightNode extends MapNode {
        /**
         * Flag indicating if the tile height data was loaded.
         */
        heightLoaded: boolean;
        /**
         * Flag indicating if the tile texture was loaded.
         */
        textureLoaded: boolean;
        /**
         * Original tile size of the images retrieved from the height provider.
         */
        static tileSize: number;
        /**
         * Size of the grid of the geometry displayed on the scene for each tile.
         */
        geometrySize: number;
        /**
         * If true the tiles will compute their normals.
         */
        geometryNormals: boolean;
        /**
         * Map node plane geometry.
         */
        static geometry: BufferGeometry;
        /**
         * Base geometry shared across all the nodes.
         */
        static baseGeometry: BufferGeometry;
        /**
         * Map height node constructor.
         *
         * @param parentNode - The parent node of this node.
         * @param mapView - Map view object where this node is placed.
         * @param location - Position in the node tree relative to the parent.
         * @param level - Zoom level in the tile tree of the node.
         * @param x - X position of the node in the tile tree.
         * @param y - Y position of the node in the tile tree.
         * @param material - Material used to render this height node.
         * @param geometry - Geometry used to render this height node.
         */
        constructor(parentNode?: MapHeightNode, mapView?: MapView, location?: number, level?: number, x?: number, y?: number, geometry?: BufferGeometry, material?: Material);
        initialize(): Promise<void>;
        /**
         * Load tile texture from the server.
         *
         * Aditionally in this height node it loads elevation data from the height provider and generate the appropiate maps.
         */
        loadData(): Promise<void>;
        /**
         * Load height texture from the server and create a geometry to match it.
         *
         * @returns Returns a promise indicating when the geometry generation has finished.
         */
        loadHeightGeometry(): Promise<any>;
        createChildNodes(): void;
        /**
         * Overrides normal raycasting, to avoid raycasting when isMesh is set to false.
         */
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
    }

    declare interface MapInterface<T, KEY extends string | number = string | number> {
        delete(key: KEY): boolean;
        has(key: KEY): boolean;
        get(key: KEY): T | undefined;
        set(key: KEY, value: T): this;
        keys(): KEY[];
        forEach(callback: (value: T, key: KEY) => void): void;
    }

    /**
     * Represents a map tile node inside of the tiles quad-tree
     *
     * Each map node can be subdivided into other nodes.
     *
     * It is intended to be used as a base class for other map node implementations.
     */
    export declare abstract class MapNode extends Mesh {
        /**
         * Default texture used when texture fails to load.
         */
        static defaultTexture: Texture;
        static defaultTransparentTexture: Texture;
        /**
         * The map view object where the node is placed.
         */
        mapView: MapView;
        /**
         * Parent node (from an upper tile level).
         */
        parentNode: MapNode;
        /**
         * Index of the map node in the quad-tree parent node.
         *
         * Position in the tree parent, can be topLeft, topRight, bottomLeft or bottomRight.
         */
        location: number;
        /**
         * Tile level of this node.
         */
        level: number;
        /**
         * Tile x position.
         */
        x: number;
        /**
         * Tile y position.
         */
        y: number;
        /**
         * Variable to check if the node is subdivided.
         *
         * To avoid bad visibility changes on node load.
         */
        subdivided: boolean;
        /**
         * Flag to indicate if the map node was disposed.
         *
         * When a map node is disposed its resources are dealocated to save memory.
         */
        disposed: boolean;
        /**
         * Indicates how many children nodes are loaded.
         *
         * The child on become visible once all of them are loaded.
         */
        nodesLoaded: number;
        /**
         * Cache with the children objects created from subdivision.
         *
         * Used to avoid recreate object after simplification and subdivision.
         *
         * The default value is null. Only used if "cacheTiles" is set to true.
         */
        childrenCache: Object3D[];
        /**
         * Base geometry is attached to the map viewer object.
         *
         * It should have the full size of the world so that operations over the MapView bounding box/sphere work correctly.
         */
        static baseGeometry: BufferGeometry;
        /**
         * How many children each branch of the tree has.
         *
         * For a quad-tree this value is 4.
         */
        static childrens: number;
        /**
         * Flag to check if the node is a mesh by the renderer.
         *
         * Used to toggle the visibility of the node. The renderer skips the node rendering if this is set false.
         */
        isMesh: true;
        constructor(parentNode?: MapNode, mapView?: MapView, location?: number, level?: number, x?: number, y?: number, geometry?: BufferGeometry, material?: Material);
        /**
         * Initialize resources that require access to data from the MapView.
         *
         * Called automatically by the constructor for child nodes and MapView when a root node is attached to it.
         */
        initialize(): Promise<void>;
        /**
         * Create the child nodes to represent the next tree level.
         *
         * These nodes should be added to the object, and their transformations matrix should be updated.
         */
        createChildNodes(): void;
        /**
         * Subdivide node,check the maximum depth allowed for the tile provider.
         *
         * Uses the createChildNodes() method to actually create the child nodes that represent the next tree level.
         */
        subdivide(): void;
        /**
         * Simplify node, remove all children from node, store them in cache.
         *
         * Reset the subdivided flag and restore the visibility.
         *
         * This base method assumes that the node implementation is based off Mesh and that the isMesh property is used to toggle visibility.
         */
        simplify(): void;
        /**
         * Load tile texture from the server.
         *
         * This base method assumes the existence of a material attribute with a map texture.
         */
        loadData(): Promise<void>;
        /**
         * Increment the child loaded counter.
         *
         * Should be called after a map node is ready for display.
         */
        nodeReady(): void;
        /**
         * Dispose the map node and its resources.
         *
         * Should cancel all pending processing for the node.
         */
        dispose(): void;
    }

    /**
     * Map node geometry is a geometry used to represent the map nodes.
     *
     * Consists of a XZ plane with normals facing +Y.
     *
     * The geometry points start in XZ plane that can be manipulated for example for height adjustment.
     *
     * Geometry can also include skirts to mask off missalignments between tiles.
     */
    export declare class MapNodeGeometry extends BufferGeometry {
        /**
         * Map node geometry constructor.
         *
         * @param width - Width of the node.
         * @param height - Height of the node.
         * @param widthSegments - Number of subdivisions along the width.
         * @param heightSegments - Number of subdivisions along the height.
         * @param skirt - Skirt around the plane to mask gaps between tiles.
         */
        constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number, skirt?: boolean, skirtDepth?: number);
        static buildPlane(width: number, height: number, widthSegments: number, heightSegments: number, indices: number[], vertices: number[], normals: number[], uvs: number[]): void;
        static buildSkirt(width: number, height: number, widthSegments: number, heightSegments: number, skirtDepth: number, indices: number[], vertices: number[], normals: number[], uvs: number[]): void;
    }

    export declare class MapNodeHeightGeometry extends BufferGeometry {
        /**
         * Map node geometry constructor.
         *
         * @param width - Width of the node.
         * @param height - Height of the node.
         * @param widthSegments - Number of subdivisions along the width.
         * @param heightSegments - Number of subdivisions along the height.
         * @param skirt - Skirt around the plane to mask gaps between tiles.
         */
        constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number, skirt?: boolean, skirtDepth?: number, imageData?: ImageData, calculateNormals?: boolean, heightScale?: number);
        /**
         * Compute normals for the height geometry.
         *
         * Only computes normals for the surface of the map geometry. Skirts are not considered.
         *
         * @param widthSegments - Number of segments in width.
         * @param heightSegments - Number of segments in height.
         */
        computeNormals(widthSegments: number, heightSegments: number): void;
    }

    export declare enum MapOpenWay {
        /** 内存模式. */
        Memory = "Memory",
        /** 存储为几何数据再渲染模式 */
        GeomRender = "GeomRender"
    }

    /**
     * Represents a basic plane tile node.
     */
    export declare class MapPlaneNode extends MapNode {
        constructor(parentNode?: any, mapView?: any, location?: number, level?: number, x?: number, y?: number);
        /**
         * Map node plane geometry.
         */
        static geometry: BufferGeometry;
        static baseGeometry: BufferGeometry;
        initialize(): Promise<void>;
        createChildNodes(): void;
        /**
         * Overrides normal raycasting, to avoid raycasting when isMesh is set to false.
         */
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
    }

    /**
     * A map provider is a object that handles the access to map tiles of a specific service.
     *
     * They contain the access configuration and are responsible for handling the map theme size etc.
     *
     * MapProvider should be used as a base for all the providers.
     */
    export declare class MapProvider {
        /**
         * Name of the map provider
         */
        mapView: MapView;
        /**
         * Name of the map provider
         */
        name: string;
        /**
         * Minimum tile level.
         */
        minZoom: number;
        /**
         * Maximum tile level.
         */
        maxZoom: number;
        /**
         * Map bounds.
         */
        bounds?: Box2;
        layers: MapProviderLayer[];
        options?: MapProviderParameters;
        constructor(layers: MapProviderLayer | MapProviderLayer[], options?: MapProviderParameters);
        /**
         * Get a tile for the x, y, zoom based on the provider configuration.
         *
         * The tile should be returned as a image object, compatible with canvas context 2D drawImage() and with webgl texImage2D() method.
         *
         * @param zoom - Zoom level.
         * @param x - Tile x.
         * @param y - Tile y.
         * @returns Promise with the image obtained for the tile ready to use.
         */
        fetchTile(zoom: number, x: number, y: number): {
            promise: Promise<any>;
            layers: MapProviderLayer[];
        };
    }

    declare interface MapProviderLayer {
        /**
         * Name of the map provider
         */
        name?: string;
        /**
         * Minimum tile level.
         */
        minZoom?: number;
        /**
         * Maximum tile level.
         */
        maxZoom?: number;
        /**
         * Map bounds.
         */
        bounds?: [number, number, number, number];
        opacity?: number;
        url?: string;
        tileUrl?: string;
        fetchTile?: (zoom: number, x: number, y: number) => Promise<any>;
    }

    declare interface MapProviderParameters extends MeshBasicMaterialParameters {
        /** 最开始的[瓦片缩级别，行，列], 默认为[0, 0, 0] */
        rootTile?: [number, number, number];
        /** 背景颜色 */
        backColor?: ColorRepresentation;
        /** 材质属性 */
        texture?: {
            magFilter?: MagnificationTextureFilter;
            minFilter?: MinificationTextureFilter;
            [key: string]: any;
        };
        /** 颜色滤镜 */
        colorFilter?: FilterColorOptions;
    }

    declare type MapSources<T, Immediate> = {
        [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : T[K] extends object ? Immediate extends true ? T[K] | undefined : T[K] : never;
    };

    export declare class MapThreeLayer {
        #private;
        map: any;
        options: MapThreeLayerOptions;
        app: App;
        world: any;
        worldEntity: Entity;
        cameraSync: any;
        scene: Scene;
        constructor(map: any, options?: MapThreeLayerOptions);
        init(map: any, options: any): void;
        update(): void;
        repaint(): void;
        onRemove(map: any, gl: any): void;
    }

    export declare interface MapThreeLayerOptions extends AppOptions {
        passiveRendering?: boolean;
    }

    /**
     * @deprecated
     */
    declare const mapToColor: typeof lerp_3;

    declare type MapToType<T extends Dictionary<any>, S> = {
        [P in keyof T]: T[P] extends Dictionary<any> ? MapToType<T[P], S> : S;
    };

    export declare class MapUtils {
        /** The equatorial semi perimeter in meters. */
        static EQUATORIAL_SEMIPERIMETER: number;
        /** The equatorial semi perimeter in meters. */
        static EARTH_BOUNDS: [number, number, number, number];
        /**
         * 经纬度转墨卡托 .
         * @param pt 经纬度
         * @param isMercatorNormalize 是否对输出的墨卡托坐标归一化，到0-1区间
         */
        static lngLatToMercator(pt: [number, number], isMercatorNormalize?: boolean): [number, number];
        /**
         * 墨卡托转经纬度 .
         * @param pt 墨卡托坐标
         * @param isMercatorNormalize 输入的的墨卡托坐标是否是归一化的坐标
         */
        static mercatorToLngLat(pt: [number, number], isMercatorNormalize?: boolean): [number, number];
        /**
         * 归一化坐标，默认是墨卡托坐标范围
         * @param pt 要归一化的坐标
         * @param mapBounds 地图范围，不填默认为墨卡托坐标范围
         */
        static toNormalize(pt: [number, number], mapBounds?: [number, number, number, number]): [number, number];
        /**
         * 归一化的墨卡托坐标还原成真实的墨卡托坐标 .，默认是墨卡托坐标范围
         * @param pt 归一化的坐标
         * @param mapBounds 地图范围，不填默认为墨卡托坐标范围
         */
        static fromNormalize(pt: [number, number], mapBounds?: [number, number, number, number]): [number, number];
        /**
         * 自定义坐标系坐标转墨卡托(epsg:3857)
         * @param pt 坐标点
         * @param mapBounds 地图范围 [minx, miny,maxx, maxy]
         *  @param isMercatorNormalize 是否对输出的墨卡托坐标归一化，到0-1区间
         * @return {[number, number]}
         */
        static toMercator(pt: [number, number], mapBounds: [number, number, number, number], isMercatorNormalize?: boolean): [number, number];
        /**
         * 墨卡托(epsg:3857)转自定义坐标系坐标
         * @param pt 墨卡托坐标点
         * @param mapBounds 地图范围 [minx, miny,maxx, maxy]
         * @param isMercatorNormalize 输入的的墨卡托坐标是否是归一化的坐标
         * @return {[number, number]}
         */
        static fromMercator(pt: [number, number], mapBounds: [number, number, number, number], isMercatorNormalize?: boolean): [number, number];
        /**
         * 互联网坐标类型
         */
        static WebMapCoordType: {
            unknown: number;
            LngLat: number;
            Mercator: number;
            NormalizeMercator: number;
        };
        /**
         * 根据值获取可能的互联网坐标类型，经纬度坐标， 墨卡托坐标，0-1区间的归一化的墨卡托坐标
         */
        static getLikeCoordType(pt: [number, number] | [number, number][]): number;
        /**
         * getTileBBox
         *
         * @param    {Number}  x  Tile coordinate x
         * @param    {Number}  y  Tile coordinate y
         * @param    {Number}  z  Tile zoom
         * @returns  {String}  String of the bounding box
         */
        static getTileBBox(x: any, y: any, z: any): string;
        /**
         * 获取瓦片的墨托卡坐标范围
         *
         * @param    {Number}  x  Tile coordinate x
         * @param    {Number}  y  Tile coordinate y
         * @param    {Number}  z  Tile zoom
         * @returns  {String}  String of the bounding box
         */
        static getTileMercator(x: any, y: any, z: any): [number, number, number, number];
        /**
         * getMercCoords
         *
         * @param    {Number}  x  Pixel coordinate x
         * @param    {Number}  y  Pixel coordinate y
         * @param    {Number}  z  Tile zoom
         * @returns  {Array}   [x, y]
         */
        static getMercCoords(x: any, y: any, z: any): number[];
        static fetchDebugTile(zoom: number, x: number, y: number, startColor?: ColorRepresentation, endColor?: ColorRepresentation, borderColor?: ColorRepresentation, resolution?: number): Promise<any>;
    }

    /**
     * Map viewer is used to read and display map tiles from a server.
     *
     * It was designed to work with a OpenMapTiles but can also be used with another map tiles.
     *
     * The map is drawn in plane map nodes using a quad tree that is subdivided as necessary to guaratee good map quality.
     */
    export declare class MapView extends Mesh {
        #private;
        /**
         * Planar map projection.
         */
        static PLANAR: number;
        /**
         * Spherical map projection.
         */
        /**
         * Planar map projection with height deformation.
         */
        static HEIGHT: number;
        /**
         * Planar map projection with height deformation using the GPU for height generation.
         */
        static HEIGHT_SHADER: number;
        /**
         * RTIN map mode.
         */
        static MARTINI: number;
        /**
         * Map of the map node types available.
         */
        static mapModes: Map<number, any>;
        /**
         * LOD control object used to defined how tiles are loaded in and out of memory.
         */
        lod: LODControl;
        /**
         * Map tile color layer provider.
         */
        provider: MapProvider;
        /**
         * Map height (terrain elevation) layer provider.
         *
         * Only used for HEIGHT, HEIGHT_SHADER and MARTINI map modes.
         */
        heightProvider: MapProvider;
        /**
         * Define the type of map node in use, defined how the map is presented.
         *
         * Should only be set on creation.
         */
        root: MapNode;
        /**
         * Indicate if the nodes should cache its children when it is simplified. Nodes that are no longer in use should be kept in memory.
         *
         * Usefull for fast moving scenarios to prevent reparsing data in fast moving scenes.
         *
         * Should only be used if the child generation process is time consuming. Should be kept off unless required.
         */
        cacheTiles: boolean;
        scheduler: Scheduler;
        useScheduler: boolean;
        isClip?: boolean;
        options: MapViewOption;
        /**
         * Constructor for the map view objects.
         *
         * @param root - Map view node modes can be HEIGHT or PLANAR. PLANAR is used by default. Can also be a custom MapNode instance.
         * @param provider - Map color tile provider by default a OSM maps provider is used if none specified.
         * @param heightProvider - Map height tile provider, by default no height provider is used.
         */
        constructor(options: MapViewOption);
        /**
         * Ajust node configuration depending on the camera distance.
         *
         * Called everytime automatically before render by the renderer.
         */
        onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group_2) => void;
        /**
         * 地图坐标转局部世界坐标
         */
        mapToLocal(point: [number, number]): Vector3;
        /**
         * 局部世界坐标转地图坐标
         */
        localToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 地图坐标转世界坐标
         */
        mapToWorld(lngLat: [number, number]): Vector3;
        /**
         * 世界坐标转地图坐标
         */
        worldToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转局部世界坐标
         */
        lngLatToLocal(lngLat: [number, number]): Vector3;
        /**
         * 局部世界坐标转经纬度
         */
        localToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转世界坐标
         */
        lngLatToWorld(lngLat: [number, number]): Vector3;
        /**
         * 世界坐标转经纬度
         */
        worldToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转归一化的坐标, 先会把经纬度转墨卡托，然后根据最开始的[瓦片缩级别，行，列]rootTile的范围，归一化到0-1范围区间
         */
        lngLatToNormalize(lngLat: [number, number]): [number, number];
        getMapBounds(): [number, number, number, number];
        worldResolution(): number;
        /**
         * 是否为互联网地图底图 (选项中设置了mapBounds的为cad底图，没设置mapBounds的为互联网底图)
         */
        isWebBaseMap(): boolean;
        clip(): void;
        /**
         * Set the root of the map view.
         *
         * Is set by the constructor by default, can be changed in runtime.
         *
         * @param root - Map node to be used as root.
         */
        setRoot(root: (MapNode | number)): void;
        /**
         * Pre-subdivide map tree to create nodes of levels not available in the provider.
         *
         * Checks for the minimum zoom level in the providers attached to the map view.
         */
        preSubdivide(): void;
        /**
         * Change the map provider of this map view.
         *
         * Will discard all the tiles already loaded using the old provider.
         */
        setProvider(provider: MapProvider): void;
        /**
         * Change the map height provider of this map view.
         *
         * Will discard all the tiles already loaded using the old provider.
         */
        setHeightProvider(heightProvider: MapProvider): void;
        /**
         * Clears all tiles from memory and reloads data. Used when changing the provider.
         *
         * Should be called manually if any changed to the provider are made without setting the provider.
         */
        clear(): any;
        /**
         * Get the minimum zoom level available in the providers attached to the map view.
         *
         * @returns Minimum zoom level available.
         */
        minZoom(): number;
        /**
         * Get the maximum zoom level available in the providers attached to the map view.
         *
         * @returns Maximum zoom level available.
         */
        maxZoom(): number;
        raycast(raycaster: Raycaster, intersects: any[]): boolean;
    }

    /**
     * 地图对象实体
     */
    export declare class MapViewEntity extends MeshEntity {
        map: MapView;
        constructor(mapOptions: MapViewOption, meshOptions?: MapViewEntityOptions);
        /**
         * 地图坐标转局部世界坐标
         */
        mapToLocal(point: [number, number]): Vector3;
        /**
         * 局部世界坐标转地图坐标
         */
        localToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 地图坐标转世界坐标
         */
        mapToWorld(lngLat: [number, number]): Vector3;
        /**
         * 世界坐标转地图坐标
         */
        worldToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转局部世界坐标
         */
        lngLatToLocal(lngLat: [number, number]): Vector3;
        /**
         * 局部世界坐标转经纬度
         */
        localToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转世界坐标
         */
        lngLatToWorld(lngLat: [number, number]): Vector3;
        /**
         * 世界坐标转经纬度
         */
        worldToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
        /**
         * 经纬度转归一化的坐标, 先会把经纬度转墨卡托，然后根据最开始的[瓦片缩级别，行，列]rootTile的范围，归一化到0-1范围区间
         */
        lngLatToNormalize(lngLat: [number, number]): [number, number];
        getMapBounds(): [number, number, number, number];
        worldResolution(): number;
        /**
         * 是否为互联网地图底图 (选项中设置了mapBounds的为cad底图，没设置mapBounds的为互联网底图)
         */
        isWebBaseMap(): boolean;
        clip(): void;
        /**
         * Set the root of the map view.
         *
         * Is set by the constructor by default, can be changed in runtime.
         *
         * @param root - Map node to be used as root.
         */
        setRoot(root: (MapNode | number)): void;
        /**
         * Pre-subdivide map tree to create nodes of levels not available in the provider.
         *
         * Checks for the minimum zoom level in the providers attached to the map view.
         */
        preSubdivide(): void;
        /**
         * Change the map provider of this map view.
         *
         * Will discard all the tiles already loaded using the old provider.
         */
        setProvider(provider: MapProvider): void;
        /**
         * Change the map height provider of this map view.
         *
         * Will discard all the tiles already loaded using the old provider.
         */
        setHeightProvider(heightProvider: MapProvider): void;
        /**
         * Clears all tiles from memory and reloads data. Used when changing the provider.
         *
         * Should be called manually if any changed to the provider are made without setting the provider.
         */
        clear(): any;
        /**
         * Get the minimum zoom level available in the providers attached to the map view.
         *
         * @returns Minimum zoom level available.
         */
        minZoom(): number;
        /**
         * Get the maximum zoom level available in the providers attached to the map view.
         *
         * @returns Maximum zoom level available.
         */
        maxZoom(): number;
    }

    declare interface MapViewEntityOptions extends MeshEntityOptions {
        /** 自动把设置当前地图 默认true*/
        autoSetAppCurrentMapView?: boolean;
        /** 禁止射线查询 默认true*/
        disableRayQuery?: boolean;
    }

    declare interface MapViewOption {
        root?: number | MapNode;
        provider: MapProvider;
        heightProvider?: MapProvider;
        heightScale?: number;
        skirtDepthScale?: number;
        baseScale?: number;
        mapBounds?: [number, number, number, number];
        clipPolygon?: [number, number][] | Shape_2;
        isUseClipOuter?: boolean;
        isAfterRenderClearStencil?: boolean;
        lod?: {
            subdivisionRays?: number;
            /**
             * Threshold to subdivide the map tiles. 缺省 0.6
             *
             * Lower value will subdivide earlier (less zoom required to subdivide).
             */
            thresholdUp?: number;
            /**
             * Threshold to simplify the map tiles. 缺省 0.15
             *
             * Higher value will simplify earlier.
             */
            thresholdDown?: number;
            /**
             * Consider the distance powered to level of the node. 缺省false
             */
            powerDistance?: boolean;
            /**
             * Consider the scale of the node when calculating the distance.. 缺省false
             *
             * If distance is not considered threshold values should be absolute distances.
             */
            scaleDistance?: boolean;
        };
        useScheduler?: boolean;
        polygonOffset?: boolean;
        polygonOffsetFactor?: number;
        polygonOffsetUnits?: number;
    }

    /**
     * 2d的html的标记
     */
    export declare class Marker2D extends CSS2DObject {
        #private;
        app: App;
        _anchor: Anchor;
        _offset: [number, number];
        _element: HTMLElement;
        _color?: string;
        _scale: number;
        _defaultMarker: boolean;
        _draggable: boolean;
        _rotation: number;
        _clickTolerance: number;
        _isDragging: boolean;
        _state: 'inactive' | 'pending' | 'active';
        _pointerdownPos?: Vector2;
        _unProjectOpts: UnProjectOpts;
        _allowOverlap: boolean;
        _options: Marker2dOptions;
        _opacity: string;
        _occlusion: boolean;
        _popup?: Popup2D;
        _originalTabIndex?: string;
        signal: {
            dragstart: Signal;
            drag: Signal;
            dragend: Signal;
            click: Signal;
            occlusion: Signal;
            elementSizeReady: Signal;
            onAdd: Signal;
            onRemove: Signal;
        };
        isMarker2D: boolean;
        constructor(options?: Marker2dOptions);
        isShow(): boolean;
        show(): void;
        hide(): void;
        /**
         * 获取位置
         *
         */
        getPosition(): Vector3;
        /**
         * 设置位置
         *
         */
        setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): void;
        _onKeyPress(e: KeyboardEvent): void;
        togglePopup(): this;
        setPopup(popup?: Popup2D): this;
        /**
         * 增加至应用或实体中
         *
         */
        addTo(app: App | Entity | Object3D, curApp?: App): this;
        /**
         * 获取元素对象
         *
         */
        getElement(): Element;
        /**
         * 得到透明度
         *
         */
        getOpacity(): number;
        /**
         * 设置透明度
         *
         */
        setOpacity(opacity: string | number): void;
        _onMapClick(e: InteractiveEvent): void;
        _onMove(e: InteractiveEvent): void;
        _onUp(): void;
        _addDragHandler(e: InteractiveEvent): void;
        /**
         * 设置是否允许重叠
         */
        setAllowOverlap(allowOverlap: boolean): void;
        getBoundingRect(): {
            x1: number;
            y1: number;
            x2: number;
            y2: number;
            cx: number;
            cy: number;
            rotation: number;
            position: Vector3;
            zIndex: number;
            id: string;
            groupName: string;
            setVisible: (visible: any) => void;
        };
        /**
         * 是否允许重叠
         */
        isAllowOverlap(): boolean;
        /**
         * 设置是否可拖动
         *
         */
        setDraggable(shouldBeDraggable: boolean): this;
        /**
         * 是否可拖动
         *
         */
        isDraggable(): boolean;
        /**
         * 移除
         *
         */
        remove(...object: Object3D<Object3DEventMap>[]): this;
        /**
         * 设置动画
         * @param animationType
         * MAP_ANIMATION_NONE 无动画
         * MAP_ANIMATION_BOUNCE 弹跳
         * MAP_ANIMATION_DROP 坠落
         */
        setAnimation(animationType: "MAP_ANIMATION_NONE" | "MAP_ANIMATION_BOUNCE" | "MAP_ANIMATION_DROP" | ""): void;
        /**
         * 设置光标
         * @param cur 光标名称
         */
        setCursor(cur: string): void;
    }

    export declare interface Marker2dOptions {
        /** html元素 */
        element?: HTMLElement;
        /** 图片 element为空时有效*/
        image?: {
            /** 图像地址，可以是svg */
            src: string;
            /** 宽 */
            width?: number;
            /** 高 */
            height?: number;
        };
        /** 偏移像素量 */
        offset?: [number, number];
        /** 位置  */
        position?: [number, number, number] | Vector3;
        /** 对齐方式 */
        anchor?: Anchor;
        /** 颜色 */
        color?: string;
        /** 缩放比例 */
        scale?: number;
        /** 是否可拖动 默认xz平面（地图模式xy平面), 按shift键捕捉到实体 按ctrl键垂直于相机平面的位置点 */
        draggable?: boolean;
        /** 旋转角度(0-360) */
        rotation?: number;
        /** 点击拖动时超过此距离即以为是开始拖动 */
        clickTolerance?: number;
        /** 是否允许重叠 默认是 */
        allowOverlap?: boolean;
        /** 碰撞检测时的zindex，值越大，越往上 */
        collideZIndex?: number;
        /** 同一个id会一起显示和隐藏 */
        collideId?: string;
        /** 碰撞监测组名 会对同一个组名内的进行碰撞检测 */
        collideGroupName?: string;
        /** 碰撞检测时，如果有弹出信息框也包括信息框的范围 默认是 */
        collideIncludePopup?: boolean;
        /** 拖动时位置投影选项 */
        dragUnProjectOpts?: UnProjectOpts;
        /** 透明度随相机距离大小 */
        fadeDistance?: number;
        /** 遮挡时的透明度 */
        occlusionOpacity?: number;
        /** 当透明度小于这个值时不响应事件 默认0.1 */
        disableOpacity?: number;
        /** 拖动变化是否以命令执行（可撤销重做) 默认是 */
        dragAsCommand?: boolean;
        /** 开始时隐藏 */
        isHide?: boolean;
    }

    /**
     * 3d的html的标记
     */
    export declare class Marker3D extends Object3D {
        #private;
        private _defaultMarker;
        pixelWidth: number;
        pixelHeight: number;
        _options: Marker3dOptions;
        app: App;
        css3dObject: CSS3DObject | CSS3DSprite;
        maskMesh: Mesh | Sprite;
        _popup?: Popup2D;
        _originalTabIndex?: string;
        _opacity: string;
        _occlusion: boolean;
        signal: {
            click: Signal;
            occlusion: Signal;
            elementSizeReady: Signal;
            onAdd: Signal;
            onRemove: Signal;
        };
        isMarker3D: boolean;
        constructor(options?: Marker3dOptions);
        isShow(): boolean;
        show(): void;
        hide(): void;
        getElement(): HTMLElement;
        updateSize(w?: number, h?: number): void;
        /**
         * 获取位置
         *
         */
        getPosition(): Vector3;
        /**
         * 设置位置
         *
         */
        setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): void;
        /**
         * 更新弹出框信息窗口位置
         *
         */
        updatePopupPosition(): void;
        /**
         * 增加至应用中
         *
         */
        addTo(app: App | Entity | Object3D, curApp?: App): void;
        isCss3dSprite(): boolean;
        togglePopup(): this;
        /**
         * 得到透明度
         *
         */
        getOpacity(): number;
        /**
         * 设置透明度
         *
         */
        setOpacity(opacity: string | number): void;
        _onMapClick(e: InteractiveEvent): void;
        _onKeyPress(e: KeyboardEvent): void;
        setPopup(popup?: Popup2D): this;
        /**
         * 移除
         *
         */
        remove(...object: Object3D<Object3DEventMap>[]): this;
        /**
         * 设置动画
         * @param animationType
         * MAP_ANIMATION_NONE 无动画
         * MAP_ANIMATION_BOUNCE 弹跳
         * MAP_ANIMATION_DROP 坠落
         */
        setAnimation(animationType: "MAP_ANIMATION_NONE" | "MAP_ANIMATION_BOUNCE" | "MAP_ANIMATION_DROP" | ""): void;
        /**
         * 设置光标
         * @param cur 光标名称
         */
        setCursor(cur: string): void;
    }

    export declare interface Marker3dOptions {
        element?: HTMLElement;
        /** 图片 element为空时有效*/
        image?: {
            /** 图像地址，可以是svg */
            src: string;
            /** 宽 */
            width?: number;
            /** 高 */
            height?: number;
        };
        color?: string;
        width?: number;
        height?: number;
        pixelWidth?: number;
        pixelHeight?: number;
        asSprite?: boolean;
        anchor?: Anchor;
        popupAnchor?: Anchor;
        popupOffset?: PopopOffset;
        rotation?: [number, number, number];
        occlude?: boolean;
        occludeMaterial?: Record<string, any>;
        createMaskObject?: boolean;
        disableOpacity?: number;
        fadeDistance?: number;
        occlusionOpacity?: number;
        /** 开始时隐藏 */
        isHide?: boolean;
    }

    /**
     * Marks an object so that it will never be converted to a proxy. Returns the
     * object itself.
     *
     * @example
     * ```js
     * const foo = markRaw({})
     * console.log(isReactive(reactive(foo))) // false
     *
     * // also works when nested inside other reactive objects
     * const bar = reactive({ foo })
     * console.log(isReactive(bar.foo)) // false
     * ```
     *
     * **Warning:** `markRaw()` together with the shallow APIs such as
     * {@link shallowReactive()} allow you to selectively opt-out of the default
     * deep reactive/readonly conversion and embed raw, non-proxied objects in your
     * state graph.
     *
     * @param value - The object to be marked as "raw".
     */
    declare function markRaw<T extends object>(value: T): Raw<T>;

    /**
     * A 3x3 matrix.
     * Authored by {@link http://github.com/schteppe/ schteppe}
     */
    declare class Mat3 {
        /**
         * A vector of length 9, containing all matrix elements.
         */
        elements: number[];
        /**
         * @param elements A vector of length 9, containing all matrix elements.
         */
        constructor(elements?: number[]);
        /**
         * Sets the matrix to identity
         * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
         * @todo Create another function that immediately creates an identity matrix eg. `eye()`
         */
        identity(): void;
        /**
         * Set all elements to zero
         */
        setZero(): void;
        /**
         * Sets the matrix diagonal elements from a Vec3
         */
        setTrace(vector: Vec3): void;
        /**
         * Gets the matrix diagonal elements
         */
        getTrace(target?: Vec3): Vec3;
        /**
         * Matrix-Vector multiplication
         * @param v The vector to multiply with
         * @param target Optional, target to save the result in.
         */
        vmult(v: Vec3, target?: Vec3): Vec3;
        /**
         * Matrix-scalar multiplication
         */
        smult(s: number): void;
        /**
         * Matrix multiplication
         * @param matrix Matrix to multiply with from left side.
         */
        mmult(matrix: Mat3, target?: Mat3): Mat3;
        /**
         * Scale each column of the matrix
         */
        scale(vector: Vec3, target?: Mat3): Mat3;
        /**
         * Solve Ax=b
         * @param b The right hand side
         * @param target Optional. Target vector to save in.
         * @return The solution x
         * @todo should reuse arrays
         */
        solve(b: Vec3, target?: Vec3): Vec3;
        /**
         * Get an element in the matrix by index. Index starts at 0, not 1!!!
         * @param value If provided, the matrix element will be set to this value.
         */
        e(row: number, column: number): number;
        e(row: number, column: number, value: number): void;
        /**
         * Copy another matrix into this matrix object.
         */
        copy(matrix: Mat3): Mat3;
        /**
         * Returns a string representation of the matrix.
         */
        toString(): string;
        /**
         * reverse the matrix
         * @param target Target matrix to save in.
         * @return The solution x
         */
        reverse(target?: Mat3): Mat3;
        /**
         * Set the matrix from a quaterion
         */
        setRotationFromQuaternion(q: Quaternion_2): Mat3;
        /**
         * Transpose the matrix
         * @param target Optional. Where to store the result.
         * @return The target Mat3, or a new Mat3 if target was omitted.
         */
        transpose(target?: Mat3): Mat3;
    }

    /**
     * Defines a physics material.
     */
    declare class Material_2 {
        /**
         * Material name.
         * If options is a string, name will be set to that string.
         * @todo Deprecate this
         */
        name: string;
        /** Material id. */
        id: number;
        /**
         * Friction for this material.
         * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
         */
        friction: number;
        /**
         * Restitution for this material.
         * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
         */
        restitution: number;
        static idCounter: number;
        constructor(options?: {
            /**
             * Friction for this material.
             * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
             */
            friction?: number;
            /**
             * Restitution for this material.
             * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
             */
            restitution?: number;
        } | string);
    }

    export declare type MaterialConstructor = new (opts: {
        [key: string]: any;
    }) => Material;

    declare type MaterialOptions = ConstructorParameters<typeof Material_2>[0];

    declare type MaterialParams<T extends MaterialConstructor> = ConstructorParameters<T>[0];

    declare namespace matrix {
        export {
            create,
            identity,
            copy,
            mul,
            translate,
            rotate,
            scale,
            invert,
            clone,
            MatrixArray
        }
    }

    declare type MatrixArray = number[];

    /**
     * 求两个向量最大值
     */
    declare function max<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

    /**
     *
     * Returns highest value out of 2 supplied
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    export declare function max2(a: any, b: any): any;

    /**
     * Returns highest value out of 3 supplied
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @returns {number}
     */
    export declare function max3(a: any, b: any, c: any): any;

    export declare function maxNumberToInfinity(value: number): number;

    /** 求一个数组的最大值 */
    export declare function maxValue(arr: number[]): number;

    declare type MaybeRef<T = any> = T | Ref<T>;

    declare type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T);

    /**
     * 测量要绘制元素的矩形大小
     * @param element 要绘制元素
     * @param maxSize 最大的大小，默认20000
     * @returns
     */
    declare const measureBoundingRect: (element: Element_2 | Element_2[], maxSize?: number) => BoundingRect;

    export declare interface MeasureRulerOptions {
        /** 标尺起始点 */
        startPoint: Vector3 | [number, number, number];
        /** 标尺结束点 */
        endPoint: Vector3 | [number, number, number];
        /** 标尺所在平面的另外一点，默认原心(0,0,0) */
        planePoint?: Vector3 | [number, number, number];
        /** 标尺线样式 */
        rulerLineStyle?: LineMaterialParameters_2;
        /**两侧线样式 */
        sideLineStyle?: LineMaterialParameters_2;
        /** 两侧线长度, 为零不显示 */
        sideLineLength?: number;
        /** 箭头样式 */
        arrowStyle?: {
            /** 颜色 */
            color?: ColorRepresentation;
            /** 透明度(0-1) */
            opacity?: number;
        };
        /** 箭头长度, 为零不显示 */
        arrowLineLength?: number;
        /** 箭头高度, 为零不显示 */
        arrowLineHeight?: number;
        /** 文本 */
        textStyle?: LabelOptions;
        /** 小数点位数，默认2 */
        fractionDigits?: number;
        /** 自动求坐标的相对于线长度的比例 默认 1/ 15*/
        distRatio?: number;
        /** 自动转换为地图坐标 默认true */
        autoFromWorld?: boolean;
        /** 显示文字回调 */
        showTextCb?: (ptStart: Vector3, ptEnd: Vector3, dist: number, fractionDigits: number) => string;
        /** 设置文字旋转回调 */
        textAngleCb?: (ptStart: Vector3, ptEnd: Vector3, quat: Quaternion) => [
            {
            axis: Vector3 | "x" | "y" | "z";
            angle: number;
        }
        ] | undefined;
    }

    export declare interface MemorizedFunctionColorGenerator {
        type: 'memorizedFunction';
        startGen(memory: any): void;
        genColor(color: Vector4, t: number, memory: any): Vector4;
        toJSON(): FunctionJSON;
        clone(): MemorizedFunctionColorGenerator;
    }

    declare function merge<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overwrite?: boolean): T & S;

    declare function merge<T extends any, S extends any>(target: T, source: S, overwrite?: boolean): T | S;

    /**
     * @param targetAndSources The first item is target, and the rests are source.
     * @param overwrite
     * @return Merged result
     */
    declare function mergeAll(targetAndSources: any[], overwrite?: boolean): any;

    declare function mergeAttributes(attributes: BufferAttribute[]): BufferAttribute;

    declare function mergeGeometries(geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry;

    declare function mergeGroups(geometry: BufferGeometry): BufferGeometry;

    /**
     * Merge multiple paths
     */
    declare function mergePath(pathEls: Path[], opts: PathProps): Path<PathProps>;

    declare function mergeVertices(geometry: BufferGeometry, tolerance?: number): BufferGeometry;

    declare class MeshBVH {
        readonly geometry: BufferGeometry;
        static serialize(bvh: MeshBVH, options?: MeshBVHSerializeOptions): SerializedBVH;
        static deserialize(data: SerializedBVH, geometry: BufferGeometry, options?: MeshBVHDeserializeOptions): MeshBVH;
        constructor(geometry: BufferGeometry, options?: MeshBVHOptions);
        raycast(ray: Ray, materialOrSide: Side | Array<Material> | Material): Array<Intersection>;
        raycastFirst(ray: Ray, materialOrSide: Side | Array<Material> | Material): Intersection;
        intersectsSphere(sphere: Sphere): boolean;
        intersectsBox(box: Box3, boxToMesh: Matrix4): boolean;
        intersectsGeometry(geometry: BufferGeometry, geometryToBvh: Matrix4): boolean;
        closestPointToPoint(point: Vector3, target?: HitPointInfo, minThreshold?: number, maxThreshold?: number): HitPointInfo | null;
        closestPointToGeometry(geometry: BufferGeometry, geometryToBvh: Matrix4, target1?: HitPointInfo, target2?: HitPointInfo, minThreshold?: number, maxThreshold?: number): HitPointInfo | null;
        shapecast(callbacks: {
            intersectsBounds: (box: Box3, isLeaf: boolean, score: number | undefined, depth: number, nodeIndex: number) => ShapecastIntersection | boolean;
            boundsTraverseOrder?: (box: Box3) => number;
        } & ({
            intersectsRange: (triangleOffset: number, triangleCount: number, contained: boolean, depth: number, nodeIndex: number, box: Box3) => boolean;
        } | {
            intersectsTriangle: (triangle: ExtendedTriangle, triangleIndex: number, contained: boolean, depth: number) => boolean | void;
        })): boolean;
        bvhcast(otherBVH: MeshBVH, matrixToLocal: Matrix4, callbacks: ({
            intersectsRanges: (offset1: number, count1: number, offset2: number, count2: number, depth1: number, index1: number, depth2: number, index2: number) => boolean;
        } | {
            intersectsTriangles: (triangle1: ExtendedTriangle, triangle2: ExtendedTriangle, i1: number, i2: number, depth1: number, index1: number, depth2: number, index2: number) => boolean;
        })): boolean;
        traverse(callback: (depth: number, isLeaf: boolean, boundingData: ArrayBuffer, offsetOrSplit: number, count: number) => void, rootIndex?: number): void;
        refit(nodeIndices?: Array<number> | Set<number>): void;
        getBoundingBox(target: Box3): Box3;
    }

    declare interface MeshBVHDeserializeOptions {
        setIndex?: boolean;
    }

    declare class MeshBVHHelper extends Group_2 {
        opacity: number;
        depth: number;
        displayParents: boolean;
        displayEdges: boolean;
        edgeMaterial: LineBasicMaterial;
        meshMaterial: MeshBasicMaterial;
        constructor(mesh: Mesh, depth?: number);
        update(): void;
        get color(): Color;
    }

    declare interface MeshBVHOptions {
        strategy?: SplitStrategy;
        maxDepth?: number;
        maxLeafTris?: number;
        setBoundingBox?: boolean;
        useSharedArrayBuffer?: boolean;
        verbose?: boolean;
        onProgress?: (progress: number) => void;
    }

    declare interface MeshBVHSerializeOptions {
        cloneBuffers?: boolean;
    }

    declare class MeshBVHUniformStruct {
        updateFrom(bvh: MeshBVH): void;
        dispose(): void;
    }

    /**
     * mesh实体
     */
    export declare class MeshEntity extends Entity {
        /**
         * mesh对象
         */
        mesh: Mesh;
        /**
         * 获取最开始的原生材质，为空表示没有修改过
         */
        nativeMaterial: () => Material | Material[];
        /**
         * 获取替换后的正使用的材质，为空表示没有修改过
         */
        useMaterial: () => Material | Material[];
        /**
         * 获取可修改的材质对象
         */
        readonly material: Material | Material[];
        /**
         * 增加模型边框线
         * @param option
         * @param isHideMesh 是否隐藏mesh本身（默认false)
         */
        addEdges: (option?: LineBasicMaterialParameters, isHideMesh?: boolean) => void;
        /**
         * 移除模型边框线
         */
        clearEdges: () => void;
        /**
         * 获取模型边框线
         */
        getEdges: () => any;
        /**
         * 替换材质
         */
        replaceMaterial: (material: Material | Material[]) => void;
        /**
         * 恢复材质
         */
        resetMaterial: () => void;
        /** 设置热力图数据分析材质 */
        setHeatmapDataMaterial: (options: {
            /** 数据 */
            data: {
                x: number;
                y: number;
                z: number;
                /** 值 */
                value: number;
            }[];
            /** x轴分段数 默认20 */
            segmentX?: number;
            /** y轴分段数 默认20 */
            segmentY?: number;
            /** z轴分段数 默认20 */
            segmentZ?: number;
            /** 数据最大值 */
            dataMax?: number;
            /** 数据最小值 */
            dataMin?: number;
            /** 颜色表[值(0-1),颜色]，默认为 [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]] */
            colorMap?: [number, number][];
            /** 颜色表分的总数 默认100 */
            colorCount?: number;
            /** 插值选项 */
            interpolation?: {
                /** 使用反距离权重插值法 */
                useInvDistWeight?: boolean;
                /** 反距离幂指数，用于控制距离和权重之间的关系 缺省值2 */
                power?: number;
                /** 模型 默认 exponential*/
                model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
                /** sigma2是σ²，对应高斯过程的方差参数，也就是这组数据z的距离，方差参数σ²的似然性反映了高斯过程中的误差，并应手动设置。一般设置为 0 ，其他数值设了可能会出空白图 */
                sigma2?: number;
                /** Alpha α对应方差函数的先验值，此参数可能控制钻孔扩散范围,越小范围越大,少量点效果明显，但点多了且分布均匀以后改变该数字即基本无效果了，默认设置为100 */
                alpha?: number;
            };
        }) => Promise<{
            lut: Lut;
            material: ShaderMaterial;
            reset: () => void;
        }>;
        /**
         * 是否高亮
         */
        isHighlight: () => boolean;
        /**
         * 设置高亮
         */
        setHighlight: (color: ColorRepresentation, opacity: number) => {};
        /**
         * 清除高亮
         */
        clearHighlight: () => void;
        /**
         * 获取高亮材质
         */
        highlightMaterial: () => Material | Material[];
        /**
         * 设置透明度
         * @param opacity  透明度0(完全透明)-1(不透明)
         * @param isAccOpacity 是否累加透明度(ture和之前透明度相乘，false直接设置透明度)
         */
        setOpacity: (opacity: number, isAccOpacity?: boolean) => void;
        /**
         * 获取透明度材质
         */
        opacityMaterial: () => Material | Material[];
        constructor(mesh: Mesh, options?: MeshEntityOptions);
    }

    export declare interface MeshEntityOptions extends EntityOptions {
        selected?: boolean;
        bloom?: boolean;
        outline?: boolean;
    }

    export declare class MeshLine extends Mesh<MeshLineGeometry, MeshLineMaterial> {
        readonly isMeshLine = true;
        readonly type = "MeshLine";
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
    }

    export declare class MeshLineGeometry extends BufferGeometry {
        #private;
        readonly isMeshLineGeometry = true;
        readonly type = "MeshLineGeometry";
        /**
         * A callback to be called for each point to determine the width of the line
         * at that point. Although `setPoints` accepts this function as an argument,
         * this has to be a public property so it can be used as a prop in
         * react-three-fiber.
         */
        widthCallback: ((point: number, index: number) => number) | null;
        smooth?: boolean;
        curvePointNum?: number;
        curvePointPosRatio?: number;
        attributes: Partial<{
            position: Float32BufferAttribute;
            previous: Float32BufferAttribute;
            next: Float32BufferAttribute;
            side: Float32BufferAttribute;
            width: Float32BufferAttribute;
            uv: Float32BufferAttribute;
            counters: Float32BufferAttribute;
            index: Uint16BufferAttribute;
        }>;
        /**
         * As an alternative to meshLine.setPoints(points), we can set
         * meshLine.points = points. This was added for and is public for use as a
         * prop in react-three-fiber.
         */
        get points(): Vector3[] | WritableArrayLike<number>;
        set points(value: Vector3[] | WritableArrayLike<number>);
        setPoints(points: Array<Vector3> | WritableArrayLike<number>, widthCallback?: ((point: number, index: number) => number) | null, smooth?: boolean, updateBounds?: boolean): void;
        /**
         * Fast method to advance the line by one position.  The oldest position is removed.
         */
        advance(position: Vector3): void;
    }

    export declare class MeshLineMaterial extends ShaderMaterial {
        readonly isMeshLineMaterial = true;
        readonly type = "MeshLineMaterial";
        uniforms: (typeof UniformsLib)['fog'] & {
            lineWidth: IUniform<number>;
            map: IUniform<Texture | null>;
            useMap: IUniform<boolean>;
            alphaMap: IUniform<Texture | null>;
            useAlphaMap: IUniform<boolean>;
            color: IUniform<Color>;
            opacity: IUniform<number>;
            resolution: IUniform<Vector2>;
            sizeAttenuation: IUniform<boolean>;
            dashArray: IUniform<number>;
            dashOffset: IUniform<number>;
            dashRatio: IUniform<number>;
            useDash: IUniform<boolean>;
            visibility: IUniform<number>;
            alphaTest: IUniform<number>;
            repeat: IUniform<Vector2>;
            offset: IUniform<Vector2>;
            time: IUniform<Vector4>;
            speed: IUniform<Vector2>;
        };
        constructor(parameters: ShaderMaterialParameters & MeshLineMaterial);
        copy(source: MeshLineMaterial): this;
    }

    export declare interface MeshLineMaterial {
        fogColor: Color;
        fogDensity: number;
        fogNear: number;
        fogFar: number;
        lineWidth: number;
        map: Texture;
        useMap: boolean;
        alphaMap: Texture;
        useAlphaMap: boolean;
        color: Color;
        opacity: number;
        resolution?: Vector2 | {
            value: Vector2;
        };
        sizeAttenuation: boolean;
        dashArray: number;
        dashOffset: number;
        dashRatio: number;
        useDash: boolean;
        visibility: number;
        alphaTest: number;
        repeat: Vector2;
        offset: Vector2;
        time?: Vector4 | {
            value: Vector4;
        };
        speed: Vector2;
    }

    /**
     * mesh模块
     */
    export declare class MeshModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        constructor(entity: Entity, options?: MeshModuleOption);
        /**
         * mesh对象
         */
        get mesh(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
        /**
         * 获取最开始的原生材质，为空表示没有修改过
         */
        rawMaterial(): any;
        /**
         * 获取替换后的正使用的材质，为空表示没有修改过
         */
        useMaterial(): any;
        /**
         * 获取可修改的材质对象
         */
        get material(): any;
        /**
         * 增加模型边框线
         * @param option
         * @param isHideMesh 是否隐藏mesh本身（默认false)
         */
        addEdges(option?: LineBasicMaterialParameters, isHideMesh?: boolean): void;
        /**
         * 移除模型边框线
         */
        clearEdges(): void;
        /**
         * 获取模型边框线
         */
        getEdges(): any;
        /**
         * 替换材质
         */
        replaceMaterial(material: Material | Material[]): void;
        /**
         * 恢复材质
         */
        resetMaterial(): void;
        /** 设置热力图数据分析材质 */
        setHeatmapDataMaterial(options: {
            /** 数据 */
            data: {
                x: number;
                y: number;
                z: number;
                /** 值 */
                value: number;
            }[];
            /** x轴分段数 默认10 */
            segmentX?: number;
            /** y轴分段数 默认10 */
            segmentY?: number;
            /** z轴分段数 默认10 */
            segmentZ?: number;
            /** 数据最大值 */
            dataMax?: number;
            /** 数据最小值 */
            dataMin?: number;
            /** 颜色表[值(0-1),颜色]，默认为 [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]] */
            colorMap?: [number, number][];
            /** 颜色表分的总数 默认100 */
            colorCount?: number;
            /** 插值选项 */
            interpolation?: {
                /** 使用反距离权重插值法 */
                useInvDistWeight?: boolean;
                /** 反距离幂指数，用于控制距离和权重之间的关系 缺省值2 */
                power?: number;
                /** 模型 默认 exponential*/
                model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
                /** sigma2是σ²，对应高斯过程的方差参数，也就是这组数据z的距离，方差参数σ²的似然性反映了高斯过程中的误差，并应手动设置。一般设置为 0 ，其他数值设了可能会出空白图 */
                sigma2?: number;
                /** Alpha α对应方差函数的先验值，此参数可能控制钻孔扩散范围,越小范围越大,少量点效果明显，但点多了且分布均匀以后改变该数字即基本无效果了，默认设置为100 */
                alpha?: number;
            };
            /** 材质参数 */
            MaterialParameters?: ShaderMaterialParameters;
        }): Promise<{
            lut: Lut;
            material: ShaderMaterial;
            reset: () => void;
        }>;
        /**
         * 是否高亮
         */
        isHighlight(): boolean;
        /**
         * 设置高亮
         */
        setHighlight(color?: ColorRepresentation, opacity?: number): void;
        /**
         * 清除高亮
         */
        clearHighlight(): void;
        /**
         * 获取高亮材质
         */
        highlightMaterial(): any;
        /**
         * 设置透明度
         * @param opacity  透明度0(完全透明)-1(不透明)
         * @param isAccOpacity 是否累加透明度(ture和之前透明度相乘，false直接设置透明度)
         */
        setOpacity(opacity: number, isAccOpacity?: boolean): void;
        /**
         * 获取透明度材质
         */
        opacityMaterial(): any;
        onDestroy(): void;
        toJSON(): {
            mesh: {
                uuid: string;
            };
        };
        fromJSON(data: Record<string, any>, objects: Map<string, Object3D>): void;
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            app: App;
            children: ({
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
                value?: undefined;
                bounds?: undefined;
                stepSize?: undefined;
                onChange?: undefined;
            } | {
                type: string;
                label: string;
                value: number;
                bounds: number[];
                stepSize: number;
                onChange: (v: any) => void;
                getValue?: undefined;
                setValue?: undefined;
            } | {
                type: string;
                label: string;
                value: boolean;
                onChange: (v: any) => void;
                getValue?: undefined;
                setValue?: undefined;
                bounds?: undefined;
                stepSize?: undefined;
            } | {
                type: string;
                label: string;
                getValue: () => number;
                setValue: (v: any) => void;
                value?: undefined;
                bounds?: undefined;
                stepSize?: undefined;
                onChange?: undefined;
            })[];
        };
    }

    export declare interface MeshModuleOption {
        mesh: Mesh;
    }

    export declare interface MeshPhysicsObject {
        body?: CANNON.Body | PhysicsBodyOption;
        type?: ShapeType2;
        copyPosition?: boolean;
        copyQuaternion?: boolean;
    }

    export declare interface MeshPhysicsObjectParams extends MeshPhysicsObject {
        mesh: Object3D | Entity;
    }

    /**
     * A material for reflection, which has blur support.
     */
    export declare class MeshReflectorMaterial {
        app: App;
        parent: Mesh;
        material: MeshReflectorMaterialImpl;
        virtualCamera: PerspectiveCamera;
        fbo1: WebGLRenderTarget;
        fbo2: WebGLRenderTarget;
        blurpass: BlurPass;
        hasBlur: boolean;
        ignoreObjects: Object3D[];
        beforeRender: () => void;
        constructor(app: App, parent: Mesh, config?: Partial<MeshReflectorMaterialConfig & MeshStandardMaterialParameters>);
        update(): void;
    }

    declare class MeshReflectorMaterial2 {
        #private;
        parent: Mesh;
        ignoreObjects: Object3D[];
        _camera: PerspectiveCamera;
        reflectPlane: Plane;
        _reflectMatrix: Matrix4;
        _renderTexture: any;
        mipmapper: any;
        mirrorFBO: WebGLRenderTarget;
        mipmapFBO: any;
        app: App;
        scene: Scene;
        constructor(app: App, parent: Mesh, config?: Partial<MeshReflectorMaterialConfig2>);
        dispose(): void;
        update(): void;
        beforeRender(): void;
    }

    export declare interface MeshReflectorMaterialConfig {
        resolution: number;
        mixBlur: number;
        mixStrength: number;
        blur: [number, number] | number;
        mirror: number;
        ignoreObjects: Object3D[];
    }

    declare interface MeshReflectorMaterialConfig2 {
        resolution?: number;
        ignoreObjects?: Object3D[];
        includeObjects?: Object3D[];
    }

    declare class MeshReflectorMaterialImpl extends MeshStandardMaterial {
        _tDepth: UninitializedUniform<Texture>;
        _distortionMap: UninitializedUniform<Texture>;
        _tDiffuse: UninitializedUniform<Texture>;
        _tDiffuseBlur: UninitializedUniform<Texture>;
        _textureMatrix: UninitializedUniform<Matrix4>;
        _hasBlur: {
            value: boolean;
        };
        _mirror: {
            value: number;
        };
        _mixBlur: {
            value: number;
        };
        _blurStrength: {
            value: number;
        };
        _minDepthThreshold: {
            value: number;
        };
        _maxDepthThreshold: {
            value: number;
        };
        _depthScale: {
            value: number;
        };
        _depthToBlurRatioBias: {
            value: number;
        };
        _distortion: {
            value: number;
        };
        _mixContrast: {
            value: number;
        };
        constructor(parameters?: {});
        onBeforeCompile(shader: any): void;
        get tDiffuse(): Texture | null;
        set tDiffuse(v: Texture | null);
        get tDepth(): Texture | null;
        set tDepth(v: Texture | null);
        get distortionMap(): Texture | null;
        set distortionMap(v: Texture | null);
        get tDiffuseBlur(): Texture | null;
        set tDiffuseBlur(v: Texture | null);
        get textureMatrix(): Matrix4 | null;
        set textureMatrix(v: Matrix4 | null);
        get hasBlur(): boolean;
        set hasBlur(v: boolean);
        get mirror(): number;
        set mirror(v: number);
        get mixBlur(): number;
        set mixBlur(v: number);
        get mixStrength(): number;
        set mixStrength(v: number);
        get minDepthThreshold(): number;
        set minDepthThreshold(v: number);
        get maxDepthThreshold(): number;
        set maxDepthThreshold(v: number);
        get depthScale(): number;
        set depthScale(v: number);
        get depthToBlurRatioBias(): number;
        set depthToBlurRatioBias(v: number);
        get distortion(): number;
        set distortion(v: number);
        get mixContrast(): number;
        set mixContrast(v: number);
    }

    export declare interface MeshReflectorOptions extends MeshReflectorMaterialConfig2 {
        color?: ColorRepresentation;
        speed?: number;
        intensity?: number;
    }

    export declare interface MeshSettings {
        /**
         * Rotation axis.
         * @type {Vector3}
         */
        rotationAxis?: Vector3;
        /**
         * Initial rotation around the X-axis.
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startRotationX: ValueGenerator | FunctionValueGenerator;
        /**
         * Initial rotation around the Y-axis.
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startRotationY: ValueGenerator | FunctionValueGenerator;
        /**
         * Initial rotation around the Z-axis.
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startRotationZ: ValueGenerator | FunctionValueGenerator;
    }

    /**
     * A particle emitter that emits particles from the surface of a mesh uniformly.
     */
    export declare class MeshSurfaceEmitter implements EmitterShape {
        type: string;
        private _triangleIndexToArea;
        private _geometry?;
        get geometry(): BufferGeometry | undefined;
        set geometry(geometry: BufferGeometry | undefined);
        constructor(geometry?: BufferGeometry);
        private _tempA;
        private _tempB;
        private _tempC;
        initialize(p: Particle): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any, meta: JsonMetaData): MeshSurfaceEmitter;
        clone(): EmitterShape;
        update(system: ParticleSystem, delta: number): void;
    }

    /**
     * Reference: https://blog.maximeheckel.com/posts/refraction-dispersion-and-other-shader-light-effects/
     */
    export declare class MeshTransmissionMaterial {
        fbo: WebGLRenderTarget;
        fboBack: WebGLRenderTarget;
        material: ShaderMaterial;
        parent: Mesh;
        backside: boolean;
        background: Texture | Color | null;
        oldBg: Texture | Color | null;
        app: App;
        constructor(app: App, parent: Mesh, config?: Partial<MeshTransmissionMaterialConfig>);
        update(): void;
    }

    export declare interface MeshTransmissionMaterialConfig {
        backside: boolean;
        samples: number;
        background: Texture | Color | null;
        chromaticAberration: number;
        refraction: number;
        saturation: number;
        lightPosition: Vector3;
        diffuse: number;
        specular: number;
        fresnel: number;
        fresnelColor: Color;
    }

    /**
     * Interface representing metadata used in Threejs object toJSON method.
     */
    export declare interface MetaData {
        geometries: {
            [key: string]: any;
        };
        materials: {
            [key: string]: any;
        };
        textures: {
            [key: string]: any;
        };
        images: {
            [key: string]: any;
        };
        shapes: {
            [key: string]: any;
        };
        skeletons: {
            [key: string]: any;
        };
        animations: {
            [key: string]: any;
        };
        nodes: {
            [key: string]: any;
        };
    }

    declare interface Methods {
        GET: "GET";
        POST: "POST";
        PUT: "PUT";
        DELETE: "DELETE";
        PATCH: "PATCH";
        OPTIONS: "OPTIONS";
        HEAD: "HEAD";
    }

    /**
     * 求两个向量最小值
     */
    declare function min<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

    /**
     * Returns lowest value out of 2 supplied
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    export declare function min2(a: any, b: any): any;

    /**
     * Returns lowest value out of 3 supplied
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @returns {number}
     */
    export declare function min3(a: any, b: any, c: any): any;

    /** 小地图控件 */
    export declare class MiniMapControl {
        private container;
        private panel;
        private app;
        private readonly style;
        options: MiniMapControlOption;
        private _miniMapRenderer;
        private mapRotateZ;
        private _miniMapDomEl;
        private _miniMapCamera;
        private mapSyncRotateZ;
        private followTarget;
        constructor(options?: MiniMapControlOption);
        setFollowTarget(followTarget: Object3D): void;
        insertControl(): void;
        updateCamera(): void;
        onAdd(app: App): HTMLElement;
        onUpdate(): void;
        onRemove(): void;
        getDefaultPosition(): string;
    }

    export declare interface MiniMapControlOption {
        /** 背景样式 */
        bkDivStyle?: {
            border: string;
            backgroundColor: string;
        };
        /** 背景样式 */
        mapDivStyle?: Partial<CSSStyleDeclaration>;
        /** 节流时间 ms*/
        throttleTime?: number;
        /** 主场景 默认用应用的场景 */
        scene?: Scene;
        /** 主场景 地图以之为中心点的3D目标 */
        followTarget?: Object3D;
        /** 跟随目标时相机高度 默认10*/
        followTargetCameraHeight?: number;
        /** 决定了摄像机看到的内容大小，默认10 */
        mapSize?: number;
        /** 决定了小地图2D平面的大小，默认200 */
        mapRenderSize?: number;
        /** 小地图沿着Z轴（垂直屏幕）旋转角度，默认0 */
        mapRotateZ?: number;
        /** 小地图沿着Z轴（垂直屏幕）是否跟着一同target旋转，默认false */
        mapSyncRotateZ?: boolean;
        /** 渲染参数 */
        rendererParameters?: WebGLRendererParameters;
        /** 是否可使用阴影 默认是*/
        shadowMapEnabled?: boolean;
        /** 相机选项，默认正交相机 */
        cameraOption?: CameraOptions;
        /** 相机更新回调 如果返回true将不调用默认的行为 */
        cameraUpdate?: (camera: Camera, target?: Object3D, context?: any) => boolean;
    }

    /** 求一个数组的最小值 */
    export declare function minValue(arr: number[]): number;

    declare function mixin<T, S>(target: T | Function, source: S | Function, override?: boolean): void;

    /**
     * Check if the browser is running on a mobile or tablet device.
     */
    export declare function mobileAndTabletCheck(): boolean;

    /**
     * 模型模块
     */
    export declare class ModelModule extends EntityModuleBase implements IEntityModuleBase {
        static moduleName: string;
        modelEntity: Entity;
        signal: {
            onLoad: Signal;
            onError: Signal;
        };
        constructor(entity: Entity, options?: ModelModuleOptions);
        /** 获取所有Mesh实体 */
        getMeshEntities(): any[];
    }

    /**
     * 模型选项
     */
    export declare interface ModelModuleOptions extends ILoadModelOption {
        url: string;
    }

    /**
     * @param color
     * @param alpha 0 ~ 1
     * @return Color string in rgba format.
     * @memberOf module:render2d/util/color
     */
    declare function modifyAlpha(color: string, alpha?: number): string;

    /**
     * @param color
     * @param h 0 ~ 360, ignore when null.
     * @param s 0 ~ 1, ignore when null.
     * @param l 0 ~ 1, ignore when null.
     * @return Color string in rgba format.
     * @memberOf module:render2d/util/color
     */
    declare function modifyHSL(color: string, h?: number, s?: number, l?: number): string;

    export declare class ModuleBase extends AppObject {
        private _awoken;
        private _phasedActive;
        private _enabled;
        appRenderIndex: number;
        static moduleName: string;
        /**
         * Indicates whether the component is enabled.
         */
        get enabled(): boolean;
        set enabled(value: boolean);
    }

    /**
     * 模块管理
     */
    export declare class ModuleManager {
        modules: Map<string, ModuleBase[]>;
        private readonly _isApp;
        private readonly _orderDirty;
        constructor(isApp?: boolean);
        addModule(module: ModuleBase): void;
        getModules(methodName: string): ModuleBase[];
        callModules(methodName: string, ...args: any): void;
        removeModule(module: ModuleBase): void;
    }

    /**
     * Morphing from old path to new path.
     */
    declare function morphPath(fromPath: Path, toPath: Path, animationOpts: ElementAnimateConfig): Path;

    declare namespace morphPathTool {
        export {
            alignBezierCurves,
            centroid,
            isCombineMorphing,
            isMorphing,
            morphPath,
            combineMorph,
            separateMorph,
            CombineMorphingPath,
            DividePathParams,
            DividePath,
            IndividualDelay,
            CombineConfig,
            SeparateConfig,
            split as defaultDividePath
        }
    }

    export declare type Motion<T> = {
        [key in keyof FilteredType<T>]: FilteredType<T>[key];
    };

    /**
     * Interface for configuring motion animations in a Tween.
     * You can specify easing, callback functions, and progress tracking functions.
     * @template T - The type of the target object being tweened.
     */
    export declare interface MotionConfig<T = any> {
        /** The easing function to control the animation's progression. */
        easing?: Easing;
        /**
         * A callback function to execute when the animation completes.
         * @param target - The target object that was tweened.
         * @param isEnd 是否整个动画都结束了
         * @param isStop 是否强制终止了
         */
        onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
        /**
         * A callback function to execute when the animation starts.
         * @param target - The target object that is being tweened.
         */
        onStart?: (target: T) => void;
        /**
         * A callback function to be executed after each property has been updated.
         * @param target - The target object that is being tweened.
         */
        onUpdate?: (target: T) => void;
        /**
         * A callback function to be executed before each property is updated.
         * @param target - The target object that is being tweened.
         * @param key - The key or property being animated.
         * @param start - The initial value of the animated property.
         * @param end - The final value of the animated property.
         * @param alpha - The current animation progress as a normalized value (0 to 1).
         * @param reversed - 是否反向
         * @returns If `false`, will not assign a new value to the property.
         */
        onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
    }

    declare const MOUSE_BUTTON: {
        readonly LEFT: 1;
        readonly RIGHT: 2;
        readonly MIDDLE: 4;
    };

    declare type MOUSE_BUTTON = typeof MOUSE_BUTTON[keyof typeof MOUSE_BUTTON];

    declare type mouseButtonAction = typeof ACTION.ROTATE | typeof ACTION.TRUCK | typeof ACTION.OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

    declare interface MouseButtons {
        left: mouseButtonAction;
        middle: mouseButtonAction;
        right: mouseButtonAction;
        wheel: mouseWheelAction;
    }

    /** 鼠标位置控件 */
    export declare class MousePositionControl {
        #private;
        private readonly digits;
        private readonly trackCenter;
        private readonly labelFormat;
        private container;
        private panel;
        private app;
        private readonly style;
        private unProjectModes?;
        constructor(options?: MousePositionControlOption);
        insertControl(): void;
        defaultLabelFormat(x: number, y: number, z: number): string;
        onMouseMove(evt?: any): Promise<void>;
        onAdd(app: App): HTMLElement;
        onRemove(): void;
        getDefaultPosition(): string;
    }

    export declare interface MousePositionControlOption {
        digits?: number;
        trackCenter?: boolean;
        labelFormat?: (x: number, y: number, z: number, context: MousePositionControl, retIntersectObject?: any) => string;
        style?: {
            border: string;
            backgroundColor: string;
        };
        UnProjectModes?: (UnProjectOpts | "depth")[];
    }

    declare type mouseWheelAction = typeof ACTION.ROTATE | typeof ACTION.TRUCK | typeof ACTION.OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

    /**
     * 矩阵相乘
     */
    declare function mul(out: MatrixArray, m1: MatrixArray, m2: MatrixArray): MatrixArray;

    /**
     * 向量乘法
     */
    declare function mul_2<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

    export declare class MultiCmdsCommand extends BaseCommand {
        private commands;
        constructor(commands: ICommand[]);
        execute(): void;
        undo(): void;
        redo(): void;
        addCommand(cmd: ICommand | ICommand[]): void;
        execCommand(cmd: ICommand | ICommand[]): void;
        getCommands(): ICommand[];
    }

    /**
     * 多条线之间根据交点相互分开,返回相交后的所有线段，请确保每条线段不要自相交
     * @param lines
     * @param dotErr 允许误差的小数点后几位，默认6位
     */
    export declare function multiLineSplit(lines: GeoPoint[][], dotErr?: number): GeoPoint[][];

    /**
     * MultiLineString Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.5
     */
    declare interface MultiLineString extends GeometryObject {
        type: "MultiLineString";
        coordinates: Position[][];
    }

    /**
     * MultiPoint Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.3
     */
    declare interface MultiPoint extends GeometryObject {
        type: "MultiPoint";
        coordinates: Position[];
    }

    /**
     * MultiPolygon Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.7
     */
    declare interface MultiPolygon extends GeometryObject {
        type: "MultiPolygon";
        coordinates: Position[][][];
    }

    declare type multiTouchAction = typeof ACTION.TOUCH_DOLLY_ROTATE | typeof ACTION.TOUCH_DOLLY_TRUCK | typeof ACTION.TOUCH_DOLLY_OFFSET | typeof ACTION.TOUCH_ZOOM_ROTATE | typeof ACTION.TOUCH_ZOOM_TRUCK | typeof ACTION.TOUCH_ZOOM_OFFSET | typeof ACTION.TOUCH_DOLLY | typeof ACTION.TOUCH_ZOOM | typeof ACTION.TOUCH_ROTATE | typeof ACTION.TOUCH_TRUCK | typeof ACTION.TOUCH_OFFSET | typeof ACTION.NONE;

    declare type MultiWatchSources = Array<WatchSource<unknown> | object>;

    /**
     * Naive broadphase implementation, used in lack of better ones.
     *
     * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
     */
    declare class NaiveBroadphase extends Broadphase {
        /**
         * @todo Remove useless constructor
         */
        constructor();
        /**
         * Get all the collision pairs in the physics world
         */
        collisionPairs(world: World, pairs1: Body_2[], pairs2: Body_2[]): void;
        /**
         * Returns all the bodies within an AABB.
         * @param result An array to store resulting bodies in.
         */
        aabbQuery(world: World, aabb: AABB, result?: Body_2[]): Body_2[];
    }

    /**
     * Helper class for the World. Generates ContactEquations.
     * @todo Sphere-ConvexPolyhedron contacts
     * @todo Contact reduction
     * @todo should move methods to prototype
     */
    declare class Narrowphase {
        /**
         * Internal storage of pooled contact points.
         */
        contactPointPool: ContactEquation[];
        frictionEquationPool: FrictionEquation[];
        result: ContactEquation[];
        frictionResult: FrictionEquation[];
        /**
         * Pooled vectors.
         */
        v3pool: Vec3Pool;
        world: World;
        currentContactMaterial: ContactMaterial;
        enableFrictionReduction: boolean;
        get [COLLISION_TYPES.sphereSphere](): (si: Sphere_2, sj: Sphere_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => boolean | void;
        get [COLLISION_TYPES.spherePlane](): (si: Sphere_2, sj: Plane_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.boxBox](): (si: Box, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.sphereBox](): (si: Sphere_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.planeBox](): (si: Plane_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.convexConvex](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
        get [COLLISION_TYPES.sphereConvex](): (si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.planeConvex](): (planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.boxConvex](): (si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.sphereHeightfield](): (sphereShape: Sphere_2, hfShape: Heightfield, spherePos: Vec3, hfPos: Vec3, sphereQuat: Quaternion_2, hfQuat: Quaternion_2, sphereBody: Body_2, hfBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.boxHeightfield](): (si: Box, sj: Heightfield, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.convexHeightfield](): (convexShape: ConvexPolyhedron, hfShape: Heightfield, convexPos: Vec3, hfPos: Vec3, convexQuat: Quaternion_2, hfQuat: Quaternion_2, convexBody: Body_2, hfBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.sphereParticle](): (sj: Sphere_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.planeParticle](): (sj: Plane_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.boxParticle](): (si: Box, sj: Particle2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.convexParticle](): (sj: ConvexPolyhedron, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.cylinderCylinder](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
        get [COLLISION_TYPES.sphereCylinder](): (si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.planeCylinder](): (planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.boxCylinder](): (si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.convexCylinder](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
        get [COLLISION_TYPES.heightfieldCylinder](): (hfShape: Heightfield, convexShape: Cylinder, hfPos: Vec3, convexPos: Vec3, hfQuat: Quaternion_2, convexQuat: Quaternion_2, hfBody: Body_2, convexBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.particleCylinder](): (si: Particle2, sj: Cylinder, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.sphereTrimesh](): (sphereShape: Sphere_2, trimeshShape: Trimesh, spherePos: Vec3, trimeshPos: Vec3, sphereQuat: Quaternion_2, trimeshQuat: Quaternion_2, sphereBody: Body_2, trimeshBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        get [COLLISION_TYPES.planeTrimesh](): (planeShape: Plane_2, trimeshShape: Trimesh, planePos: Vec3, trimeshPos: Vec3, planeQuat: Quaternion_2, trimeshQuat: Quaternion_2, planeBody: Body_2, trimeshBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
        constructor(world: World);
        /**
         * Make a contact object, by using the internal pool or creating a new one.
         */
        createContactEquation(bi: Body_2, bj: Body_2, si: Shape, sj: Shape, overrideShapeA?: Shape | null, overrideShapeB?: Shape | null): ContactEquation;
        createFrictionEquationsFromContact(contactEquation: ContactEquation, outArray: FrictionEquation[]): boolean;
        /**
         * Take the average N latest contact point on the plane.
         */
        createFrictionFromAverage(numContacts: number): void;
        /**
         * Generate all contacts between a list of body pairs
         * @param p1 Array of body indices
         * @param p2 Array of body indices
         * @param result Array to store generated contacts
         * @param oldcontacts Optional. Array of reusable contact objects
         */
        getContacts(p1: Body_2[], p2: Body_2[], world: World, result: ContactEquation[], oldcontacts: ContactEquation[], frictionResult: FrictionEquation[], frictionPool: FrictionEquation[]): void;
        sphereSphere(si: Sphere_2, sj: Sphere_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): boolean | void;
        spherePlane(si: Sphere_2, sj: Plane_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        boxBox(si: Box, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        sphereBox(si: Sphere_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        planeBox(si: Plane_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        convexConvex(si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean, faceListA?: number[] | null, faceListB?: number[] | null): true | void;
        sphereConvex(si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        planeConvex(planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean): true | void;
        boxConvex(si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        sphereHeightfield(sphereShape: Sphere_2, hfShape: Heightfield, spherePos: Vec3, hfPos: Vec3, sphereQuat: Quaternion_2, hfQuat: Quaternion_2, sphereBody: Body_2, hfBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        boxHeightfield(si: Box, sj: Heightfield, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        convexHeightfield(convexShape: ConvexPolyhedron, hfShape: Heightfield, convexPos: Vec3, hfPos: Vec3, convexQuat: Quaternion_2, hfQuat: Quaternion_2, convexBody: Body_2, hfBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        sphereParticle(sj: Sphere_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        planeParticle(sj: Plane_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        boxParticle(si: Box, sj: Particle2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        convexParticle(sj: ConvexPolyhedron, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        heightfieldCylinder(hfShape: Heightfield, convexShape: Cylinder, hfPos: Vec3, convexPos: Vec3, hfQuat: Quaternion_2, convexQuat: Quaternion_2, hfBody: Body_2, convexBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        particleCylinder(si: Particle2, sj: Cylinder, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        sphereTrimesh(sphereShape: Sphere_2, trimeshShape: Trimesh, spherePos: Vec3, trimeshPos: Vec3, sphereQuat: Quaternion_2, trimeshQuat: Quaternion_2, sphereBody: Body_2, trimeshBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
        planeTrimesh(planeShape: Plane_2, trimeshShape: Trimesh, planePos: Vec3, trimeshPos: Vec3, planeQuat: Quaternion_2, trimeshQuat: Quaternion_2, planeBody: Body_2, trimeshBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
    }

    declare const nativeSlice: (start?: number, end?: number) => any[];

    /**
     * 求负向量
     */
    declare function negate<T extends VectorArray>(out: T, v: VectorArray): T;

    declare class Node_2 {
        id: string;
        inputs: (Wire | ConstInput | Adapter | undefined)[];
        outputs: Wire[][];
        definition: NodeDef;
        signatureIndex: number;
        data: NodeData;
        position: Vector2;
        outputValues: any[];
        constructor(definition: NodeDef, signatureIndex?: number, data?: NodeData);
        get inputTypes(): NodeValueType[];
        get outputTypes(): NodeValueType[];
        func(context: ExecutionContext, inputs: any[], outputs: any[]): void;
    }
    export { Node_2 as Node }

    export declare type NodeData = {
        [key: string]: any;
    };

    export declare class NodeDef {
        name: string;
        type: NodeType;
        nodeTypeSignatures: NodeTypeSignature[];
        constructor(name: string, type: NodeType);
        addSignature(inputTypes: NodeValueType[], outputTypes: NodeValueType[], func: NodeExecFunction): void;
    }

    declare type NodeExecFunction = (context: ExecutionContext, data: NodeData, inputs: NodeValue[], outputs: NodeValue[]) => void;

    export declare class NodeGraph {
        uuid: string;
        name: string;
        version: string;
        revision: number;
        inputNodes: Node_2[];
        outputNodes: Node_2[];
        allNodes: Map<string, Node_2>;
        wires: Wire[];
        compiled: boolean;
        nodesInOrder: Array<Node_2>;
        constructor(name: string);
        addWire(wire: Wire): void;
        addNode(node: Node_2): void;
        getNode(id: string): Node_2 | undefined;
        deleteNode(node: Node_2): void;
        deleteWire(wire: Wire): void;
        toJSON(): any;
        clone(): NodeGraph;
    }

    /**
     * Particle implementation for node-based particle systems.
     */
    export declare class NodeParticle implements IParticle {
        /**
         * Position of the particle.
         * @type {Vector3}
         */
        position: Vector3;
        /**
         * Velocity of the particle.
         * @type {Vector3}
         */
        velocity: Vector3;
        /**
         * Age of the particle.
         * @type {number}
         */
        age: number;
        /**
         * Life duration of the particle.
         * @type {number}
         */
        life: number;
        /**
         * Size of the particle.
         * @type {number}
         */
        size: number;
        /**
         * Angular velocity of the particle.
         * @type {number | Quaternion}
         */
        angularVelocity?: number | Quaternion;
        /**
         * Rotation of the particle.
         * @type {number | Quaternion}
         */
        rotation: number | Quaternion;
        /**
         * Color of the particle.
         * @type {Vector4}
         */
        color: Vector4;
        /**
         * UV tile index.
         * @type {number}
         */
        uvTile: number;
        /**
         * Indicates if the particle has died.
         * @type {boolean}
         */
        get died(): boolean;
        /**
         * Resets the particle properties to initial values.
         */
        reset(): void;
    }

    export declare enum NodeType {
        Variable = 0,
        Expression = 1,
        Storage = 2,
        Function = 3
    }

    export declare const NodeTypes: {
        [key: string]: NodeDef;
    };

    export declare interface NodeTypeSignature {
        inputTypes: NodeValueType[];
        outputTypes: NodeValueType[];
        func: NodeExecFunction;
    }

    declare type NodeValue = number | boolean | Vector2 | Vector3 | Vector4 | Array<any>;

    export declare enum NodeValueType {
        Number = 0,
        Vec2 = 1,
        Vec3 = 2,
        Vec4 = 3,
        Boolean = 4,
        AnyType = 5,
        NullableAnyType = 6,
        EventStream = 7
    }

    /**
     * NodeVFX represents a node graph based visual effect
     *
     * @class
     */
    export declare class NodeVFX implements IParticleSystem {
        signal: {
            onRestart: Signal;
            onPlay: Signal;
            onPause: Signal;
            onEnd: Signal;
        };
        emissionGraph: NodeGraph;
        updateGraph: NodeGraph;
        interpreter: Interpreter;
        /**
         * Determines whether the ParticleSystem should be automatically disposed when it finishes emitting particles.
         *
         * @type {boolean}
         */
        autoDestroy: boolean;
        /**
         * Determines whether a looping ParticleSystem should prewarm, i.e., the Particle System looks like it has already simulated for one loop when first becoming visible.
         *
         * @type {boolean}
         */
        prewarm: boolean;
        /**
         * Determines whether the ParticleSystem should loop, i.e., restart emitting particles after the duration of the particle system is expired.
         *
         * @type {boolean}
         */
        looping: boolean;
        /**
         * The duration of the ParticleSystem in seconds.
         *
         * @type {number}
         */
        duration: number;
        /**
         * The number of particles in the ParticleSystem.
         *
         * @type {number}
         */
        particleNum: number;
        /**
         * Determines whether the ParticleSystem is paused.
         *
         * @type {boolean}
         */
        paused: boolean;
        /**
         * All the particles in the ParticleSystem.
         *
         * @type {Array<Particle>}
         */
        particles: Array<IParticle>;
        /**
         * the emitter object that should be added in the scene.
         *
         * @type {ParticleEmitter<Object3DEventMap>}
         */
        emitter: ParticleEmitter<Object3DEventMap>;
        /**
         * the VFX renderer settings for the batch renderer
         *
         * @type {VFXBatchSettings}
         */
        rendererSettings: VFXBatchSettings;
        /**
         * whether needs to update renderer settings for the batch renderer
         *
         * @type {boolean}
         */
        neededToUpdateRender: boolean;
        rendererEmitterSettings: {};
        worldSpace: boolean;
        private prewarmed;
        private emissionState;
        private emitEnded;
        private markForDestroy;
        private previousWorldPos?;
        private temp;
        private travelDistance;
        private normalMatrix;
        set time(time: number);
        get time(): number;
        get layers(): Layers;
        get texture(): Texture;
        set texture(texture: Texture);
        get material(): Material;
        set material(material: Material);
        get instancingGeometry(): BufferGeometry;
        set instancingGeometry(geometry: BufferGeometry);
        get renderMode(): RenderMode;
        set renderMode(renderMode: RenderMode);
        get renderOrder(): number;
        set renderOrder(renderOrder: number);
        get blending(): Blending;
        set blending(blending: Blending);
        constructor(parameters: VFXParameters);
        pause(): void;
        play(): void;
        private spawn;
        endEmit(): void;
        dispose(): void;
        restart(): void;
        private update;
        emit(delta: number, emissionState: EmissionState_2, emitterMatrix: Matrix4): void;
        toJSON(meta: any, options?: SerializationOptions): any;
        getRendererSettings(): VFXBatchSettings;
        clone(): IParticleSystem;
        speedFactor: number;
    }

    /**
     * Apply noise to particles.
     */
    export declare class Noise implements Simulation {
        frequency: FunctionValueGenerator | ValueGenerator;
        power: FunctionValueGenerator | ValueGenerator;
        positionAmount: FunctionValueGenerator | ValueGenerator;
        rotationAmount: FunctionValueGenerator | ValueGenerator;
        type: string;
        duration: number;
        constructor(frequency: FunctionValueGenerator | ValueGenerator, power: FunctionValueGenerator | ValueGenerator, positionAmount?: FunctionValueGenerator | ValueGenerator, rotationAmount?: FunctionValueGenerator | ValueGenerator);
        initialize(particle: Particle): void;
        update(particle: Particle, _: number): void;
        toJSON(): any;
        frameUpdate(delta: number): void;
        static fromJSON(json: any): Simulation;
        clone(): Simulation;
        reset(): void;
    }

    declare function noop(): void;

    /**
     * 向量归一化
     */
    declare function normalize<T extends VectorArray>(out: T, v: VectorArray): T;

    /**
     * Normalize css liked array configuration
     * e.g.
     *  3 => [3, 3, 3, 3]
     *  [4, 2] => [4, 2, 4, 2]
     *  [4, 3, 2] => [4, 3, 2, 3]
     */
    declare function normalizeCssArray(val: number | number[]): number[];

    export { NormalPass }

    declare const NOT_INTERSECTED: ShapecastIntersection;

    /**
     * Returns the current time in milliseconds. If performance.now() is available, it is used, otherwise Date.now() is used.
     *
     * @category Time
     */
    export declare function now(): number;

    /**
     * object3d对象转实体对象
     * @param object object3d对象
     * @param splitSubEntity 是否按组拆分成一个个子字体
     * @param autoAsMeshEntity 如果满足条件时是否自动转为mesh实体 （默认false) splitSubEntity为false时有效
     */
    export declare function object2Entity(object: Object3D, splitSubEntity?: boolean, autoAsMeshEntity?: boolean): Entity;

    /**
     * Records what objects are colliding with each other
     */
    declare class ObjectCollisionMatrix {
        /**
         * The matrix storage.
         */
        matrix: Record<string, boolean>;
        /**
         * @todo Remove useless constructor
         */
        constructor();
        /**
         * get
         */
        get(bi: Body_2, bj: Body_2): boolean;
        /**
         * set
         */
        set(bi: Body_2, bj: Body_2, value: boolean): void;
        /**
         * Empty the matrix
         */
        reset(): void;
        /**
         * Set max number of objects
         */
        setNumObjects(n: number): void;
    }

    /**
     * Check if an object has a property.
     * @param o
     * @param v
     */
    export declare function objectHasOwn(o: object, v: PropertyKey): boolean;

    /**
     * 物体变化参数
     */
    export declare interface ObjectTransform {
        position?: Vector3;
        rotation?: Vector3;
        scale?: number | Vector3;
    }

    /**
     * 物体平移变化参数转成矩阵
     */
    export declare function objectTransformToMatrix(tf: ObjectTransform): Matrix4;

    declare interface ObjectValueType<T> {
        copy(value: T): ObjectValueType<T>;
        lerp(value: T, pos: number): ObjectValueType<T>;
        clone(): ObjectValueType<T>;
    }

    /**
     * Octree
     */
    declare class Octree extends OctreeNode {
        /**
         * Maximum subdivision depth
         * @default 8
         */
        maxDepth: number;
        /**
         * @param aabb The total AABB of the tree
         */
        constructor(aabb?: AABB, options?: {
            /**
             * Maximum subdivision depth
             * @default 8
             */
            maxDepth?: number;
        });
    }

    /**
     * OctreeNode
     */
    declare class OctreeNode {
        /** The root node */
        root: OctreeNode | null;
        /** Boundary of this node */
        aabb: AABB;
        /** Contained data at the current node level */
        data: number[];
        /** Children to this node */
        children: OctreeNode[];
        constructor(options?: {
            /** The root node */
            root?: Octree | null;
            /** Boundary of this node */
            aabb?: AABB;
        });
        /**
         * reset
         */
        reset(): void;
        /**
         * Insert data into this node
         * @return True if successful, otherwise false
         */
        insert(aabb: AABB, elementData: number, level?: number): boolean;
        /**
         * Create 8 equally sized children nodes and put them in the `children` array.
         */
        subdivide(): void;
        /**
         * Get all data, potentially within an AABB
         * @return The "result" object
         */
        aabbQuery(aabb: AABB, result: number[]): number[];
        /**
         * Get all data, potentially intersected by a ray.
         * @return The "result" object
         */
        rayQuery(ray: Ray_2, treeTransform: Transform, result: number[]): number[];
        /**
         * removeEmptyNodes
         */
        removeEmptyNodes(): void;
    }

    /** 对一组坐标，给定一个偏移量，获取偏移后的坐标
     * @param paths 坐标序列
     * @param offset 偏移量
     */
    export declare function offsetCoords(paths: [number, number, number?][], offset: number): [number, number, number?][];

    export declare function offsetPolygon(vertices: number[], holes?: number[], offset?: number, miterLimit?: number, close?: boolean, removeIntersections?: boolean, removeIntersectionsHole?: boolean): any[] | Float32Array;

    export declare type Omitype<T, U> = {
        [P in keyof T as T[P] extends U ? never : P]: T[P];
    };

    /**
     * Decorator that redefines a property with getter and setter, and calls a function when the property is changed.
     * Parameters passed to the function are the property key and the new value.
     * @note - Does not work with "target": "esnext" in tsconfig.json
     * @note - Requires "experimentalDecorators": true in tsconfig.json
     * @todo add example.
     * @param fnKey - use: `<MyClass>.prototype.<myFunction>` or define an arrow function: `(key, value, oldValue) => {}`.
     * @param paramType -
     * if param, the function is called with 3 parameters: `key, value, oldValue`, default for {@link onChange}
     * if object, the function is called with an object parameter: `{key, value, oldValue}`, default for {@link onChange3}
     * if void then no params are passed. {@link onChange2}
     * Default: false.
     *
     * @category Decorators
     */
    export declare function onChange(fnKey: string | ((key: string, value: any, oldValue: any) => void), paramType?: "param" | "object" | "void"): PropertyDecorator;

    /**
     * Similar to {@link onChange}, but accepts any function and paramType defaults to 'void'. The function is called with no parameters. if 'void'
     * @param fnKey
     * @param paramType
     */
    export declare function onChange2(fnKey: string | AnyFunction, paramType?: "param" | "object" | "void"): PropertyDecorator;

    /**
     * Similar to {@link onChange}, but accepts any function and paramType defaults to 'object'. The function is called with an object parameter: `{key, value, oldValue}`.
     * @param fnKey
     * @param paramType
     */
    export declare function onChange3(fnKey: string | ((obj: {
        key: string;
        value: any;
        oldValue: any;
    }) => void), paramType?: "object" | "void"): PropertyDecorator;

    declare type OnCleanup = (cleanupFn: () => void) => void;

    declare type ondestroyCallback = () => void;

    declare type OnframeCallback = (percent: number) => void;

    declare type OnframeCallback_2<T> = (target: T, percent: number) => void;

    declare type onrestartCallback = () => void;

    /**
     * Registers a dispose callback on the current active effect scope. The
     * callback will be invoked when the associated effect scope is stopped.
     *
     * @param fn - The callback function to attach to the scope's cleanup.
     */
    declare function onScopeDispose(fn: () => void): void;

    /**
     * 打开地图的深色背景样式，值为 {backcolor: 0}
     */
    export declare function openMapDarkStyle(): IMapStyleParam;

    /**
     * 打开地图的浅色色背景样式，值为 {backcolor: 0xFFFFFF}
     */
    export declare function openMapLightStyle(): IMapStyleParam;

    declare class Operation extends Brush {
        isOperation: boolean;
        markUpdated(): void;
        isDirty(): boolean;
        insertBefore(brush: Brush): void;
        insertAfter(brush: Brush): void;
    }

    declare class OperationDebugData {
        intersectionEdges: Line3[];
        enabled: boolean;
        addIntersectingTriangles(ia: number, triA: Triangle, ib: number, triB: Triangle): void;
        addEdge(edge: Line3): void;
        reset(): void;
    }

    declare class OperationGroup extends Group_2 {
        isOperatioinGroup: boolean;
        markUpdated(): void;
        isDirty(): boolean;
    }

    /** 优化模型渲染 */
    export declare const optimizeModelRender: (renderer: WebGLRenderer) => void;

    declare interface Opts {
        style?: {
            backgroundColor?: string;
            color?: string;
        };
        autoHideDelay?: number;
    }

    export declare class OrbitControlModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: OrbitControlModuleOptions;
        constructor(app?: App, options?: OrbitControlModuleOptions);
        get cameraControl(): CameraControls;
        get enableCameraControlRef(): Ref<boolean>;
        get enableCameraControl(): boolean;
        set enableCameraControl(v: boolean);
        get enableWheelWhenCtrlDisabled(): any;
        set enableWheelWhenCtrlDisabled(v: any);
        onAwake(): void;
        onAppRender(time: Time): void;
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface OrbitControlModuleOptions {
        /**
         * target
         */
        target?: [number, number, number] | Vector3;
        /**
         * Minimum vertical angle in radians.
         * The angle has to be between `0` and `.maxPolarAngle` inclusive.
         * The default value is `0`.
         *
         * e.g.
         * ```
         * cameraControl.maxPolarAngle = 0;
         * ```
         */
        minPolarAngle?: number;
        /**
         * Maximum vertical angle in radians.
         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
         * The default value is `Math.PI`.
         *
         * e.g.
         * ```
         * cameraControl.maxPolarAngle = Math.PI;
         * ```
         */
        maxPolarAngle?: number;
        /**
         * Minimum horizontal angle in radians.
         * The angle has to be less than `.maxAzimuthAngle`.
         * The default value is `- Infinity`.
         *
         * e.g.
         * ```
         * cameraControl.minAzimuthAngle = - Infinity;
         * ```
         */
        minAzimuthAngle?: number;
        /**
         * Maximum horizontal angle in radians.
         * The angle has to be greater than `.minAzimuthAngle`.
         * The default value is `Infinity`.
         *
         * e.g.
         * ```
         * cameraControl.maxAzimuthAngle = Infinity;
         * ```
         */
        maxAzimuthAngle?: number;
        /**
         * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
         * PerspectiveCamera only.
         */
        minDistance?: number;
        /**
         * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
         * PerspectiveCamera only.
         */
        maxDistance?: number;
        /**
         * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
         * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
         */
        infinityDolly?: boolean;
        /**
         * Minimum camera zoom. Default is `0.01`.
         */
        minZoom?: number;
        /**
         * Maximum camera zoom.Default is `Infinity`.
         */
        maxZoom?: number;
        /**
         * Approximate time in seconds to reach the target. A smaller value will reach the target faster.Default is `0.25`.
         */
        smoothTime?: number;
        /**
         * the smoothTime while draggingDefault is `0.125`.
         */
        draggingSmoothTime?: number;
        /**
         * Max transition speed in unit-per-seconds. Default is `Infinity`.
         */
        maxSpeed?: number;
        /**
         * Speed of azimuth (horizontal) rotation. Default is `1.0`.
         */
        azimuthRotateSpeed?: number;
        /**
         * Speed of polar (vertical) rotation.  Default is `1.0`.
         */
        polarRotateSpeed?: number;
        /**
         * Speed of mouse-wheel dollying.  Default is `1.0`.
         */
        dollySpeed?: number;
        /**
         * `true` to invert direction when dollying or zooming via drag  Default is `false`.
         */
        dollyDragInverted?: boolean;
        /**
         * Speed of drag for pan and pedestal. Default is `2.0`.
         */
        truckSpeed?: number;
        /**
         * `true` to enable Dolly-in to the mouse cursor coords. Default is `false`.
         */
        dollyToCursor?: boolean;
        /**
         * Properties Default is `false`.
         */
        dragToOffset?: boolean;
        /**
         *  if true, pan in screen-space default true
         */
        verticalDragToForward?: boolean;
        /**
         * Friction ratio of the boundary..Default is `0.0`.
         */
        boundaryFriction?: number;
        /**
         * Controls how soon the `rest` event fires as the camera slows. .Default is `0.01`.
         */
        restThreshold?: number;
        /**
         * An array of Meshes to collide with camera.
         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
         */
        colliderMeshes?: Object3D;
        /**
         * User's mouse input config.
         *
         * | button to assign      | behavior |
         * | --------------------- | -------- |
         * | `mouseButtons.left`   | `CameraControls.ACTION.ROTATE`* \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
         * | `mouseButtons.right`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK`* \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
         * | `mouseButtons.wheel` ¹ | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
         * | `mouseButtons.middle` ² | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY`* \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
         *
         * 1. Mouse wheel event for scroll "up/down" on mac "up/down/left/right"
         * 2. Mouse click on wheel event "button"
         * - \* is the default.
         * - The default of `mouseButtons.wheel` is:
         *   - `DOLLY` for Perspective camera.
         *   - `ZOOM` for Orthographic camera, and can't set `DOLLY`.
         */
        mouseButtons?: MouseButtons;
        /**
         * User's touch input config.
         *
         * | fingers to assign     | behavior |
         * | --------------------- | -------- |
         * | `touches.one` | `CameraControls.ACTION.TOUCH_ROTATE`* \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.DOLLY` | `CameraControls.ACTION.ZOOM` | `CameraControls.ACTION.NONE` |
         * | `touches.two` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `ACTION.TOUCH_DOLLY` \| `ACTION.TOUCH_ZOOM` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
         * | `touches.three` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
         *
         * - \* is the default.
         * - The default of `touches.two` and `touches.three` is:
         *   - `TOUCH_DOLLY_TRUCK` for Perspective camera.
         *   - `TOUCH_ZOOM_TRUCK` for Orthographic camera, and can't set `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY`.
         * @category Properties
         */
        touches?: Touches;
        /** 开启双击定位到中心点，默认是 */
        dblClickSetToCenter?: boolean;
        /** 双击定位时屏幕坐标转世界坐标使用深度，默认是 */
        unProjectUseDepth?: boolean;
        /** 双击定位时把当前坐标用Marker调试输出，默认false */
        dblClickAddDebugMarker?: boolean;
        /** 是否启用 */
        enable?: boolean;
        /** 允许更新 */
        disableUpdate?: boolean;
        /** 事件来源于输入模块 */
        eventFromInputModule?: boolean;
        /** 左键用于平移 (同时右键将用于旋转)*/
        leftButtonPan?: boolean;
        /** 旋转时显示旋转中心点坐标位置图标(默认是) */
        rotateShowTargetMarker?: boolean;
        /** 缩放时显示旋转中心点坐标位置图标(默认是) */
        zoomShowTargetMarker?: boolean;
        /** 旋转中心点坐标位置图标 */
        targetMarkerImage?: string;
        /** 旋转中心点坐标位置图标颜色，默认 #d4237a */
        targetMarkerColor?: string;
        /** 旋转中心点坐标位置图标大小 */
        targetMarkerSize?: number;
        /** 旋转中心点坐标位置图标透明度(0-1) */
        targetMarkerOpacity?: number;
        /** 初始状态 */
        initState?: CameraState & {
            enableTransition?: boolean;
        };
    }

    /**
     * Orbit particles around an axis over their life.
     */
    export declare class OrbitOverLife implements Simulation {
        orbitSpeed: FunctionValueGenerator | ValueGenerator;
        axis: Vector3;
        type: string;
        rotation: Quaternion;
        line: Line3;
        temp: Vector3;
        constructor(orbitSpeed: FunctionValueGenerator | ValueGenerator, axis?: Vector3);
        initialize(particle: Particle): void;
        update(particle: Particle, delta: number): void;
        frameUpdate(delta: number): void;
        toJSON(): any;
        static fromJSON(json: any): Simulation;
        clone(): Simulation;
        reset(): void;
    }

    export declare enum OrderIndex {
        StartMost = -1000000,
        Start = -1000,
        Normal = 0,
        End = 1000,
        EndMost = 1000000
    }

    declare class OrientedBoundingRect {
        private _corners;
        private _axes;
        private _origin;
        constructor(rect?: BoundingRect, transform?: MatrixArray);
        fromBoundingRect(rect: BoundingRect, transform?: MatrixArray): void;
        /**
         * If intersect with another OBB
         * @param other Bounding rect to be intersected with
         * @param mtv Calculated .
         *  If it's not overlapped. it means needs to move given rect with Maximum Translation Vector to be overlapped.
         *  Else it means needs to move given rect with Minimum Translation Vector to be not overlapped.
         */
        intersect(other: OrientedBoundingRect, mtv?: PointLike): boolean;
        private _intersectCheckOneSide;
        private _getProjMinMaxOnAxis;
    }

    declare class OrientedBox {
        min: Vector3;
        max: Vector3;
        matrix: Matrix4;
        needsUpdate: boolean;
        constructor(min: Vector3, max: Vector3);
        set(min: Vector3, max: Vector3, matrix: Matrix4): OrientedBox;
        intersectsBox(box: Box3): boolean;
        intersectsTriangle(tri: Triangle): boolean;
        closestPointToPoint(point: Vector3, target?: Vector3): number;
        distanceToPoint(point: Vector3): number;
        distanceToBox(box: Box3, threshold?: number, target1?: Vector3, target2?: Vector3): number;
    }

    export { OutlineEffect }

    /**
     * 实体描边模块
     */
    export declare class OutlineModule extends EntityModuleBase implements IEntityModuleBase {
        static moduleName: string;
        options: OutlinesProps;
        outlines: OutlinesType[];
        constructor(entity: Entity, options?: OutlinesProps);
        onAppUpdate(time: Time): void;
    }

    export declare function Outlines({ color, opacity, transparent, thickness, angle, }?: Partial<OutlinesProps>): OutlinesType;

    export declare type OutlinesProps = {
        /** Outline color, default: black */
        color?: Color;
        /** Outline opacity, default: 1 */
        opacity?: number;
        /** Outline transparency, default: false */
        transparent?: boolean;
        /** Outline thickness, default 0.05 */
        thickness?: number;
        /** Geometry crease angle (0 === no crease), default: Math.PI */
        angle?: number;
        pulsePeriod?: number;
    };

    export declare type OutlinesType = {
        group: Group_2;
        updateProps: (props: Partial<OutlinesProps>) => void;
        /**
         * **Note**: Call this method to generate the outline mesh
         */
        generate: () => void;
        dispose: () => void;
    };

    export declare const OutputNodeTypeNames: Set<string>;

    declare class OverlapKeeper {
        current: number[];
        previous: number[];
        /**
         * @todo Remove useless constructor
         */
        constructor();
        /**
         * getKey
         */
        getKey(i: number, j: number): number;
        /**
         * set
         */
        set(i: number, j: number): void;
        /**
         * tick
         */
        tick(): void;
        /**
         * getDiff
         */
        getDiff(additions: number[], removals: number[]): void;
    }

    export { OverrideMaterialManager }

    export declare class PackedMipMapGenerator {
        _swapTarget: any;
        _copyQuad: any;
        _mipQuad: any;
        _mipMaterials: any;
        constructor(mipmapLogic?: string);
        update(texture: any, target: any, renderer: any, forcePowerOfTwo?: boolean): number;
        dispose(): void;
    }

    declare interface PainterBase {
        type: string;
        root?: HTMLElement;
        ssrOnly?: boolean;
        resize(width?: number | string, height?: number | string): void;
        refresh(): void;
        clear(): void;
        renderToString?(): string;
        getType: () => string;
        getWidth(): number;
        getHeight(): number;
        dispose(): void;
        getViewportRoot: () => HTMLElement;
        getViewportRootOffset: () => {
            offsetLeft: number;
            offsetTop: number;
        };
        refreshHover(): void;
        configLayer(zlevel: number, config: Dictionary<any>): void;
        setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;
    }

    declare type PainterBaseCtor = {
        new (dom: HTMLElement, storage: Storage_2, ...args: any[]): PainterBase;
    };

    /**
     * Executes all contained behaviors in parallel
     */
    export declare class ParallelBehavior extends CompositeBehavior {
        successPolicy: ParallelBehaviorPolicy;
        failurePolicy: ParallelBehaviorPolicy;
        activeSet: any;
        successCount: number;
        failureCount: number;
        /**
         *
         * @param {ParallelBehaviorPolicy} successPolicy
         * @param {ParallelBehaviorPolicy} failurePolicy
         */
        constructor(successPolicy: any, failurePolicy: any);
        /**
         *
         * @return {ParallelBehaviorPolicy}
         */
        getSuccessPolicy(): ParallelBehaviorPolicy;
        /**
         *
         * @param policy
         */
        setSuccessPolicy(policy: ParallelBehaviorPolicy): void;
        /**
         *
         * @return {ParallelBehaviorPolicy}
         */
        getFailurePolicy(): ParallelBehaviorPolicy;
        /**
         *
         * @param  policy
         */
        setFailurePolicy(policy: ParallelBehaviorPolicy): void;
        /**
         *
         * @param {number} timeDelta
         * @returns {BehaviorStatus|number}
         */
        tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
        initialize(context: any): void;
        /**
         *
         * @private
         */
        __finalizeActiveChildren(): void;
        finalize(): void;
        /**
         *
         * @param {Behavior[]} elements
         * @param {ParallelBehaviorPolicy} success how should successful completion be determined?
         * @param {ParallelBehaviorPolicy} failure how should failing completion be determined
         * @returns {ParallelBehavior}
         */
        static from(elements: Behavior[], success?: ParallelBehaviorPolicy, failure?: ParallelBehaviorPolicy): ParallelBehavior;
    }

    /**
     *
     * @enum {number}
     */
    export declare enum ParallelBehaviorPolicy {
        RequireOne = 0,
        RequireAll = 1
    }

    export declare type ParameterPair = [string, ParameterType];

    export declare type ParameterType = FieldType | 'self';

    declare function parse(colorStr: string, rgbaArr?: number[]): number[];

    /**
     * Parse a file extension from a path
     * @param path - The path to parse
     * @returns file extension without the dot (e.g. 'png')
     *
     * @category Text
     */
    export declare function parseFileExtension(path: string): string;

    declare function parseSVG(xml: string | Document | SVGElement, opt: SVGParserOption): SVGParserResult;

    /**
     * Partial pick type with all keys optional
     */
    export declare type PartialPick<T, K extends keyof T> = Partial<T> & Pick<T, K>;

    /**
     * Partial record type with all keys optional
     * @example
     * ```ts
     * type T = PartialRecord<'a' | 'b', number>
     * // T = {a?: number, b?: number}
     * ```
     */
    export declare type PartialRecord<K extends keyof any, T> = {
        [P in K]?: T;
    };

    export declare interface Particle extends IParticle {
        /**
         * Speed modifier of the particle.
         * @type {number}
         */
        speedModifier: number;
        /**
         * Emission state of the particle.
         * @type {EmissionState}
         */
        emissionState?: EmissionState;
        /**
         * Parent matrix for transformation.
         * @type {Matrix4}
         */
        parentMatrix?: Matrix4;
        /**
         * Initial speed of the particle.
         * @type {number}
         */
        startSpeed: number;
        /**
         * Initial color of the particle.
         * @type {Vector4}
         */
        startColor: Vector4;
        /**
         * Initial size of the particle.
         * @type {number}
         */
        startSize: number;
    }

    /**
     * Particle2 shape.
     * @example
     *     const particleShape = new CANNON.Particle2()
     *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })
     *     world.addBody(particleBody)
     */
    declare class Particle2 extends Shape {
        constructor();
        /**
         * calculateLocalInertia
         */
        calculateLocalInertia(mass: number, target?: Vec3): Vec3;
        volume(): number;
        updateBoundingSphereRadius(): void;
        calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
    }

    /**
     * Class representing a three.Particle particle emitter. particle emitter is a node in the three.js scene graph
     * every particle emitter only associates with a particle system.
     * particle system
     * @extends Object3D
     * @template E - Type of the event map.
     */
    export declare class ParticleEmitter<E extends Object3DEventMap = Object3DEventMap> extends Object3D<E> {
        type: string;
        system: IParticleSystem;
        /**
         * Creates an instance of ParticleEmitter.
         * @param {IParticleSystem} system - The particle system to be used.
         */
        constructor(system: IParticleSystem);
        /**
         * Clones the particle emitter.
         * @returns {ParticleEmitter} A new instance of ParticleEmitter.
         */
        clone(): any;
        /**
         * Disposes the particle emitter.
         */
        dispose(): void;
        /**
         * Extracts data from the cache.
         * @param {any} cache - The cache to extract data from.
         * @returns {any[]} An array of extracted data without metadata.
         */
        extractFromCache(cache: any): any[];
        /**
         * Converts the particle emitter to JSON.
         * @param {MetaData} [meta] - Optional metadata.
         * @param {SerializationOptions} [options={}] - Optional serialization options.
         * @returns {any} The JSON representation of the particle emitter.
         */
        toJSON(meta?: MetaData, options?: SerializationOptions): any;
    }

    /**
     * Loader for Particle particle system.
     */
    export declare class ParticleLoader extends ObjectLoader {
        onData?: (data: any) => any;
        constructor(opts?: {
            manager?: LoadingManager;
            onData?: (data: any) => any;
        });
        /**
         * Links the references of the particle system.
         * It's used to link the references of sub particle systems.
         * @param object the target object to link the references.
         */
        linkReference(object: Object3D): void;
        /**
         * Parses the json data to create a Particle particle system.
         * @param json the json data to parse.
         * @param onLoad the callback function to be called after the object is loaded.
         */
        parse<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void): T;
        parseObject(data: any, geometries: {
            [uuid: string]: BufferGeometry;
        }, materials: {
            [uuid: string]: Material;
        }, textures: {
            [uuid: string]: Texture;
        }, animations: AnimationClip[]): Object3D;
    }

    /**
     * 粒子模块
     */
    export declare class ParticleModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        constructor(entity: Entity, options?: ParticleModuleOption | ParticleModuleOption[]);
        /**
         * 增加粒子
         * @param particle
         */
        getParticles(name?: string): ParticleEmitter<Object3DEventMap>[];
        /**
         * 增加粒子
         * @param particle
         */
        addParticle(particle: ParticleModuleOption): void;
        /**
         * 移除粒子
         * @param particle
         */
        removeParticle(name?: string): void;
    }

    export declare interface ParticleModuleOption {
        /** 粒子系统参数 */
        system?: ParticleSystemParameters;
        /** 粒子模拟行为  */
        simulations?: Simulation | Simulation[];
        /** 名称 */
        name?: string;
        /** 位置  */
        position?: Vector3 | [number, number, number];
        /** 旋转 */
        rotation?: Vector3 | [number, number, number];
        /** 缩放 */
        scale?: Vector3 | [number, number, number] | number;
        /** 加载粒子资源 */
        resource?: Object3D;
        /** 克隆资源 默认是 */
        isCloneRes?: boolean;
        /** 当结束时自动删除，默认为true */
        disposeWhenEnd?: boolean;
        /** 加载粒子系统前回调 */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
    }

    export declare interface ParticlePlugin {
        id: string;
        initialize: () => void;
        emitterShapes: Array<EmitterShapeParticlePlugin>;
        simulations: Array<SimulationParticlePlugin>;
    }

    export declare const ParticlePlugins: Array<ParticlePlugin>;

    /**
     * 粒子系统模块
     */
    export declare class ParticleRenderModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: ParticleRenderModuleOptions;
        enable?: boolean;
        batchRendererSet: Map<string, BatchedRenderer>;
        constructor(app?: App, options?: ParticleRenderModuleOptions);
        get batchRenderer(): BatchedRenderer;
        get particleRenderer(): BatchedRenderer;
        onAwake(): void;
        onAppRender(time: Time): void;
        addParticleSystem(system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean): void;
        addParticle(opts: {
            system: ParticleSystemParameters;
            simulations?: Simulation | Simulation[];
            name?: string;
            position?: Vector3 | [number, number, number];
            rotation?: Vector3 | [number, number, number];
            scale?: Vector3 | [number, number, number] | number;
            parent?: Object3D;
            disposeWhenEnd?: boolean;
        }): ParticleEmitter<Object3DEventMap>;
        removeParticle(obj: ParticleEmitter<Object3DEventMap>): void;
        loadParticle(url: string, opts?: {
            system?: ParticleSystemParameters;
            simulations?: Simulation | Simulation[];
            name?: string;
            position?: Vector3 | [number, number, number];
            rotation?: Vector3 | [number, number, number];
            scale?: Vector3 | [number, number, number] | number;
            parent?: Object3D;
            disposeWhenEnd?: boolean;
            onData?: (data: any) => any;
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
            crossOrigin?: string;
            withCredentials?: boolean;
            urlPath?: string;
            resourcePath?: string;
            requestHeader?: {
                [header: string]: string;
            };
        }): Promise<unknown>;
        loadParticleFromJson(json: string | JSON, opts?: {
            system?: ParticleSystemParameters;
            simulations?: Simulation | Simulation[];
            name?: string;
            position?: Vector3 | [number, number, number];
            rotation?: Vector3 | [number, number, number];
            scale?: Vector3 | [number, number, number] | number;
            parent?: Object3D;
            disposeWhenEnd?: boolean;
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
            onData?: (data: any) => any;
        }): Object3D<Object3DEventMap>;
        loadParticleFromRes(obj: Object3D, opts?: {
            system?: ParticleSystemParameters;
            simulations?: Simulation | Simulation[];
            name?: string;
            position?: Vector3 | [number, number, number];
            rotation?: Vector3 | [number, number, number];
            scale?: Vector3 | [number, number, number] | number;
            parent?: Object3D;
            disposeWhenEnd?: boolean;
            onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        }): Object3D<Object3DEventMap>;
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface ParticleRenderModuleOptions {
        /** 是否启动。默认true */
        enable?: boolean;
    }

    /**
     * ParticleSystem represents a system that generates and controls particles with similar attributes.
     *
     * @class
     */
    export declare class ParticleSystem implements IParticleSystem {
        signal: {
            onRestart: Signal;
            onPlay: Signal;
            onPause: Signal;
            onEnd: Signal;
        };
        /**
         * Determines whether the ParticleSystem should be automatically disposed when it finishes emitting particles.
         *
         * @type {boolean}
         */
        autoDestroy: boolean;
        /**
         * Determines whether a looping ParticleSystem should prewarm, i.e., the Particle System looks like it has already simulated for one loop when first becoming visible.
         *
         * @type {boolean}
         */
        prewarm: boolean;
        /**
         * Determines whether the ParticleSystem should loop, i.e., restart emitting particles after the duration of the particle system is expired.
         *
         * @type {boolean}
         */
        looping: boolean;
        /**
         * The duration of the ParticleSystem in seconds.
         *
         * @type {number}
         */
        duration: number;
        /**
         * The value generator or function value generator for the starting life of particles.
         *
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startLife: ValueGenerator | FunctionValueGenerator;
        /**
         * The value generator or function value generator for the starting speed of particles.
         *
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startSpeed: ValueGenerator | FunctionValueGenerator;
        /**
         * The value generator or function value generator or rotation generator for the starting rotation of particles.
         *
         * @type {ValueGenerator | FunctionValueGenerator | RotationGenerator}
         */
        startRotation: ValueGenerator | FunctionValueGenerator | RotationGenerator;
        /**
         * The value generator or function value generator for the starting size of particles.
         *
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        startSize: ValueGenerator | FunctionValueGenerator;
        /**
         * The color generator or function color generator for the starting color of particles.
         *
         * @type {ColorGenerator | FunctionColorGenerator}
         */
        startColor: ColorGenerator | FunctionColorGenerator | MemorizedFunctionColorGenerator;
        /**
         * The value generator for the starting tile index of particles.
         *
         * @type {ValueGenerator}
         */
        startTileIndex: ValueGenerator;
        /**
         * The renderer emitter settings for the ParticleSystem.
         *
         * @type {TrailSettings | MeshSettings | BillBoardSettings | StretchedBillBoardSettings}
         */
        rendererEmitterSettings: RendererEmitterSettings;
        /**
         * The value generator or function value generator for the emission rate of particles over time.
         *
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        emissionOverTime: ValueGenerator | FunctionValueGenerator;
        /**
         * The value generator or function value generator for the emission rate of particles over distance.
         *
         * @type {ValueGenerator | FunctionValueGenerator}
         */
        emissionOverDistance: ValueGenerator | FunctionValueGenerator;
        /**
         * An array of burst parameters for the ParticleSystem.
         *
         * @type {Array<BurstParameters>}
         */
        emissionBursts: Array<BurstParameters>;
        /**
         * Determines whether the ParticleSystem is only used by other ParticleSystems.
         *
         * @type {boolean}
         */
        onlyUsedByOther: boolean;
        /**
         * Determines whether the ParticleSystem is in world space or local space.
         *
         * @type {boolean}
         */
        worldSpace: boolean;
        /**
         * The number of particles in the ParticleSystem.
         *
         * @type {number}
         */
        particleNum: number;
        /**
         * Determines whether the ParticleSystem is paused.
         *
         * @type {boolean}
         */
        paused: boolean;
        /**
         * All the particles in the ParticleSystem.
         *
         * @type {Array<Particle>}
         */
        particles: Array<Particle>;
        /**
         * the shape of the emitter.
         *
         * @type {EmitterShape}
         */
        emitterShape: EmitterShape;
        /**
         * the emitter object that should be added in the scene.
         *
         * @type {ParticleEmitter<Object3DEventMap>}
         */
        emitter: ParticleEmitter<Object3DEventMap>;
        /**
         * the VFX renderer settings for the batch renderer
         *
         * @type {VFXBatchSettings}
         */
        rendererSettings: VFXBatchSettings;
        /**
         * whether needs to update renderer settings for the batch renderer
         *
         * @type {boolean}
         */
        neededToUpdateRender: boolean;
        /**
         * a list of particle simulations in the particle system
         *
         * @type {Array<Simulation>}
         */
        simulations: Array<Simulation>;
        emissionState: EmissionState;
        private prewarmed;
        private emitEnded;
        private markForDestroy;
        private previousWorldPos?;
        private temp;
        private travelDistance;
        private normalMatrix;
        /**
         * set the time of the playback of the particle system
         * @param time
         */
        set time(time: number);
        /**
         * get the current time of the playback of the particle system
         */
        get time(): number;
        /**
         * layers control visibility of the object.
         * currently if you change the layers setting, you need manually set this.neededToUpdateRender = true;
         * @type {Layers}
         * @see {@link https://threejs.org/docs/index.html#api/en/core/Layers | Official Documentation}
         * @see {@link https://github.com/mrdoob/three.js/blob/master/src/core/Layers.js | Source}
         */
        get layers(): Layers;
        /**
         * get the texture of the particle system
         */
        get texture(): Texture | null;
        /**
         * Set the texture of the particle system
         * It will rebuild the material
         */
        set texture(texture: Texture | null);
        /**
         * Get the material of the particle system
         */
        get material(): Material;
        /**
         * Set the material of the particle system
         * It will rebuild the material
         */
        set material(material: Material);
        /**
         * Get the number of horizontal tiles in the texture.
         */
        get uTileCount(): number;
        /**
         * Set the number of horizontal tiles in the texture.
         * @param u
         */
        set uTileCount(u: number);
        /**
         * Get the number of vertical tiles in the texture.
         */
        get vTileCount(): number;
        /**
         * Set the number of vertical tiles in the texture.
         * @param v
         */
        set vTileCount(v: number);
        /**
         * get whether the particle texture blends tile transitions
         */
        get blendTiles(): boolean;
        /**
         * Set whether the particle texture blends tile transitions
         * @param v
         */
        set blendTiles(v: boolean);
        /**
         * Get whether the particle system uses soft particles.
         * Soft particles are particles that fade out when they are close to geometry.
         */
        get softParticles(): boolean;
        /**
         * Set whether the particle system uses soft particles.
         * Soft particles are particles that fade out when they are close to geometry.
         * @param v
         */
        set softParticles(v: boolean);
        get softNearFade(): number;
        set softNearFade(v: number);
        get softFarFade(): number;
        set softFarFade(v: number);
        /**
         * Get the instancing geometry of the particle system.
         * @param geometry
         */
        get instancingGeometry(): BufferGeometry;
        /**
         * Set the instancing geometry of the particle system.
         * @param geometry
         */
        set instancingGeometry(geometry: BufferGeometry);
        /**
         * Get the render mode of the particle system.
         * {@link RenderMode}
         */
        get renderMode(): RenderMode;
        /**
         * Set the render mode of the particle system.
         * {@link RenderMode}
         */
        set renderMode(renderMode: RenderMode);
        /**
         * get the render order of the particle system in render pipeline.
         * the higher the value, the later the particle system is rendered.
         */
        get renderOrder(): number;
        /**
         * set the render order of the particle system in render pipeline.
         * the higher the value, the later the particle system is rendered.
         */
        set renderOrder(renderOrder: number);
        /**
         * get which blending to use.
         * @default THREE.NormalBlending
         */
        get blending(): Blending;
        /**
         * Set which blending to use.
         * @default THREE.NormalBlending
         */
        set blending(blending: Blending);
        constructor(parameters: ParticleSystemParameters);
        pause(): void;
        play(): void;
        private spawn;
        /**
         * Stops emitting particles
         */
        endEmit(): void;
        /**
         * remove the particle system's emitter from the scene
         */
        dispose(): void;
        restart(): void;
        private firstTimeUpdate;
        /**
         * Update the particle system per frame
         * @param delta
         * @private
         */
        private update;
        /**
         * Emit particles
         * @param delta the duration of the frame
         * @param emissionState the state of the emission
         * @param emitterMatrix the matrix of the emitter
         */
        emit(delta: number, emissionState: EmissionState, emitterMatrix: Matrix4): void;
        /**
         * output the particle system to JSON
         * @param meta serialization meta data
         * @param options serialization options
         */
        toJSON(meta: MetaData, options?: SerializationOptions): ParticleSystemJSONParameters;
        /**
         * Create a ParticleSystem from JSON
         * @param json the JSON data
         * @param meta serialization meta data
         * @param dependencies the dependencies of the particle system
         */
        static fromJSON(json: ParticleSystemJSONParameters, meta: {
            textures: {
                [uuid: string]: Texture;
            };
            materials: {
                [uuoid: string]: Material;
            };
            geometries: {
                [uuid: string]: BufferGeometry;
            };
        }, dependencies: {
            [uuid: string]: Simulation;
        }): ParticleSystem;
        /**
         * Add a simulation to the particle system
         * @param simulation
         */
        addSimulation(simulation: Simulation): void;
        /**
         * Remove a simulation from the particle system
         */
        getRendererSettings(): VFXBatchSettings;
        /**
         * Clone the particle system
         */
        clone(): ParticleSystem;
    }

    export declare interface ParticleSystemJSONParameters {
        version: string;
        autoDestroy: boolean;
        looping: boolean;
        prewarm: boolean;
        duration: number;
        shape: ShapeJSON;
        startLife: FunctionJSON;
        startSpeed: FunctionJSON;
        startRotation: FunctionJSON;
        startSize: FunctionJSON;
        startColor: FunctionJSON;
        emissionOverTime: FunctionJSON;
        emissionOverDistance: FunctionJSON;
        emissionBursts?: Array<BurstParametersJSON>;
        onlyUsedByOther: boolean;
        rendererEmitterSettings: RendererEmitterSettings;
        instancingGeometry?: any;
        renderMode: number;
        renderOrder?: number;
        speedFactor?: number;
        texture?: string;
        material: string;
        layers?: number;
        startTileIndex: FunctionJSON | number;
        uTileCount: number;
        vTileCount: number;
        blendTiles?: boolean;
        softParticles?: boolean;
        softFarFade?: number;
        softNearFade?: number;
        blending?: Blending;
        transparent?: boolean;
        simulations: Array<any>;
        worldSpace: boolean;
    }

    /**
     * Interface representing the parameters for a particle system.
     */
    export declare interface ParticleSystemParameters {
        /**
         * Whether the particle system auto-destroys.
         */
        autoDestroy?: boolean;
        /**
         * Whether the particle system loops.
         */
        looping?: boolean;
        /**
         * Whether the particle system prewarms.
         */
        prewarm?: boolean;
        /**
         * The duration of the particle system.
         */
        duration?: number;
        /**
         * The shape of the emitter.
         */
        shape?: EmitterShape;
        /**
         * The initial life of particles.
         */
        startLife?: ValueGenerator | FunctionValueGenerator;
        /**
         * The initial speed of particles.
         */
        startSpeed?: ValueGenerator | FunctionValueGenerator;
        /**
         * The initial rotation of particles.
         */
        startRotation?: ValueGenerator | FunctionValueGenerator | RotationGenerator;
        /**
         * The initial size of particles.
         */
        startSize?: ValueGenerator | FunctionValueGenerator;
        /**
         * The initial length of particles.
         */
        startLength?: ValueGenerator | FunctionValueGenerator;
        /**
         * The initial color of particles.
         */
        startColor?: ColorGenerator | FunctionColorGenerator | MemorizedFunctionColorGenerator;
        /**
         * The emission rate over time.
         */
        emissionOverTime?: ValueGenerator | FunctionValueGenerator;
        /**
         * The emission rate over distance.
         */
        emissionOverDistance?: ValueGenerator | FunctionValueGenerator;
        /**
         * The burst parameters for emission.
         */
        emissionBursts?: Array<BurstParameters>;
        /**
         * Whether the particle system is only used by others.
         */
        onlyUsedByOther?: boolean;
        /**
         * The simulations of the particle system.
         */
        simulations?: Array<Simulation>;
        /**
         * The instancing geometry of the particle system.
         */
        instancingGeometry?: BufferGeometry;
        /**
         * The render mode of the particle system.
         */
        renderMode?: RenderMode;
        /**
         * The renderer emitter settings.
         */
        rendererEmitterSettings?: RendererEmitterSettings;
        /**
         * The speed factor of the particle system.
         */
        speedFactor?: number;
        /**
         * The material of the particle system.
         */
        material: Material;
        /**
         * The layers of the particle system.
         */
        layers?: Layers;
        /**
         * The initial tile index for particles.
         */
        startTileIndex?: ValueGenerator;
        /**
         * The number of tiles in the u direction.
         */
        uTileCount?: number;
        /**
         * The number of tiles in the v direction.
         */
        vTileCount?: number;
        /**
         * Whether to blend tiles.
         */
        blendTiles?: boolean;
        /**
         * Whether to use soft particles.
         */
        softParticles?: boolean;
        /**
         * The far fade distance for soft particles.
         */
        softFarFade?: number;
        /**
         * The near fade distance for soft particles.
         */
        softNearFade?: number;
        /**
         * The render order of the particle system.
         */
        renderOrder?: number;
        /**
         * Whether the particle system uses world space.
         */
        worldSpace?: boolean;
    }

    export { Pass }

    declare interface Path<Props extends PathProps = PathProps> {
        animate(key?: '', loop?: boolean): Animator_2<this>;
        animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
        animate(key: 'shape', loop?: boolean): Animator_2<this['shape']>;
        getState(stateName: string): PathState;
        ensureState(stateName: string): PathState;
        states: Dictionary<PathState>;
        stateProxy: (stateName: string) => PathState;
    }

    declare class Path<Props extends PathProps = PathProps> extends Displayable<Props> {
        path: PathProxy;
        strokeContainThreshold: number;
        segmentIgnoreThreshold: number;
        subPixelOptimize: boolean;
        style: PathStyleProps;
        /**
         * If element can be batched automatically
         */
        autoBatch: boolean;
        private _rectStroke;
        protected _normalState: PathState;
        protected _decalEl: Path;
        shape: Dictionary<any>;
        constructor(opts?: Props);
        update(): void;
        getDecalElement(): Path<PathProps>;
        protected _init(props?: Props): void;
        protected getDefaultStyle(): Props['style'];
        protected getDefaultShape(): {};
        protected canBeInsideText(): boolean;
        protected getInsideTextFill(): "#333" | "#ccc" | "#eee";
        protected getInsideTextStroke(textFill?: string): string;
        buildPath(ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBatch?: boolean): void;
        pathUpdated(): void;
        getUpdatedPathProxy(inBatch?: boolean): PathProxy;
        createPathProxy(): void;
        hasStroke(): boolean;
        hasFill(): boolean;
        getBoundingRect(): BoundingRect;
        contain(x: number, y: number): boolean;
        /**
         * Shape changed
         */
        dirtyShape(): void;
        dirty(): void;
        /**
         * Alias for animate('shape')
         * @param {boolean} loop
         */
        animateShape(loop: boolean): Animator_2<this["shape"]>;
        updateDuringAnimation(targetKey: string): void;
        attrKV(key: PathKey, value: PathPropertyType): void;
        setShape(obj: Props['shape']): this;
        setShape<T extends keyof Props['shape']>(obj: T, value: Props['shape'][T]): this;
        /**
         * If shape changed. used with dirtyShape
         */
        shapeChanged(): boolean;
        /**
         * Create a path style object with default values in it's prototype.
         * @override
         */
        createStyle(obj?: Props['style']): Props["style"];
        protected _innerSaveToNormal(toState: PathState): void;
        protected _applyStateObj(stateName: string, state: PathState, normalState: PathState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
        protected _mergeStates(states: PathState[]): PathState;
        getAnimationStyleProps(): MapToType<PathProps, boolean>;
        /**
         * If path shape is zero area
         */
        isZeroArea(): boolean;
        /**
         * 扩展一个 Path element, 比如星形，圆等。
         * Extend a path element
         * @DEPRECATED Use class extends
         * @param props
         * @param props.type Path type
         * @param props.init Initialize
         * @param props.buildPath Overwrite buildPath method
         * @param props.style Extended default style config
         * @param props.shape Extended default shape config
         */
        static extend<Shape extends Dictionary<any>>(defaultProps: {
            type?: string;
            shape?: Shape;
            style?: PathStyleProps;
            beforeBrush?: Displayable['beforeBrush'];
            afterBrush?: Displayable['afterBrush'];
            getBoundingRect?: Displayable['getBoundingRect'];
            calculateTextPosition?: Element_2['calculateTextPosition'];
            buildPath(this: Path, ctx: CanvasRenderingContext2D | PathProxy, shape: Shape, inBatch?: boolean): void;
            init?(this: Path, opts: PathProps): void;
        }): {
            new (opts?: PathProps & {
                shape: Shape;
            }): Path;
        };
        protected static initDefaultProps: void;
    }

    /**
     * 路径动画模块
     */
    export declare class PathAnimateModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        options: PathAnimateModuleOptions;
        tween: Tween;
        constructor(entity: Entity, options?: PathAnimateModuleOptions);
        /** 开始动画 */
        start(options?: PathAnimateModuleOptions): Promise<{
            target: any;
            isEnd: boolean;
            isStop: boolean;
            error: boolean;
        }>;
        lookAt(point: Vector3, pointNext: Vector3, model?: Object3D, opts?: {
            tPosition?: number;
            tQuat?: number;
            euler?: Euler;
            offsetAngle?: number;
            followDist?: number;
            followAngle?: number;
            cameraFollow?: boolean;
        }): void;
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            children: UiObjectConfig<any, string, any>[];
        };
    }

    export declare interface PathAnimateModuleOptions {
        /** 路径点坐标 */
        paths: Vector3[] | [number, number, number][];
        /** 路径离散的点数 默认 300 */
        discretePointsNum?: number;
        /** 模型转弯时方向平滑值 0-1 默认1 */
        quatLerpT?: number;
        /** 模型朝向偏移角度 默认0 */
        offsetAngle?: number;
        /** 模型朝向偏移欧拉角，如果上面的 offsetAngle 不能满足时，可用这个 */
        euler?: Euler;
        /** 是否相机跟随 */
        cameraFollow?: boolean;
        /** 相机跟随时距离模型距离 默认模型高度的5倍 */
        followDist?: number;
        /** 相机跟随时距离模型角度 默认 35*/
        followAngle?: number;
        /** 运行的目标对象，默认当前实体 */
        target?: Object3D;
        /** 动画往返运行时模型是否自动改变方向 默认true */
        isAutoChangeDir?: boolean;
        /** 退出模块时自动完成动画 默认false */
        autoCompleteWhenExit?: boolean;
        /** 动画模块索引 如果有动画模块时，默认为0*/
        animatorIndex?: number;
        /** 停止时动画名称 为空时停止所有动作 */
        stopAimatorClipName?: string;
        /** 运行时动画名称 为空时停止所有动作 */
        startAimatorClipName?: string;
        /** 动画属性 */
        animation?: {
            /** id */
            id?: string;
            /** 分类 */
            tag?: string;
            /** 持续时长 默认5000 五秒*/
            duration: number;
            /** easing 默认 linear */
            easing?: Easing;
            /** 是否往返循环 */
            yoyoForever?: boolean;
            /** 往返次数 */
            yoyoTimes?: number;
            /** 重复循环 */
            repeatForever?: boolean;
            /** 重复次数 */
            repeatTimes?: number;
            /** 延迟时长 */
            delay?: number;
            /** 自动播放动画，默认是 */
            autoPlay?: boolean;
            /**
             * 动画完成回调.
             * @param target 对象.
             * @param isEnd 是否整个动画都结束了
             * @param isStop 是否强制终止了
             */
            onComplete?: (target: any, isEnd: boolean, isStop: boolean) => void;
            onStart?: (target: any) => void;
            onUpdate?: (target: any) => void;
            onProgress?: (target: any, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
        };
    }

    export declare class PathEmitter implements EmitterShape {
        type: string;
        mode: EmitterMode;
        spread: number;
        speed: ValueGenerator | FunctionValueGenerator;
        paths: [number, number, number][];
        constructor(parameters: PathEmitterParameters);
        update(system: ParticleSystem, delta: number): void;
        initialize(p: Particle): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any): PathEmitter;
        clone(): EmitterShape;
    }

    export declare interface PathEmitterParameters {
        paths?: [number, number, number][];
        mode?: EmitterMode;
        spread?: number;
        speed?: ValueGenerator | FunctionValueGenerator;
    }

    /**
     * PathGeometry
     */
    export declare class PathGeometry extends BufferGeometry {
        /**
         * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
         * @param {Boolean} [generateUv2=false]
         */
        constructor(initData?: {
            pathPointList: PathPointList;
            options: Record<string, any>;
            usage: Usage;
        } | Number, generateUv2?: Boolean);
        _initByMaxVertex(maxVertex: any, generateUv2: any): void;
        _initByData(pathPointList: any, options: {}, usage: any, generateUv2: any): void;
        /**
         * Update geometry by PathPointList instance
         * @param {PathPointList} pathPointList
         * @param {Object} options
         * @param {Number} [options.width=0.1]
         * @param {Number} [options.progress=1]
         * @param {Boolean} [options.arrow=true]
         * @param {String} [options.side='both'] - "left"/"right"/"both"
         */
        update(pathPointList: PathPointList, options?: {
            width?: number;
            progress?: number;
            arrow?: Boolean;
            side?: "left" | "right" | "both";
        }): void;
        _resizeAttribute(name: any, len: any): void;
        _resizeIndex(len: any): void;
        _updateAttributes(position: any, normal: any, uv: any, uv2: any, indices: any): void;
    }

    /**
     * Join path parts with separator. Similar to PHP's pathJoin
     * @param parts - path parts
     * @param separator - separator, default '/'
     */
    export declare function pathJoin(parts: string[], separator?: string): string;

    declare type PathKey = keyof PathProps;

    /**
     * PathPointList
     * input points to generate a PathPoint list
     */
    export declare class PathPointList {
        array: any[];
        count: number;
        constructor();
        /**
         * Set points
         * @param {Vector3[]} points key points array
         * @param {number} cornerRadius? the corner radius. set 0 to disable round corner. default is 0.1
         * @param {number} cornerSplit? the corner split. default is 10.
         * @param {number} up? force up. default is auto up (calculate by tangent).
         * @param {boolean} close? close path. default is false.
         */
        set(points: any, cornerRadius?: number, cornerSplit?: number, up?: any, close?: boolean): void;
        /**
         * Get distance of this path
         * @return {number}
         */
        distance(): any;
        _getByIndex(index: any): any;
        _start(current: any, next: any, up: any): void;
        _end(current: any): void;
        _corner(current: any, next: any, cornerRadius: any, cornerSplit: any, up: any): void;
        _sharpCorner(current: any, next: any, up: any, dirType?: number, sharp?: boolean): void;
    }

    declare type PathPropertyType = PropType<PathProps, PathKey>;

    declare interface PathProps extends DisplayableProps {
        strokeContainThreshold?: number;
        segmentIgnoreThreshold?: number;
        subPixelOptimize?: boolean;
        style?: PathStyleProps;
        shape?: Dictionary<any>;
        autoBatch?: boolean;
        __value?: (string | number)[] | (string | number);
        buildPath?: (ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBatch?: boolean) => void;
    }

    declare class PathProxy {
        dpr: number;
        data: number[] | Float32Array;
        /**
         * Version is for tracking if the path has been changed.
         */
        private _version;
        /**
         * If save path data.
         */
        private _saveData;
        /**
         * If the line segment is too small to draw. It will be added to the pending pt.
         * It will be added if the subpath needs to be finished before stroke, fill, or starting a new subpath.
         */
        private _pendingPtX;
        private _pendingPtY;
        private _pendingPtDist;
        private _ctx;
        private _xi;
        private _yi;
        private _x0;
        private _y0;
        private _len;
        private _pathSegLen;
        private _pathLen;
        private _ux;
        private _uy;
        static CMD: {
            M: number;
            L: number;
            C: number;
            Q: number;
            A: number;
            Z: number;
            R: number;
        };
        constructor(notSaveData?: boolean);
        increaseVersion(): void;
        /**
         * Version can be used outside for compare if the path is changed.
         * For example to determine if need to update svg d str in svg renderer.
         */
        getVersion(): number;
        /**
         * @readOnly
         */
        setScale(sx: number, sy: number, segmentIgnoreThreshold?: number): void;
        setDPR(dpr: number): void;
        setContext(ctx: ExtendedCanvasRenderingContext2D): void;
        getContext(): ExtendedCanvasRenderingContext2D;
        beginPath(): this;
        /**
         * Reset path data.
         */
        reset(): void;
        moveTo(x: number, y: number): this;
        lineTo(x: number, y: number): this;
        bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): this;
        quadraticCurveTo(x1: number, y1: number, x2: number, y2: number): this;
        arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise?: boolean): this;
        arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;
        rect(x: number, y: number, w: number, h: number): this;
        closePath(): this;
        fill(ctx: CanvasRenderingContext2D): void;
        stroke(ctx: CanvasRenderingContext2D): void;
        len(): number;
        setData(data: Float32Array | number[]): void;
        appendPath(path: PathProxy | PathProxy[]): void;
        /**
         * 填充 Path 数据。
         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
         */
        addData(cmd: number, a?: number, b?: number, c?: number, d?: number, e?: number, f?: number, g?: number, h?: number): void;
        private _drawPendingPt;
        private _expandData;
        /**
         * Convert dynamic array to static Float32Array
         *
         * It will still use a normal array if command buffer length is less than 10
         * Because Float32Array itself may take more memory than a normal array.
         *
         * 10 length will make sure at least one M command and one A(arc) command.
         */
        toStatic(): void;
        getBoundingRect(): BoundingRect;
        private _calculateLength;
        /**
         * Rebuild path from current data
         * Rebuild path will not consider javascript implemented line dash.
         * @param {CanvasRenderingContext2D} ctx
         */
        rebuildPath(ctx: PathRebuilder, percent: number): void;
        clone(): PathProxy;
        private static initDefaultProps;
    }

    declare interface PathRebuilder {
        moveTo(x: number, y: number): void;
        lineTo(x: number, y: number): void;
        bezierCurveTo(x: number, y: number, x2: number, y2: number, x3: number, y3: number): void;
        quadraticCurveTo(x: number, y: number, x2: number, y2: number): void;
        arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise: boolean): void;
        ellipse(cx: number, cy: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: boolean): void;
        rect(x: number, y: number, width: number, height: number): void;
        closePath(): void;
    }

    declare type PathState = Pick<PathProps, PathStatePropNames> & {
        hoverLayer?: boolean;
    };

    declare type PathStatePropNames = DisplayableStatePropNames | 'shape';

    declare interface PathStyleProps extends CommonStyleProps {
        fill?: string | PatternObject | LinearGradientObject | RadialGradientObject;
        stroke?: string | PatternObject | LinearGradientObject | RadialGradientObject;
        decal?: PatternObject;
        /**
         * Still experimental, not works weel on arc with edge cases(large angle).
         */
        strokePercent?: number;
        strokeNoScale?: boolean;
        fillOpacity?: number;
        strokeOpacity?: number;
        /**
         * `true` is not supported.
         * `false`/`null`/`undefined` are the same.
         * `false` is used to remove lineDash in some
         * case that `null`/`undefined` can not be set.
         * (e.g., emphasis.lineStyle in )
         */
        lineDash?: false | number[] | 'solid' | 'dashed' | 'dotted';
        lineDashOffset?: number;
        lineWidth?: number;
        lineCap?: CanvasLineCap;
        lineJoin?: CanvasLineJoin;
        miterLimit?: number;
        /**
         * Paint order, if do stroke first. Similar to SVG paint-order
         * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order
         */
        strokeFirst?: boolean;
    }

    declare namespace pathTool {
        export {
            createFromString,
            extendFromString,
            mergePath,
            clonePath
        }
    }

    /** 路径管道实体类 */
    export declare class PathTubeEntities {
        #private;
        options: PathTubeEntitiesOptions;
        entity: Entity;
        constructor(options: PathTubeEntitiesOptions);
        coordHash(pt: [number, number, number]): string;
        /** 更新 */
        update(): void;
        addTo(target?: App | Entity): void;
    }

    export declare interface PathTubeEntitiesOptions {
        /** 数据 */
        data: {
            /** 路径点 */
            paths: [number, number, number][];
            /** 禁止该路径合并节点 默认false */
            disableMergeNode?: boolean;
            /** 其他属性数据 */
            [key: string]: any;
        }[];
        /** 断面选项 */
        sect: PathTubeGeometryOptions;
        /** 节点半径大小 默认 0.3 */
        nodeRadius?: number;
        /** 外部材质 */
        outerMaterial?: Material;
        /** 内部材质如不填，则使用和外部一样的材质 */
        innerSideMaterial?: Material;
        /** 以为是同一个节点的小数位置精度默认6 */
        decimalPrecision?: number;
        /** 是否是地图模式 */
        isMapMode?: boolean;
        /** 是否做为实体增加 默认true */
        asEntity?: boolean;
        /** 内存分配方式 */
        usage?: Usage;
        /** 节点y方向缩放 默认1 */
        nodeWidthScaleY?: number;
        cornerSplit?: number;
    }

    /**
     * PathTubeGeometry
     */
    export declare class PathTubeGeometry extends PathGeometry {
        /**
         * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
         * @param {Boolean} [generateUv2=false]
         */
        constructor(initData?: {
            pathPointList: PathPointList;
            options: PathTubeGeometryOptions;
            usage: Usage;
        } | Number, generateUv2?: boolean);
        _initByData(pathPointList: any, options: {}, usage: any, generateUv2: any): void;
        /**
         * Update geometry by PathPointList instance
         * @param {PathPointList} pathPointList
         * @param {Object} options
         * @param {Number} [options.radius=0.1]
         * @param {Number} [options.progress=1]
         * @param {Boolean} [options.radialSegments=8]
         * @param {String} [options.startRad=0]
         */
        update(pathPointList: PathPointList, options?: PathTubeGeometryOptions): void;
    }

    declare interface PathTubeGeometryOptions {
        /** 形状为圆的半径，默认0.1 */
        radius?: number;
        /** 绘制进度，默认全绘 1  */
        progress?: number;
        /** 把圆分为几段绘制，默认8 */
        radialSegments?: number;
        /** 开始弧度，默认0 */
        startRad?: number;
        /** 断面形状 */
        shape?: "rect" | "arch" | "custom" | "circle";
        /** 矩形或拱形断面时宽，默认1 */
        rectWidth?: number;
        /** 矩形或拱形断面时高，默认0.5 */
        rectHeight?: number;
        /** 自定义形状时点坐标序列 形状，要求，xy平面，从y轴正方向开始加点，只需要给出右半部分的点 */
        shapePoints?: [number, number][];
    }

    declare class Pattern {
        type: 'pattern';
        image: ImageLike | string;
        /**
         * svg element can only be used in svg renderer currently.
         *
         * Will be string if using SSR rendering.
         */
        svgElement: SVGElement | string;
        repeat: ImagePatternRepeat;
        x: number;
        y: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        constructor(image: ImageLike | string, repeat: ImagePatternRepeat);
    }

    declare type PatternObject = ImagePatternObject | SVGPatternObject;

    declare interface PatternObjectBase {
        id?: number;
        type?: 'pattern';
        x?: number;
        y?: number;
        rotation?: number;
        scaleX?: number;
        scaleY?: number;
    }

    /**
     * Temporarily pauses tracking.
     */
    declare function pauseTracking(): void;

    export declare interface PhysicsBodyOption {
        /**
         * The collision group the body belongs to.
         * @default 1
         */
        collisionFilterGroup?: number;
        /**
         * The collision group the body can collide with.
         * @default -1
         */
        collisionFilterMask?: number;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
         */
        collisionResponse?: boolean;
        /**
         * World space position of the body.
         */
        position?: Vec3;
        /**
         * World space velocity of the body.
         */
        velocity?: Vec3;
        /**
         * The mass of the body.
         * @default 0
         */
        mass?: number;
        /**
         * The physics material of the body. It defines the body interaction with other bodies.
         */
        material?: Material_2;
        /**
         * How much to damp the body velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        linearDamping?: number;
        /**
         * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
         */
        type?: BodyType;
        /**
         * If true, the body will automatically fall to sleep.
         * @default true
         */
        allowSleep?: boolean;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @default 0.1
         */
        sleepSpeedLimit?: number;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @default 1
         */
        sleepTimeLimit?: number;
        /**
         * World space orientation of the body.
         */
        quaternion?: Quaternion;
        /**
         * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
         */
        angularVelocity?: Vec3;
        /**
         * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
         * @default false
         */
        fixedRotation?: boolean;
        /**
         * How much to damp the body angular velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        angularDamping?: number;
        /**
         * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
         */
        linearFactor?: Vec3;
        /**
         * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
         */
        angularFactor?: Vec3;
        /**
         * Add a Shape to the body.
         */
        shape?: Shape;
        /**
         * When true the body behaves like a trigger. It does not collide
         * with other bodies but collision events are still triggered.
         * @default false
         */
        isTrigger?: boolean;
    }

    export declare class PhysicsManagerModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: PhysicsManagerModuleOptions;
        world: World;
        CANNON: typeof CANNON;
        bodies: MeshPhysicsObjectParams[];
        constructor(app?: App, options?: PhysicsManagerModuleOptions);
        get physicsEnable(): boolean;
        set physicsEnable(enable: boolean);
        /** 得到物理引擎世界对象 */
        get physicsWorld(): CANNON.World;
        /** 得到物理引擎对象 */
        get physicsEngine(): typeof CANNON;
        /** 启动物体引擎 */
        enablePhysicsEngine(): Promise<typeof CANNON>;
        /** 增加物理刚体 */
        addPhysicsBody(phyObject: MeshPhysicsObjectParams): MeshPhysicsObjectParams;
        removePhysicsObject(object: Object3D | Entity): void;
        addPhysicsGround(): CANNON.Plane;
        setPhysicsDebugger(enable: boolean): void;
        onAwake(): void;
        onAppAfterUpdate(time: Time): void;
    }

    export declare interface PhysicsManagerModuleOptions {
        /**
         * The gravity of the world.
         */
        gravity?: Vec3;
        /**
         * Gravity to use when approximating the friction max force (mu*mass*gravity).
         * If undefined, global gravity will be used.
         */
        frictionGravity?: Vec3;
        /**
         * Makes bodies go to sleep when they've been inactive.
         * @default false
         */
        allowSleep?: boolean;
        /**
         * The broadphase algorithm to use.
         * @default NaiveBroadphase
         */
        broadphase?: Broadphase;
        /**
         * The solver algorithm to use.
         * @default GSSolver
         */
        solver?: Solver;
        /**
         * Set to true to use fast quaternion normalization. It is often enough accurate to use.
         * If bodies tend to explode, set to false.
         * @default false
         */
        quatNormalizeFast?: boolean;
        /**
         * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
         * @default 0
         */
        quatNormalizeSkip?: number;
        maxSubSteps?: number;
    }

    /**
     * 模型模块
     */
    export declare class PhysicsModule extends EntityModuleBase implements IEntityModuleBase {
        static moduleName: string;
        physics: MeshPhysicsObjectParams;
        constructor(entity: Entity, options?: MeshPhysicsObject);
        /** 获取碰撞体对象 */
        getBody(): CANNON.Body;
        /** 移除物理 */
        removePhysics(): void;
    }

    declare interface PhysicsResolver {
        resolve(pos: Vector3, normal: Vector3): boolean;
    }

    /**
     * Pick `props` from `object.
     *
     * Runtime version of `Pick<T,K>`.
     */
    export declare function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K>;

    /** 拾取工具进入选项 */
    export declare interface PickEnterOptions extends TLEventType {
        /** 高亮模式是否用外包盒的方式 默认false*/
        highlightUseBoxHelper?: boolean;
        /** 选中时高亮的颜色 默认 "#ff0000" */
        highlightColor?: ColorRepresentation;
        /** 选中时高亮的透明度 默认0.5 */
        highlightOpacity?: number;
        /** 预先的实体 */
        target?: InteractiveObject;
        /** 查询条件 */
        queryOptions?: EntityQueryOption;
        /** 没有选中实体时退出拾取 默认true */
        clickNoEntityExit?: boolean;
        /** 点击到其他实体时或没有选中实体退出拾取 默认false */
        clickNoSelfEntityExit?: boolean;
        /** 点击判断是否是其他实体的物体对象，默认为控件关联的对象 */
        clickIsEqualObject?: Object3D | Function;
        /** 点击选中新的实体时拾取上此实体 默认true */
        clickEntitySelected?: boolean;
        /** 右键退出拾取 默认false */
        rightClickConfirmExit?: boolean;
        /** 回车或esc退出拾取 默认 true */
        enterEscConfirmExit?: boolean;
        /** 回调 */
        pickCallBack?: (cb: {
            oldPick: InteractiveObject | undefined | null;
            curPick: InteractiveObject | undefined | null;
        }) => void;
        /** 鼠标移动事件 */
        onPointerMove?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: (info?: TLEventHandler) => void;
        }, oldHover?: InteractiveObject, newHover?: InteractiveObject) => void;
        /** 键盘事件 */
        onKeyUp?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: (info?: TLEventHandler) => void;
        }) => void;
        /** 右键上下文菜单回调 */
        onContextMenu?: (info: TLEventHandler, context: {
            /** 如需要完成时调用  */
            complete: (info?: TLEventHandler) => void;
        }) => void;
        /** 完成回调 */
        onComplete?: (isCancel: boolean, info?: TLEventHandler, select?: InteractiveObject) => void;
    }

    export declare interface PickEntityOptions {
        /** 高亮模式是否用外包盒的方式 默认false*/
        highlightUseBoxHelper?: boolean;
        /** 选中时高亮的颜色 默认 "#ff0000" */
        highlightColor?: ColorRepresentation;
        /** 选中时高亮的透明度 默认0.5 */
        highlightOpacity?: number;
        /** 同unproject的第三个参数 (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组  或同时指定包含或过滤的实体 depth 使用深度*/
        unprojectOpts?: UnProjectOpts | "depth";
        /** 选择多少个实体后自动确认返回。默认不限制 */
        maxSelectedCount?: number;
        /** 是否ESC取消 默认是 */
        escCancel?: boolean;
        /** 是否回车键确认 默认是 */
        enterKeyConfirm?: boolean;
        /** 是否双击确认 默认是*/
        dblClickConfirm?: boolean;
        /** 是否右键确认 默认否*/
        rightClickConfirm?: boolean;
        /** 选择结束后自动清除 */
        exitAutoClearHighlight?: boolean;
        /** 选择结束后自动清除延迟时间（使最后那个有选中的显示时间) 默认100ms， 0不延迟 */
        exitAutoClearDelay?: number;
        /** 是否允许矩形框选 默认允许（需同时按shift键) */
        canSelectBox?: boolean;
        /** 矩形框选需同时按shift键 默认是 */
        shiftSelectBox?: boolean;
        /** 矩形框选样式 */
        selectBoxStyle?: Record<string, any>;
        /** 只能矩形选择 */
        onlyUseSelectBox?: boolean;
        /** 已选中实体，再次选择时是否需同时按Ctrl键取消实体（默认不需要按ctrl，再次选择时取消选择) */
        ctrlKeyCencelSelect?: boolean;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 过滤实体回调 满足条件的返回true */
        filterEntityCb?: (ent: Entity) => boolean;
        /**  右键回调 */
        rightClickCb?: (e: any, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 按enter回调（例如可以调出输入界面等 enterKeyConfirm 为false时有效) */
        enterKeyCb?: (e: any, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 按键回调 */
        keydownCb?: (e: any, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 更新坐标回调 */
        updateCoordinate?: (e: any, context: {
            worldPos?: Vector3;
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 结束框选回调 */
        onSelectBoxEnd?: (pointLeftTop: Vector2, pointBottomRight: Vector2, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 选择了一个实体回调 如果返回false将不加入选择集 */
        onSelect?: (currentEntity: Entity, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<boolean> | any;
        /** 结果确定前回调 返回true交确认结果。其他继续拾取 */
        beforeConfirm?: (e: any, context: {
            entity?: Entity[];
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 选择结束结果回调 */
        onResult?: (entity?: Entity[]) => Promise<any> | any;
    }

    /**
     * 拾取模块
     */
    export declare class PickModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        constructor(app?: App);
        get isFreeStatus(): boolean;
        set isFreeStatus(v: boolean);
        get isFreeStatusRef(): Ref<boolean>;
        onAwake(): void;
        /**
         * 拾取一个点
         */
        pickPoint(opts?: PickPointOptions): Promise<unknown>;
        /**
         * 拾取实体
         */
        pickEntity(opts?: PickEntityOptions): Promise<unknown>;
        drawSelectBox(style?: Record<string, any>, shiftSelectBox?: boolean): Promise<unknown>;
        actionDrawPoint(opts?: IDrawPointEnterOptions): Promise<unknown>;
        actionDrawLineSting(opts?: IDrawLineEnterOptions): Promise<unknown>;
        actionDrawPolygon(opts?: IDrawPolygonEnterOptions): Promise<unknown>;
        actionDrawEdit(opts?: IDrawEditEnterOptions): Promise<unknown>;
        actionPickSelect(opts?: PickEnterOptions): Promise<unknown>;
        getDrawLayer(layerName?: string, noCreateStyle?: Record<string, any>): {
            symbol: () => SymbolEntity | undefined;
            polylines: () => PolylinesEntity | undefined;
            polygons: () => PolygonsEntity | undefined;
            addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
            addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
            addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
            updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
            updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
            updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
            deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
            deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
            deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
        };
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface PickPointOptions {
        /** 同unproject的第三个参数 (undefined根据地图配置决定， false 不用场景数据, true用场景数据)   深度 (-1近裁剪面 到 1 远裁剪面) 或者输入 平面  或者由一个点所在的屏幕平面 或者使用当前场景实体 或 指定实体数组  或同时指定包含或过滤的实体 depth 使用深度*/
        unprojectOpts?: UnProjectOpts | "depth";
        /** 是否ESC取消 默认是 */
        escCancel?: boolean;
        /** 是否右键取消 */
        rightClickCancel?: boolean;
        /** 进入时先自动调用一次更新坐标事件 */
        callUpdateWhenAwake?: boolean;
        /** 进入时使div元素自动获取焦点（能响应键盘事件) 默认是 */
        autoFocus?: boolean;
        /** 右键回调 */
        rightClickCb?: (e: any, context: {
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any>;
        /** 按enter回调（例如可以调出输入界面等) */
        enterKeyCb?: (e: any, context: {
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any>;
        /** 按键回调 */
        keydownCb?: (e: any, context: {
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any>;
        /** 更新坐标回调 */
        updateCoordinate?: (e: any, context: {
            worldPos?: Vector3;
            intersectObject?: any;
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
        /** 结果确定前回调 返回true交确认结果。其他继续拾取 */
        beforeConfirm?: (e: any, context: {
            worldPos?: Vector3;
            intersectObject?: any;
            resolve: (value: unknown) => void;
            reject: (reason?: any) => void;
        }) => Promise<any> | any;
    }

    /** 拾取工具 */
    export declare class PickTool extends StateNode {
        static id: string;
        static initial: string;
        static children: () => (typeof Idle_4)[];
    }

    export declare type PickType<T, U> = {
        [P in keyof T as T[P] extends U ? P : never]: T[P];
    };

    export declare class PiecewiseBezier extends PiecewiseFunction<Bezier> implements FunctionValueGenerator {
        constructor(curves?: Array<[Bezier, number]>);
        genValue(t?: number): number;
        toSVG(length: number, segments: number): string;
        type: "function";
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): PiecewiseBezier;
        clone(): FunctionValueGenerator;
    }

    export declare abstract class PiecewiseFunction<T> {
        functions: Array<[T, number]>;
        protected constructor();
        findFunction(t: number): number;
        getStartX(index: number): number;
        setStartX(index: number, x: number): void;
        getEndX(index: number): number;
        setEndX(index: number, x: number): void;
        insertFunction(t: number, func: T): void;
        removeFunction(index: number): T;
        getFunction(index: number): T;
        setFunction(index: number, func: T): void;
        get numOfFunctions(): number;
    }

    export { PixelationEffect }

    /**
     * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
     * @example
     *     const planeShape = new CANNON.Plane()
     *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })
     *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
     *     world.addBody(planeBody)
     */
    declare class Plane_2 extends Shape {
        /** worldNormal */
        worldNormal: Vec3;
        /** worldNormalNeedsUpdate */
        worldNormalNeedsUpdate: boolean;
        boundingSphereRadius: number;
        constructor();
        /** computeWorldNormal */
        computeWorldNormal(quat: Quaternion_2): void;
        calculateLocalInertia(mass: number, target?: Vec3): Vec3;
        volume(): number;
        calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
        updateBoundingSphereRadius(): void;
    }

    export declare interface PlaneConfig {
        vertexShader: string;
        fragmentShader: string;
        uniforms: {
            [uniform: string]: IUniform<any>;
        };
        /** 透明色 */
        opacityColor?: ColorRepresentation;
        /** 透明度 */
        opacity?: number;
        /** 深度测试 */
        depthTest?: boolean;
        /** 写深度 默认false*/
        depthWrite?: boolean;
        /** 纹理 */
        map?: Texture;
        /** 材质参数 */
        materialParam?: ShaderMaterialParameters;
        /** 直接给材质参数 */
        material?: Material;
        /** 如果不输入，则默认为当前鼠标 如输入[0-1] */
        mouseInputPos?: [number, number];
        /** 渲染次序 */
        renderOrder?: number;
        /** 视锥体剔除 默认true */
        frustumCulled?: boolean;
    }

    declare interface Platform {
        createCanvas(): HTMLCanvasElement;
        measureText(text: string, font?: string): {
            width: number;
        };
        loadImage(src: string, onload: () => void | HTMLImageElement['onload'], onerror: () => void | HTMLImageElement['onerror']): HTMLImageElement;
    }

    /** 插件管理 */
    export declare class PluginManager {
        #private;
        cacheResult: Map<string, any>;
        private loaderUrlPath;
        /**
         * 加载一个插件
         * @param path 路径
         * @param opts
         */
        loadPlugin(path: string, opts?: LoadPluginOpts): Promise<any>;
        /**
         * 加载一个库
         * @param path 路径
         * @param opts
         */
        loadLibrary(path: string, opts?: LoadPluginOpts): Promise<any>;
        setLoaderPath(urlPath: string, dirs?: Array<string>): void;
    }

    export declare let Plugins: vjmap3d_2.PluginManager;

    declare class Point {
        x: number;
        y: number;
        constructor(x?: number, y?: number);
        /**
         * Copy from another point
         */
        copy(other: PointLike): this;
        /**
         * Clone a point
         */
        clone(): Point;
        /**
         * Set x and y
         */
        set(x: number, y: number): this;
        /**
         * If equal to another point
         */
        equal(other: PointLike): boolean;
        /**
         * Add another point
         */
        add(other: PointLike): this;
        scale(scalar: number): void;
        scaleAndAdd(other: PointLike, scalar: number): void;
        /**
         * Sub another point
         */
        sub(other: PointLike): this;
        /**
         * Dot product with other point
         */
        dot(other: PointLike): number;
        /**
         * Get length of point
         */
        len(): number;
        /**
         * Get squared length
         */
        lenSquare(): number;
        /**
         * Normalize
         */
        normalize(): this;
        /**
         * Distance to another point
         */
        distance(other: PointLike): number;
        /**
         * Square distance to another point
         */
        distanceSquare(other: Point): number;
        /**
         * Negate
         */
        negate(): this;
        /**
         * Apply a transform matrix array.
         */
        transform(m: MatrixArray): this;
        toArray(out: number[]): number[];
        fromArray(input: number[]): void;
        static set(p: PointLike, x: number, y: number): void;
        static copy(p: PointLike, p2: PointLike): void;
        static len(p: PointLike): number;
        static lenSquare(p: PointLike): number;
        static dot(p0: PointLike, p1: PointLike): number;
        static add(out: PointLike, p0: PointLike, p1: PointLike): void;
        static sub(out: PointLike, p0: PointLike, p1: PointLike): void;
        static scale(out: PointLike, p0: PointLike, scalar: number): void;
        static scaleAndAdd(out: PointLike, p0: PointLike, p1: PointLike, scalar: number): void;
        static lerp(out: PointLike, p0: PointLike, p1: PointLike, t: number): void;
    }

    export declare function pointDistance(a: [number, number, number], b: [number, number, number]): number;

    /**
     * A point emitter emits particles from a single point.
     */
    export declare class PointEmitter implements EmitterShape {
        type: string;
        constructor();
        update(system: ParticleSystem, delta: number): void;
        initialize(p: Particle): void;
        toJSON(): ShapeJSON;
        static fromJSON(json: any): PointEmitter;
        clone(): EmitterShape;
    }

    /**
     * A helper class to handle pointer events and dispatch drag events: `drag`, `dragStart` and `dragEnd` with NDC coordinates and time.
     *
     * To use, create an object of the class, set `element` with the HTML element(like canvas) and add event listeners to drag events.
     *
     * @example
     * ```ts
     * const pointerDragHelper = new PointerDragHelper()
     * pointerDragHelper.element = canvas
     * pointerDragHelper.addEventListener('dragStart', (e) => {
     *    console.log('dragStart', e.pointer)
     *    // {x: -0.5, y: 0.5, time: 123456789}
     *    // x and y are NDC coordinates, time is the time when the event is fired.
     *    // x and y are in the range of [-1, 1].
     *    // x is left to right, y is bottom to top.
     *    // time is in milliseconds.
     * })
     * pointerDragHelper.addEventListener('drag', (e) => {
     *   console.log('drag', e.pointer)
     *   // {x: -0.5, y: 0.5, time: 123456789}
     * })
     * pointerDragHelper.addEventListener('dragEnd', (e) => {
     *  console.log('dragEnd', e.pointer)
     *  // {x: -0.5, y: 0.5, time: 123456789}
     * })
     * ```
     */
    export declare class PointerDragHelper extends SimpleEventDispatcher<"dragStart" | "drag" | "dragEnd"> implements IDisposable {
        private _pointerDown?;
        private _pointer?;
        private _pointerUp?;
        get element(): HTMLElement | undefined;
        set element(value: HTMLElement | undefined);
        private _element?;
        private _removeElement;
        private _addElement;
        private readonly _onPointerDown;
        private readonly _onPointerMove;
        private readonly _onPointerUp;
        dispose(): void;
    }

    declare interface PointerInput {
        pointerId: number;
        clientX: number;
        clientY: number;
        deltaX: number;
        deltaY: number;
        mouseButton: MOUSE_BUTTON | null;
    }

    declare interface PointLike {
        x: number;
        y: number;
    }

    declare class PointsHelper extends InstancedMesh {
        constructor(count?: number, points?: Vector3[]);
        setPoints(points: Vector3): void;
    }

    /**
     * Connects two bodies at given offset points.
     * @example
     *     const bodyA = new Body({ mass: 1 })
     *     const bodyB = new Body({ mass: 1 })
     *     bodyA.position.set(-1, 0, 0)
     *     bodyB.position.set(1, 0, 0)
     *     bodyA.addShape(shapeA)
     *     bodyB.addShape(shapeB)
     *     world.addBody(bodyA)
     *     world.addBody(bodyB)
     *     const localPivotA = new Vec3(1, 0, 0)
     *     const localPivotB = new Vec3(-1, 0, 0)
     *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB)
     *     world.addConstraint(constraint)
     */
    declare class PointToPointConstraint extends Constraint {
        /**
         * Pivot, defined locally in bodyA.
         */
        pivotA: Vec3;
        /**
         * Pivot, defined locally in bodyB.
         */
        pivotB: Vec3;
        equationX: ContactEquation;
        equationY: ContactEquation;
        equationZ: ContactEquation;
        /**
         * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
         * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
         * @param pivotB The point relative to the center of mass of bodyB which bodyB is constrained to.
         * @param maxForce The maximum force that should be applied to constrain the bodies.
         */
        constructor(bodyA: Body_2, pivotA: Vec3, bodyB: Body_2, pivotB?: Vec3, maxForce?: number);
        update(): void;
    }

    /**
     * 点到线段的距离
     * @param p
     * @param p1
     * @param p2
     * @return {number}
     */
    export declare function pointToSegmentDistance(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): number;

    declare class Polygon extends Path<PolygonProps> {
        shape: PolygonShape;
        constructor(opts?: PolygonProps);
        getDefaultShape(): PolygonShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: PolygonShape): void;
    }

    /**
     * Polygon Geometry Object
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.6
     */
    declare interface Polygon_2 extends GeometryObject {
        type: "Polygon";
        coordinates: Position[][];
    }

    export declare interface PolygonItemData {
        /** id */
        id?: string;
        /** 坐标 */
        coordinates: [number, number, number][][] | [number, number, number][];
        /** 颜色 */
        color?: ColorRepresentation | ColorRepresentation[];
        /** 透明度(0-1) */
        opacity?: number;
        /** 颜色 */
        borderColor?: ColorRepresentation;
        /**  是否显示顶点 */
        showVertex?: boolean;
        /** 是否禁止编辑 */
        disableEdit?: boolean;
        /** 是否隐藏 */
        hidden?: boolean;
        /** 自定义数据 */
        [key: string]: any;
    }

    declare interface PolygonProps extends PathProps {
        shape?: Partial<PolygonShape>;
    }

    /**
     * 多边形实体
     */
    export declare class PolygonsEntity extends Entity {
        constructor(options: PolygonsEntityOptions);
        /**
         * 获取多边形对象
         */
        getPolygons: () => Mesh;
        /**
         * 获取顶点对象
         */
        getVertexSymbol: () => SymbolEntity;
        /**
         * 是否显示顶点
         */
        isShowVertex: () => boolean;
        /**
         * 设置是否显示顶点
         */
        setShowVertex: (show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }) => void;
        /**
         * 获取顶点数据
         */
        getVertexData: (isGetAll?: boolean) => SymbolItemData[];
        /**
         * 获取多边形边框对象
         */
        getBorderPolyline: () => LineSegments2_2;
        /**
         * 更新样式
         */
        updateStyle: (style: MeshBasicMaterialParameters) => void;
        /**
         * 更新高亮样式
         */
        updateHightStyle: (style: MeshBasicMaterialParameters) => void;
        /**
         * 修改数据
         */
        setData: (data: PolygonItemData[]) => void;
        /**
         * 获取数据
         */
        getData: () => PolygonItemData[];
        /**
         * 通过faceIndex获取
         * @param faceIndex 索引
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
            positionIndex: number;
        } & PolygonItemData;
        /**
         * 刷新高亮数据
         */
        refreshHighlight: () => void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight: (id: string) => boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight: () => void;
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
    }

    export declare type PolygonsEntityOptions = EntityOptions & PolygonsModuleOption;

    declare class PolygonShape {
        points: VectorArray[];
        smooth?: number;
        smoothConstraint?: VectorArray[];
    }

    /**
     * 拉伸模块,用来绘制批量拉伸
     */
    export declare class PolygonsModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        polygons: Mesh;
        data: PolygonItemData[];
        style: MeshBasicMaterialParameters;
        highlightPolygons: Mesh;
        highlightData: PolygonItemData[];
        highlightIndexMap: Map<string, number>;
        highlightStyle: MeshBasicMaterialParameters;
        facePosIndex: Map<number, {
            polyIndex: number;
            face: [number, number, number];
        }>;
        isXYPlane: boolean;
        borderStyle: LineMaterialParameters_2;
        showBorder: boolean;
        useBvh: boolean;
        borderPolyline: LineSegments2_2;
        vertexEntity: SymbolEntity;
        showVertex: boolean;
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
        constructor(entity: Entity, options?: PolygonsModuleOption);
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            app: App;
            children: {
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
            }[];
        };
        /**
         * 获取拉伸对象
         */
        getPolygons(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
        /**
         * 获取顶点对象
         */
        getVertexSymbol(): SymbolEntity;
        /**
         * 获取拉伸边框对象
         */
        getBorderPolyline(): LineSegments2_2;
        /**
         * 更新样式
         */
        updateStyle(style: MeshBasicMaterialParameters): void;
        /**
         * 更新高亮样式
         */
        updateHightStyle(style: MeshBasicMaterialParameters): void;
        /**
         * 是否显示顶点
         */
        isShowVertex(): boolean;
        /**
         * 获取顶点数据
         */
        getVertexData(isGetAll?: boolean): SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex(show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }): void;
        /**
         * 修改数据
         */
        setData(data: PolygonItemData[]): void;
        /**
         * 获取数据
         */
        getData(): PolygonItemData[];
        /**
         * 通过faceIndex获取
         * @param faceIndex 面索引值
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
            data: PolygonItemData;
            face: [number, number, number];
        } | {
            face: number[];
            /** id */
            id?: string;
            /** 坐标 */
            coordinates: [number, number, number][] | [number, number, number][][];
            /** 颜色 */
            color?: ColorRepresentation | ColorRepresentation[];
            /** 透明度(0-1) */
            opacity?: number;
            /** 颜色 */
            borderColor?: ColorRepresentation;
            /**  是否显示顶点 */
            showVertex?: boolean;
            /** 是否禁止编辑 */
            disableEdit?: boolean;
            /** 是否隐藏 */
            hidden?: boolean;
            data?: undefined;
        };
        /**
         * 刷新高亮数据
         * @returns
         */
        refreshHighlight(): void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight(id: string): boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight(): void;
    }

    export declare interface PolygonsModuleOption {
        /** 数据 */
        data: PolygonItemData[];
        /** 样式 */
        style?: MeshBasicMaterialParameters;
        /** 高亮样式 */
        highlightStyle?: MeshBasicMaterialParameters;
        /** 边框样式 */
        borderStyle?: LineMaterialParameters_2;
        /** 是否显示边框 */
        showBorder?: boolean;
        /** 数据是否在xy平面，默认为xz 平面 */
        isXYPlane?: boolean;
        /** 是否使用bvh射线查询。默认是 */
        useBvh?: boolean;
        /** 是否显示顶点(全局控制显示) */
        showVertex?: boolean;
        /** y方向偏离值，默认0.1，用于解决z-fighting */
        yOffsetDelta?: number;
        /** 顶点样式 */
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
    }

    declare class Polyline extends Path<PolylineProps> {
        shape: PolylineShape;
        constructor(opts?: PolylineProps);
        getDefaultStyle(): {
            stroke: string;
            fill: string;
        };
        getDefaultShape(): PolylineShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: PolylineShape): void;
    }

    export declare interface PolylineItemData {
        /** id */
        id?: string;
        /** 坐标 */
        coordinates: [number, number, number][];
        /** 颜色 */
        color?: ColorRepresentation | ColorRepresentation[];
        /** 线宽 */
        lineWidth?: number;
        /** 透明度 */
        opacity?: number;
        /** 是否是虚线 */
        dashed?: boolean;
        /** 虚线偏移量 */
        dashOffset?: number;
        /** 虚线缩放量 */
        dashScale?: number;
        /** 虚线尺寸 */
        dashSize?: number;
        /** 间隙尺寸 */
        gapSize?: number;
        /** 是否显示顶点 */
        showVertex?: boolean;
        /** 是否禁止编辑 */
        disableEdit?: boolean;
        /** 是否隐藏 */
        hidden?: boolean;
        /** 自定义数据 */
        [key: string]: any;
    }

    declare interface PolylineProps extends PathProps {
        shape?: Partial<PolylineShape>;
    }

    /**
     * 多段线实体
     */
    export declare class PolylinesEntity extends Entity {
        constructor(options: PolylinesEntityOptions);
        /**
         * 获取线对象
         */
        getPolylines: () => LineSegments2_2;
        /**
         * 获取顶点对象
         */
        getVertexSymbol: () => SymbolEntity;
        /**
         * 是否显示顶点
         */
        isShowVertex: () => boolean;
        /**
         * 获取顶点数据
         */
        getVertexData: (isGetAll?: boolean) => SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex: (show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }) => void;
        /**
         * 更新样式
         */
        updateStyle: (style: LineMaterialParameters_2) => void;
        /**
         * 更新高亮样式
         */
        updateHightStyle: (style: LineMaterialParameters_2) => void;
        /**
         * 修改数据
         */
        setData: (data: PolylineItemData[]) => void;
        /**
         * 获取数据
         */
        getData: () => PolylineItemData[];
        /**
         * 通过faceIndex获取
         * @param faceIndex 面索引值
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
            positionIndex: number;
        } & PolylineItemData;
        /**
         * 刷新高亮数据
         */
        refreshHighlight: () => void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight: (id: string) => boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight: () => void;
        /**
         * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
         */
        isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
    }

    export declare type PolylinesEntityOptions = EntityOptions & PolylinesModuleOption;

    declare class PolylineShape {
        points: VectorArray[];
        percent?: number;
        smooth?: number;
        smoothConstraint?: VectorArray[];
    }

    /**
     * 多段线模块,用来绘制批量多段线
     */
    export declare class PolylinesModule extends EntityModuleBase implements IEntityModuleBase {
        #private;
        static moduleName: string;
        polylines: LineSegments2;
        data: PolylineItemData[];
        style: LineMaterialParameters;
        highlightPolylines: LineSegments2;
        highlightData: PolylineItemData[];
        highlightStyle: LineMaterialParameters;
        highlightIndexMap: Map<string, number>;
        facePosIndex: Map<number, {
            lineIndex: number;
            positionIndex: number;
        }>;
        vertexEntity: SymbolEntity;
        showVertex: boolean;
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
        constructor(entity: Entity, options?: PolylinesModuleOption);
        setupUiConfig(): {
            type: string;
            expanded: boolean;
            label: string;
            app: App;
            children: {
                type: string;
                label: string;
                getValue: () => boolean;
                setValue: (v: any) => void;
            }[];
        };
        /**
         * 获取线对象
         */
        getPolylines(): LineSegments2;
        /**
         * 获取顶点对象
         */
        getVertexSymbol(): SymbolEntity;
        /**
         * 更新样式
         */
        updateStyle(style: LineMaterialParameters): void;
        /**
         * 更新高亮样式
         */
        updateHightStyle(style: LineMaterialParameters): void;
        /**
         * 修改数据
         */
        setData(data: PolylineItemData[]): void;
        /**
         * 是否显示顶点
         */
        isShowVertex(): boolean;
        /**
         * 获取顶点数据
         */
        getVertexData(isGetAll?: boolean): SymbolItemData[];
        /**
         * 设置是否显示顶点
         */
        setShowVertex(show: boolean, symbolStyleOptions?: {
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }): void;
        /**
         * 获取数据
         */
        getData(): PolylineItemData[];
        /**
         * 通过faceIndex获取
         * @param faceIndex 面索引值
         * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
         */
        getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
            data: PolylineItemData;
            positionIndex: number;
        } | {
            positionIndex: number;
            /** id */
            id?: string;
            /** 坐标 */
            coordinates: [number, number, number][];
            /** 颜色 */
            color?: ColorRepresentation | ColorRepresentation[];
            /** 线宽 */
            lineWidth?: number;
            /** 透明度 */
            opacity?: number;
            /** 是否是虚线 */
            dashed?: boolean;
            /** 虚线偏移量 */
            dashOffset?: number;
            /** 虚线缩放量 */
            dashScale?: number;
            /** 虚线尺寸 */
            dashSize?: number;
            /** 间隙尺寸 */
            gapSize?: number;
            /** 是否显示顶点 */
            showVertex?: boolean;
            /** 是否禁止编辑 */
            disableEdit?: boolean;
            /** 是否隐藏 */
            hidden?: boolean;
            data?: undefined;
        };
        /**
         * 刷新高亮数据
         * @returns
         */
        refreshHighlight(): void;
        /**
         * 设置某项高亮与否
         * @param id id
         * @param ishighlight 是否
         * @param disableAutoRefreshData  不自动刷新，需要调用 refreshHighlight 来刷新
         * @returns
         */
        setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
        /**
         * 获取某项高亮与否
         * @param id id
         * @returns
         */
        isItemHighlight(id: string): boolean;
        /**
         * 清除所有高亮
         * @returns
         */
        clearHighlight(): void;
    }

    export declare interface PolylinesModuleOption {
        /** 数据 */
        data: PolylineItemData[];
        /** 样式 */
        style?: LineMaterialParameters;
        /** 高亮样式(高亮样式的线宽是指在原来的线宽上的变化值) */
        highlightStyle?: LineMaterialParameters;
        /** 是否显示顶点(全局控制显示) */
        showVertex?: boolean;
        /** 顶点样式 */
        vertexStyle?: SymbolMaterialProps & {
            pointColor?: ColorRepresentation;
            pointBorderColor?: ColorRepresentation;
            pointSize?: number;
        };
    }

    /**
     * For pooling objects that can be reused.
     */
    declare class Pool {
        /**
         * The objects array.
         */
        objects: any[];
        /**
         * The type of the objects.
         */
        type: any;
        /**
         * Release an object after use
         */
        release(...args: any[]): Pool;
        /**
         * Get an object
         */
        get(): any;
        /**
         * Construct an object. Should be implemented in each subclass.
         */
        constructObject(): void;
        /**
         * @return Self, for chaining
         */
        resize(size: number): Pool;
    }

    export declare type PopopOffset = [number, number] | number | {
        'center'?: [number, number];
        'top'?: [number, number];
        'bottom'?: [number, number];
        'left'?: [number, number];
        'right'?: [number, number];
        'top-left'?: [number, number];
        'top-right'?: [number, number];
        'bottom-left'?: [number, number];
        'bottom-right'?: [number, number];
    };

    /**
     * 2d的html的信息弹出窗
     */
    export declare class Popup2D extends CSS2DObject {
        #private;
        app: App;
        options: PopupOptions;
        _content: HTMLElement;
        _container: HTMLElement;
        _closeButton: HTMLElement;
        _tip: HTMLElement;
        _pos?: [number, number];
        _anchor: Anchor;
        _classList: Set<string>;
        isPopup2D: boolean;
        signal: {
            open: Signal;
            close: Signal;
            elementSizeReady: Signal;
        };
        constructor(options?: PopupOptions);
        /**
         * 增加弹出信息框.
         *
         * @param {App} app add the popup to.
         */
        addTo(app: App | Entity | Object3D, curApp?: App): this;
        /**
         * 弹出信息框是否打开.
         *
         * @returns {boolean} `true` 打开, `false` 关闭
         * @example
         * const isPopupOpen = popup.isOpen();
         */
        isOpen(): boolean;
        /**
         * 移除弹出信息框.
         *
         * @example
         * const popup = new vjvjmap3d.Popup().addTo(app);
         * popup.remove();
         * @returns {Popup} Returns itself to allow for method chaining.
         */
        remove(): this;
        /**
         * 获取位置.
         */
        getPosition(): Vector3;
        /**
         *设置位置.
         */
        setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): this;
        /**
         * 获取信息弹出框元素.
         *
         * @example
         * // Change the `Popup` element's font size
         * const popup = new vjvjmap3d.Popup()
         *     .setLngLat([-96, 37.8])
         *     .setHTML("<p>Hello World!</p>")
         *     .addTo(app);
         * const popupElem = popup.getElement();
         * popupElem.style.fontSize = "25px";
         * @returns {HTMLElement} Returns container element.
         */
        getElement(): HTMLElement;
        isShow(): boolean;
        show(): void;
        hide(): void;
        /**
         * 设置信息弹出框信息内容.
         *
         * This function creates a Text node in the DOM,
         * so it cannot insert raw HTML. Use this method for security against XSS
         * if the popup content is user-provided.
         *
         * @param {string} text Textual content for the popup.
         * @returns {Popup} Returns itself to allow for method chaining.
         * @example
         * popup.setText('Hello, world!')
         */
        setText(text: string): this;
        /**
         * 设置信息弹出框html内容.
         *
         * @param {string} html A string representing HTML content for the popup.
         * @returns {Popup} Returns itself to allow for method chaining.
         * @example
         * popup.setHTML("<h1>Hello World!</h1>")
         */
        setHTML(html: string): this;
        /**
         * 获取信息弹出框最大宽度.
         *
         * @returns {string} The maximum width of the popup.
         * @example
         * const maxWidth = popup.getMaxWidth();
         */
        getMaxWidth(): string;
        /**
         * 设置信息弹出框最大宽度. CSS 属性 `max-width`.
         *
         * @param {string} maxWidth A string representing the value for the maximum width.
         * @returns {Popup} Returns itself to allow for method chaining.
         * @example
         * popup.setMaxWidth('50');
         */
        setMaxWidth(maxWidth: string): this;
        /**
         * 将弹出窗口的内容设置为作为DOM节点提供的元素.
         *
         * @param {Element} htmlNode A DOM node to be used as content for the popup.
         * @returns {Popup} Returns itself to allow for method chaining.
         * @example
         * // create an element with the popup content
         * const div = window.document.createElement('div');
         * div.innerHTML = 'Hello, world!';
         * popup.setDOMContent(div)
         */
        setDOMContent(htmlNode: Node): this;
        /**
         * 将CSS类名添加到弹出容器元素中。
         *
         * @param {string} className Non-empty string with CSS class name to add to popup container.
         * @returns {Popup} Returns itself to allow for method chaining.
         *
         * @example
         * const popup = new vjvjmap3d.Popup();
         * popup.addClassName('some-class');
         */
        addClassName(className: string): this;
        /**
         * 从弹出式容器元素中删除一个CSS类。
         *
         * @param {string} className Non-empty string with CSS class name to remove from popup container.
         *
         * @returns {Popup} Returns itself to allow for method chaining.
         * @example
         * const popup = new vjvjmap3d.Popup({className: 'some classes'});
         * popup.removeClassName('some');
         */
        removeClassName(className: string): this;
        /**
         * 设置信息弹出框偏移量
         *
         * @param {number | PointLike | Object} offset Sets the popup's offset. The `Object` is of the following structure
         * @returns {Popup} `this`.
         * @example
         * popup.setOffset(10);
         */
        setOffset(offset?: PopopOffset): this;
        /**
         * 在弹出容器上添加或删除给定的CSS类，具体取决于容器当前是否具有该类。
         *
         * @param {string} className Non-empty string with CSS class name to add/remove.
         *
         * @returns {boolean} If the class was removed return `false`. If the class was added, then return `true`.
         *
         * @example
         * const popup = new vjvjmap3d.Popup();
         * popup.toggleClassName('highlighted');
         */
        toggleClassName(className: string): boolean;
        _createCloseButton(): void;
        _onMouseUp(event: InteractiveEvent): void;
        _onMouseMove(event: InteractiveEvent): void;
        _onDrag(event: InteractiveEvent): void;
        _getAnchor(offset: any): Anchor;
        updateClassList(): void;
        /**
         * 设置颜色
         * @param bkColor 背景色
         * @param closeBtnColor 关闭按钮颜色
         */
        setColor(bkColor?: string, closeBtnColor?: string): void;
        update(cursor?: [number, number]): void;
        _focusFirstElement(): void;
        _onClose(): void;
        setOpacity(opacity: string | number): void;
        static normalizeOffset(offset?: PopopOffset): {
            center: number[];
            top: number[];
            'top-left': number[];
            'top-right': number[];
            bottom: number[];
            'bottom-left': number[];
            'bottom-right': number[];
            left: number[];
            right: number[];
        };
    }

    export declare type PopupOptions = {
        closeButton?: boolean;
        closeOnClick?: boolean;
        closeOnMove?: boolean;
        focusAfterOpen?: boolean;
        anchor?: Anchor;
        offset?: PopopOffset;
        className?: string;
        maxWidth?: string;
        backgroundColor?: string;
        buttonColor?: string;
        showArrow?: boolean;
        /** 开始时隐藏 */
        isHide?: boolean;
    };

    /**
     * Position
     *
     * https://tools.ietf.org/html/rfc7946#section-3.1.1
     * Array should contain between two and three elements.
     * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
     * but the current specification only allows X, Y, and (optionally) Z to be defined.
     */
    declare type Position = [number, number] | [number, number, number];

    export declare class PostProcessModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: PostProcessModuleOptions;
        _isFirstRender: boolean;
        depthPickingPass: DepthPickingPass_2;
        _composer: EffectComposer_2;
        _passes: Pass_2[];
        signal: {
            beforeAddComposer: Signal;
            afterAddComposer: Signal;
            beforeAddRenderPass: Signal;
            afterAddRenderPass: Signal;
            beforeRemoveComposer: Signal;
            afterRemoveComposer: Signal;
            beforeRemoveRenderPass: Signal;
            afterRemoveRenderPass: Signal;
            beforRenderComposer: Signal;
            afterRenderComposer: Signal;
            beforRebuild: Signal;
            afterRebuild: Signal;
        };
        constructor(app?: App, options?: PostProcessModuleOptions);
        get composer(): EffectComposer_2;
        addEffectRenderPass(pass: Pass_2, orderIndex?: number): void;
        setEffectRenderPassOrder(pass: Pass_2, orderIndex: number): void;
        removeEffectRenderPass(pass: Pass_2): void;
        setEffectRenderPassEnable(pass: Pass_2, enable: boolean): void;
        isComposerEnable(): boolean;
        setComposerEnable(b: boolean): void;
        onAwake(): void;
        get outlineEffect(): OutlineEffect_2;
        get bloomEffect(): SelectiveBloomEffect_3;
        get selectedEffect(): OutlineEffect_2;
        getDepth(x: number, y: number): Promise<number>;
        refreshEffectRenderPass(foreceUpdate?: boolean): void;
        onAppRender(time: Time): void;
        addKawaseBlurPass(): void;
        addToneMappingEffect(): void;
        addColorDepthEffect(): void;
        addDepthOfFieldEffect(): void;
        addGlitchEffect(): void;
        addPixelationEffect(): void;
        addSSAOEffect(): void;
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface PostProcessModuleOptions {
        enable?: boolean;
        renderTargetOptions?: {
            depthBuffer?: boolean;
            stencilBuffer?: boolean;
            alpha?: boolean;
            /** 默认4 */
            multisampling?: number;
            frameBufferType?: number;
        };
        /** 自动增加渲染通道 */
        autoAddRenderPass?: boolean;
        /** 自动增加Selected Outline通道 */
        autoAddSelectedPass?: boolean;
        /** 自动增加辉光通道 */
        autoAddBloomPass?: boolean;
        /** 自动增加Outline通道 */
        autoAddOutlinePass?: boolean;
        /** 自动增加copypass通道 */
        autoAddCopyPass?: boolean;
        /** 当selected空闲时，自动禁用，有数据时才启用，默认true*/
        disableSelectedPassWhenIdle?: boolean;
        /** 当bloom空闲时，自动禁用，有数据时才启用，默认true*/
        disableBloomPassWhenIdle?: boolean;
        /** 当bloom空闲时，自动禁用，有数据时才启用，默认true*/
        disableOutlinePassWhenIdle?: boolean;
        /** 是否允许渲染更新 */
        renderUpdate?: boolean;
        /** 自动清除 */
        autoClear?: boolean;
        /** 使用smaa反锯齿 */
        useSMAA?: boolean;
        /** 使用fxaa反锯齿 */
        useFXAA?: boolean;
        /** 当无需后期处理时自动禁止后期处理,默认false */
        disableWhenIdle?: boolean;
        depthPickingPass?: boolean;
        /** 当深度拾取空闲时，自动停止,时间秒,0表示不自动停止。默认3*/
        disableDepthPickTime?: number;
        /** 拾取深度时，有效最小值，默认0 */
        depthPickMinZ?: number;
        /** 当logarithmicDepthBuffer为true时禁止深度拾取，默认false */
        disableDepthPickWhenlogDepthBuffer?: boolean;
        /** workaroundEnabled */
        workaroundEnabled?: boolean;
        /**  禁止自动合并通道 默认false */
        disableMergeEffect?: boolean;
        /**  合并道道时禁止缓存 默认false */
        disableCacheEffectPass?: boolean;
        bloomPass?: {
            blendFunction?: BlendFunction_2;
            luminanceThreshold?: number;
            luminanceSmoothing?: number;
            mipmapBlur?: boolean;
            intensity?: number;
            radius?: number;
            levels?: number;
            kernelSize?: KernelSize_2;
            resolutionScale?: number;
            width?: number;
            height?: number;
            resolutionX?: number;
            resolutionY?: number;
            luminancePassEnabled?: boolean;
            ignoreBackground?: boolean;
            inverted?: boolean;
            /**  禁止自动合并通道 默认true */
            disableMergeEffect?: boolean;
        };
        outlinePass?: {
            blendFunction?: BlendFunction_2;
            patternTexture?: Texture;
            patternScale?: number;
            edgeStrength?: number;
            pulseSpeed?: number;
            visibleEdgeColor?: number;
            hiddenEdgeColor?: number;
            multisampling?: number;
            resolutionScale?: number;
            resolutionX?: number;
            resolutionY?: number;
            width?: number;
            height?: number;
            blur?: boolean;
            xRay?: boolean;
            blurriness?: number;
            /**  禁止自动合并通道 默认false */
            disableMergeEffect?: boolean;
        };
        selectedPass?: {
            blendFunction?: BlendFunction_2;
            patternTexture?: Texture;
            patternScale?: number;
            edgeStrength?: number;
            pulseSpeed?: number;
            visibleEdgeColor?: number;
            hiddenEdgeColor?: number;
            multisampling?: number;
            resolutionScale?: number;
            resolutionX?: number;
            resolutionY?: number;
            width?: number;
            height?: number;
            blur?: boolean;
            xRay?: boolean;
            blurriness?: number;
            /**  禁止自动合并通道 默认false */
            disableMergeEffect?: boolean;
        };
    }

    export { PredicationMode }

    /**
     * Styles the default scrollbar to be more pretty and less intrusive (especially on dark backgrounds), (similar to MacOS)
     */
    export declare function prettyScrollbar(root?: Element | undefined): HTMLStyleElement;

    export declare function preventDefaultEvent(event?: any): void;

    declare const PRIMARY_STATES_KEYS: ["x" | "y" | "originX" | "originY" | "anchorX" | "anchorY" | "rotation" | "scaleX" | "scaleY" | "skewX" | "skewY", "ignore"];

    declare type Primitive = string | number | boolean | bigint | symbol | undefined | null;

    /**
     * `GeoPoint` 地理坐标.
     */
    export declare abstract class Projection {
        /** The equatorial semi perimeter in meters. */
        static EQUATORIAL_SEMIPERIMETER: number;
        /** The equatorial semi perimeter in meters. */
        static EARTH_BOUNDS: [number, number, number, number];
        /**
         * 经纬度转墨卡托 .
         */
        static lngLat2Mercator(input: GeoPointLike): [number, number];
        /**
         * 墨卡托转经纬度 .
         */
        static mercator2LngLat(input: GeoPointLike): [number, number];
        /**
         * 坐标转墨卡托(epsg:3857)
         * @param input 坐标点
         * @return {[number, number]}
         */
        abstract toMercator(input: GeoPointLike): [number, number];
        /**
         * 墨卡托(epsg:3857)转坐标
         * @param input 墨卡托坐标点
         * @return {[number, number]}
         */
        abstract fromMercator(input: GeoPointLike): [number, number];
        /**
         * 地图地理坐标转经纬度
         * @param input 地理坐标点
         * @return {[number, number]}
         */
        abstract toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): [number, number];
        /**
         * 经纬度转地图地理坐标
         * @param input 经纬度坐标点
         * @return {GeoPoint}
         */
        abstract fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
        /**
         * 得到地图范围
         * @return {GeoBounds}
         */
        abstract getMapExtent(): GeoBounds;
        /**
         * 把距离转化为米
         * @param dist
         */
        abstract toMeter(dist: number): number;
        /**
         * 把米转化为距离
         * @param meter
         */
        abstract fromMeter(meter: number): number;
    }

    declare class ProjectionGenerator {
        [key: string]: any;
    }

    export declare class PromiseBehavior extends Behavior {
        __factory: any;
        __promise: any;
        __promise_state: BehaviorStatus;
        /**
         *
         * @param {()=>Promise} factory
         */
        constructor(factory: Promise<any>);
        initialize(context: BehaviorContext): void;
        tick(timeDelta: number): BehaviorStatus;
    }

    /**
     * Properties
     *
     * https://tools.ietf.org/html/rfc7946#section-3.2
     * A Feature object has a member with the name 'properties'.
     * The value of the properties member is an object (any JSON object or a JSON null value).
     */
    declare type Properties = {
        [name: string]: any;
    } | null;

    declare type PropType<TObj, TProp extends keyof TObj> = TObj[TProp];

    /**
     * Returns a reactive proxy for the given object.
     *
     * If the object already is reactive, it's returned as-is. If not, a new
     * reactive proxy is created. Direct child properties that are refs are properly
     * handled, as well.
     *
     * @param objectWithRefs - Either an already-reactive object or a simple object
     * that contains refs.
     */
    declare function proxyRefs<T extends object>(objectWithRefs: T): ShallowUnwrapRef<T>;

    /**
     * 对状态进行设置，采用堆栈方案，会保存之前的状态，退出时还原之前的状态
     */
    export declare function pushObjectStatus(obj: Record<string, any>, attr: Record<string, any>): {
        push: () => void;
        pop: () => void;
    };

    export declare class PushValueCommand<T> extends BaseCommand {
        private container;
        private object;
        constructor(container: T[], object: T);
        execute(): void;
        undo(): void;
        redo(): void;
    }

    /**
     * Constants to store quad-tree positions.
     */
    export declare class QuadTreePosition {
        /**
         * Root node has no location.
         */
        static root: number;
        /**
         * Index of top left quad-tree branch node.
         *
         * Can be used to navigate the children array looking for neighbors.
         */
        static topLeft: number;
        /**
         * Index of top left quad-tree branch node.
         *
         * Can be used to navigate the children array looking for neighbors.
         */
        static topRight: number;
        /**
         * Index of top left quad-tree branch node.
         *
         * Can be used to navigate the children array looking for neighbors.
         */
        static bottomLeft: number;
        /**
         * Index of top left quad-tree branch node.
         *
         * Can be used to navigate the children array looking for neighbors.
         */
        static bottomRight: number;
    }

    /**
     * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
     * @param x Multiplier of the imaginary basis vector i.
     * @param y Multiplier of the imaginary basis vector j.
     * @param z Multiplier of the imaginary basis vector k.
     * @param w Multiplier of the real part.
     * @see http://en.wikipedia.org/wiki/Quaternion
     */
    declare class Quaternion_2 {
        x: number;
        y: number;
        z: number;
        w: number;
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * Set the value of the quaternion.
         */
        set(x: number, y: number, z: number, w: number): Quaternion_2;
        /**
         * Convert to a readable format
         * @return "x,y,z,w"
         */
        toString(): string;
        /**
         * Convert to an Array
         * @return [x, y, z, w]
         */
        toArray(): [number, number, number, number];
        /**
         * Set the quaternion components given an axis and an angle in radians.
         */
        setFromAxisAngle(vector: Vec3, angle: number): Quaternion_2;
        /**
         * Converts the quaternion to [ axis, angle ] representation.
         * @param targetAxis A vector object to reuse for storing the axis.
         * @return An array, first element is the axis and the second is the angle in radians.
         */
        toAxisAngle(targetAxis?: Vec3): [Vec3, number];
        /**
         * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
         */
        setFromVectors(u: Vec3, v: Vec3): Quaternion_2;
        /**
         * Multiply the quaternion with an other quaternion.
         */
        mult(quat: Quaternion_2, target?: Quaternion_2): Quaternion_2;
        /**
         * Get the inverse quaternion rotation.
         */
        inverse(target?: Quaternion_2): Quaternion_2;
        /**
         * Get the quaternion conjugate
         */
        conjugate(target?: Quaternion_2): Quaternion_2;
        /**
         * Normalize the quaternion. Note that this changes the values of the quaternion.
         */
        normalize(): Quaternion_2;
        /**
         * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
         * @author unphased, https://github.com/unphased
         */
        normalizeFast(): Quaternion_2;
        /**
         * Multiply the quaternion by a vector
         */
        vmult(v: Vec3, target?: Vec3): Vec3;
        /**
         * Copies value of source to this quaternion.
         * @return this
         */
        copy(quat: Quaternion_2): Quaternion_2;
        /**
         * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
         * @param order Three-character string, defaults to "YZX"
         */
        toEuler(target: Vec3, order?: string): void;
        /**
         * Set the quaternion components given Euler angle representation.
         *
         * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
         *
         * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
         */
        setFromEuler(x: number, y: number, z: number, order?: string): Quaternion_2;
        clone(): Quaternion_2;
        /**
         * Performs a spherical linear interpolation between two quat
         *
         * @param toQuat second operand
         * @param t interpolation amount between the self quaternion and toQuat
         * @param target A quaternion to store the result in. If not provided, a new one will be created.
         * @returns {Quaternion} The "target" object
         */
        slerp(toQuat: Quaternion_2, t: number, target?: Quaternion_2): Quaternion_2;
        /**
         * Rotate an absolute orientation quaternion given an angular velocity and a time step.
         */
        integrate(angularVelocity: Vec3, dt: number, angularFactor: Vec3, target?: Quaternion_2): Quaternion_2;
    }

    export declare const RAD2DEG: number;

    export declare const RadarMaterial: (new (parameters?: ShaderMaterialParameters & Partial<RadarMaterialProps>, uniforms?: Partial<RadarMaterialProps>) => ShaderMaterial & RadarMaterialProps) & {
        key: string;
    };

    export declare type RadarMaterialProps = {
        /** 半径 */
        uRadius?: number;
        /** 颜色 */
        uColor?: Color;
        /** 速度 */
        uSpeed?: number;
        /** 扇区角度 */
        uSectorAngle?: number;
        /** 边缘距离 */
        uEdge?: number;
        /** 时间变量 */
        uTime?: number | {
            value: number;
        };
        [key: string]: any;
    };

    /**
     * x, y, r are all percent from 0 to 1 when globalCoord is false
     */
    declare class RadialGradient extends Gradient_2 {
        type: 'radial';
        x: number;
        y: number;
        r: number;
        constructor(x: number, y: number, r: number, colorStops?: GradientColorStop[], globalCoord?: boolean);
    }

    declare interface RadialGradientObject extends GradientObject {
        type: 'radial';
        x: number;
        y: number;
        r: number;
    }

    declare const RADIAN_TO_DEGREE: number;

    export declare function radToDeg(radians: number): number;

    export declare const randColor: () => Color;

    export declare const randHtmlColor: () => string;

    /**
     * 生成一个区间的随机总数
     * @param n
     * @param m
     * @return {number}
     */
    export declare function randInt(n: number, m: number): number;

    /**
     * Generate a random color
     */
    declare function random(): string;

    export declare class RandomColor implements ColorGenerator {
        a: Vector4;
        b: Vector4;
        constructor(a: Vector4, b: Vector4);
        genColor(color: Vector4): Vector4;
        type: "value";
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): RandomColor;
        clone(): ColorGenerator;
    }

    export declare class RandomColorBetweenGradient implements MemorizedFunctionColorGenerator {
        gradient1: Gradient;
        gradient2: Gradient;
        constructor(gradient1: Gradient, gradient2: Gradient);
        startGen(memory: any): void;
        genColor(color: Vector4, t: number, memory?: any): Vector4;
        type: 'memorizedFunction';
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): RandomColorBetweenGradient;
        clone(): RandomColorBetweenGradient;
    }

    /**
     * A random() function, must return a numer in the interval [0,1), just like Math.random().
     */
    declare type RandomFn = () => number;

    export declare class RandomQuatGenerator implements RotationGenerator {
        type: "rotation";
        constructor();
        genValue(quat: Quaternion, t: number): Quaternion;
        toJSON(): FunctionJSON;
        static fromJSON(json: FunctionJSON): RotationGenerator;
        clone(): RotationGenerator;
    }

    export declare const randPoint2D: (opts?: {
        maxX?: number;
        maxY?: number;
        minX?: number;
        minY?: number;
    }) => number[];

    export declare const randPoint3D: (opts?: {
        maxX?: number;
        maxY?: number;
        maxZ?: number;
        minX?: number;
        minY?: number;
        minZ?: number;
    }) => number[];

    declare type Raw<T> = T & {
        [RawSymbol]?: true;
    };

    declare const RawSymbol: unique symbol;

    /**
     * A line in 3D space that intersects bodies and return points.
     */
    declare class Ray_2 {
        /**
         * from
         */
        from: Vec3;
        /**
         * to
         */
        to: Vec3;
        /**
         * direction
         */
        direction: Vec3;
        /**
         * The precision of the ray. Used when checking parallelity etc.
         * @default 0.0001
         */
        precision: number;
        /**
         * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
         * @default true
         */
        checkCollisionResponse: boolean;
        /**
         * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
         * @default false
         */
        skipBackfaces: boolean;
        /**
         * collisionFilterMask
         * @default -1
         */
        collisionFilterMask: number;
        /**
         * collisionFilterGroup
         * @default -1
         */
        collisionFilterGroup: number;
        /**
         * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
         * @default RAY.ANY
         */
        mode: number;
        /**
         * Current result object.
         */
        result: RaycastResult;
        /**
         * Will be set to `true` during intersectWorld() if the ray hit anything.
         */
        hasHit: boolean;
        /**
         * User-provided result callback. Will be used if mode is Ray.ALL.
         */
        callback: RaycastCallback;
        /**
         * CLOSEST
         */
        static CLOSEST: 1;
        /**
         * ANY
         */
        static ANY: 2;
        /**
         * ALL
         */
        static ALL: 4;
        get [Shape.types.SPHERE](): (sphere: Sphere_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
        get [Shape.types.PLANE](): (shape: Plane_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
        get [Shape.types.BOX](): (box: Box, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
        get [Shape.types.CYLINDER](): (shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
            faceList: number[];
        }) => void;
        get [Shape.types.CONVEXPOLYHEDRON](): (shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
            faceList: number[];
        }) => void;
        get [Shape.types.HEIGHTFIELD](): (shape: Heightfield, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
        get [Shape.types.TRIMESH](): (mesh: Trimesh, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
            faceList?: any[];
        }) => void;
        constructor(from?: Vec3, to?: Vec3);
        /**
         * Do itersection against all bodies in the given World.
         * @return True if the ray hit anything, otherwise false.
         */
        intersectWorld(world: World, options: RayOptions): boolean;
        /**
         * Shoot a ray at a body, get back information about the hit.
         * @deprecated @param result set the result property of the Ray instead.
         */
        intersectBody(body: Body_2, result?: RaycastResult): void;
        /**
         * Shoot a ray at an array bodies, get back information about the hit.
         * @param bodies An array of Body objects.
         * @deprecated @param result set the result property of the Ray instead.
         *
         */
        intersectBodies(bodies: Body_2[], result?: RaycastResult): void;
        /**
         * Updates the direction vector.
         */
        private updateDirection;
        private intersectShape;
        _intersectBox(box: Box, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
        _intersectPlane(shape: Plane_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
        /**
         * Get the world AABB of the ray.
         */
        getAABB(aabb: AABB): void;
        _intersectHeightfield(shape: Heightfield, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
        _intersectSphere(sphere: Sphere_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
        _intersectConvex(shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
            faceList: number[];
        }): void;
        /**
         * @todo Optimize by transforming the world to local space first.
         * @todo Use Octree lookup
         */
        _intersectTrimesh(mesh: Trimesh, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
            faceList?: any[];
        }): void;
        /**
         * @return True if the intersections should continue
         */
        private reportIntersection;
        /**
         * As per "Barycentric Technique" as named
         * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
         */
        static pointInTriangle(p: Vec3, a: Vec3, b: Vec3, c: Vec3): boolean;
    }

    /**
     * RAY_MODES
     */
    declare const RAY_MODES: {
        /** CLOSEST */
        readonly CLOSEST: 1;
        /** ANY */
        readonly ANY: 2;
        /** ALL */
        readonly ALL: 4;
    };

    declare type RaycastCallback = (result: RaycastResult) => void;

    /**
     * Storage for Ray casting data
     */
    declare class RaycastResult {
        /**
         * rayFromWorld
         */
        rayFromWorld: Vec3;
        /**
         * rayToWorld
         */
        rayToWorld: Vec3;
        /**
         * hitNormalWorld
         */
        hitNormalWorld: Vec3;
        /**
         * hitPointWorld
         */
        hitPointWorld: Vec3;
        /**
         * hasHit
         */
        hasHit: boolean;
        /**
         * shape
         */
        shape: Shape | null;
        /**
         * body
         */
        body: Body_2 | null;
        /**
         * The index of the hit triangle, if the hit shape was a trimesh
         */
        hitFaceIndex: number;
        /**
         * Distance to the hit. Will be set to -1 if there was no hit
         */
        distance: number;
        /**
         * If the ray should stop traversing the bodies
         */
        shouldStop: boolean;
        constructor();
        /**
         * Reset all result data.
         */
        reset(): void;
        /**
         * abort
         */
        abort(): void;
        /**
         * Set result data.
         */
        set(rayFromWorld: Vec3, rayToWorld: Vec3, hitNormalWorld: Vec3, hitPointWorld: Vec3, shape: Shape, body: Body_2, distance: number): void;
    }

    /**
     * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
     */
    declare class RaycastVehicle {
        /** The car chassis body. */
        chassisBody: Body_2;
        /** The wheels. */
        wheelInfos: WheelInfo[];
        /** Will be set to true if the car is sliding. */
        sliding: boolean;
        world: World | null;
        /** Index of the right axis. x=0, y=1, z=2 */
        indexRightAxis: number;
        /** Index of the forward axis. x=0, y=1, z=2 */
        indexForwardAxis: number;
        /** Index of the up axis. x=0, y=1, z=2 */
        indexUpAxis: number;
        /** The constraints. */
        constraints: Constraint[];
        /** Optional pre-step callback. */
        preStepCallback: () => void;
        currentVehicleSpeedKmHour: number;
        /** Number of wheels on the ground. */
        numWheelsOnGround: number;
        constructor(options: {
            /** The car chassis body. */
            chassisBody: Body_2;
            /** Index of the right axis. x=0, y=1, z=2 */
            indexRightAxis?: number;
            /** Index of the forward axis. x=0, y=1, z=2 */
            indexForwardAxis?: number;
            /** Index of the up axis. x=0, y=1, z=2 */
            indexUpAxis?: number;
        });
        /**
         * Add a wheel. For information about the options, see `WheelInfo`.
         */
        addWheel(options?: WheelInfoOptions): number;
        /**
         * Set the steering value of a wheel.
         */
        setSteeringValue(value: number, wheelIndex: number): void;
        /**
         * Set the wheel force to apply on one of the wheels each time step
         */
        applyEngineForce(value: number, wheelIndex: number): void;
        /**
         * Set the braking force of a wheel
         */
        setBrake(brake: number, wheelIndex: number): void;
        /**
         * Add the vehicle including its constraints to the world.
         */
        addToWorld(world: World): void;
        /**
         * Get one of the wheel axles, world-oriented.
         */
        private getVehicleAxisWorld;
        updateVehicle(timeStep: number): void;
        updateSuspension(deltaTime: number): void;
        /**
         * Remove the vehicle including its constraints from the world.
         */
        removeFromWorld(world: World): void;
        castRay(wheel: WheelInfo): number;
        updateWheelTransformWorld(wheel: WheelInfo): void;
        /**
         * Update one of the wheel transform.
         * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
         * @param wheelIndex The wheel index to update.
         */
        updateWheelTransform(wheelIndex: number): void;
        /**
         * Get the world transform of one of the wheels
         */
        getWheelTransformWorld(wheelIndex: number): Transform;
        updateFriction(timeStep: number): void;
    }

    declare type RaycastVehicleOptions = ConstructorParameters<typeof RaycastVehicle>[0];

    /**
     * RayMode
     */
    declare type RayMode = typeof RAY_MODES[keyof typeof RAY_MODES];

    /**
     * RayOptions
     */
    declare type RayOptions = {
        /**
         * from
         */
        from?: Vec3;
        /**
         * to
         */
        to?: Vec3;
        /**
         * mode
         */
        mode?: RayMode;
        /**
         * result
         */
        result?: RaycastResult;
        /**
         * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
         * @default false
         */
        skipBackfaces?: boolean;
        /**
         * collisionFilterMask
         * @default -1
         */
        collisionFilterMask?: number;
        /**
         * collisionFilterGroup
         * @default -1
         */
        collisionFilterGroup?: number;
        /**
         * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
         * @default true
         */
        checkCollisionResponse?: boolean;
        /**
         * callback
         */
        callback?: RaycastCallback;
    };

    /** 射线查询类型 */
    export declare enum RayQueryType {
        /** 禁止 */
        Disable = 0,
        /** 允许 */
        Allow = 1,
        /** 禁止自己查询，只允许查子实体 */
        AllowOnlyChilds = 2
    }

    /**
     * Returns a reactive proxy of the object.
     *
     * The reactive conversion is "deep": it affects all nested properties. A
     * reactive object also deeply unwraps any properties that are refs while
     * maintaining reactivity.
     *
     * @example
     * ```js
     * const obj = reactive({ count: 0 })
     * ```
     *
     * @param target - The source object.
     */
    declare function reactive<T extends object>(target: T): UnwrapNestedRefs<T>;

    declare class ReactiveEffect<T = any> {
        fn: () => T;
        scheduler: EffectScheduler | null;
        active: boolean;
        deps: Dep[];
        parent: ReactiveEffect | undefined;
        onStop?: () => void;
        constructor(fn: () => T, scheduler?: EffectScheduler | null, scope?: EffectScope);
        run(): T;
        stop(): void;
    }

    declare interface ReactiveEffectOptions {
        lazy?: boolean;
        scheduler?: EffectScheduler;
        scope?: EffectScope;
        allowRecurse?: boolean;
        onStop?: () => void;
    }

    declare interface ReactiveEffectRunner<T = any> {
        (): T;
        effect: ReactiveEffect;
    }

    declare const enum ReactiveFlags {
        SKIP = "__v_skip",
        IS_REACTIVE = "__v_isReactive",
        IS_READONLY = "__v_isReadonly",
        IS_SHALLOW = "__v_isShallow",
        RAW = "__v_raw"
    }

    declare namespace reactivity {
        export {
            ref,
            shallowRef,
            isRef,
            toRef,
            toValue,
            toRefs,
            unref,
            proxyRefs,
            customRef,
            triggerRef,
            Ref,
            MaybeRef,
            MaybeRefOrGetter,
            ToRef,
            ToRefs,
            UnwrapRef,
            ShallowRef,
            ShallowUnwrapRef,
            RefUnwrapBailTypes,
            CustomRefFactory,
            reactive,
            readonly,
            isReactive,
            isReadonly,
            isShallow,
            isProxy,
            shallowReactive,
            shallowReadonly,
            markRaw,
            toRaw,
            ReactiveFlags,
            Raw,
            DeepReadonly,
            ShallowReactive,
            UnwrapNestedRefs,
            computed,
            ComputedRef,
            WritableComputedRef,
            WritableComputedOptions,
            ComputedGetter,
            ComputedSetter,
            deferredComputed,
            effect,
            stop_2 as stop,
            trigger,
            track,
            enableTracking,
            pauseTracking,
            resetTracking,
            ITERATE_KEY,
            ReactiveEffect,
            ReactiveEffectRunner,
            ReactiveEffectOptions,
            EffectScheduler,
            effectScope,
            EffectScope,
            getCurrentScope,
            onScopeDispose,
            TrackOpTypes,
            TriggerOpTypes,
            watch,
            watchEffect,
            watchSyncEffect,
            createPathGetter,
            WatchEffect,
            WatchOptions,
            WatchOptionsBase,
            WatchCallback,
            WatchSource,
            WatchStopHandle
        }
    }
    export { reactivity }

    /**
     * Takes an object (reactive or plain) or a ref and returns a readonly proxy to
     * the original.
     *
     * A readonly proxy is deep: any nested property accessed will be readonly as
     * well. It also has the same ref-unwrapping behavior as {@link reactive()},
     * except the unwrapped values will also be made readonly.
     *
     * @example
     * ```js
     * const original = reactive({ count: 0 })
     *
     * const copy = readonly(original)
     *
     * watchEffect(() => {
     *   // works for reactivity tracking
     *   console.log(copy.count)
     * })
     *
     * // mutating original will trigger watchers relying on the copy
     * original.count++
     *
     * // mutating the copy will fail and result in a warning
     * copy.count++ // warning!
     * ```
     *
     * @param target - The source object.
     */
    declare function readonly<T extends object>(target: T): DeepReadonly<UnwrapNestedRefs<T>>;

    export declare class RecordState {
        position: Vector3;
        size: number;
        color: Vector4;
        /**
         * Creates a new record state.
         * @param {Vector3} position - The position of the particle.
         * @param {number} size - The size of the particle.
         * @param {Vector4} color - The color of the particle.
         */
        constructor(position: Vector3, size: number, color: Vector4);
    }

    declare class Rect extends Path<RectProps> {
        shape: RectShape;
        constructor(opts?: RectProps);
        getDefaultShape(): RectShape;
        buildPath(ctx: CanvasRenderingContext2D, shape: RectShape): void;
        isZeroArea(): boolean;
    }

    export declare class RectCollideModule extends AppModuleBase implements IAppModuleBase {
        #private;
        static moduleName: string;
        options: RectCollideModuleOptions;
        constructor(app?: App, options?: RectCollideModuleOptions);
        onAwake(): void;
        addCollideRectObject(item: IRectCollide): void;
        removeCollideRectObject(item: IRectCollide): void;
        setCollideRectDirty(): void;
        updateCollideRect(): void;
        onAppUpdate(time: Time): void;
        setupUiConfig(): UiObjectConfig;
    }

    export declare interface RectCollideModuleOptions {
        /** 重叠边距 */
        overlapMargin?: number;
        /** 刷新防抖或节流时间毫秒，默认500 */
        refreshTimeout?: number;
        /**  如果为false，则使用防抖来刷新，否则节流用来刷新，默认false */
        useDebounce?: boolean;
    }

    declare type RectLike = {
        x: number;
        y: number;
        width: number;
        height: number;
    };

    declare interface RectProps extends PathProps {
        shape?: Partial<RectShape>;
    }

    declare class RectShape {
        r?: number | number[];
        x: number;
        y: number;
        width: number;
        height: number;
    }

    declare function reduce<T, S, Context>(arr: readonly T[], cb: (this: Context, previousValue: S, currentValue: T, currentIndex?: number, arr?: readonly T[]) => S, memo?: S, context?: Context): S;

    declare interface Ref<T = any> {
        value: T;
        /**
         * Type differentiator only.
         * We need this to be in public d.ts but don't want it to show up in IDE
         * autocomplete, so we use a private Symbol instead.
         */
        [RefSymbol]: true;
    }

    /**
     * Takes an inner value and returns a reactive and mutable ref object, which
     * has a single property `.value` that points to the inner value.
     *
     * @param value - The object to wrap in the ref.
     */
    declare function ref<T extends Ref>(value: T): T;

    declare function ref<T>(value: T): Ref<UnwrapRef<T>>;

    declare function ref<T = any>(): Ref<T | undefined>;

    export declare class ReflectorBlurMaterial extends RawShaderMaterial {
        constructor();
    }

    export declare class ReflectorDudvMaterial extends RawShaderMaterial {
        constructor({ map, reflectivity, dithering }?: {
            map?: any;
            reflectivity?: number;
            dithering?: boolean;
        });
    }

    /** 反射材质 */
    export declare class ReflectorMaterial extends RawShaderMaterial {
        constructor({ color, map, normalMap, normalScale, reflectivity, mirror, mixStrength, fog, dithering }?: {
            color?: Color;
            map?: any;
            normalMap?: any;
            normalScale?: Vector2;
            reflectivity?: number;
            mirror?: number;
            mixStrength?: number;
            fog?: any;
            dithering?: boolean;
        });
    }

    export declare class ReflectorObject extends Group_2 {
        clipBias: number;
        blurIterations: number;
        reflectorPlane: Plane;
        normal: Vector3;
        reflectorWorldPosition: Vector3;
        cameraWorldPosition: Vector3;
        rotationMatrix: Matrix4;
        lookAtPosition: Vector3;
        clipPlane: Vector4;
        view: Vector3;
        target: Vector3;
        q: Vector4;
        textureMatrix: Matrix4;
        virtualCamera: PerspectiveCamera;
        textureMatrixUniform: {
            value: any;
        };
        renderTarget: any;
        renderTargetRead: any;
        renderTargetWrite: any;
        renderTargetUniform: {
            value: any;
        };
        blurMaterial: ReflectorBlurMaterial;
        screenCamera: OrthographicCamera;
        screenTriangle: any;
        screen: any;
        constructor({ width, height, clipBias, blurIterations }?: {
            width?: number;
            height?: number;
            clipBias?: number;
            blurIterations?: number;
        });
        setSize(width: any, height: any): void;
        update(renderer: any, scene: any, camera: any): void;
        destroy(): any;
    }

    declare const RefSymbol: unique symbol;

    declare interface RefTypeValue {
        value: number;
    }

    /**
     * This is a special exported interface for other packages to declare
     * additional types that should bail out for ref unwrapping. For example
     * \@vue/runtime-dom can declare it like so in its d.ts:
     *
     * ``` ts
     * declare module '@vue/reactivity' {
     *   export interface RefUnwrapBailTypes {
     *     runtimeDOMBailTypes: Node | Window
     *   }
     * }
     * ```
     */
    declare interface RefUnwrapBailTypes {
    }

    declare function registerPainter(name: string, Ctor: PainterBaseCtor): void;

    export declare function registerShaderChunks(): void;

    declare function registerSSRDataGetter<T>(getter: ElementSSRDataGetter<T>): void;

    /**
     * Returns a blob:// URL which points to a javascript file which will call importScripts with the given URL, to be used for cross-origin workers.
     * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     * @param url - URL to the worker js file
     * @param wasmURL - optional wasm file URL, will be passed to a created Module.locateFile (for emscripten)
     */
    export declare function remoteWorkerURL(url: string, wasmURL?: string): string;

    declare class Render2D {
        /**
         * Not necessary if using SSR painter like svg-ssr
         */
        dom?: HTMLElement;
        id: number;
        storage: Storage_2;
        painter: PainterBase;
        handler: Handler;
        animation: Animation_2;
        private _sleepAfterStill;
        private _stillFrameAccum;
        private _needsRefresh;
        private _needsRefreshHover;
        /**
         * If theme is dark mode. It will determine the color strategy for labels.
         */
        private _darkMode;
        private _backgroundColor;
        constructor(id: number, dom?: HTMLElement, opts?: Render2DInitOpt);
        /**
         * 添加元素
         */
        add(el: Element_2): void;
        /**
         * 删除元素
         */
        remove(el: Element_2): void;
        /**
         * Change configuration of layer
         */
        configLayer(zLevel: number, config: LayerConfig): void;
        /**
         * Set background color
         */
        setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;
        getBackgroundColor(): string | GradientObject | PatternObject;
        /**
         * Force to set dark mode
         */
        setDarkMode(darkMode: boolean): void;
        isDarkMode(): boolean;
        /**
         * Repaint the canvas immediately
         */
        refreshImmediately(fromInside?: boolean): void;
        /**
         * Mark and repaint the canvas in the next frame of browser
         */
        refresh(): void;
        /**
         * Perform all refresh
         */
        flush(): void;
        private _flush;
        /**
         * Set sleep after still for frames.
         * Disable auto sleep when it's 0.
         */
        setSleepAfterStill(stillFramesCount: number): void;
        /**
         * Wake up animation loop. But not render.
         */
        wakeUp(): void;
        /**
         * Refresh hover in next frame
         */
        refreshHover(): void;
        /**
         * Refresh hover immediately
         */
        refreshHoverImmediately(): void;
        /**
         * Resize the canvas.
         * Should be invoked when container size is changed
         */
        resize(opts?: {
            width?: number | string;
            height?: number | string;
        }): void;
        /**
         * Stop and clear all animation immediately
         */
        clearAnimation(): void;
        /**
         * Get container width
         */
        getWidth(): number;
        /**
         * Get container height
         */
        getHeight(): number;
        /**
         * Set default cursor
         * @param cursorStyle='default' 例如 crosshair
         */
        setCursorStyle(cursorStyle: string): void;
        /**
         * Find hovered element
         * @param x
         * @param y
         * @return {target, topTarget}
             */
         findHover(x: number, y: number): {
             target: Displayable;
             topTarget: Displayable;
         };
         on<Ctx>(eventName: ElementEventName, eventHandler: ElementEventCallback<Ctx, Render2dType>, context?: Ctx): this;
         on<Ctx>(eventName: string, eventHandler: WithThisType<EventCallback<any[]>, unknown extends Ctx ? Render2dType : Ctx>, context?: Ctx): this;
         /**
          * Unbind event
          * @param eventName Event name
          * @param eventHandler Handler function
          */
         off(eventName?: string, eventHandler?: EventCallback): void;
         /**
          * Trigger event manually
          *
          * @param eventName Event name
          * @param event Event object
          */
         trigger(eventName: string, event?: unknown): void;
         /**
          * Clear all objects and the canvas.
          */
         clear(): void;
         /**
          * Dispose self.
          */
         dispose(): void;
        }

        declare namespace render2d {
            export {
                init,
                dispose,
                disposeAll,
                getInstance,
                registerPainter,
                getElementSSRData,
                registerSSRDataGetter,
                Render2DInitOpt,
                ElementSSRData,
                ElementSSRDataGetter,
                Render2dType,
                Point,
                PointLike,
                Element_2 as Element,
                ElementAnimateConfig,
                ElementTextConfig,
                ElementTextGuideLineConfig,
                ElementEvent,
                ElementEventCallback,
                ElementProps,
                Displayable,
                DisplayableProps,
                Group,
                GroupProps,
                Path,
                PathStyleProps,
                PathProps,
                PathStatePropNames,
                PathState,
                ZRImage as Image,
                ImageStyleProps,
                ImageProps,
                ImageState,
                CompoundPath,
                CompoundPathShape,
                TSpan,
                TSpanStyleProps,
                TSpanProps,
                TSpanState,
                IncrementalDisplayable,
                ZRText as Text,
                TextStylePropsPart,
                TextStyleProps,
                TextProps_2 as TextProps,
                TextState,
                Arc,
                ArcProps,
                ArcShape,
                BezierCurve,
                BezierCurveProps,
                BezierCurveShape,
                Circle,
                CircleProps,
                CircleShape,
                Droplet,
                DropletProps,
                DropletShape,
                Ellipse,
                EllipseProps,
                EllipseShape,
                Heart,
                HeartProps,
                HeartShape,
                Isogon,
                IsogonProps,
                IsogonShape,
                Line,
                LineProps,
                LineShape,
                Polygon,
                PolygonProps,
                PolygonShape,
                Polyline,
                PolylineProps,
                PolylineShape,
                Rect,
                RectProps,
                RectShape,
                Ring,
                RingProps,
                RingShape,
                Rose,
                RoseProps,
                RoseShape,
                Sector,
                SectorProps,
                SectorShape,
                Star,
                StarProps,
                StarShape,
                Trochoid,
                TrochoidProps,
                TrochoidShape,
                LinearGradient,
                LinearGradientObject,
                RadialGradient,
                RadialGradientObject,
                Pattern,
                PatternObjectBase,
                PatternObject,
                ImagePatternObject,
                SVGPatternObject,
                BoundingRect,
                RectLike,
                OrientedBoundingRect,
                matrix,
                vector,
                colorTool as color,
                pathTool as path,
                zrUtil as util,
                morphPathTool as morph,
                parseSVG,
                showDebugDirtyRect,
                setPlatformAPI,
                measureBoundingRect
            }
        }
        export { render2d }

        declare interface Render2DInitOpt {
            renderer?: string;
            devicePixelRatio?: number;
            width?: number | string;
            height?: number | string;
            useDirtyRect?: boolean;
            useCoarsePointer?: 'auto' | boolean;
            pointerSize?: number;
            ssr?: boolean;
        }

        export declare interface Render2dTextureOptions {
            /** 绘制的元素，元素组 */
            elements?: render2d.Element | render2d.Element[];
            /** 渲染对象 */
            render2dObject?: render2d.Render2dType;
            /** 是否有事件 */
            pointerEvents?: boolean;
            /** 绘布宽 */
            canvasWidth?: number;
            /** 绘布高 */
            canvasHeight?: number;
            /** 是否根据绘制的内容计算渲染的大小 */
            autoCanvasSize?: boolean;
            /** 是否为了提高效率共享一个canvas */
            sharedCanvas?: boolean;
            /** 纹理颜色空间。默认srgb */
            colorSpace?: ColorSpace;
        }

        /**
         * @type {string}
         */
        declare interface Render2dType extends Render2D {
        }

        /**
         * 创建3d绘图渲染材质
         */
        export declare class Render3dTexture {
            #private;
            fbo: WebGLRenderTarget;
            app: App;
            scene: Scene;
            camera: Camera;
            renderCount: number;
            renderInterval: number;
            _texture: CanvasTexture | Texture;
            signal: {
                onRenderFinsh: Signal;
                onRenderOne: Signal;
            };
            /**
             *
             * @param app 如果app是离屏渲染，并且options中scene为空，将使用app中的渲染场景做为材质；否则app对象只是用来更新材质的计时器使用
             * @param options
             */
            constructor(app: App, options?: Render3dTextureOptions);
            /**
             * 获取材质
             */
            get texture(): Texture | CanvasTexture;
            update(): void;
            dispose(): void;
        }

        export declare interface Render3dTextureOptions extends FBOSettings {
            /**
             * 要渲染的场景
             */
            scene?: Scene;
            /**
             * 相机
             */
            camera?: Camera;
            /** 纹理宽度(默认1024)像素，需要乘pixelRatio */
            width?: number;
            /** 纹理高度(默认1024)像素，需要乘pixelRatio */
            height?: number;
            /** 渲染次数 为0时表示无限 */
            renderCount?: number;
            /** 渲染间隔帧数 为0时表示不跳帧 */
            renderInterval?: number;
            /** 如果是离屏渲染app时，销毁时是否自动销毁app对象 默认true */
            autoDisposeApp?: boolean;
        }

        export declare interface RenderElementFlowMaterialOptions {
            geometryWidth: number;
            geometryHeight: number;
            flowDirection?: "horizon" | "vertical";
            flowSpeed?: number;
            element: Element_2 | Element_2[];
            canvasWidth?: number;
            canvasHeight?: number;
            autoCanvasSize?: boolean;
            expandRect?: number | [number, number, number, number];
        }

        export declare type RendererEmitterSettings = TrailSettings | MeshSettings | BillBoardSettings | StretchedBillBoardSettings;

        /**
         * Enum representing the render modes for particles.
         */
        export declare enum RenderMode {
            /**
             * Renders particles as billboards facing the camera.
             */
            BillBoard = 0,
            /**
             * Renders particles as billboards that stretches towards the direction the particle is moving to.
             */
            StretchedBillBoard = 1,
            /**
             * Renders particles as meshes.
             */
            Mesh = 2,
            /**
             * Renders particles as trails.
             */
            Trail = 3,
            /**
             * Renders particles as horizontal billboards.
             */
            HorizontalBillBoard = 4,
            /**
             * Renders particles as vertical billboards.
             */
            VerticalBillBoard = 5
        }

        export { RenderPass }

        /**
         * Converts a render target to a png/jpeg data url string.
         * Note: this will clamp the values to [0, 1] and converts to srgb for float and half-float render targets.
         * @param target
         * @param mimeType
         * @param quality
         * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
         */
        export declare function renderTargetToDataUrl(renderer: WebGLRenderer, target: WebGLMultipleRenderTargets | WebGLRenderTarget, mimeType?: string, quality?: number, textureIndex?: number): string;

        /**
         * @extends {Behavior}
         */
        export declare class RepeatBehavior extends AbstractDecoratorBehavior {
            limit: number;
            protected __iterator: number;
            /**
             *
             * @param {Behavior} source
             * @param {number} [count=Infinity]
             */
            constructor(source: Behavior, count?: number);
            /**
             * @deprecated use .limit directly instead
             * @param {number} v
             */
            setCount(v: number): void;
            /**
             * @deprecated use .limit directly instead
             * @return {number}
             */
            getCount(): number;
            /**
             *
             * @param {Behavior} source
             * @param {number} [count]
             * @return {RepeatBehavior}
             */
            static from(source: Behavior, count?: number): RepeatBehavior;
            initialize(context: BehaviorContext): void;
            tick(timeDelta: number): BehaviorStatus.Initial | BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Suspended | BehaviorStatus.Invalid;
        }

        /**
         * @extends {Behavior}
         */
        export declare class RepeatUntilFailureBehavior extends AbstractDecoratorBehavior {
            protected __limit: number;
            protected __iterator: number;
            /**
             *
             * @param {Behavior} source
             * @param {number} [count=Infinity]
             */
            constructor(source: Behavior, count?: number);
            /**
             *
             * @returns {RepeatUntilFailureBehavior}
             * @param {Behavior} source
             * @param {number} [limit]
             */
            static from(source: Behavior, limit?: number): RepeatUntilFailureBehavior;
            tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
        }

        export declare class RepeatUntilSuccessBehavior extends AbstractDecoratorBehavior {
            protected __limit: number;
            protected __iterator: number;
            /**
             *
             * @param {Behavior} source
             * @param {number} [count=Infinity]
             */
            constructor(source: Behavior, count?: number);
            /**
             *
             * @param {Behavior} source
             * @param {number} [limit]
             * @return {RepeatUntilSuccessBehavior}
             */
            static from(source: Behavior, limit?: number): RepeatUntilSuccessBehavior;
            tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
        }

        /**
         * Replace all occurrences of a string in another string
         * @param str - The string to search
         * @param find - The string to replace
         * @param replace - The replacement string
         *
         * @category Text
         */
        export declare function replaceAll(str: string, find: string, replace: string): string;

        /**
         * Resets the previous global effect tracking state.
         */
        declare function resetTracking(): void;

        /** 根据坐标位置重置uv坐标 */
        export declare const resetUV: (geometry: BufferGeometry) => void;

        export declare const ResManager: ResourceManager;

        export declare interface ResourceItem {
            /** 资源名称 */
            name?: string;
            /** 资源路径 */
            url?: string;
            /** 是否使用缓存，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象 */
            useCache?: boolean;
            /** 资源类型 为custom时，options可输入一个异步回调函数 */
            type?: "model" | "texture" | "plugin" | "library" | "extensionIfcLoader" | "extensionLoader" | "custom" | string;
            /** 选项 */
            options?: ILoadModelOption | LoadPluginOpts | Function;
        }

        export declare class ResourceManager {
            #private;
            loaderManager: LoaderManager;
            defaultError: (err: string) => void;
            useCacheResMap: Map<string, any>;
            serviceAasserUrlPath: string;
            constructor(_loaderManager?: LoaderManager);
            /**
             * 设置服务器资源数据
             * @param path
             */
            setServiceUrlPath(path: string, dirs?: Array<string>): void;
            /**
             * 根据名称获取服务器端资源路径
             * @param name 资源名称或路径。如果只通过名称的话，为了获取资源类型。需采用 名称.后缀 的格式
             * @param type 默认是assert
             */
            svrUrl(name?: string, type?: string): string;
            /**
             * 获取资源
             * @param url
             * @param useCache 是否使用缓存，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
             * @param fileType 是否指定资源类型。如果不指定。则通过url获取
             * @returns this
             */
            loadRes(url: string, useCache: boolean, fileType?: string): Promise<any>;
            /**
             * 获取材质(线性空间)
             * @param url
             * @param useCache 是否使用缓存(默认是)，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
             * @param  fileType 文件类型 默认 img
             * @param onError 错误回调
             */
            loadTextureLinear(url: string, useCache?: boolean, fileType?: string, onError?: (err: any) => void): Texture;
            /**
             * 获取材质(线性空间)返回一个promise
             * @param url
             * @param useCache 是否使用缓存(默认是)，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
             * @param  fileType 文件类型 默认 img
             * @param colorSpace 颜色空间默认 SRGBColorSpace
             */
            loadTextureLinearSync(url: string, useCache?: boolean, fileType?: string, colorSpace?: ColorSpace): Promise<Texture>;
            /**
             * 获取材质(默认srgb空间)
             * @param url
             * @param useCache 是否使用缓存(默认是)，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
             * @param  fileType 文件类型 默认 img
             * @param onError 错误回调
             * @param colorSpace 颜色空间默认 SRGBColorSpace
             */
            loadTexture(url: string, useCache?: boolean, fileType?: string, onError?: (err: any) => void, colorSpace?: ColorSpace): Texture;
            /**
             * 获取材质(默认srgb空间)返回一个promise
             * @param url
             * @param useCache 是否使用缓存(默认是)，是的话，将把获取的资源保存至缓存，下次获取的是获取缓存保存的同一个资源对象。不使用缓存每次将创建新的资源对象
             * @param  fileType 文件类型 默认 img
             * @param colorSpace 颜色空间默认 SRGBColorSpace
             */
            loadTextureSync(url: string, useCache?: boolean, fileType?: string, colorSpace?: ColorSpace): Promise<Texture>;
            /**
             * 加载模型资源文件
             */
            loadModelRes(url: string, option?: ILoadModelOption): Promise<Object3D>;
            /**
             * 增加模型资源对象
             * res 资源对象
             * url 资源的url
             * option 选项
             */
            addModel(res: any, url: string, option?: ILoadModelOption): Entity;
            /**
             * 加载模型文件
             */
            loadModel(url: string, option?: ILoadModelOption): Promise<Entity>;
            /** 加载资源数组 */
            loadResources(_resources: ResourceItem[]): RosourceItemsReturnType;
            /**
             * 清除资源缓存
             */
            clearResourceCache(): void;
            /**
             * 加载扩展的loader库
             */
            loadExtensionLoader(): Promise<void>;
            /**
             * 加载扩展的IfcLoader库
             */
            loadExtensionIfcLoader(options?: {
                setupOptionalCategoriesOpts?: Record<string, any>;
                applyWebIfcConfigOpts?: Record<string, any>;
            }): Promise<void>;
            /**
             * 获取加载器
             * @param ext 资源类型
             * @returns
             */
            getLoader(ext: string): Loader | null;
            dispose(): void;
        }

        declare interface Response_2 {
            status: number;
            response: Record<string, unknown>;
            data?: string | Record<string, unknown>;
            xhr: XMLHttpRequest;
        }
        export { Response_2 as Response }

        /**
         * 状态
         */
        export declare enum ResStatus {
            /** 不存在 */
            NoExist = 0,
            /** 正在加载 */
            Loading = 1,
            /** 加载完成 */
            LoadFinish = 2,
            /** 加载失败 */
            LoadError = 3
        }

        /**
         * If value1 is not null, then return value1, otherwise judget rest of values.
         * Low performance.
         * @return Final value
         */
        declare function retrieve<T>(...args: T[]): T;

        declare function retrieve2<T, R>(value0: T, value1: R): T | R;

        declare function retrieve3<T, R, W>(value0: T, value1: R, value2: W): T | R | W;

        declare const REVERSE_SUBTRACTION: CSGOperation;

        /**
         * Simple vehicle helper class with spherical rigid body wheels.
         */
        declare class RigidVehicle {
            /**
             * The bodies of the wheels.
             */
            wheelBodies: Body_2[];
            coordinateSystem: Vec3;
            /**
             * The chassis body.
             */
            chassisBody: Body_2;
            /**
             * The constraints.
             */
            constraints: (HingeConstraint & {
                motorTargetVelocity?: number;
            })[];
            /**
             * The wheel axes.
             */
            wheelAxes: Vec3[];
            /**
             * The wheel forces.
             */
            wheelForces: number[];
            constructor(options?: {
                /**
                 * A Vector3 defining the world coordinate system.
                 * @default new Vec3(1, 2, 3)
                 */
                coordinateSystem?: Vec3;
                /**
                 * Optionally pass a body for the chassis
                 */
                chassisBody?: Body_2;
            });
            /**
             * Add a wheel
             */
            addWheel(options?: {
                /** The wheel body */
                body?: Body_2;
                /** Position of the wheel, locally in the chassis body. */
                position?: Vec3;
                /** Axis of rotation of the wheel, locally defined in the chassis. */
                axis?: Vec3;
                /** Slide direction of the wheel along the suspension. */
                direction?: Vec3;
            }): number;
            /**
             * Set the steering value of a wheel.
             * @todo check coordinateSystem
             */
            setSteeringValue(value: number, wheelIndex: number): void;
            /**
             * Set the target rotational speed of the hinge constraint.
             */
            setMotorSpeed(value: number, wheelIndex: number): void;
            /**
             * Set the target rotational speed of the hinge constraint.
             */
            disableMotor(wheelIndex: number): void;
            /**
             * Set the wheel force to apply on one of the wheels each time step
             */
            setWheelForce(value: number, wheelIndex: number): void;
            /**
             * Apply a torque on one of the wheels.
             */
            applyWheelForce(value: number, wheelIndex: number): void;
            /**
             * Add the vehicle including its constraints to the world.
             */
            addToWorld(world: World): void;
            private _update;
            /**
             * Remove the vehicle including its constraints from the world.
             */
            removeFromWorld(world: World): void;
            /**
             * Get current rotational velocity of a wheel
             */
            getWheelSpeed(wheelIndex: number): number;
        }

        declare type RigidVehicleOptions = ConstructorParameters<typeof RigidVehicle>[0];

        declare class Ring extends Path<RingProps> {
            shape: RingShape;
            constructor(opts?: RingProps);
            getDefaultShape(): RingShape;
            buildPath(ctx: CanvasRenderingContext2D, shape: RingShape): void;
        }

        declare interface RingProps extends PathProps {
            shape?: Partial<RingShape>;
        }

        declare class RingShape {
            cx: number;
            cy: number;
            r: number;
            r0: number;
        }

        declare class Rose extends Path<RoseProps> {
            shape: RoseShape;
            constructor(opts?: RoseProps);
            getDefaultStyle(): {
                stroke: string;
                fill: string;
            };
            getDefaultShape(): RoseShape;
            buildPath(ctx: CanvasRenderingContext2D, shape: RoseShape): void;
        }

        declare interface RoseProps extends PathProps {
            shape?: Partial<RoseShape>;
        }

        declare class RoseShape {
            cx: number;
            cy: number;
            r: number[];
            k: number;
            n: number;
        }

        export declare interface RosourceItemsReturnType {
            promises: (progressCb?: (percentage: number, error?: any) => void) => Promise<any[]>;
            getResouces: () => {
                name?: string;
                url?: string;
                type?: string;
                resource: any;
            }[];
            getResource: (name: any) => any;
            getTexture: (name: any) => Texture;
            getModel: (name: any) => Entity;
            /** 根据模型名称克隆新的模型 */
            cloneModel: (name: string, options?: ILoadModelOption) => Entity;
        }

        /**
         * 旋转变换
         */
        declare function rotate(out: MatrixArray, a: MatrixArray, rad: number, pivot?: VectorArray): MatrixArray;

        /**
         * 旋转的光环.
         */
        export declare class RotatingApertureMarker extends AnimateMarkerBase {
            constructor(features: FeatureCollection | {
                position: [number, number, number?];
                text?: string;
            }, options?: AnimateMarkerLayerOption);
            setMarkersWidth(width: number, index?: number): void;
            setMarkersColors(colors: string[], index?: number): void;
            _createMarker(): void;
            private _createMakerElement;
            private _getDotsStyleObj;
        }

        /**
         * 旋转的文本框.
         */
        export declare class RotatingTextBorderMarker extends AnimateMarkerBase {
            constructor(features: FeatureCollection | {
                position: [number, number, number?];
                text?: string;
            }, options?: AnimateMarkerLayerOption);
            setMarkersWidth(width: number): void;
            setMarkersHeight(height: number): void;
            setMarkersTextField(textField: string, index?: number): void;
            setMarkersTextColor(textColor: string, index?: number): void;
            setMarkersTextFontSize(textFontSize: number, index?: number): void;
            setMarkersColors(colors: string[], index?: number): void;
            _createMarker(): void;
            _setMarkerContainerProperty(properties: any, index?: number): void;
        }

        /**
         * Apply rotation to particles over their life.
         */
        export declare class Rotation3DOverLife implements Simulation {
            angularVelocity: RotationGenerator;
            type: string;
            private tempQuat;
            private dynamic;
            constructor(angularVelocity: RotationGenerator);
            initialize(particle: Particle): void;
            update(particle: Particle, delta: number): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        /**
         * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
         */
        declare class RotationalEquation extends Equation {
            /**
             * World oriented rotational axis.
             */
            axisA: Vec3;
            /**
             * World oriented rotational axis.
             */
            axisB: Vec3;
            /**
             * maxAngle
             */
            maxAngle: number;
            constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                /**
                 * World oriented rotational axis.
                 */
                axisA?: Vec3;
                /**
                 * World oriented rotational axis.
                 */
                axisB?: Vec3;
                /**
                 * maxAngle
                 */
                maxAngle?: number;
                /**
                 * @default 1e6
                 */
                maxForce?: number;
            });
            computeB(h: number): number;
        }

        declare type RotationalEquationOptions = ConstructorParameters<typeof RotationalEquation>[2];

        /**
         * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
         */
        declare class RotationalMotorEquation extends Equation {
            /**
             * World oriented rotational axis.
             */
            axisA: Vec3;
            /**
             * World oriented rotational axis.
             */
            axisB: Vec3;
            /**
             * Motor velocity.
             */
            targetVelocity: number;
            constructor(bodyA: Body_2, bodyB: Body_2, maxForce?: number);
            computeB(h: number): number;
        }

        export declare class RotationBehavior extends Behavior {
            axis: Vector3;
            speed: number;
            angle: number;
            __offset: Quaternion;
            resetWhenFinalize: boolean;
            constructor();
            static fromJSON(param: {
                axis?: Vector3;
                speed?: number;
                angle?: number;
                resetWhenFinalize?: boolean;
            }): RotationBehavior;
            /**
             *
             * @param axis
             * @param speed
             * @param angle
             */
            fromJSON(param: {
                axis?: Vector3;
                speed?: number;
                angle?: number;
                resetWhenFinalize?: boolean;
            }): void;
            initialize(context: BehaviorContext): void;
            tick(timeDelta: any): BehaviorStatus;
            finalize(): void;
        }

        /**
         * Apply rotation to particles based on their speed.
         */
        export declare class RotationBySpeed implements Simulation {
            angularVelocity: ValueGenerator | FunctionValueGenerator;
            speedRange: IntervalValue;
            type: string;
            private tempQuat;
            constructor(angularVelocity: ValueGenerator | FunctionValueGenerator, speedRange: IntervalValue);
            initialize(particle: Particle): void;
            update(particle: Particle, delta: number): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        export declare interface RotationGenerator {
            type: 'rotation';
            genValue(q: Quaternion, t?: number): Quaternion;
            toJSON(): FunctionJSON;
            clone(): RotationGenerator;
        }

        export declare function RotationGeneratorFromJSON(json: FunctionJSON): RotationGenerator;

        /**
         * Apply rotation to particles over their life.
         */
        export declare class RotationOverLife implements Simulation {
            angularVelocity: ValueGenerator | FunctionValueGenerator;
            type: string;
            private dynamic;
            constructor(angularVelocity: ValueGenerator | FunctionValueGenerator);
            initialize(particle: Particle): void;
            update(particle: Particle, delta: number): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        export declare function roundToStep(value: number, step: number): number;

        /**
         * This class represents a running tween for a specific target object.
         * It manages the execution of actions and tweens associated with the tween.
         * Don't instantiate this manually.
         * @template T - The type of the target object.
         */
        export declare class RunningTween<T = any> {
            /**
             * Indicates whether the execution of the running tween is paused.
             * If set to `true`, the tween will not progress until it is resumed.
             */
            paused: boolean;
            /**
             * The time scale factor for the running tween.
             * It determines the speed at which the tween progresses.
             * A value of `1` represents normal speed, while `0.5` would be half-speed, and `2` would be double-speed.
             */
            timeScale: number;
            /**
             * Indicates whether the running tween has finished executing.
             */
            get finished(): boolean;
            tweenManager: TweenManager;
            /**
             * Don't instantiate this manually.
             */
            constructor(target: T, tween: Tween<T>, tweenManager: TweenManager);
            /**
             * Set the time scale for the running tween.
             * @param value - The time scale value to apply.
             * @returns The updated RunningTween instance.
             */
            setTimeScale(value: number): this;
            /**
             * Pause the execution of the running tween.
             */
            pause(): void;
            /**
             * Resume the execution of the running tween if it was paused.
             */
            resume(): void;
            /**
             * Stop the running tween, causing it to finish immediately.
             */
            stop(): void;
            /**
             * Complete the running tween, causing it to finish immediately.
             */
            complete(): void;
        }

        /**
         * Set value only if setter exists
         * @param object - object to set
         * @param prop - property to set
         * @param value - value to set
         * @param allowWritable - allow writable properties without setter
         * @param allowAny - allow any property (even if it doesn't exist)
         *
         * @category JS Object
         */
        export declare function safeSetProperty<T, K extends keyof T>(object: T | undefined | null, prop: K, value: NonNullable<T>[K], allowWritable?: boolean, allowAny?: boolean): boolean;

        declare const SAH: SplitStrategy;

        /**
         * Sweep and prune broadphase along one axis.
         */
        declare class SAPBroadphase extends Broadphase {
            /**
             * List of bodies currently in the broadphase.
             */
            axisList: Body_2[];
            /**
             * The world to search in.
             */
            world: World | null;
            /**
             * Axis to sort the bodies along.
             * Set to 0 for x axis, and 1 for y axis.
             * For best performance, pick the axis where bodies are most distributed.
             */
            axisIndex: 0 | 1 | 2;
            private _addBodyHandler;
            private _removeBodyHandler;
            /**
             * Check if the bounds of two bodies overlap, along the given SAP axis.
             */
            static checkBounds(bi: Body_2, bj: Body_2, axisIndex: 0 | 1 | 2): boolean;
            /**
             * insertionSortX
             */
            static insertionSortX(a: Body_2[]): Body_2[];
            /**
             * insertionSortY
             */
            static insertionSortY(a: Body_2[]): Body_2[];
            /**
             * insertionSortZ
             */
            static insertionSortZ(a: Body_2[]): Body_2[];
            constructor(world: World);
            /**
             * Change the world
             */
            setWorld(world: World): void;
            /**
             * Collect all collision pairs
             */
            collisionPairs(world: World, p1: Body_2[], p2: Body_2[]): void;
            sortList(): void;
            /**
             * Computes the variance of the body positions and estimates the best axis to use.
             * Will automatically set property `axisIndex`.
             */
            autoDetectAxis(): void;
            /**
             * Returns all the bodies within an AABB.
             * @param result An array to store resulting bodies in.
             */
            aabbQuery(world: World, aabb: AABB, result?: Body_2[]): Body_2[];
        }

        /**
         * 缩放变换
         */
        declare function scale(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;

        /**
         * 向量缩放
         */
        declare function scale_2<T extends VectorArray>(out: T, v: VectorArray, s: number): T;

        /**
         * 向量缩放后相加
         */
        declare function scaleAndAdd<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, a: number): T;

        export declare class SceneModule extends AppModuleBase implements IAppModuleBase {
            #private;
            static moduleName: string;
            allScenes: Scene[];
            allCameras: Camera[];
            allControlStates: (CameraState | undefined)[];
            options: SceneModuleOptions;
            _axesHelper: AxesHelper;
            _loadedResources: RosourceItemsReturnType;
            _config: EnvConfigOption & {
                [key: string]: any;
            };
            constructor(app?: App, options?: SceneModuleOptions);
            get sceneEntity(): any;
            setAxesHelperVisible(visible?: boolean, size?: number): void;
            isAxesHelperVisible(): boolean;
            setBackgroundEnvironment(options?: BackgroundEnvironmentOptions): Promise<void>;
            get envConfig(): EnvConfigOption & {
                [key: string]: any;
            };
            setEnvConfig(key: string, value: any): void;
            clearScenes(): void;
            addScene(scene?: Scene, camera?: CameraOptions): Scene;
            activeScene(_scene: Scene, opts?: {
                oldScene?: Scene;
                camera?: Camera;
                oldCamera?: Camera;
                cameraState?: CameraState;
                enableTransition?: boolean;
                exitBlurTime?: number;
            }): Promise<void>;
            removeScene(_scene: Scene): Promise<boolean>;
            setScene(scene?: Scene, camera?: CameraOptions): Promise<Scene>;
            /** 初始化场景对象 */
            initScene(scene: Scene, opts?: {
                defaultLights?: boolean;
                gridHelper?: GridHelperModuleOptions;
            }): void;
            onAwake(): void;
            updateSceneMatixWorld(): void;
            addDefaultLights(scene?: Scene): void;
            getSceneStatData(): {
                objects: number;
                vertices: number;
                triangles: number;
            };
            setFocus(): void;
            /** 加载资源数组 */
            loadResources(_resources: ResourceItem[], options?: loadResourcesOptions): Promise<RosourceItemsReturnType>;
            getLoadedResources(): RosourceItemsReturnType;
            setupUiConfig(): UiObjectConfig;
        }

        export declare type SceneModuleOptions = EnvConfigOption & BackgroundEnvironmentOptions;

        /**
         * The Scheduler is in charge of managing the Providers that
         * are used to gather resources needed to display the layers on a View.
         * There is only one instance of a Scheduler per webview, and it is instanciated
         * with the creation of the first view.
         *
         * @constructor
         */
        export declare class Scheduler {
            constructor();
            runCommand(command: any, queue: any, executingCounterUpToDate: any): void;
            execute(command: {
                id?: string;
                url?: string;
                priority?: number;
                notifyChange?: Function;
                executeCommand?: Function;
                [key: string]: any;
            }): any;
            /**
             * Adds a provider for a specified protocol. The provider will be used when
             * executing the queue to provide resources.
             */
            addProtocolProvider(protocol: any, provider: any): void;
            /**
             * Get a specific Provider given a particular protocol.
             *
             * @param {string} protocol
             *
             * @return {Provider}
             */
            getProtocolProvider(protocol: any): any;
            commandsWaitingExecutionCount(): any;
            commandsRunningCount(): any;
            resetCommandsCount(type: any): any;
            deQueue(queue: any): any;
        }

        /**
         * 一个全屏平面，使用它可以创建全屏效果
         */
        export declare class ScreenQuad {
            material: Material;
            mesh: Mesh;
            constructor(app: App, config?: Partial<PlaneConfig>);
        }

        export declare interface Screenshot {
            quality?: number;
            mine?: string;
            download?: boolean;
        }

        export declare interface ScriptDefaultOptions {
            src: string;
            strategy?: string;
            injectLocation?: string;
            async?: boolean;
        }

        declare class Sector extends Path<SectorProps> {
            shape: SectorShape;
            constructor(opts?: SectorProps);
            getDefaultShape(): SectorShape;
            buildPath(ctx: CanvasRenderingContext2D, shape: SectorShape): void;
            isZeroArea(): boolean;
        }

        declare interface SectorProps extends PathProps {
            shape?: Partial<SectorShape>;
        }

        declare class SectorShape {
            cx: number;
            cy: number;
            r0: number;
            r: number;
            startAngle: number;
            endAngle: number;
            clockwise: boolean;
            /**
             * Corner radius of sector
             *
             * clockwise, from inside to outside, four corners are
             * inner start -> inner end
             * outer start -> outer end
             *
             * 5               => [5, 5, 5, 5]
             * [5]             => [5, 5, 0, 0]
             * [5, 10]         => [5, 5, 10, 10]
             * [5, 10, 15]     => [5, 10, 15, 15]
             * [5, 10, 15, 20] => [5, 10, 15, 20]
             */
            cornerRadius: number | number[];
        }

        /**
         * 线段相交
         * @param x1
         * @param y1
         * @param x2
         * @param y2
         * @param x3
         * @param y3
         * @param x4
         * @param y4
         * @return {{result: string, status: boolean} | {result: string, status: boolean} | {x: number, y: number, status: boolean, ratio: number} | {result: string, status: boolean}}
         */
        export declare function segmentIntersect(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): {
            result: string;
            status: boolean;
            x?: undefined;
            y?: undefined;
            ratio?: undefined;
        } | {
            status: boolean;
            x: number;
            y: number;
            ratio: number;
            result?: undefined;
        };

        export { SelectiveBloomEffect }

        /**
         * Will try every child behaviour in order until one succeeds or if all fail - the selector behavior will fail too
         */
        export declare class SelectorBehavior extends CompositeBehavior {
            __currentBehaviour: Behavior;
            __currentBehaviourIndex: number;
            constructor();
            /**
             *
             * @param {Behavior[]} children
             * @returns {SelectorBehavior}
             */
            static from(children: Behavior[]): SelectorBehavior;
            tick(timeDelta: number): BehaviorStatus;
            finalize(): void;
            initialize(context: BehaviorContext): void;
        }

        export declare class SendEventBehavior extends Behavior {
            event: string;
            data: any;
            target: any;
            constructor();
            fromJSON({ event, data, target }: {
                event: any;
                data?: {};
                target?: any;
            }): void;
            static fromJSON(j: {
                event: string;
                data: any;
                target?: any;
            }): SendEventBehavior;
            tick(timeDelta: number): BehaviorStatus;
        }

        declare interface SeparateConfig extends ElementAnimateConfig {
            dividePath?: DividePath;
            individualDelay?: IndividualDelay;
        }

        /**
         * Make separate morphing from one path to many paths.
         * Make the MorphingKind of `toPath` become `'ONE_ONE'`.
         */
        declare function separateMorph(fromPath: Path, toPathList: Path[], animationOpts: SeparateConfig): {
            fromIndividuals: Path<PathProps>[];
            toIndividuals: Path<PathProps>[];
            count: number;
        };

        /**
         * Executes all contained behaviors one after another in a sequence, next behaviour in the sequence will not be started until the previous one signal success
         * If any of the contained behaviours fail - the whole sequence fails
         */
        export declare class SequenceBehavior extends CompositeBehavior {
            __currentBehaviourIndex: number;
            __currentBehaviourState: BehaviorStatus;
            __currentBehaviour: Behavior;
            constructor();
            initialize(context: BehaviorContext): void;
            /**
             *
             * @param {number} timeDelta
             * @returns {BehaviorStatus}
             */
            tick(timeDelta: number): BehaviorStatus;
            finalize(): void;
            /**
             *
             * @param {Behavior[]} list
             * @return {SequenceBehavior}
             */
            static from(list: Behavior[]): SequenceBehavior;
        }

        export declare interface Sequencer {
            transform(position: Vector3, index: number): void;
            toJSON(): any;
            clone(): Sequencer;
        }

        export declare function SequencerFromJSON(json: any): Sequencer;

        /**
         * Decorator to mark a class as serializable using the {@link Serialization} class.
         * @note - Requires "experimentalDecorators": true in tsconfig.json
         * @param id - The id to use when serializing the class. This is used to identify the class when deserializing. Class names can be mangled during minification, so it is required to provide an id.
         */
        export declare function serializable(id: string): <T extends new (...args: any[]) => any>(constructor: T) => T;

        /**
         * Serialization class with static methods for serializing and deserializing objects.
         * Properties and classes can be marked serializable by adding {@link serialize} and {@link serializable} decorators.
         * @category Serialization
         */
        export declare class Serialization {
            static TypeMap: Map<ObjectConstructor, [string, string][]>;
            static SerializableClasses: Map<string, any>;
            /**
             * Serializers for primitive, array and struct/custom object types
             */
            static Serializers: Serializer[];
            static GetSerializer(obj: any): Serializer;
            static RegisterSerializer(...serializers: Serializer[]): void;
            static UnregisterSerializer(...serializers: Serializer[]): void;
            /**
             * Serialize an object
             * @param obj - object to serialize
             * @param meta - Optional object to store common meta-data/resources across the serialization process of multiple objects
             @param isThis - true if called from inside the serialization function, like custom {@link IJSONSerializable.toJSON}.
             */
            static Serialize(obj: any, meta?: Record<string, Record<string, any>>, isThis?: boolean): any;
            /**
             * Deserialize an object
             * @param data - data to deserialize
             * @param obj - current object that's set. If of the same class/type the data is deserialized into that instead of creating new objects.
             * @param meta - Optional object to retrieve common meta-data/resources across the deserialization process of multiple objects. Objects in meta must be class instances, not js objects. (like Material, Texture, Object3D etc)
             * @param isThis - true if called from inside the deserialization function, like custom {@link IJSONSerializable.fromJSON}
             */
            static Deserialize(data: any, obj: any, meta?: Record<string, any>, isThis?: boolean): any;
        }

        export declare interface SerializationOptions {
            /**
             * Use URL for image.
             * @type {boolean}
             */
            useUrlForImage?: boolean;
        }

        /**
         * Decorator to mark a class property as serializable using the {@link Serialization} class.
         * @note - Requires "experimentalDecorators": true in tsconfig.json
         * @param key - The key to use when serializing the property. If not provided, the property name is used (for this make sure the property name is not mangled during minification).
         * @category Decorators
         */
        export declare function serialize(key?: string): PropertyDecorator;

        declare class SerializedBVH {
            roots: Array<ArrayBuffer>;
            index: ArrayBufferView;
        }

        /**
         * Serializer interface for primitive, array and struct/custom object types
         * @category Serialization
         */
        export declare interface Serializer {
            serialize: (obj: any, meta?: any) => any;
            deserialize: (data: any, obj: any, meta?: any) => any;
            isType: (obj: any) => boolean;
            priority?: number;
        }

        /**
         * `Service` 服务类.
         *
         */
        export declare class Service {
            /**
             * 服务器地址
             * @type {string}
             */
            serverUrl: string;
            /**
             * 访问凭证
             * @type {string}
             */
            accessToken: string;
            private readonly _reqImpl;
            private _cur_map_param;
            private _svr_url_map;
            private readonly _svr_url_service;
            private _secretKeys?;
            private _accessKeys?;
            private _workspaceName?;
            /**
             * 构造函数
             * @param url 服务地址
             * @param token 访问凭证
             * @param req 请求的方法实现（默认内部实现)
             */
            constructor(url: string, token?: string, req?: IRequest);
            private _url;
            /**
             * 克隆一个新的服务实例对象
             * @param isCloneWorkspace 是否克隆当前工作区 (默认是)
             * @return Service
             */
            clone(isCloneWorkspace?: boolean): Service;
            /**
             * 得到服务地址
             * @param u 要拼接的地址
             * @return string
             */
            serviceUrl(u: string): string;
            /**
             * 切换至工作区
             * @param workspaceName 工作区名称
             * @return
             */
            switchWorkspace(workspaceName: string): void;
            /**
             * 获取当前的工作区名称
             * @return
             */
            getCurWorkspaceName(): string;
            /**
             * 获取所有工作区(如果不是root权限的token获取非公开的工作区名称将返回空)
             * @return
             */
            getWorkspaces(): Promise<any>;
            /**
             * 创建工作区(默认需要root权限)
             * @param workspace 工作区设置
             * @return
             */
            workspaceCreate(workspace: IWorkspace): Promise<any>;
            /**
             * 修改工作区(默认需要root权限)
             * @param workspace 工作区
             * @return
             */
            workspaceModify(workspace: IWorkspace): Promise<any>;
            /**
             * 删除工作区（会同时删除工作区下面的所有目录文件）(默认需要root权限)
             * @param name 要删除的工作区名称
             * @return
             */
            workspaceDelete(name: string): Promise<any>;
            /**
             * 密码转换为秘钥
             * @param pwd 密码
             */
            pwdToSecretKey(pwd: string): string;
            /**
             * 增加秘钥key
             * @param key key值
             */
            addSecretKey(key: string): Set<string>;
            /**
             * 移除秘钥key, 如果key为undefined时，则移除所有的
             * @param key key值
             */
            removeSecretKey(key: string): Set<string>;
            /**
             * 增加访问key
             * @param key key值
             */
            addAccessKey(key: string): Set<string>;
            /**
             * 移除访问key, 如果key为undefined时，则移除所有的
             * @param key key值
             */
            removeAccessKey(key: string): void;
            private _to_layer_string;
            private _addTokenHeader;
            private _get;
            private _post;
            private _del;
            /**
             * 把图层名称数组转成图层索引数组
             * @param layernames 图层名称数组
             * @param layers 图层列表
             * @return {number[]}
             */
            toLayerIndex(layernames: string[], layers: any[]): number[];
            private _waitOpenMap;
            /**
             * 设置打开地图参数
             */
            setCurrentMapParam(param: IOpenMapResponse): IOpenMapResponse | null;
            /**
             * 当前地图参数
             */
            currentMapParam(): IOpenMapResponse | null;
            /**
             * 打开图
             * @param param
             * @param isWaitFinish 是否等待打开完成
             * @return {Promise<any>}
             */
            openMap(param: IOpenMapParam, isWaitFinish?: boolean): Promise<any>;
            /**
             * 更新地图
             * @param param
             * @param isWaitFinish 是否等待打开完成
             */
            updateMap(param: IUpdateMapParam, isWaitFinish?: boolean): Promise<any>;
            /**
             * 字体地址
             * @param param
             */
            glyphsUrl(): string;
            /**
             * 服务根地址
             */
            baseUrl(): string;
            /**
             * 精灵图片名称
             * @param name 精灵名称
             */
            spriteUrl(name: string): string;
            /**
             * 设置精灵图片名称
             * @param name 精灵名称
             */
            setSprite(name: string): string;
            /**
             * 空白瓦片地址
             */
            blankTileUrl(): string;
            /**
             * 二维码图片地址
             * @param content 生成二维码的内容
             * @param size 生成二维码的大小，默认256
             */
            qrcodeUrl(content: string, size?: number): string;
            /**
             * 栅格瓦片地址
             * @param param
             */
            rasterTileUrl(param?: ITileUrlParam): string;
            /**
             * 矢量瓦片地址
             * @param param
             */
            vectorTileUrl(param?: ITileUrlParam): string;
            /**
             * 检查文件是否上传过
             * @param filemd5 文件md5值
             */
            checkFileHasUpload(filemd5: string): Promise<any>;
            /**
             * 返回上传文件的url地址
             * @return {string}
             */
            uploadUrl(): string;
            /**
             * 获取字符串的Md5值
             * @param str
             * @return {string}
             */
            strMd5(str: string): string;
            /**
             * 得到style的版本号
             */
            styleVersion(): number;
            /**
             * 获取文件的Md5值
             * @param file
             * @return {Promise<any>}
             */
            fileMd5(file: File): Promise<any>;
            /**
             * 上传地图
             * @param file
             * @return {Promise<any>}
             */
            uploadMap(file: File): Promise<any>;
            /**
             * 执行命令
             * @return {string}
             */
            execCommand(cmdname: string, param?: Record<string, any>, mapid?: string, version?: string, useGet?: boolean): Promise<any>;
            /**
             * 获取地图元数据
             * @param mapid 地图ID ，为空, 则为当前打开的图形
             * @param version 版本号，为空 则为当前打开的版本;
             */
            metadata(mapid?: string, version?: string): Promise<any>;
            /**
             * 修改地图元数据
             * @param meta 要修改的元数据项
             * @param mapid 地图ID ，为空, 则为当前打开的图形
             * @param version 版本号，为空 则为当前打开的版本;
             */
            updateMetadata(meta: Record<string, number | boolean | string | undefined | null>, mapid?: string, version?: string): Promise<any>;
            /**
             * 获取所有地图信息
             * @param mapid 地图ID，为空，则获取所有的；如果传入的是地图ID数组，则获取指定的地图ID数组的信息。如果不想一次性获取，可通过传入分页对象获取，如{curPage: 1, pageCount: 10}
             * @param version 版本号，为空，则获取最新的; * 则获取所有的版本
             */
            listMaps(mapid?: string | string[] | {
                curPage: number;
                pageCount: number;
                mapIds?: string[];
            }, version?: string): Promise<any>;
            /**
             * 等待地图打开完成
             * @param mapid 地图ID
             * @param version 地图版本号
             * @param tryTime 每次尝试时间间隔(秒)
             * @param maxTryTimes 最大尝试次数
             * @return {Promise<void>}
             */
            waitMapOpenFinish(mapid: string, version: string, tryTime?: number, maxTryTimes?: number): Promise<any>;
            /**
             * 处理查询结果
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             */
            processQueryResult(param: any, cb?: (point: [number, number]) => [number, number] | null | undefined): any;
            /**
             * 处理查询结果
             * @private
             */
            private _processQueryResult;
            /**
             * 点查询实体
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             */
            pointQueryFeature(param: IPointQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
            /**
             * 矩形查询实体
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             */
            rectQueryFeature(param: IRectQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
            /**
             * 表达式查询实体
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             */
            exprQueryFeature(param: IExprQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
            /**
             * 条件查询实体
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             */
            conditionQueryFeature(param: IConditionQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
            /**
             * 得到地图图层集合，调用前请确保地图已打开，否则会抛异常
             */
            getMapLayers(): IMapLayer[];
            /**
             * 切换图层
             * @param visibleLayers 让可见的图层列表数组
             * @return {Promise<void>}
             */
            cmdSwitchLayers(visibleLayers: string[]): Promise<any>;
            /**
             * 更新样式
             * @param param 样式参数
             * @return {Promise<any>}
             *
             *
             * Example:
             * ```typescript
             * const res = svc.cmdUpdateStyle({
             *     name: "style1",
             *     layeron: [0,1,2,4,5,6,7,8,9],
             *     layeroff: "",
             *     clipbounds: "",
             *     backcolor: 0,
             *     lineweight:[1,1,0]
             *     expression: "gOutColorRed := gInColorGreen;gOutColorGreen := gInColorBlue;gOutColorBlue := gInColorRed;gOutColorAlpha := gInColorAlpha;"
             * });
             * ```
             */
            cmdUpdateStyle(param: IUpdateStyle): Promise<any>;
            /**
             * 对图层进行切片缓存
             * @param param
             * @return {Promise<any>}
             */
            cmdSliceLayer(param: ISliceLayer): Promise<any>;
            /**
             * 获取样式图层名
             * @param style 样式参数
             * @param mapid 地图ID
             * @param version 版本号，为空，则获取最新的;
             * @param isGeomLayer 几何渲染图层优先(默认true)
             * @return {Promise<any>}
             */
            createStyle(style: IMapStyleParam, mapid?: string, version?: string, isGeomLayer?: boolean): Promise<any>;
            /**
             * 获取已缓存的切片级别
             * @param param 参数
             * @return {Promise<any>}
             */
            getSliceCacheZoom(param: ISliceCacheZoom): Promise<any>;
            /**
             * 获取图形中有数据的范围区域
             * @param mapid 地图id
             * @param version 版本号
             * @return {Promise<any>}
             */
            cmdGetDrawBounds(mapid?: string, version?: string): Promise<GeoBounds | null>;
            /**
             * 获取样式图层名
             * @param mapid 地图ID
             * @param version 版本号，为空，则获取最新的;
             * @param isGeomLayer 几何渲染图层优先(默认true)
             * @param name 有名称时，根据名称来查找;
             * @return {Promise<any>}
             */
            getStyleLayerName(mapid: string, version?: string, isGeomLayer?: boolean, name?: string): Promise<any>;
            /**
             * 获取图的缩略图
             * @param mapid
             * @param version
             * @param width
             * @param height
             * @param darkTheme 是否是深色主题，是的话，图片将反色（黑色变白色）
             */
            thumbnailUrl(mapid?: string, version?: string, width?: number, height?: number, darkTheme?: boolean): string;
            wmsTileUrl(param: IWmsTileUrl): string;
            /**
             * 删除地图
             * @return {Promise<any>}
             * @param mapid 地图ID
             * @param version 版本号，如删除所有版本，输入"*"号
             * @param retainVersionMaxCount 删除所有版本时，保留的最新的版本总数。如总共有10个版本，retainVersionMaxCount为3时，会保存最新的3个版本，其余的都会删除
             */
            cmdDeleteMap(mapid: string, version: string, retainVersionMaxCount?: number): Promise<any>;
            /**
             * 获取地图的AccessKey，获取之前请确保已成功打开了地图
             * @param mapid 地图ID
             * @param key secretKey秘钥和超级管理员superKey
             * @return {Promise<any>}
             */
            cmdGetAccessKey(mapid: string, key: string): Promise<any>;
            /**
             * 重置地图的AccessKey，获取之前请确保已成功打开了地图
             * @param mapid 地图ID
             * @param key secretKey秘钥和超级管理员superKey
             * @return {Promise<any>}
             */
            cmdResetAccessKey(mapid: string, key: string): Promise<any>;
            /**
             * 重置地图的密码，如果之前有密码，则是修改密码。如果之前没有密码，则是把此地图设置了密码保护。如果设置密码为空，则取消对此地图的密码保护。
             * @param mapid 地图ID
             * @param key 旧的secretKey秘钥和超级管理员superKey
             * @param newKey 新的secretKey秘钥
             * @return {Promise<any>}
             */
            cmdSetMapPassword(mapid: string, key: string, newKey: string): Promise<any>;
            /**
             * 地图ID重命名
             * @return {Promise<any>}
             * @param oldMapID 旧地图ID
             * @param newMapID 新地图ID
             */
            cmdRenameMap(oldMapID: string, newMapID: string): Promise<any>;
            /**
             * 清空地图的几何和瓦片缓存数据
             * @return {Promise<any>}
             * @param mapid 地图ID
             * @param version 版本号
             */
            cmdClearMapCache(mapid: string, version: string): Promise<any>;
            /**
             * 清空地图的瓦片缓存数据
             * @return {Promise<any>}
             * @param mapid 地图ID
             * @param version 版本号
             */
            cmdClearTileCache(mapid: string, version: string): Promise<any>;
            /**
             * 删除地图样式
             * @return {Promise<any>}
             * @param param 样式接口
             */
            cmdDeleteStyle(param: IDeleteStyle): Promise<any>;
            /**
             * 删除地图缓存
             * @return {Promise<any>}
             * @param param 缓存接口
             */
            cmdDeleteCache(param: IDeleteCache): Promise<any>;
            /**
             * 获取当前运行状态
             * @return {Promise<any>}
             * @param bDetail 是否需要细节 (默认false)
             */
            cmdRunStatus(bDetail?: boolean): Promise<any>;
            /**
             * 获取支持的格式类型
             * @return {Promise<any>}
             */
            cmdGetSupportFormat(): Promise<any>;
            /**
             * 获取服务后台常量设置
             * @return {Promise<any>}
             */
            getConstData(): Promise<any>;
            /**
             * 空白栅格style
             * @param minzoom 最小级别，缺省0
             * @param maxzoom 最大级别，缺省24
             * @param prefix 前缀，缺省rasterBlank
             */
            rasterBlankStyle(minzoom?: number, maxzoom?: number, prefix?: string): {
                version: number;
                sources: {
                    [x: string]: {
                        type: string;
                        tiles: string[];
                        tileSize: number;
                        minzoom: number;
                        maxzoom: number;
                    };
                };
                glyphs: string;
                layers: {
                    id: string;
                    type: string;
                    source: string;
                    minzoom: number;
                    maxzoom: number;
                    layout: {
                        visibility: string;
                    };
                }[];
            };
            /**
             * 获取栅格图层ID
             * @param prefix
             * @return {string}
             */
            rasterLayerId(prefix?: string): string;
            /**
             * 获取栅格源ID
             * @param prefix
             * @return {string}
             */
            rasterSourceId(prefix?: string): string;
            /**
             * 栅格style
             * @param tileUrl 栅格瓦片地址
             * @param minzoom 最小级别，缺省0
             * @param maxzoom 最大级别，缺省24
             * @param prefix 前缀，缺省raster
             */
            rasterStyle(tileUrl?: string, minzoom?: number, maxzoom?: number, prefix?: string): {
                version: number;
                sources: {
                    [x: string]: {
                        type: string;
                        tiles: string[];
                        tileSize: number;
                        minzoom: number;
                        maxzoom: number;
                    };
                };
                glyphs: string;
                layers: {
                    id: string;
                    type: string;
                    source: string;
                    minzoom: number;
                    maxzoom: number;
                    layout: {
                        visibility: string;
                    };
                }[];
            };
            /**
             * 矢量style
             * @param tileUrl 矢量瓦片地址 或者为一个Object，为Object时，设置项为参数的每个项值，做为一个参数传入
             * @param minzoom 最小级别，缺省0
             * @param maxzoom 最大级别，缺省24
             * @param prefix 前缀，缺省vector
             * @param hoverColor 高亮时颜色，缺省rgba(0,0,255,255)
             * @param hoverOpacity 高亮时透明度,缺省0.5
             * @param hoverLineWidth 高亮时线宽,缺省3
             * @param customColorCaseExpr 自定义颜色表达式，必须为数组[条件1，值，条件2，值,...]，如[['==', ['feature-state', 'status'], 'alarm'], '#ff0000', ['==', ['feature-state', 'status'], 'normal'], '#00ff00'],缺省默认
             * @param customOpacityCaseExpr 自定义透明度表达式，必须为数组,缺省默认
             * @param customLineWidthCaseExpr 自定义线宽表达式，必须为数组,缺省默认
             * @param disableHover 禁止hover
             */
            vectorStyle(tileUrl?: string | Record<string, any>, minzoom?: number, maxzoom?: number, prefix?: string, hoverColor?: string, hoverOpacity?: number, hoverLineWidth?: number, customColorCaseExpr?: any[], customOpacityCaseExpr?: any[], customLineWidthCaseExpr?: any[], disableHover?: boolean): {
                layers: ({
                    id: string;
                    type: string;
                    source: string;
                    "source-layer": string;
                    paint: {
                        "line-color": any[];
                        "line-opacity": any[];
                        "line-width": (string | number | boolean | (string | boolean | string[])[])[];
                        "fill-color"?: undefined;
                        "fill-antialias"?: undefined;
                        "fill-outline-color"?: undefined;
                        "fill-opacity"?: undefined;
                        "line-blur"?: undefined;
                        "circle-radius"?: undefined;
                        "circle-color"?: undefined;
                        "circle-stroke-color"?: undefined;
                        "circle-opacity"?: undefined;
                    };
                    layout?: undefined;
                } | {
                    id: string;
                    type: string;
                    source: string;
                    "source-layer": string;
                    paint: {
                        "fill-color": any[];
                        "fill-antialias": boolean;
                        "fill-outline-color": any[];
                        "fill-opacity": any[];
                        "line-color"?: undefined;
                        "line-opacity"?: undefined;
                        "line-width"?: undefined;
                        "line-blur"?: undefined;
                        "circle-radius"?: undefined;
                        "circle-color"?: undefined;
                        "circle-stroke-color"?: undefined;
                        "circle-opacity"?: undefined;
                    };
                    layout: {
                        "line-cap"?: undefined;
                    };
                } | {
                    id: string;
                    type: string;
                    source: string;
                    "source-layer": string;
                    layout: {
                        "line-cap": string;
                    };
                    paint: {
                        "line-color": any[];
                        "line-blur": (string | number | boolean | (string | boolean | string[])[])[];
                        "line-opacity": any[];
                        "line-width": any[];
                        "fill-color"?: undefined;
                        "fill-antialias"?: undefined;
                        "fill-outline-color"?: undefined;
                        "fill-opacity"?: undefined;
                        "circle-radius"?: undefined;
                        "circle-color"?: undefined;
                        "circle-stroke-color"?: undefined;
                        "circle-opacity"?: undefined;
                    };
                } | {
                    id: string;
                    type: string;
                    source: string;
                    "source-layer": string;
                    paint: {
                        "circle-radius": any[];
                        "circle-color": any[];
                        "circle-stroke-color": any[];
                        "circle-opacity": any[];
                        "line-color"?: undefined;
                        "line-opacity"?: undefined;
                        "line-width"?: undefined;
                        "fill-color"?: undefined;
                        "fill-antialias"?: undefined;
                        "fill-outline-color"?: undefined;
                        "fill-opacity"?: undefined;
                        "line-blur"?: undefined;
                    };
                    layout?: undefined;
                })[];
                version: number;
                sources: {
                    [x: string]: {
                        type: string;
                        tiles: (string | Record<string, any>)[];
                        maxzoom: number;
                        minzoom: number;
                    };
                };
                glyphs: string;
            };
            /**
             * 得到所有矢量字体名称
             * @return {Promise<any>}
             */
            getFontsCapacity(): Promise<unknown>;
            /**
             * 清空服务器缓存数据
             * @return {Promise<any>}
             * @param prefix key前缀
             */
            clearCache(prefix?: string): Promise<unknown>;
            /**
             * 获取服务器地图服务地址
             * @param tileProvider
             * @return {string}
             */
            webMapUrl(tileProvider: {
                tileCrs?: "gcj02" | "wgs84";
                tileSize?: number;
                tileRetina?: number;
                tileMaxZoom?: number;
                tileUrl: string | string[];
                tileShards?: string;
                tileToken?: string | string[];
                tileFlipY?: boolean;
                mapbounds?: string;
                fourParameterBefore?: string;
                fourParameterAfter?: string;
                srs?: string;
            }): string;
            /**
             * 组合成新地图
             * @param param 组合参数
             * @return {Promise<any>}
             */
            composeNewMap(param: IComposeNewMap | IComposeNewMap[]): Promise<any>;
            /**
             * 比较地图不同
             * @param param 组合参数
             * @return {Promise<any>}
             */
            cmdMapDiff(param: IMapDiff): Promise<any>;
            /**
             * 导出布局空间为dwg图
             * @param param 参数
             * @return {Promise<any>}
             */
            cmdExportLayout(param: IExportLayout): Promise<any>;
            /**
             * 目标匹配
             * @param param 参数
             * @return {Promise<any>}
             */
            cmdMatchObject(param: IMatchObject): Promise<any>;
            /**
             * 获取创建实体的几何数据
             * @param param 参数
             * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
             * @return {Promise<any>}
             */
            cmdCreateEntitiesGeomData(param: ICreateEntitiesGeomData, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
            /**
             * 坐标转换
             * @return {Promise<any>}
             * @param srs 源坐标系名称，如 EPSG:4326
             * @param crs 目标坐标系名称，如 EPSG:3857
             * @param points 要转换的坐标
             * @param fourParameter 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正
             * @param isInverseFourParamter 是否是上面四参数坐标的反算
             */
            cmdTransform(srs: string, crs: string, points: GeoPoint | GeoPoint[], fourParameter?: string | string[], isInverseFourParamter?: boolean): Promise<any>;
            /**
             * 投影prj文件WKT字符转proj4字符串
             * @return {Promise<any>}
             * @param srs 投影prj文件WKT字符
             * @param from 字符串来源，为空为话为WKT
             */
            cmdPrjWktToPrj4(wkt: string, from?: undefined | "" | "wmsauto" | "xml" | "urn" | "crsurl" | "url" | "micoordsys" | "pci"): Promise<any>;
            /**
             * 保存用户自定义数据
             * @param key 键名(必须唯一，否则会覆盖之前的数据，同类型的key前缀尽量一样)，如果是数组的话，可以批量
             * @param value 键值
             * @param prop 属性值
             * @param ttl 有效时间，单位秒，默认长期有效
             */
            saveCustomData(key: string | {
                key: string;
                value: any;
                prop?: any;
                ttl?: number;
            }[], value?: any, prop?: any, ttl?: number): Promise<any>;
            /**
             * 获取用户自定义数据
             * @param key 键名，如果是数组的话，可以查询.
             * @param options 选项 retDataType为空时查询数据及属性,"value"只查询数据，"prop"只查询属性。contentType返回类型,为空时为json，为"image"时为图片.
             */
            getCustomData(key: string | string[], options?: {
                retDataType?: "" | "value" | "prop";
                contentType?: "" | "image";
            }): Promise<any>;
            /**
             * 通过前缀获取用户自定义数据的键值
             * @param prefix 键名前缀
             */
            getCustomDataKeysByPrefix(prefix: string): Promise<any>;
            /**
             * 删除用户自定义数据
             * @param key 键名，如果是数组的话，可以查询
             * @param isPrefix 是否删除所有前缀为key的所有键值，默认false
             */
            deleteCustomData(key: string | string[], isPrefix?: boolean): Promise<any>;
            /**
             * 转成文档字符串
             * @param content 如果传入了内容，则以content为主。json格式
             * @return {string}
             */
            toDbDoc(content: string | Record<string, any>): string;
        }

        /**
         * 设置向量的两个项
         */
        declare function set<T extends VectorArray>(out: T, a: number, b: number): T;

        /**
         * Set an object as primitive to be ignored traversing children in clone or merge
         */
        declare function setAsPrimitive(obj: any): void;

        export declare class SetDataCommand extends BaseCommand {
            private readonly oldData;
            private readonly newData;
            private readonly object;
            constructor(object: IHasDataEntity, newData: any, oldData?: any, autoExecute?: boolean);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        export declare class SetEmitDirection implements Simulation {
            type: string;
            _temp: Vector3;
            _q: Quaternion;
            velocityX: number;
            velocityY: number;
            velocityZ: number;
            opts: any;
            constructor(opts: {
                velocityX?: ValueGenerator;
                velocityY?: ValueGenerator;
                velocityZ?: ValueGenerator;
            });
            initialize(particle: Particle): void;
            update(particle: Particle, delta: number): void;
            frameUpdate(delta: number): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            clone(): Simulation;
            reset(): void;
        }

        export declare class SetMaterialMapCommand extends BaseCommand {
            private material;
            private mapName;
            private newMap;
            private materialSlot;
            private oldMap;
            constructor(material: Material, mapName: any, newMap: Texture, materialSlot: any);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        /**
         * 设置材质透明
         * @param material
         * @param opacity 透明度
         * @param opts isAccOpacity 是否累加透明度(ture和之前透明度相乘，false直接设置透明度), isClone 是否克隆成新的材质 disposeOldMaterial 当克隆时是否删除旧的材质
         */
        export declare const setMaterialOpacity: (material: Mesh | Material | Material[], opacity: number, opts?: {
            isAccOpacity?: boolean;
            isClone?: boolean;
            disposeOldMaterial?: boolean;
        }) => any;

        /** 设置一个mesh可镜面反射 */
        export declare function setMeshReflector(mesh: Mesh, options?: MeshReflectorOptions, app?: App): {
            setColor: (color: ColorRepresentation) => void;
            setSpeed: (speed: number) => void;
            setIntensity: (intensity: number) => void;
            material: CustomShaderMaterial<MaterialConstructor>;
            reflectMaterial: MeshReflectorMaterial2;
            dispose: () => void;
            mesh: Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
        };

        export declare class SetMultipleValuesCommand<T> extends BaseCommand {
            private object;
            private attributes;
            private oldValues;
            constructor(object: T, attributes: Partial<T>);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        export declare function setPhysicsResolver(resolver: PhysicsResolver): void;

        declare function setPlatformAPI(newPlatformApis: Partial<Platform>): void;

        export declare class SetPositionCommand extends BaseCommand {
            private object;
            private newPosition;
            private oldPosition;
            constructor(object: Object3D, newPosition: Vector3, oldPosition?: Vector3);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        export declare class SetRotationCommand extends BaseCommand {
            private object;
            private newRotation;
            private optionalOldRotation;
            private readonly oldRotation;
            constructor(object: Object3D, newRotation: Euler, optionalOldRotation?: Euler);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        export declare class SetScaleCommand extends BaseCommand {
            private object;
            private newScale;
            private optionalOldScale?;
            private readonly oldScale;
            constructor(object: Object3D, newScale: Vector3, optionalOldScale?: Vector3);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        /**
         * Set URL query parameter. If value is null, remove parameter. Similar to PHP's $_GET
         * @param p - parameter name to set
         * @param v - parameter value or null to remove
         * @param reload - reload page after setting parameter, default false. If false, `history.replaceState` is used.
         *
         * @category URL
         */
        export declare function setUrlQueryParam(p: string, v: string | null, reload?: boolean): void;

        export declare class SetValueCommand<T, K extends keyof T> extends BaseCommand {
            private object;
            private attributeName;
            private newValue;
            private oldValue;
            constructor(object: T, attributeName: K, newValue: T[K], oldValue?: T[K]);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        declare const shaderFunctions: string;

        export declare function shaderMaterial<TProps extends UniformProps>(uniforms: TProps, vertexShader: string, fragmentShader: string, onInit?: (material: ShaderMaterialInstance<TProps>) => void): ShaderMaterialEx<TProps>;

        declare type ShaderMaterialEx<TProps extends UniformProps> = (new (parameters?: ShaderMaterialParametersEx<TProps>, uniforms?: Partial<TProps>) => ShaderMaterialInstance<TProps>) & {
            key: string;
        };

        declare type ShaderMaterialInstance<TProps extends UniformProps> = ShaderMaterial & TProps;

        declare type ShaderMaterialParametersEx<TProps extends UniformProps> = ShaderMaterialParameters & Partial<TProps>;

        export { ShaderPass }

        declare const shaderStructs: string;

        /**
         *  Shadertoy shader (只支持imageBuffer,不支持BufferA,B,C,D)https://www.shadertoy.com/
         */
        export declare class ShadertoyMaterial extends ShaderMaterial {
            constructor(app: App, parameters?: ShadertoyMaterialParameters);
        }

        export declare interface ShadertoyMaterialParameters extends ShaderMaterialParameters {
            /**
             * 背景颜色
             */
            color?: ColorRepresentation;
            /**
             *  背景颜色透明度(0-1)
             * */
            colorOpacity?: number;
            /**
             * 背景材质
             */
            map?: Texture;
            /**
             * commom shader
             */
            common?: string;
            /**
             * 等同于image中的shader
             */
            shader?: string;
            /**
             * 透明度
             */
            opacity?: number;
            /**
             * 透明色
             */
            opacityColor?: ColorRepresentation;
            /**
             * 亮度透明值 大于0表示亮度值*值表示透明度，小于0表示 （1-亮度值)*值表示透明度
             */
            brightOpacity?: number;
            /**
             * uniforms
             */
            inputUniforms?: {
                /**
                 * uniform名称
                 */
                name: string;
                /**
                 * 用在 shader中声明写法
                 */
                declare: string;
                /**
                 * 值
                 */
                value: Uniform_2;
            }[];
            /**
             * hsb偏移 (对输出颜色进行处理)
             */
            hsbOffset?: [number, number, number];
            /**
             * hsb颜色表达式 (变量hsb)
             */
            hsbExpr?: string;
            /**
             * 如果不输入，则默认为当前鼠标像素坐标
             */
            mouseInputPos?: [number, number];
            /**
             * 生成纹理的材质预定义宏
             */
            defines?: Record<string, any>;
            /**
             * 重复纹理
             */
            repeat?: [number, number];
            /**
             * 分辨率，是1000,1000
             */
            resolution?: [number, number];
            /**
             * 是否使用大小衰减(根据相机远近自动调整点的大小) false的话，表示用像素大小，true表示世界坐标
             */
            sizeAttenuation?: boolean;
            /**
             * sizeAttenuation为false表示像素大小时的尺寸xyz方向的比例大小
             */
            sizeAttScale?: number | [number, number, number];
            /**
             * uv旋转角度
             */
            uvRotateAngle?: number;
            /**
             * uv旋转中心点，默认（0.5，0.5）
             */
            uvRotateCenter?: [number, number];
            /**
             * uv缩放倍数
             */
            uvScale?: [number, number];
            /**
             * uv缩放倍中心点，默认（0.5，0.5）
             */
            uvScaleCenter?: [number, number];
            /**
             * uv缩放背景色(r,b,g,a) (0-1)
             */
            uvScaleBgColor?: [number, number, number, number];
        }

        /**
         *  Shadertoy材质 https://www.shadertoy.com/
         */
        export declare class ShadertoyTexture {
            app: App;
            _texture: Texture;
            image: BufferShader;
            bufferA: BufferShader;
            bufferB: BufferShader;
            bufferC: BufferShader;
            bufferD: BufferShader;
            opacityColor?: Color;
            uniforms: UniformMap;
            clock: Clock;
            set common(value: string);
            get texture(): Texture;
            constructor(app: App, options: ShadertoyTextureOptions);
            render(): void;
            dispose(): void;
        }

        export declare interface ShadertoyTextureItemOptions {
            shader?: string;
            iChannel0?: (Texture | BufferShader);
            iChannel1?: (Texture | BufferShader);
            iChannel2?: (Texture | BufferShader);
            iChannel3?: (Texture | BufferShader);
        }

        export declare interface ShadertoyTextureOptions {
            /** 像素宽 */
            width: number;
            /** 像素高 */
            height: number;
            /** 背景颜色 */
            color?: ColorRepresentation;
            /** 背景颜色透明度(0-1) */
            colorOpacity?: number;
            /** 背景材质 */
            map?: Texture;
            /** common的shader */
            common?: string;
            /** 等同于image中的shader */
            shader?: string;
            /** image的shader */
            image?: ShadertoyTextureItemOptions;
            /** bufferA的shader */
            bufferA?: ShadertoyTextureItemOptions;
            /** bufferB的shader */
            bufferB?: ShadertoyTextureItemOptions;
            /** bufferC的shader */
            bufferC?: ShadertoyTextureItemOptions;
            /** bufferD的shader */
            bufferD?: ShadertoyTextureItemOptions;
            /** 透明度 */
            opacity?: number;
            /** 透明色 */
            opacityColor?: ColorRepresentation;
            /** 亮度透明值 大于0表示亮度值*值表示透明度，小于0表示 （1-亮度值)*值表示透明度 */
            brightOpacity?: number;
            /** uniforms */
            inputUniforms?: {
                /** uniform名称 */
                name: string;
                /** 用在 shader中声明写法 */
                declare: string;
                value: Uniform_2;
            }[];
            /** hsb偏移 (对输出颜色进行处理) */
            hsbOffset?: [number, number, number];
            /** hsb颜色表达式 (变量hsb) */
            hsbExpr?: string;
            /** 如果不输入，则默认为当前鼠标像素位置  */
            mouseInputPos?: [number, number];
            /** 生成纹理的材质预定义宏 */
            defines?: Record<string, any>;
            /** 生成纹理的材质参数 */
            materialParameters?: MaterialParameters;
            /** 生成纹理的渲染参数 */
            renderTargetOptions?: RenderTargetOptions;
            /** 重复纹理 */
            repeat?: [number, number];
            /**
             * uv旋转角度
             */
            uvRotateAngle?: number;
            /**
             * uv旋转中心点，默认（0.5，0.5）
             */
            uvRotateCenter?: [number, number];
            /**
             * uv缩放倍数
             */
            uvScale?: [number, number];
            /**
             * uv缩放倍中心点，默认（0.5，0.5）
             */
            uvScaleCenter?: [number, number];
            /**
             * uv缩放背景色(r,b,g,a) (0-1)
             */
            uvScaleBgColor?: [number, number, number, number];
        }

        declare type ShallowReactive<T> = T & {
            [ShallowReactiveMarker]?: true;
        };

        /**
         * Shallow version of {@link reactive()}.
         *
         * Unlike {@link reactive()}, there is no deep conversion: only root-level
         * properties are reactive for a shallow reactive object. Property values are
         * stored and exposed as-is - this also means properties with ref values will
         * not be automatically unwrapped.
         *
         * @example
         * ```js
         * const state = shallowReactive({
         *   foo: 1,
         *   nested: {
         *     bar: 2
         *   }
         * })
         *
         * // mutating state's own properties is reactive
         * state.foo++
         *
         * // ...but does not convert nested objects
         * isReactive(state.nested) // false
         *
         * // NOT reactive
         * state.nested.bar++
         * ```
         *
         * @param target - The source object.
         */
        declare function shallowReactive<T extends object>(target: T): ShallowReactive<T>;

        declare const ShallowReactiveMarker: unique symbol;

        /**
         * Shallow version of {@link readonly()}.
         *
         * Unlike {@link readonly()}, there is no deep conversion: only root-level
         * properties are made readonly. Property values are stored and exposed as-is -
         * this also means properties with ref values will not be automatically
         * unwrapped.
         *
         * @example
         * ```js
         * const state = shallowReadonly({
         *   foo: 1,
         *   nested: {
         *     bar: 2
         *   }
         * })
         *
         * // mutating state's own properties will fail
         * state.foo++
         *
         * // ...but works on nested objects
         * isReadonly(state.nested) // false
         *
         * // works
         * state.nested.bar++
         * ```
         *
         * @param target - The source object.
         */
        declare function shallowReadonly<T extends object>(target: T): Readonly<T>;

        declare type ShallowRef<T = any> = Ref<T> & {
            [ShallowRefMarker]?: true;
        };

        /**
         * Shallow version of {@link ref()}.
         *
         * @example
         * ```js
         * const state = shallowRef({ count: 1 })
         *
         * // does NOT trigger change
         * state.value.count = 2
         *
         * // does trigger change
         * state.value = { count: 2 }
         * ```
         *
         * @param value - The "inner value" for the shallow ref.
         */
        declare function shallowRef<T extends object>(value: T): T extends Ref ? T : ShallowRef<T>;

        declare function shallowRef<T>(value: T): ShallowRef<T>;

        declare function shallowRef<T = any>(): ShallowRef<T | undefined>;

        declare const ShallowRefMarker: unique symbol;

        declare type ShallowUnwrapRef<T> = {
            [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K] extends Ref<infer V> | undefined ? unknown extends V ? undefined : V | undefined : T[K];
        };

        /**
         * Base class for shapes
         */
        declare class Shape {
            /**
             * Identifier of the Shape.
             */
            id: number;
            /**
             * The type of this shape. Must be set to an int > 0 by subclasses.
             */
            type: ShapeType | 0;
            /**
             * The local bounding sphere radius of this shape.
             */
            boundingSphereRadius: number;
            /**
             * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
             * @default true
             */
            collisionResponse: boolean;
            /**
             * @default 1
             */
            collisionFilterGroup: number;
            /**
             * @default -1
             */
            collisionFilterMask: number;
            /**
             * Optional material of the shape that regulates contact properties.
             */
            material: Material_2 | null;
            /**
             * The body to which the shape is added to.
             */
            body: Body_2 | null;
            static idCounter: number;
            /**
             * All the Shape types.
             */
            static types: {
                /** SPHERE */
                readonly SPHERE: 1;
                /** PLANE */
                readonly PLANE: 2;
                /** BOX */
                readonly BOX: 4;
                /** COMPOUND */
                readonly COMPOUND: 8;
                /** CONVEXPOLYHEDRON */
                readonly CONVEXPOLYHEDRON: 16;
                /** HEIGHTFIELD */
                readonly HEIGHTFIELD: 32;
                /** PARTICLE */
                readonly PARTICLE: 64;
                /** CYLINDER */
                readonly CYLINDER: 128;
                /** TRIMESH */
                readonly TRIMESH: 256;
            };
            constructor(options?: {
                /**
                 * The type of this shape.
                 */
                type?: ShapeType;
                /**
                 * Whether to produce contact forces when in contact with other bodies.
                 * @default true
                 */
                collisionResponse?: boolean;
                /**
                 * @default 1
                 */
                collisionFilterGroup?: number;
                /**
                 * @default -1
                 */
                collisionFilterMask?: number;
                /**
                 * Optional material of the shape that regulates contact properties.
                 * @default null
                 * @todo check this, the material is passed to the body, right?
                 */
                material?: Material_2;
            });
            /**
             * Computes the bounding sphere radius.
             * The result is stored in the property `.boundingSphereRadius`
             */
            updateBoundingSphereRadius(): void;
            /**
             * Get the volume of this shape
             */
            volume(): number;
            /**
             * Calculates the inertia in the local frame for this shape.
             * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
             */
            calculateLocalInertia(mass: number, target: Vec3): void;
            /**
             * @todo use abstract for these kind of methods
             */
            calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
        }

        /**
         * The available shape types.
         */
        declare const SHAPE_TYPES: {
            /** SPHERE */
            readonly SPHERE: 1;
            /** PLANE */
            readonly PLANE: 2;
            /** BOX */
            readonly BOX: 4;
            /** COMPOUND */
            readonly COMPOUND: 8;
            /** CONVEXPOLYHEDRON */
            readonly CONVEXPOLYHEDRON: 16;
            /** HEIGHTFIELD */
            readonly HEIGHTFIELD: 32;
            /** PARTICLE */
            readonly PARTICLE: 64;
            /** CYLINDER */
            readonly CYLINDER: 128;
            /** TRIMESH */
            readonly TRIMESH: 256;
        };

        declare enum ShapecastIntersection {
        }

        declare function shapeCompareFunc(a: Displayable, b: Displayable): number;

        export declare interface ShapeJSON {
            type: string;
            radius?: number;
            arc?: number;
            thickness?: number;
            donutRadius?: number;
            angle?: number;
            width?: number;
            height?: number;
            column?: number;
            row?: number;
            mesh?: string;
            mode?: number;
            particleSystem?: string;
            spread?: number;
            speed?: any;
        }

        export declare interface ShapeOptions {
            type?: ShapeType2;
            cylinderAxis?: 'x' | 'y' | 'z';
            sphereRadius?: number;
        }

        declare type ShapeOptions2 = ConstructorParameters<typeof Shape>[0];

        export declare interface ShapeParameters<T extends ShapeType2 = ShapeType2> {
            type: T;
            params: ShapeTypeToShapeParameters[T];
            offset?: CANNON.Vec3;
            orientation?: CANNON.Quaternion;
        }

        export declare interface ShapeResult<T extends CANNON.Shape = CANNON.Shape> {
            shape: T;
            offset?: CANNON.Vec3;
            orientation?: CANNON.Quaternion;
        }

        /**
         * ShapeType
         */
        declare type ShapeType = typeof SHAPE_TYPES[keyof typeof SHAPE_TYPES];

        export declare enum ShapeType2 {
            BOX = "Box",
            CYLINDER = "Cylinder",
            SPHERE = "Sphere",
            HULL = "ConvexPolyhedron",
            MESH = "Trimesh"
        }

        declare type ShapeTypeToShapeParameters = {
            Box: BoxParameters;
            Cylinder: CylinderParameters;
            Sphere: SphereParameters;
            ConvexPolyhedron: ConvexPolyhedronParameters;
            Trimesh: TrimeshParameters;
        };

        declare function showDebugDirtyRect(zr: Render2dType, opts?: Opts): void;

        /**
         * Signal is a type of event bus. You can subscribe to events using {@link add} method and dispatch using sendN method where N is the number of arguments you wish to pass
         * Signal is different from a normal event bus in that 1 signal corresponds to 1 event type. For example, in HTML you have `addEventListener` which lets you subscribe to any kind of event, let's use "mousedown" as a reference. Using a Signal you would instead have a signal corresponding to "mousedown" and dispatch this signal only for this event.
         * @example `const mouseDown = new Signal<MouseEvent>(); mouseDown.send1(myMouseEvent);`
         */
        export declare class Signal {
            handlers: any;
            /**
             * Event dispatcher dedicated to single event type
             * @constructor
             */
            constructor();
            get dispatching(): boolean;
            /**
             * @deprecated
             * @param {boolean} v
             */
            set dispatching(v: boolean);
            /**
             *
             * @returns {boolean}
             */
            get silent(): boolean;
            /**
             *
             * @param {boolean} v
             */
            set silent(v: boolean);
            setFlag(flag: any): void;
            clearFlag(flag: any): void;
            writeFlag(flag: any, value: any): void;
            getFlag(flag: any): boolean;
            /**
             *
             * @param {function} h
             * @returns {boolean}
             */
            contains(h: any): boolean;
            mute(): void;
            unmute(): void;
            /**
             * Tells if there are any handlers attached to the signal or not
             * @returns {boolean}
             */
            hasHandlers(): boolean;
            /**
             *
             * @param {function} h
             * @param {*} [context]
             */
            addOne(h: any, context?: any): () => boolean;
            /**
             *
             * @param {function} h
             * @param {*} [context]
             */
            add(h: any, context?: any): () => boolean;
            /**
             *
             * @param {function} h
             * @param {*} [thisArg] if supplied, will match handlers with a specific context only
             * @returns {boolean} true if a handler was removed, false otherwise
             */
            remove(h: any, thisArg?: any): boolean;
            /**
             * Remove all handlers
             */
            removeAll(): void;
            /**
             * @param {...*} args
             */
            dispatch(...args: any[]): void;
            /**
             * @deprecated do not use
             * @returns {boolean}
             */
            isDispatching(): boolean;
            /**
             *
             * @param {Signal} other
             * @returns {Signal} merged signal combining events from this and other
             */
            merge(other: any): Signal;
        }

        export declare class SignalHandler {
            /**
             *
             * @param {function} handle
             * @param {*} [context]
             */
            constructor(handle: any, context: any);
            setFlag(flag: any): void;
            clearFlag(flag: any): void;
            writeFlag(flag: any, value: any): void;
            getFlag(flag: any): boolean;
        }

        declare class SilhouetteGenerator {
            [key: string]: any;
        }

        /**
         * A simple event dispatcher with typed event types, see {@link IEventDispatcher}.
         */
        export declare class SimpleEventDispatcher<T extends string> implements IEventDispatcher<T> {
            constructor();
            private readonly _eventListeners;
            addEventListener(type: T, listener: (event: IEvent<T>) => void): void;
            hasEventListener(type: T, listener: (event: IEvent<T>) => void): boolean;
            removeEventListener(type: T, listener: (event: IEvent<T>) => void): void;
            dispatchEvent(event: IEvent<T>): void;
        }

        /** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */
        declare class SimplexNoise {
            private p;
            private perm;
            private permMod12;
            /**
             * Creates a new `SimplexNoise` instance.
             * This involves some setup. You can save a few cpu cycles by reusing the same instance.
             * @param randomOrSeed A random number generator or a seed (string|number).
             * Defaults to Math.random (random irreproducible initialization).
             */
            constructor(randomOrSeed?: RandomFn | string | number);
            /**
             * Samples the noise field in 2 dimensions
             * @param x
             * @param y
             * @returns a number in the interval [-1, 1]
             */
            noise2D(x: number, y: number): number;
            /**
             * Samples the noise field in 3 dimensions
             * @param x
             * @param y
             * @param z
             * @returns a number in the interval [-1, 1]
             */
            noise3D(x: number, y: number, z: number): number;
            /**
             * Samples the noise field in 4 dimensions
             * @param x
             * @param y
             * @param z
             * @returns a number in the interval [-1, 1]
             */
            noise4D(x: number, y: number, z: number, w: number): number;
        }

        export declare function simplifyPoints(points: [number, number][], tolerance?: number, highestQuality?: boolean): [number, number][];

        /**
         * Interface for particle simulations.
         * a simulation is a function that modifies a particle's properties over time.
         */
        export declare interface Simulation {
            type: string;
            initialize(particle: Particle, particleSystem: IParticleSystem): void;
            update(particle: Particle, delta: number): void;
            frameUpdate(delta: number): void;
            toJSON(): any;
            clone(): Simulation;
            reset(): void;
        }

        export declare function SimulationFromJSON(json: any, particleSystem: ParticleSystem): Simulation;

        export declare interface SimulationParticlePlugin {
            type: string;
            constructor: Constructable<Simulation>;
            params: ParameterPair[];
            loadJSON: (json: any, particleSystem: ParticleSystem) => Simulation;
        }

        export declare const SimulationTypes: {
            [key: string]: SimulationParticlePlugin;
        };

        declare type singleTouchAction = typeof ACTION.TOUCH_ROTATE | typeof ACTION.TOUCH_TRUCK | typeof ACTION.TOUCH_OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

        /**
         * Apply size to particles based on their speed.
         */
        export declare class SizeBySpeed implements Simulation {
            size: FunctionValueGenerator;
            speedRange: IntervalValue;
            type: string;
            initialize(particle: Particle): void;
            constructor(size: FunctionValueGenerator, speedRange: IntervalValue);
            update(particle: Particle): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        /**
         *  Apply size to particles based on their life.
         */
        export declare class SizeOverLife implements Simulation {
            size: FunctionValueGenerator;
            type: string;
            initialize(particle: Particle): void;
            constructor(size: FunctionValueGenerator);
            update(particle: Particle): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        /** 休眠多少毫秒，默认1秒 */
        export declare function sleep(ms?: number): Promise<void>;

        declare function slice<T>(arr: ArrayLike_2<T>, ...args: SliceParams): T[];

        declare type SliceParams = Parameters<typeof nativeSlice>;

        export { SMAAEffect }

        export { SMAAPreset }

        /**
         * 平滑点，拐弯处将以曲线代替
         * points 点数组
         * curvePointNum 每个拐点增加的曲线点个数，默认5
         * curvePointPosRatio 开始拐的点所占曲线位置的长度比例 (0-1) 默认 0.9
         * oldIndexTarget 可填入一个数组，用来返回新数据索引对应的来老数组中的索引位置
         */
        export declare function smoothPoints(points: Array<[number, number, number]>, curvePointNum?: number, curvePointPosRatio?: number, oldIndexTarget?: number[]): any[];

        /**
         * Constraint equation solver base class.
         */
        declare class Solver {
            /**
             * All equations to be solved
             */
            equations: Equation[];
            /**
             * @todo remove useless constructor
             */
            constructor();
            /**
             * Should be implemented in subclasses!
             * @todo use abstract
             * @return number of iterations performed
             */
            solve(dt: number, world: World): number;
            /**
             * Add an equation
             */
            addEquation(eq: Equation): void;
            /**
             * Remove an equation
             */
            removeEquation(eq: Equation): void;
            /**
             * Add all equations
             */
            removeAllEquations(): void;
        }

        /**
         * Apply speed to particles based on their life.
         */
        export declare class SpeedOverLife implements Simulation {
            speed: FunctionValueGenerator;
            type: string;
            initialize(particle: Particle): void;
            constructor(speed: FunctionValueGenerator);
            update(particle: Particle): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            frameUpdate(delta: number): void;
            clone(): Simulation;
            reset(): void;
        }

        /**
         * Spherical shape
         * @example
         *     const radius = 1
         *     const sphereShape = new CANNON.Sphere(radius)
         *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
         *     world.addBody(sphereBody)
         */
        declare class Sphere_2 extends Shape {
            /**
             * The radius of the sphere.
             */
            radius: number;
            /**
             *
             * @param radius The radius of the sphere, a non-negative number.
             */
            constructor(radius: number);
            /** calculateLocalInertia */
            calculateLocalInertia(mass: number, target?: Vec3): Vec3;
            /** volume */
            volume(): number;
            updateBoundingSphereRadius(): void;
            calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
        }

        export declare class SphereEmitter implements EmitterShape {
            type: string;
            radius: number;
            arc: number;
            thickness: number;
            mode: EmitterMode;
            spread: number;
            speed: ValueGenerator | FunctionValueGenerator;
            constructor(parameters?: SphereEmitterParameters);
            private currentValue;
            update(system: ParticleSystem, delta: number): void;
            initialize(p: Particle, emissionState: EmissionState): void;
            toJSON(): ShapeJSON;
            static fromJSON(json: any): SphereEmitter;
            clone(): EmitterShape;
        }

        /**
         * Interface representing the parameters for a sphere emitter.
         */
        export declare interface SphereEmitterParameters {
            /**
             * The radius of the sphere.
             */
            radius?: number;
            /**
             * The arc of the sphere.
             */
            arc?: number;
            /**
             * The thickness of the sphere. 1 is a full sphere, 0 is a thin shell.
             */
            thickness?: number;
            /**
             * The mode of the emitter.
             * {@link EmitterMode}
             */
            mode?: EmitterMode;
            /**
             * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
             * {@link EmitterMode}
             */
            spread?: number;
            /**
             * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
             * {@link EmitterMode}
             */
            speed?: ValueGenerator | FunctionValueGenerator;
        }

        export declare type SphereParameters = {
            radius: number;
        };

        /**
         * Smoothed-particle hydrodynamics system
         * @todo Make parameters customizable in the constructor
         */
        declare class SPHSystem {
            /**
             * The particles array.
             */
            particles: Body_2[];
            /**
             * Density of the system (kg/m3).
             * @default 1
             */
            density: number;
            /**
             * Distance below which two particles are considered to be neighbors.
             * It should be adjusted so there are about 15-20 neighbor particles within this radius.
             * @default 1
             */
            smoothingRadius: number;
            /**
             * @default 1
             */
            speedOfSound: number;
            /**
             * Viscosity of the system.
             * @default 0.01
             */
            viscosity: number;
            /**
             * @default 0.000001
             */
            eps: number;
            pressures: number[];
            densities: number[];
            neighbors: Body_2[][];
            constructor();
            /**
             * Add a particle to the system.
             */
            add(particle: Body_2): void;
            /**
             * Remove a particle from the system.
             */
            remove(particle: Body_2): void;
            /**
             * Get neighbors within smoothing volume, save in the array neighbors
             */
            getNeighbors(particle: Body_2, neighbors: Body_2[]): void;
            update(): void;
            w(r: number): number;
            gradw(rVec: Vec3, resultVec: Vec3): void;
            nablaw(r: number): number;
        }

        export declare class SphubeGeometry extends ParametricGeometry {
            constructor(slices?: number, stacks?: number);
        }

        declare function split(path: Path, count: number): any[];

        /**
         * Splits the equations into islands and solves them independently. Can improve performance.
         */
        declare class SplitSolver extends Solver {
            /**
             * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
             */
            iterations: number;
            /**
             * When tolerance is reached, the system is assumed to be converged.
             */
            tolerance: number;
            /** subsolver */
            subsolver: GSSolver;
            nodes: SplitSolverNode[];
            nodePool: SplitSolverNode[];
            constructor(subsolver: GSSolver);
            /**
             * createNode
             */
            createNode(): SplitSolverNode;
            /**
             * Solve the subsystems
             * @return number of iterations performed
             */
            solve(dt: number, world: World): number;
        }

        declare type SplitSolverNode = {
            body: Body_2 | null;
            children: SplitSolverNode[];
            eqs: Equation[];
            visited: boolean;
        };

        declare enum SplitStrategy {
        }

        /**
         * A spring, connecting two bodies.
         * @example
         *     const spring = new Spring(boxBody, sphereBody, {
         *       restLength: 0,
         *       stiffness: 50,
         *       damping: 1,
         *     })
         *
         *     // Compute the force after each step
         *     world.addEventListener('postStep', (event) => {
         *       spring.applyForce()
         *     })
         */
        declare class Spring {
            /**
             * Rest length of the spring. A number > 0.
             * @default 1
             */
            restLength: number;
            /**
             * Stiffness of the spring. A number >= 0.
             * @default 100
             */
            stiffness: number;
            /**
             * Damping of the spring. A number >= 0.
             * @default 1
             */
            damping: number;
            /**
             * First connected body.
             */
            bodyA: Body_2;
            /**
             * Second connected body.
             */
            bodyB: Body_2;
            /**
             * Anchor for bodyA in local bodyA coordinates.
             * Where to hook the spring to body A, in local body coordinates.
             * @default new Vec3()
             */
            localAnchorA: Vec3;
            /**
             * Anchor for bodyB in local bodyB coordinates.
             * Where to hook the spring to body B, in local body coordinates.
             * @default new Vec3()
             */
            localAnchorB: Vec3;
            constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                /**
                 * Rest length of the spring. A number > 0.
                 * @default 1
                 */
                restLength?: number;
                /**
                 * Stiffness of the spring. A number >= 0.
                 * @default 100
                 */
                stiffness?: number;
                /**
                 * Damping of the spring. A number >= 0.
                 * @default 1
                 */
                damping?: number;
                /**
                 * Anchor for bodyA in local bodyA coordinates.
                 * Where to hook the spring to body A, in local body coordinates.
                 * @default new Vec3()
                 */
                localAnchorA?: Vec3;
                /**
                 * Anchor for bodyB in local bodyB coordinates.
                 * Where to hook the spring to body B, in local body coordinates.
                 * @default new Vec3()
                 */
                localAnchorB?: Vec3;
                /**
                 * Where to hook the spring to body A, in world coordinates.
                 */
                worldAnchorA?: Vec3;
                /**
                 * Where to hook the spring to body B, in world coordinates.
                 */
                worldAnchorB?: Vec3;
            });
            /**
             * Set the anchor point on body A, using world coordinates.
             */
            setWorldAnchorA(worldAnchorA: Vec3): void;
            /**
             * Set the anchor point on body B, using world coordinates.
             */
            setWorldAnchorB(worldAnchorB: Vec3): void;
            /**
             * Get the anchor point on body A, in world coordinates.
             * @param result The vector to store the result in.
             */
            getWorldAnchorA(result: Vec3): void;
            /**
             * Get the anchor point on body B, in world coordinates.
             * @param result The vector to store the result in.
             */
            getWorldAnchorB(result: Vec3): void;
            /**
             * Apply the spring force to the connected bodies.
             */
            applyForce(): void;
        }

        declare type SpringOptions = ConstructorParameters<typeof Spring>[2];

        /**
         * 精灵动画实体
         */
        export declare class SpriteAnimatorEntity extends Entity {
            constructor(options: SpriteAnimatorEntityOptions);
            /**
             * 获取精灵动画对象
             */
            readonly spriteAnimator: SpriteAnimatorType;
            /**
             * 暂停动画
             */
            pauseAnimation: () => void;
            /**
             * 运行动画
             */
            playAnimation: () => void;
            /**
             * 设置动画帧名称
             */
            setFrameName: (name: string) => void;
        }

        export declare type SpriteAnimatorEntityOptions = EntityOptions & SpriteAnimatorProps;

        /**
         * 精灵动画模块
         */
        export declare class SpriteAnimatorModule extends EntityModuleBase implements IEntityModuleBase {
            #private;
            static moduleName: string;
            isLoaded?: boolean;
            constructor(entity: Entity, options?: SpriteAnimatorProps);
            setupUiConfig(): {
                type: string;
                expanded: boolean;
                label: string;
                app: App;
                children: UiObjectConfig<any, string, any>[];
            };
            get spriteAnimator(): SpriteAnimatorType;
            onAppUpdate(time: Time): void;
            pauseAnimation(): void;
            playAnimation(): void;
            setFrameName(name: string): void;
        }

        export declare type SpriteAnimatorProps = {
            startFrame?: number;
            endFrame?: number;
            fps?: number;
            frameName?: string;
            textureDataURL?: string;
            textureImageURL: string;
            loop?: boolean;
            numberOfFrames?: number;
            autoPlay?: boolean;
            animationNames?: Array<string>;
            onStart?: Function;
            onEnd?: Function;
            onLoopEnd?: Function;
            onFrame?: Function;
            play?: boolean;
            pause?: boolean;
            flipX?: boolean;
            position?: Array<number>;
            alphaTest?: number;
            asSprite?: boolean;
        };

        export declare type SpriteAnimatorType = {
            group: Group_2;
            init: Function;
            update: Function;
            pauseAnimation: Function;
            playAnimation: Function;
            setFrameName: Function;
        };

        /**
         * A VFX batch that render sprites in a batch.
         */
        export declare class SpriteBatch extends VFXBatch {
            geometry: InstancedBufferGeometry;
            private offsetBuffer;
            private rotationBuffer;
            private sizeBuffer;
            private colorBuffer;
            private uvTileBuffer;
            private velocityBuffer?;
            constructor(settings: VFXBatchSettings);
            buildExpandableBuffers(): void;
            setupBuffers(): void;
            expandBuffers(target: number): void;
            rebuildMaterial(): void;
            vector_: Vector3;
            vector2_: Vector3;
            vector3_: Vector3;
            quaternion_: Quaternion;
            quaternion2_: Quaternion;
            quaternion3_: Quaternion;
            rotationMat_: Matrix3;
            rotationMat2_: Matrix3;
            update(): void;
            dispose(): void;
        }

        export declare interface SpriteImageItem extends SpriteImageItemData {
            material: SpriteMaterial;
            highlightMaterial?: SpriteMaterial;
            object: SpriteMarker;
        }

        /**
         * 精灵图标某项数据
         */
        export declare interface SpriteImageItemData {
            /** 位置 */
            position: Vector3 | [number, number, number];
            /** 图标 */
            icon: string | ImageLike;
            /** 高亮时的图标 */
            highlightIcon?: string | ImageLike;
            /** 高亮时的透明度 */
            highlightOpacity?: number;
            /** x对齐方式  */
            anchorX?: number | 'left' | 'center' | 'right';
            /** y对齐方式 */
            anchorY?: number | 'top' | 'center' | 'bottom';
            /** x偏移 */
            offsetX?: number;
            /** y偏移 */
            offsetY?: number;
            /** 旋转角度(0-360) */
            rotation?: number;
            /** 宽(sizeAttenuation为false是图标像素大小，否则表示世界坐标宽度) */
            width?: number;
            /** 高(sizeAttenuation为false是图标像素大小，否则表示世界坐标制图高) */
            height?: number;
            /** 碰撞检测时的zindex，值越大，越往上 */
            collideZIndex?: number;
            /** 同一个id会一起显示和隐藏 */
            collideId?: string;
        }

        /**
         * 精灵图标对象
         */
        export declare class SpriteImages extends Group_2 {
            #private;
            app: App;
            data: SpriteImageItem[];
            constructor(options: SpriteImagesOptions, app: App);
            getOptions(): SpriteImagesOptions;
            update(): void;
            getData(): SpriteImageItem[];
            setItemHighlight(index: number, isHighlight?: boolean): void;
            setData(data: SpriteImageItemData[]): Promise<void>;
            dispose(): void;
        }

        /**
         * 精灵图像实体
         */
        export declare class SpriteImagesEntity extends Entity {
            constructor(options: SpriteImagesEntityOptions);
            /**
             * 获取精灵图像对象
             */
            readonly SpriteImages: SpriteImages;
            /**
             * 获取选顶数据
             */
            getOptions(): SpriteImagesOptions;
            /**
             * 更新
             */
            update(): void;
            /**
             * 获取数据
             */
            getData(): SpriteImageItem[];
            /**
             * 设置某项高亮
             */
            setItemHighlight(index: number, isHighlight?: boolean): void;
            /**
             * 设置数据
             */
            setData(data: SpriteImageItemData[]): Promise<void>;
            /**
             * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
             */
            isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
        }

        export declare type SpriteImagesEntityOptions = EntityOptions & SpriteImagesOptions;

        /**
         * 精灵图标模块
         */
        export declare class SpriteImagesModule extends EntityModuleBase implements IEntityModuleBase {
            #private;
            static moduleName: string;
            isLoaded?: boolean;
            constructor(entity: Entity, options?: SpriteImagesOptions);
            get SpriteImages(): SpriteImages;
        }

        /**
         * 精灵图标选顶
         */
        export declare interface SpriteImagesOptions {
            /** 数据 */
            data: SpriteImageItemData[];
            /** 是否使用大小衰减(根据相机远近自动调整点的大小) false的话，表示用像素大小，true表示世界坐标 */
            sizeAttenuation?: boolean;
            /** 材质参数 */
            materialParameters?: SpriteMaterialParameters;
            /** 更新材质节流时间毫秒，默认20 */
            refreshRenderThrottleTimeout?: number;
            /** 透明度随相机距离大小 */
            fadeDistance?: number;
            /** 是否允许重叠 */
            allowOverlap?: boolean;
            /** 碰撞监测组名 会对同一个组名内的进行碰撞检测 */
            collideGroupName?: string;
            /** 自动尺寸时，获取矩形大小时，额外扩展的范围 (左上,，左下y, 右x,右下y) */
            expandRect?: number | [number, number, number, number];
        }

        /**
         * 精灵标记对象
         */
        export declare class SpriteMarker extends Sprite {
            #private;
            options: SpriteMarkerOptions;
            width: number;
            height: number;
            app: App;
            constructor(options: SpriteMarkerOptions, app?: App);
            setMaterial(material: SpriteMaterial): void;
            updateRenderTexture(cb: (context: {
                group: render2d.Group;
                render: render2d.Render2dType;
                canvas: HTMLCanvasElement;
            }) => boolean): void;
            refreshRenderTexture(): void;
            dispatchRenderTextureEvent(eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number): void;
            setAllowOverlap(allowOverlap: boolean): void;
            updateScale(): void;
            updateAnchor(): void;
            getBoundingRect(): {
                x1: number;
                y1: number;
                x2: any;
                y2: any;
                cx: number;
                cy: number;
                rotation: number;
                position: Vector3;
                zIndex: number;
                id: string;
                groupName: string;
                setVisible: (visible: any) => any;
            };
            dispose(): void;
        }

        /**
         * 精灵标记实体
         */
        export declare class SpriteMarkerEntity extends Entity {
            constructor(options: SpriteMarkerEntityOptions);
            /**
             * 获取精灵标记对象
             */
            readonly SpriteMarker: SpriteMarker;
            /**
             * 设置材质
             */
            setMaterial(material: SpriteMaterial): void;
            /**
             *更新渲染材质
             */
            updateRenderTexture(cb: (context: {
                group: render2d.Group;
                render: render2d.Render2dType;
                canvas: HTMLCanvasElement;
            }) => boolean): void;
            /**
             *刷新渲染材质
             */
            refreshRenderTexture(): void;
            /**
             * 给渲染材质触发相应事件
             */
            dispatchRenderTextureEvent(eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number): void;
            /**
             * 设置是否允许重叠
             */
            setAllowOverlap(allowOverlap: boolean): void;
            /**
             * 更新缩放尺寸
             */
            updateScale(): void;
            /**
             * 更新对齐
             */
            updateAnchor(): void;
            /**
             * 获取矩形范围
             */
            getBoundingRect(): {
                x1: number;
                y1: number;
                x2: any;
                y2: any;
                cx: number;
                cy: number;
                rotation: number;
                position: Vector3;
                zIndex: number;
                id: string;
                groupName: string;
                setVisible: (visible: any) => any;
            };
        }

        export declare type SpriteMarkerEntityOptions = EntityOptions & SpriteMarkerOptions;

        /**
         * 精灵标记模块
         */
        export declare class SpriteMarkerModule extends EntityModuleBase implements IEntityModuleBase {
            #private;
            static moduleName: string;
            isLoaded?: boolean;
            constructor(entity: Entity, options?: SpriteMarkerOptions);
            get SpriteMarker(): SpriteMarker;
            setupUiConfig(): {
                type: string;
                expanded: boolean;
                label: string;
                app: App;
                children: {
                    type: string;
                    label: string;
                    onClick: () => void;
                }[];
            };
        }

        export declare interface SpriteMarkerOptions {
            /** 位置 */
            position: Vector3 | [number, number, number];
            /** x对齐方式  */
            anchorX?: number | 'left' | 'center' | 'right';
            /** y对齐方式 */
            anchorY?: number | 'top' | 'center' | 'bottom';
            /** x偏移 */
            offsetX?: number;
            /** y偏移 */
            offsetY?: number;
            /** 旋转角度(0-360) */
            rotation?: number;
            /** 材质 */
            material?: SpriteMaterial;
            /** 材质参数 */
            materialParameters?: SpriteMaterialParameters;
            /** 是否使用大小衰减(根据相机远近自动调整点的大小) false的话，表示用像素大小，true表示世界坐标 */
            sizeAttenuation?: boolean;
            /** 宽(sizeAttenuation为false是像素大小，否则表示世界坐标宽度) */
            width?: number;
            /** 高(sizeAttenuation为false是像素大小，否则表示世界坐标制图高) */
            height?: number;
            /** 使用渲染材质 */
            renderTexture?: Render2dTextureOptions;
            /** 直接使用材质（当此项有值时renderTexture将无效) */
            texture?: Texture;
            /** 更新材质节流时间毫秒，默认20 */
            refreshRenderThrottleTimeout?: number;
            /** 透明度随相机距离大小 */
            fadeDistance?: number;
            /** 是否允许重叠 */
            allowOverlap?: boolean;
            /** 碰撞检测时的zindex，值越大，越往上 */
            collideZIndex?: number;
            /** 同一个id会一起显示和隐藏 */
            collideId?: string;
            /** 碰撞监测组名 会对同一个组名内的进行碰撞检测 */
            collideGroupName?: string;
            /** 自动尺寸时，获取矩形大小时，额外扩展的范围 (左上,，左下y, 右x,右下y) */
            expandRect?: number | [number, number, number, number];
        }

        /**
         * Particle implementation for sprite-based particle.
         */
        export declare class SpriteParticle implements Particle {
            /**
             * Parent matrix for transformation.
             * @type {Matrix4}
             */
            parentMatrix?: Matrix4;
            /**
             * Initial speed of the particle.
             * @type {number}
             */
            startSpeed: number;
            /**
             * Initial color of the particle.
             * @type {Vector4}
             */
            startColor: Vector4;
            /**
             * Initial size of the particle.
             * @type {number}
             */
            startSize: number;
            /**
             * Position of the particle.
             * @type {Vector3}
             */
            position: Vector3;
            /**
             * Velocity of the particle.
             * @type {Vector3}
             */
            velocity: Vector3;
            /**
             * Age of the particle.
             * @type {number}
             */
            age: number;
            /**
             * Life duration of the particle.
             * @type {number}
             */
            life: number;
            /**
             * Size of the particle.
             * @type {number}
             */
            size: number;
            /**
             * Speed modifier of the particle.
             * @type {number}
             */
            speedModifier: number;
            /**
             * Angular velocity of the particle.
             * @type {number | Quaternion}
             */
            angularVelocity?: number | Quaternion;
            /**
             * Rotation of the particle.
             * @type {number | Quaternion}
             */
            rotation: number | Quaternion;
            /**
             * Color of the particle.
             * @type {Vector4}
             */
            color: Vector4;
            /**
             * UV tile index.
             * @type {number}
             */
            uvTile: number;
            /**
             * Indicates if the particle has died.
             * @type {boolean}
             */
            get died(): boolean;
        }

        export declare interface SpriteTextItem extends SpriteTextItemData {
            material: SpriteMaterial;
            highlightMaterial?: SpriteMaterial;
            object: SpriteMarker;
        }

        /**
         * 精灵文本某项数据
         */
        export declare interface SpriteTextItemData {
            /** id */
            id?: string;
            /** 位置 */
            position: Vector3 | [number, number, number];
            /** 文本 */
            text: string;
            /** 文本样式 */
            style?: TextStyleProps;
            /** 高亮时的文本样式 */
            highlightStyle?: TextStyleProps;
            /** x对齐方式  */
            anchorX?: number | 'left' | 'center' | 'right';
            /** y对齐方式 */
            anchorY?: number | 'top' | 'center' | 'bottom';
            /** x偏移 */
            offsetX?: number;
            /** y偏移 */
            offsetY?: number;
            /** 旋转角度(0-360) */
            rotation?: number;
            /** 宽(sizeAttenuation为false是文本像素大小，否则表示世界坐标宽度) */
            width?: number;
            /** 高(sizeAttenuation为false是文本像素大小，否则表示世界坐标制图高) */
            height?: number;
            /** 碰撞检测时的zindex，值越大，越往上 */
            collideZIndex?: number;
            /** 同一个id会一起显示和隐藏 */
            collideId?: string;
            /** 是否根据绘制的内容计算渲染的大小 默认true */
            autoCanvasSize?: boolean;
            /** 是否为了提高效率共享一个canvas 默认true */
            sharedCanvas?: boolean;
        }

        /**
         * 精灵文本对象
         */
        export declare class SpriteTexts extends Group_2 {
            #private;
            app: App;
            data: SpriteTextItem[];
            constructor(options: SpriteTextsOptions, app: App);
            getOptions(): SpriteTextsOptions;
            update(): void;
            getData(): SpriteTextItem[];
            setItemHighlight(index: number, isHighlight?: boolean): void;
            setData(data: SpriteTextItemData[]): Promise<void>;
            dispose(): void;
        }

        /**
         * 精灵文本实体
         */
        export declare class SpriteTextsEntity extends Entity {
            constructor(options: SpriteTextsEntityOptions);
            /**
             * 获取精灵文本对象
             */
            readonly SpriteTexts: SpriteTexts;
            /**
             * 获取选顶数据
             */
            getOptions(): SpriteTextsOptions;
            /**
             * 更新
             */
            update(): void;
            /**
             * 获取数据
             */
            getData(): SpriteTextItem[];
            /**
             * 设置某项高亮
             */
            setItemHighlight(index: number, isHighlight?: boolean): void;
            /**
             * 设置数据
             */
            setData(data: SpriteTextItemData[]): Promise<void>;
            /**
             * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
             */
            isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
        }

        export declare type SpriteTextsEntityOptions = EntityOptions & SpriteTextsOptions;

        /**
         * 精灵文本模块
         */
        export declare class SpriteTextsModule extends EntityModuleBase implements IEntityModuleBase {
            #private;
            static moduleName: string;
            isLoaded?: boolean;
            constructor(entity: Entity, options?: SpriteTextsOptions);
            get SpriteTexts(): SpriteTexts;
        }

        /**
         * 精灵文本选顶
         */
        export declare interface SpriteTextsOptions {
            /**
             * 数据
             */
            data: SpriteTextItemData[];
            /**
             * 是否使用大小衰减(根据相机远近自动调整点的大小) false的话，表示用像素大小，true表示世界坐标
             */
            sizeAttenuation?: boolean;
            /** 材质参数 */
            materialParameters?: SpriteMaterialParameters;
            /** 更新材质节流时间毫秒，默认20 */
            refreshRenderThrottleTimeout?: number;
            /** 透明度随相机距离大小 */
            fadeDistance?: number;
            /** 是否允许重叠 */
            allowOverlap?: boolean;
            /** 碰撞监测组名 会对同一个组名内的进行碰撞检测 */
            collideGroupName?: string;
            /** 自动尺寸时，获取矩形大小时，额外扩展的范围 (左上,，左下y, 右x,右下y) */
            expandRect?: number | [number, number, number, number];
        }

        /**
         * Converts a single color channel from the sRGB color space to linear.
         * @param c - The color channel to be converted.
         * @category Color
         */
        export declare function SRGBToLinear(c: number): number;

        export { SSAOEffect }

        declare interface Stage {
            update?: () => void;
        }

        declare class Star extends Path<StarProps> {
            shape: StarShape;
            constructor(opts?: StarProps);
            getDefaultShape(): StarShape;
            buildPath(ctx: CanvasRenderingContext2D, shape: StarShape): void;
        }

        declare interface StarProps extends PathProps {
            shape?: Partial<StarShape>;
        }

        declare class StarShape {
            cx: number;
            cy: number;
            n: number;
            r0: number;
            r: number;
        }

        /** @public */
        export declare abstract class StateNode {
            editor: App;
            private _current;
            private _isActive;
            app: App;
            parent: StateNode;
            constructor(editor: App, parent?: StateNode);
            static id: string;
            static initial?: string;
            static children?: () => TLStateNodeConstructor[];
            id: string;
            type: TLStateNodeType;
            initial?: string;
            children?: Record<string, StateNode>;
            /**
             * This node's path of active state nodes
             *
             * @public
             */
            getPath(): string;
            /**
             * This node's current active child node, if any.
             *
             * @public
             */
            getCurrent(): any;
            /**
             * Whether this node is active.
             *
             * @public
             */
            getIsActive(): boolean;
            setIsActive(b: boolean): void;
            /**
             * Transition to a new active child state node.
             *
             * @example
             * ```ts
             * parentState.transition('childStateA')
             * parentState.transition('childStateB', { myData: 4 })
             *```
             *
             * @param id - The id of the child state node to transition to.
             * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
             *
             * @public
             */
            transition: (id: string, info?: {
                [key: string]: any;
                name?: string;
                event?: InteractiveEvent;
                object?: InteractiveObject;
            }) => this;
            handleEvent: (info: {
                name: string;
                event: InteractiveEvent;
                object: InteractiveObject;
            }) => void;
            enter: (info: TLEventType, from: string) => void;
            exit: (info: TLEventType, from: string) => void;
            /**
             * This is a hack / escape hatch that will tell the editor to
             * report a different state as active (in `getCurrentToolId()`) when
             * this state is active. This is usually used when a tool transitions
             * to a child of a different state for a certain interaction and then
             * returns to the original tool when that interaction completes; and
             * where we would want to show the original tool as active in the UI.
             *
             * @public
             */
            _currentToolIdMask: Ref<string>;
            getCurrentToolIdMask(): string;
            setCurrentToolIdMask(id: string | undefined): void;
            onMouseUp?: (info: TLEventHandler) => void;
            onMouseDown?: (info: TLEventHandler) => void;
            onMouseClick?: (info: TLEventHandler) => void;
            onMouseDblClick?: (info: TLEventHandler) => void;
            onMouseMove?: (info: TLEventHandler) => void;
            onPointerDown?: (info: TLEventHandler) => void;
            onPointerMove?: (info: TLEventHandler) => void;
            onPointerUp?: (info: TLEventHandler) => void;
            onPointerDownUp?: (info: TLEventHandler) => void;
            onPointerCancel?: (info: TLEventHandler) => void;
            onContextMenu?: (info: TLEventHandler) => void;
            onMouseOut?: (info: TLEventHandler) => void;
            onMouseOver?: (info: TLEventHandler) => void;
            onMouseLeave?: (info: TLEventHandler) => void;
            onMouseEnter?: (info: TLEventHandler) => void;
            onMouseWheel?: (info: TLEventHandler) => void;
            onKeyDown?: (info: TLEventHandler) => void;
            onKeyUp?: (info: TLEventHandler) => void;
            onEnter?: TLEnterEventHandler;
            onExit?: TLExitEventHandler;
        }

        declare class StaticGeometryGenerator {
            useGroups: boolean;
            attributes: Array<string>;
            applyWorldTransforms: boolean;
            constructor(objects: Array<Object3D> | Object3D);
            getMaterials(): Array<Material>;
            generate(target?: BufferGeometry): BufferGeometry;
        }

        export declare class StatModule extends AppModuleBase implements IAppModuleBase {
            static moduleName: string;
            private _stats;
            options: StatModuleOptions;
            constructor(app?: App, options?: StatModuleOptions);
            get showStat(): any;
            set showStat(show: any);
            onAwake(): void;
            onAppBeforeUpdate(): void;
            onAppAfterRender(): void;
            setupUiConfig(): UiObjectConfig;
        }

        export declare interface StatModuleOptions {
            show?: boolean;
            id?: string;
            left?: string;
            right?: string;
            top?: string;
            bottom?: string;
            panelIndex?: number;
        }

        /**
         * Stops the effect associated with the given runner.
         *
         * @param runner - Association with the effect to stop tracking.
         */
        declare function stop_2(runner: ReactiveEffectRunner): void;

        declare class Storage_2 {
            private _roots;
            private _displayList;
            private _displayListLen;
            traverse<T>(cb: (this: T, el: Element_2) => void, context?: T): void;
            /**
             * get a list of elements to be rendered
             *
             * @param {boolean} update whether to update elements before return
             * @param {DisplayParams} params options
             * @return {Displayable[]} a list of elements
             */
            getDisplayList(update?: boolean, includeIgnore?: boolean): Displayable[];
            /**
             * 更新图形的绘制队列。
             * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
             * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
             */
            updateDisplayList(includeIgnore?: boolean): void;
            private _updateAndAddDisplayable;
            /**
             * 添加图形(Displayable)或者组(Group)到根节点
             */
            addRoot(el: Element_2): void;
            /**
             * 删除指定的图形(Displayable)或者组(Group)
             * @param el
             */
            delRoot(el: Element_2 | Element_2[]): void;
            delAllRoots(): void;
            getRoots(): Element_2<ElementProps>[];
            /**
             * 清空并且释放Storage
             */
            dispose(): void;
            displayableSortFunc: typeof shapeCompareFunc;
        }

        /**
         * 全局变量类
         */
        export declare class Store {
            /** 全局应用类，会把最后加的app设置为全局app */
            static app: App;
            /** 全局服务类 */
            static service: Service;
            /** 全局用户数据 */
            static useData: Record<string, any>;
        }

        export declare interface StoredBatchSettings {
            instancingGeometry: BufferGeometry;
            material: Material;
            uTileCount: number;
            vTileCount: number;
            blendTiles: boolean;
            softParticles: boolean;
            softNearFade: number;
            softFarFade: number;
            renderMode: RenderMode;
            renderOrder: number;
            layers: Layers;
        }

        export declare interface StretchedBillBoardSettings {
            /**
             * how stretched the particle is in the direction of the camera based on the speed of the particle.
             * @type {number}
             */
            speedFactor: number;
            /**
             * how stretched the particle is in the direction of the camera based on the size of the particle.
             * @type {number}
             */
            lengthFactor: number;
        }

        /**
         * @param arrColor like [12,33,44,0.4]
         * @param type 'rgba', 'hsva', ...
         * @return Result color. (If input illegal, return undefined).
         */
        declare function stringify(arrColor: number[], type: string): string;

        /**
         * Extract keys from object that are strings
         */
        export declare type StringKeyOf<T extends any> = Extract<keyof T, string>;

        /**
         * 获取字符串的Md5值
         * @param str
         * @return {string}
         */
        export declare function strMd5(str: string): string;

        /**
         * 向量相减
         */
        declare function sub<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

        export declare enum SubParticleEmitMode {
            Death = 0,
            Birth = 1,
            Frame = 2
        }

        declare const SUBTRACTION: CSGOperation;

        /**
         * Behavior that always succeeds
         */
        export declare class SucceedingBehavior extends Behavior {
            delayTicks: number;
            constructor(delayTicks?: number);
            tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
            static INSTANCE: SucceedingBehavior;
        }

        declare type SVGNodeTagLower = 'g' | 'rect' | 'circle' | 'line' | 'ellipse' | 'polygon' | 'polyline' | 'image' | 'text' | 'tspan' | 'path' | 'defs' | 'switch';

        declare interface SVGParserOption {
            width?: number;
            height?: number;
            ignoreViewBox?: boolean;
            ignoreRootClip?: boolean;
        }

        declare interface SVGParserResult {
            root: Group;
            width: number;
            height: number;
            viewBoxRect: RectLike;
            viewBoxTransform: {
                x: number;
                y: number;
                scale: number;
            };
            named: SVGParserResultNamedItem[];
        }

        declare interface SVGParserResultNamedItem {
            name: string;
            namedFrom: SVGParserResultNamedItem;
            svgNodeTagLower: SVGNodeTagLower;
            el: Element_2;
        }

        declare class SVGPath extends Path {
            applyTransform(m: MatrixArray): void;
        }

        declare type SVGPathOption = Omit<PathProps, 'shape' | 'buildPath'>;

        declare interface SVGPatternObject extends PatternObjectBase {
            /**
             * svg vnode can only be used in svg renderer currently.
             * svgWidth, svgHeight defines width and height used for pattern.
             */
            svgElement?: SVGVNode;
            svgWidth?: number;
            svgHeight?: number;
        }

        /**
         * Renders an SVG to a canvas.
         * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
         * @param options - options
         *
         * @category SVGs
         */
        export declare const svgToCanvas: (svgDataUrl: string, options: ImageCanvasOptions) => Promise<HTMLCanvasElement>;

        /**
         * Renders an SVG to a png data url.
         * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
         * @param options - options
         *
         * @category SVGs
         */
        export declare const svgToPng: (svgDataUrl: string, options: ImageCanvasOptions) => Promise<string>;

        /**
         * Converts an SVG string to data url. This is useful for creating images from SVGs, or using SVGs in CSS.
         * To use put in template string: `url(${svgUrl\`<svg>...</svg>\`})`
         * @param strings - template strings
         * @param rest - template values
         *
         * @example
         * ```ts
         * const url = svgUrl\`
         *  <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> ... </svg>
         * \`
         * console.log(url) // data:image/svg+xml;charset=UTF-8,...
         * ```
         *
         * @category Template Literals
         */
        export declare const svgUrl: (strings: any, ...rest: any[]) => string;

        declare interface SVGVNode {
            tag: string;
            attrs: SVGVNodeAttrs;
            children?: SVGVNode[];
            text?: string;
            elm?: Node;
            key: string;
        }

        declare type SVGVNodeAttrs = Record<string, string | number | undefined | boolean>;

        /**
         * 符号实体
         */
        export declare class SymbolEntity extends Entity {
            constructor(options: SymbolEntityOptions);
            /**
             * 获取符号对象
             */
            readonly symbolObject: Points;
            /**
             * 更新样式
             */
            updateStyle: (style: SymbolMaterialProps) => void;
            /**
             * 获取数据
             */
            getData: () => SymbolItemData[];
            /**
             * 设置数据
             */
            setData: (data: SymbolItemData[]) => void;
            /**
             * 通过pointIndex获取
             * @param pointIndex 点索引
             * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
             */
            getItemDataByPointIndex: (pointIndex: number, isRefData?: boolean) => SymbolItemData;
            /**
             * 根据同一个实体上的两个射线的交点信息，来决定是否是不同的事件
             */
            isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
        }

        export declare type SymbolEntityOptions = EntityOptions & SymbolModuleOption;

        export declare interface SymbolItemData {
            /** id */
            id?: string;
            /** 位置 */
            position: [number, number, number];
            /** 顶点颜色 */
            color?: ColorRepresentation;
            /** 顶点边框颜色 */
            borderColor?: ColorRepresentation;
            /** 点大小 */
            size?: number;
            /** 高亮顶点颜色, 有高亮颜色时优先用高亮颜色 */
            highlightColor?: ColorRepresentation;
            /** 高亮顶点边框颜色, 有高亮颜色边框颜色时优化用高亮颜色 */
            highlightBorderColor?: ColorRepresentation;
            /** 高亮点大小, 有高亮大小时优化用高亮颜色 */
            highlightSize?: number;
            /** 是否禁止编辑 */
            disableEdit?: boolean;
            /** 是否隐藏 */
            hidden?: boolean;
        }

        export declare interface SymbolMaterialProps extends PointsMaterialParameters {
            /** 边框宽 */
            borderWidth?: number;
            /** 边框颜色 */
            borderColor?: ColorRepresentation;
            /** 透明度随相机距离大小 */
            fadeDistance?: number;
            /** 默认正方形 */
            shape?: "square" | "circle" | "triangle";
            /** 使用顶点大小 */
            vertexSize?: boolean;
            /** 使用顶点边框颜色 */
            vertexBorderColor?: boolean;
        }

        /**
         * 符号symbol模块,用来绘制批量符号点
         */
        export declare class SymbolModule extends EntityModuleBase implements IEntityModuleBase {
            #private;
            static moduleName: string;
            symbol: Points;
            material: PointsMaterial;
            geometry: BufferGeometry;
            _symbolData: SymbolItemData[];
            style: SymbolMaterialProps;
            useBvh: boolean;
            constructor(entity: Entity, options?: SymbolModuleOption);
            get symbolObject(): Points<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
            getData(): SymbolItemData[];
            setData(data?: SymbolItemData[]): void;
            updateStyle(style: SymbolMaterialProps): void;
            /**
             * 通过pointIndex获取
             * @param pointIndex 点索引
             * @param isRefData 返回的是否是数据引用的对象,默认false,将克隆新的数据
             */
            getItemDataByPointIndex(pointIndex: number, isRefData?: boolean): SymbolItemData;
        }

        export declare interface SymbolModuleOption {
            /** 符号数据 */
            data: SymbolItemData[];
            /** 样式 */
            style?: SymbolMaterialProps;
            /** 像素大小拾取 */
            pixelRaycasting?: boolean;
            /**  是否使用bvh射线查询。默认是 */
            useBvh?: boolean;
        }

        export declare const tea: {
            utf8Encode: (str: any) => any;
            utf8Decode: (bs: any, n: any) => any;
            encrypt: (data: any, key: any) => any;
            encryptToBase64: (data: any, key: any) => any;
            encryptToBase64Url: (data: any, key: any) => any;
            decrypt: (data: any, key: any) => any;
            decryptFromBase64: (data: any, key: any) => any;
            decryptFromBase64Url: (data: any, key: any) => any;
        };

        export declare function texImageToCanvas(image: TexImageSource, maxWidth: number, flipY?: boolean): HTMLCanvasElement;

        declare type TextAlign = 'left' | 'center' | 'right';

        export declare interface TextFlowMaterialOptions extends TextStyleProps {
            geometryWidth: number;
            geometryHeight: number;
            flowDirection?: "horizon" | "vertical";
            flowSpeed?: number;
        }

        declare interface TextPositionCalculationResult {
            x: number;
            y: number;
            align: TextAlign;
            verticalAlign: TextVerticalAlign;
        }

        export declare type TextProps = {
            text: string;
            characters?: string;
            color?: number | string;
            fontSize?: number;
            maxWidth?: number;
            lineHeight?: number;
            letterSpacing?: number;
            textAlign?: 'left' | 'right' | 'center' | 'justify';
            font?: string;
            anchorX?: number | 'left' | 'center' | 'right';
            anchorY?: number | 'top' | 'top-baseline' | 'middle' | 'bottom-baseline' | 'bottom';
            clipRect?: [number, number, number, number];
            depthOffset?: number;
            direction?: 'auto' | 'ltr' | 'rtl';
            overflowWrap?: 'normal' | 'break-word';
            whiteSpace?: 'normal' | 'overflowWrap' | 'nowrap';
            outlineWidth?: number | string;
            outlineOffsetX?: number | string;
            outlineOffsetY?: number | string;
            outlineBlur?: number | string;
            outlineColor?: number | string;
            outlineOpacity?: number;
            strokeWidth?: number | string;
            strokeColor?: number | string;
            strokeOpacity?: number;
            fillOpacity?: number;
            sdfGlyphSize?: number;
            debugSDF?: boolean;
            onSync?: (troika: any) => void;
            onPreloadEnd?: () => void;
        };

        declare interface TextProps_2 extends DisplayableProps {
            style?: TextStyleProps;
            zlevel?: number;
            z?: number;
            z2?: number;
            culling?: boolean;
            cursor?: string;
        }

        declare type TextState = Pick<TextProps_2, DisplayableStatePropNames> & ElementCommonState;

        declare interface TextStyleProps extends TextStylePropsPart {
            text?: string;
            x?: number;
            y?: number;
            /**
             * Only support number in the top block.
             */
            width?: number;
            /**
             * Text styles for rich text.
             */
            rich?: Dictionary<TextStylePropsPart>;
            /**
             * Strategy when calculated text width exceeds textWidth.
             * break: break by word
             * break: will break inside the word
             * truncate: truncate the text and show ellipsis
             * Do nothing if not set
             */
            overflow?: 'break' | 'breakAll' | 'truncate' | 'none';
            /**
             * Strategy when text lines exceeds textHeight.
             * Do nothing if not set
             */
            lineOverflow?: 'truncate';
            /**
             * Epllipsis used if text is truncated
             */
            ellipsis?: string;
            /**
             * Placeholder used if text is truncated to empty
             */
            placeholder?: string;
            /**
             * Min characters for truncating
             */
            truncateMinChar?: number;
        }

        declare interface TextStylePropsPart {
            text?: string;
            fill?: string;
            stroke?: string;
            strokeNoScale?: boolean;
            opacity?: number;
            fillOpacity?: number;
            strokeOpacity?: number;
            /**
             * textStroke may be set as some color as a default
             * value in upper applicaion, where the default value
             * of lineWidth should be 0 to make sure that
             * user can choose to do not use text stroke.
             */
            lineWidth?: number;
            lineDash?: false | number[];
            lineDashOffset?: number;
            borderDash?: false | number[];
            borderDashOffset?: number;
            /**
             * If `fontSize` or `fontFamily` exists, `font` will be reset by
             * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
             * So do not visit it directly in upper application (like ),
             * but use `contain/text#makeFont` instead.
             */
            font?: string;
            /**
             * The same as font. Use font please.
             * @deprecated
             */
            textFont?: string;
            /**
             * It helps merging respectively, rather than parsing an entire font string.
             */
            fontStyle?: FontStyle;
            /**
             * It helps merging respectively, rather than parsing an entire font string.
             */
            fontWeight?: FontWeight;
            /**
             * It helps merging respectively, rather than parsing an entire font string.
             */
            fontFamily?: string;
            /**
             * It helps merging respectively, rather than parsing an entire font string.
             * Should be 12 but not '12px'.
             */
            fontSize?: number | string;
            align?: TextAlign;
            verticalAlign?: TextVerticalAlign;
            /**
             * Line height. Default to be text height of '国'
             */
            lineHeight?: number;
            /**
             * Width of text block. Not include padding
             * Used for background, truncate, wrap
             */
            width?: number | string;
            /**
             * Height of text block. Not include padding
             * Used for background, truncate
             */
            height?: number;
            /**
             * Reserved for special functinality, like 'hr'.
             */
            tag?: string;
            textShadowColor?: string;
            textShadowBlur?: number;
            textShadowOffsetX?: number;
            textShadowOffsetY?: number;
            backgroundColor?: string | {
                image: ImageLike | string;
            };
            /**
             * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
             */
            padding?: number | number[];
            /**
             * Margin of label. Used when layouting the label.
             */
            margin?: number;
            borderColor?: string;
            borderWidth?: number;
            borderRadius?: number | number[];
            /**
             * Shadow color for background box.
             */
            shadowColor?: string;
            /**
             * Shadow blur for background box.
             */
            shadowBlur?: number;
            /**
             * Shadow offset x for background box.
             */
            shadowOffsetX?: number;
            /**
             * Shadow offset y for background box.
             */
            shadowOffsetY?: number;
        }

        export declare type TextType = {
            mesh: Mesh;
            updateProps: (newProps: Partial<TextProps>) => void;
            dispose: () => void;
        };

        export declare function textureDataToImageData(imgData: TextureImageData | ImageData | {
            data: Float32Array | Uint16Array | Uint8Array;
            width: number;
            height: number;
        }, colorSpace?: ColorSpace, outData?: ImageData): ImageData;

        export { TextureEffect }

        export declare class TextureSequencer implements Sequencer {
            scaleX: number;
            scaleY: number;
            position: Vector3;
            locations: Vector2[];
            constructor(scaleX?: number, scaleY?: number, position?: Vector3);
            transform(position: Vector3, index: number): void;
            static fromJSON(json: any): Sequencer;
            clone(): Sequencer;
            toJSON(): any;
            fromImage(img: CanvasImageSource, threshold: number): void;
        }

        /**
         *
         * @param texture
         * @param maxWidth
         * @param flipY
         * @param canvas
         */
        export declare function textureToCanvas(texture: Texture | DataTexture, maxWidth: number, flipY?: boolean): HTMLCanvasElement;

        export declare function textureToDataUrl(texture: Texture | DataTexture, maxWidth: number, flipY: boolean, mimeType?: string, quality?: number): string;

        /**
         * Utils for texture creation and manipulation.
         */
        export declare class TextureUtils {
            /**
             * Create a new texture filled with a CSS style.
             *
             * Can be color, gradient or pattern. Supports all options supported in the fillStyle of the canvas API.
             *
             * @param color - Style to apply to the texture surface.
             * @param width - Width of the canvas in pixels.
             * @param height - Height of the canvas in pixels.
             */
            static createFillTexture(color?: (string | CanvasGradient | CanvasPattern), width?: number, height?: number): Texture;
        }

        declare type TextVerticalAlign = 'top' | 'middle' | 'bottom';

        /**
         * Given a THREE.Object3D instance, creates a corresponding CANNON shape.
         */
        export declare const threeToCannon: (object: Object3D, options?: ShapeOptions) => ShapeResult | null;

        declare interface Throttle {
            <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "leading" | "both"): (...args: Args) => Result;
            <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailing"): (...args: Args) => Result | undefined;
            <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailingPromise"): (...args: Args) => Promise<Result>;
        }

        export declare const throttle: Throttle;

        /**
         * Documented 3d-tile state managed by the TilesRenderer* / used/usable in priority / traverseFunctions!
         */
        declare interface Tile extends TileBase {
            parent: Tile;
            /**
             * Hierarchy Depth from the TileGroup
             */
            __depth: number;
            /**
             * The screen space error for this tile
             */
            __error: number;
            /**
             * How far is this tiles bounds from the nearest active Camera.
             * Expected to be filled in during calculateError implementations.
             */
            __distanceFromCamera: number;
            /**
             * This tile is currently active if:
             *  1: Tile content is loaded and ready to be made visible if needed
             */
            __active: boolean;
            /**
             * This tile is currently visible if:
             *  1: Tile content is loaded
             *  2: Tile is within a camera frustum
             *  3: Tile meets the SSE requirements
             */
            __visible: boolean;
            /**
             * Whether or not the tile was visited during the last update run.
             */
            __used: boolean;
            /**
             * Whether or not the tile was within the frustum on the last update run.
             */
            __inFrustum: boolean;
            /**
             * TODO: Document this if it is useful enough to be the default property in the LRU sorting.
             */
            __depthFromRenderedParent: number;
        }

        /**
         * 3d-tiles Tile object per spec:
         * (incomplete, expanding as features become supported by this package.)
         *
         * See spec for full schema: https://github.com/CesiumGS/3d-tiles/blob/master/specification/schema/tile.schema.json
         */
        declare interface TileBase {
            boundingVolume: {
                /**
                 * An array of 12 numbers that define an oriented bounding box. The first three elements define the x, y, and z
                 * values for the center of the box. The next three elements (with indices 3, 4, and 5) define the x axis
                 * direction and half-length. The next three elements (indices 6, 7, and 8) define the y axis direction and
                 * half-length. The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.
                 */
                box?: number[];
                /**
                 * An array of four numbers that define a bounding sphere. The first three elements define the x, y, and z
                 * values for the center of the sphere. The last element (with index 3) defines the radius in meters.
                 */
                sphere?: number[];
            };
            /**
             * The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.
             */
            geometricError: number;
            children?: TileBase[];
            content?: {
                uri: string;
                /**
                 * Dictionary object with content specific extension objects.
                 */
                extensions?: Record<string, any>;
                extras?: Record<string, any>;
                url?: string;
            };
            /**
             * Dictionary object with tile specific extension objects.
             */
            extensions?: Record<string, any>;
            extras?: Record<string, any>;
            refine?: 'REPLACE' | 'ADD';
            transform?: number[];
        }

        declare namespace Tiles3dPluginType {
            export {
                get3dTilesLngLatHeight,
                TileBase,
                Tile,
                Tileset,
                TilesRendererBase,
                TilesGroup,
                TilesRenderer
            }
        }
        export { Tiles3dPluginType }

        /**
         * A 3d-tiles tileset.
         *
         * Schema, see: https://github.com/CesiumGS/3d-tiles/blob/main/specification/schema/tileset.schema.json
         */
        declare interface Tileset {
            /**
             * Metadata about the entire tileset.
             */
            asset: {
                /**
                 * 3d-tiles version
                 */
                version: string;
                /**
                 * Application specific version
                 */
                tilesetVersion?: string;
                /**
                 * Dictionary object with extension-specific objects.
                 */
                extensions?: Record<string, any>;
            };
            /**
             * The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.
             */
            geometricError: Number;
            /**
             * The root tile.
             */
            root: TileBase;
            /**
             * Names of 3D Tiles extensions used somewhere in this tileset.
             */
            extensionsUsed?: string[];
            /**
             * Names of 3D Tiles extensions required to properly load this tileset.
             */
            extensionsRequired?: string[];
            /**
             * A dictionary object of metadata about per-feature properties.
             */
            properties?: Record<string, any>;
            /**
             * Dictionary object with extension-specific objects.
             */
            extensions?: Record<string, any>;
            extras?: Record<string, any>;
        }

        declare class TilesGroup extends Group_2 {
            tilesRenderer: TilesRenderer;
            constructor(tilesRenderer: TilesRenderer);
        }

        declare class TilesRenderer extends TilesRendererBase {
            constructor(url: String, options?: {
                clearRootTransform?: boolean;
            });
            autoDisableRendererCulling: Boolean;
            optimizeRaycast: Boolean;
            manager: LoadingManager;
            group: TilesGroup;
            getBoundingBox(box: Box3): Boolean;
            getOrientedBoundingBox(box: Box3, matrix: Matrix4): Boolean;
            getBoundingSphere(sphere: Sphere): Boolean;
            hasCamera(camera: Camera): Boolean;
            setCamera(camera: Camera): Boolean;
            deleteCamera(camera: Camera): Boolean;
            setResolution(camera: Camera, x: Number, y: Number): Boolean;
            setResolution(camera: Camera, resolution: Vector2): Boolean;
            setResolutionFromRenderer(camera: Camera, renderer: WebGLRenderer): Boolean;
            forEachLoadedModel(callback: (scene: Object3D, tile: Tile) => void): void;
            onLoadTileSet: ((tileSet: Tileset) => void) | null;
            onLoadModel: ((scene: Object3D, tile: Tile) => void) | null;
            onDisposeModel: ((scene: Object3D, tile: Tile) => void) | null;
            onTileVisibilityChange: ((scene: Object3D, tile: Tile, visible: boolean) => void) | null;
            addEventListener(type: String, cb: (e: Object) => void): any;
            hasEventListener(type: String, cb: (e: Object) => void): any;
            removeEventListener(type: String, cb: (e: Object) => void): any;
            dispatchEvent(e: Object): any;
        }

        declare class TilesRendererBase {
            readonly rootTileset: Object | null;
            readonly root: Object | null;
            errorTarget: Number;
            errorThreshold: Number;
            loadSiblings: Boolean;
            displayActiveTiles: Boolean;
            maxDepth: Number;
            stopAtEmptyTiles: Boolean;
            fetchOptions: any;
            /** function to preprocess the url for each individual tile */
            preprocessURL: ((uri: string | URL) => string) | null;
            lruCache: any;
            parseQueue: any;
            downloadQueue: any;
            constructor(url: String);
            update(): void;
            traverse(beforeCb: ((tile: Object, parent: Object, depth: Number) => Boolean) | null, afterCb: ((tile: Object, parent: Object, depth: Number) => Boolean) | null): void;
            dispose(): void;
            resetFailedTiles(): void;
        }

        /**
         * 时间相关.
         */
        export declare class Time {
            private _frameCount;
            private _deltaTime;
            private _actualDeltaTime;
            private _elapsedTime;
            private _actualElapsedTime;
            private _lastSystemTime;
            /** 每帧允许的最大增量时间（秒）. */
            maximumDeltaTime: number;
            /** 时间尺寸比例. */
            timeScale: number;
            get frameCount(): number;
            /**
             * 从上一帧到当前帧的增量时间（秒）.
             *
             * @remarks 当帧速率较低或出现卡顿时， deltaTime 不会超过 maximumDeltaTime * timeScale 的值。
             */
            get deltaTime(): number;
            /**
             * 经过的时间（以秒为单位）.
             */
            get elapsedTime(): number;
            /**
             * 从上一帧到当前帧的实际增量时间（秒）.
             *
             * @remarks 实际增量时间不受 maximumDeltaTime * timeScale 的影响
             */
            get actualDeltaTime(): number;
            /**
             * 实际经过的时间（以秒为单位）.
             */
            get actualElapsedTime(): number;
            /**
             * 构造函数.
             */
            constructor();
        }

        /**
         * Returns a promise that resolves after the given duration. Basically a setTimeout that returns a promise.
         * @param duration - in ms
         *
         * @category Time
         */
        export declare function timeout(duration: number): Promise<unknown>;

        export declare type TLEnterEventHandler = (info: TLEventType, from: string) => void;

        export declare interface TLEventHandler {
            name?: string;
            event?: InteractiveEvent;
            object?: InteractiveObject;
        }

        export declare interface TLEventType extends TLEventHandler {
            /** 交互结束时调用哪个工具栏 */
            onInteractionEnd?: string;
            /** 交互结束时调用哪个工具栏的上下文参数 */
            onInteractionEndContext?: Record<string, any>;
            /** 进入时回调 */
            onEnterCallBack?: (node: StateNode, context: any, from: string) => void;
            /** 退出时回调 */
            onExitCallBack?: (node: StateNode, context: any) => void;
            [key: string]: any;
        }

        /** @public */
        export declare type TLExitEventHandler = (info: TLEventType, to: string) => void;

        /** @public */
        export declare interface TLStateNodeConstructor {
            new (editor: App, parent?: StateNode): StateNode;
            id: string;
            initial?: string;
            children?: () => TLStateNodeConstructor[];
        }

        declare type TLStateNodeType = 'branch' | 'leaf' | 'root';

        /**
         * Modifies the supplied geometry if it is non-indexed, otherwise creates a new, non-indexed geometry. Returns the
         * geometry with smooth normals everywhere except faces that meet at an angle greater than the crease angle.
         *
         * @param geometry The input geometry.
         * @param creaseAngle The crease angle in radians.
         */
        declare function toCreasedNormals(geometry: BufferGeometry, creaseAngle?: number): BufferGeometry;

        /**
         * 几何坐标距离长度转世界坐标距离长度.
         * @param dist 距离值
         * @param isMap2dHeightMeter 是否以米为单位，默认false以地图单位
         * @param app 应用
         * @param mapView
         */
        export declare function toDist(dist: number, isMap2dHeightMeter?: boolean, app?: App, mapView?: MapViewEntity): number;

        declare function toHex(color: string): string;

        export { ToneMappingEffect }

        export { ToneMappingMode }

        export declare class ToolStateModule extends AppModuleBase implements IAppModuleBase {
            static moduleName: string;
            _rootState: StateNode;
            options: ToolStateModuleOptions;
            constructor(app?: App, options?: ToolStateModuleOptions);
            onAwake(): void;
            get rootState(): StateNode;
            /**
             * The editor's current path of active states.
             *
             * @example
             * ```ts
             * app.getStatePath() // "draw.idle"
             * ```
             *
             * @public
             */
            getStatePath(): string;
            /**
             * Get whether a certain tool (or other state node) is currently active.
             *
             * @example
             * ```ts
             * app.stateIsIn('draw')
             * app.stateIsIn('draw.drawpoint')
             * ```
             *
             * @param path - The path of active states, separated by periods.
             *
             * @public
             */
            stateIsIn(path: string): boolean;
            /**
             * Get whether the state node is in any of the given active paths.
             *
             * @example
             * ```ts
             * app.stateInAny('draw', 'pick')
             * app.stateInAny('draw.drawpoint', 'pick.idle')
             * ```
             *
             * @public
             */
            stateInAny(...paths: string[]): boolean;
            /**
             * Set the selected tool.
             *
             * @example
             * ```ts
             * app.setCurrentTool('transform')
             * app.setCurrentTool("draw.drawpolygon", {color: 0xff0000})
             * ```
             *
             * @param id - The id of the tool to select.
             * @param info - Arbitrary data to pass along into the transition.
             *
             * @public
             */
            setCurrentTool(id?: string, info?: Record<string, any>): App;
            /**
             * The current selected tool.
             *
             * @public
             */
            getCurrentTool(): StateNode;
            /**
             * The id of the current selected tool.
             *
             * @public
             */
            getCurrentToolId(): string;
            addTool(Tool: TLStateNodeConstructor): void;
            removeTool(Tool: TLStateNodeConstructor): void;
            /**
             * Get a descendant by its path.
             *
             * @example
             * ```ts
             * app.getStateDescendant('select')
             * app.getStateDescendant('select.brushing')
             * ```
             *
             * @param path - The descendant's path of state ids, separated by periods.
             *
             * @public
             */
            getStateDescendant<T extends StateNode>(path: string): T | undefined;
            /**
             * 判断当前是否有工具处于运行中
             */
            isInActiveTool(): boolean;
            /**
             * 是否正在交互
             */
            isInteracting(): boolean;
            /**
             *  对一个物体进行变换控制器操作
             */
            transformObject(options: TransformEnterOptions): Promise<StateNode>;
            setupUiConfig(): UiObjectConfig;
        }

        export declare interface ToolStateModuleOptions {
            tools?: TLStateNodeConstructor[];
        }

        /**
         * Returns the raw, original object of a Vue-created proxy.
         *
         * `toRaw()` can return the original object from proxies created by
         * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or
         * {@link shallowReadonly()}.
         *
         * This is an escape hatch that can be used to temporarily read without
         * incurring proxy access / tracking overhead or write without triggering
         * changes. It is **not** recommended to hold a persistent reference to the
         * original object. Use with caution.
         *
         * @example
         * ```js
         * const foo = {}
         * const reactiveFoo = reactive(foo)
         *
         * console.log(toRaw(reactiveFoo) === foo) // true
         * ```
         *
         * @param observed - The object for which the "raw" value is requested.
         */
        declare function toRaw<T>(observed: T): T;

        declare type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>;

        /**
         * Used to normalize values / refs / getters into refs.
         *
         * @example
         * ```js
         * // returns existing refs as-is
         * toRef(existingRef)
         *
         * // creates a ref that calls the getter on .value access
         * toRef(() => props.foo)
         *
         * // creates normal refs from non-function values
         * // equivalent to ref(1)
         * toRef(1)
         * ```
         *
         * Can also be used to create a ref for a property on a source reactive object.
         * The created ref is synced with its source property: mutating the source
         * property will update the ref, and vice-versa.
         *
         * @example
         * ```js
         * const state = reactive({
         *   foo: 1,
         *   bar: 2
         * })
         *
         * const fooRef = toRef(state, 'foo')
         *
         * // mutating the ref updates the original
         * fooRef.value++
         * console.log(state.foo) // 2
         *
         * // mutating the original also updates the ref
         * state.foo++
         * console.log(fooRef.value) // 3
         * ```
         *
         * @param source - A getter, an existing ref, a non-function value, or a
         *                 reactive object to create a property ref from.
         * @param [key] - (optional) Name of the property in the reactive object.
         */
        declare function toRef<T>(value: T): T extends () => infer R ? Readonly<Ref<R>> : T extends Ref ? T : Ref<UnwrapRef<T>>;

        declare function toRef<T extends object, K extends keyof T>(object: T, key: K): ToRef<T[K]>;

        declare function toRef<T extends object, K extends keyof T>(object: T, key: K, defaultValue: T[K]): ToRef<Exclude<T[K], undefined>>;

        declare type ToRefs<T = any> = {
            [K in keyof T]: ToRef<T[K]>;
        };

        /**
         * Converts a reactive object to a plain object where each property of the
         * resulting object is a ref pointing to the corresponding property of the
         * original object. Each individual ref is created using {@link toRef()}.
         *
         * @param object - Reactive object to be made into an object of linked refs.
         */
        declare function toRefs<T extends object>(object: T): ToRefs<T>;

        /**
         * Convert a string to title case
         * @param str - The string to convert
         *
         * @category Text
         */
        export declare function toTitleCase(str: string): string;

        declare function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: TrianglesDrawModes): BufferGeometry;

        declare interface Touches {
            one: singleTouchAction;
            two: multiTouchAction;
            three: multiTouchAction;
        }

        /**
         * Normalizes values / refs / getters to values.
         * This is similar to {@link unref()}, except that it also normalizes getters.
         * If the argument is a getter, it will be invoked and its return value will
         * be returned.
         *
         * @example
         * ```js
         * toValue(1) // 1
         * toValue(ref(1)) // 1
         * toValue(() => 1) // 1
         * ```
         *
         * @param source - A getter, an existing ref, or a non-function value.
         */
        declare function toValue<T>(source: MaybeRefOrGetter<T>): T;

        /**
         * 转换为vector3类型
         * @param v 值
         * @returns
         */
        export declare function toVector3(v: Vector3 | [number, number, number] | number): Vector3;

        /**
         * 几何坐标转世界坐标 .
         */
        export declare function toWorld(vec3: [number, number, number?], app?: App, mapView?: MapViewEntity): Vector3;

        export declare type TParams<T> = ValOrFunc<Partial<UiObjectConfig>, [T]>;

        declare class Track {
            keyframes: Keyframe_2[];
            propName: string;
            valType: ValueType;
            discrete: boolean;
            _invalid: boolean;
            private _finished;
            private _needsSort;
            private _additiveTrack;
            private _additiveValue;
            /**
             * Last frame
             */
            private _lastFr;
            /**
             * Percent of last frame.
             */
            private _lastFrP;
            constructor(propName: string);
            isFinished(): boolean;
            setFinished(): void;
            needsAnimate(): boolean;
            getAdditiveTrack(): Track;
            addKeyframe(time: number, rawValue: unknown, easing?: AnimationEasing): Keyframe_2;
            prepare(maxTime: number, additiveTrack?: Track): void;
            step(target: any, percent: number): void;
            private _addToTarget;
        }

        /**
         * Tracks access to a reactive property.
         *
         * This will check which effect is running at the moment and record it as dep
         * which records all effects that depend on the reactive property.
         *
         * @param target - Object holding the reactive property.
         * @param type - Defines the type of access to the reactive property.
         * @param key - Identifier of the reactive property to track.
         */
        declare function track(target: object, type: TrackOpTypes, key: unknown): void;

        /**
         * wasTracked and newTracked maintain the status for several levels of effect
         * tracking recursion. One bit per level is used to define whether the dependency
         * was/is tracked.
         */
        declare interface TrackedMarkers {
            /**
             * wasTracked
             */
            w: number;
            /**
             * newTracked
             */
            n: number;
        }

        declare const enum TrackOpTypes {
            GET = "get",
            HAS = "has",
            ITERATE = "iterate"
        }

        /**
         * A VFX batch that render trails in a batch.
         */
        export declare class TrailBatch extends VFXBatch {
            geometry: BufferGeometry;
            private positionBuffer;
            private previousBuffer;
            private nextBuffer;
            private uvBuffer;
            private sideBuffer;
            private widthBuffer;
            private colorBuffer;
            private indexBuffer;
            constructor(settings: VFXBatchSettings);
            setupBuffers(): void;
            expandBuffers(target: number): void;
            rebuildMaterial(): void;
            vector_: Vector3;
            vector2_: Vector3;
            vector3_: Vector3;
            quaternion_: Quaternion;
            update(): void;
            dispose(): void;
        }

        export declare class TrailLine {
            iconUrl: any;
            _originPositions: any;
            color: any;
            opacity: any;
            lineWidth: any;
            useAlpha: any;
            showLine: any;
            placeLength: any;
            placeSpace: any;
            isAnimate: any;
            speed: any;
            smooth: any;
            uvOffset: number;
            colorArr: any[];
            _map: any;
            positions: any;
            previous: any[];
            next: any[];
            side: any[];
            width: any[];
            indices: any[];
            uvs: any[];
            geometry: any;
            texture: any;
            material: any;
            trail: any;
            options: any;
            /**
             * 宽线箭头
             * @param options
             */
            constructor(options?: any);
            /**
             * 初始化
             * @private
             */
            _init(): void;
            setVisible(bool: any): void;
            start(): void;
            stop(): void;
            compareV3(a: any, b: any): boolean;
            copyV3(a: any): any[];
            _process(): void;
            update(app: App): void;
        }

        /**
         * Particle implementation for trail-based particles.
         */
        export declare class TrailParticle implements Particle {
            /**
             * Parent matrix for transformation.
             * @type {Matrix4}
             */
            parentMatrix?: Matrix4;
            /**
             * Initial speed of the particle.
             * @type {number}
             */
            startSpeed: number;
            /**
             * Initial color of the particle.
             * @type {Vector4}
             */
            startColor: Vector4;
            /**
             * Initial size of the particle.
             * @type {number}
             */
            startSize: number;
            /**
             * Position of the particle.
             * @type {Vector3}
             */
            position: Vector3;
            /**
             * Local position of the particle.
             * @type {Vector3}
             */
            localPosition?: Vector3;
            /**
             * Velocity of the particle.
             * @type {Vector3}
             */
            velocity: Vector3;
            /**
             * Age of the particle.
             * @type {number}
             */
            age: number;
            /**
             * Life duration of the particle.
             * @type {number}
             */
            life: number;
            /**
             * Size of the particle.
             * @type {number}
             */
            size: number;
            /**
             * Length of the trail.
             * @type {number}
             */
            length: number;
            /**
             * Speed modifier of the particle.
             * @type {number}
             */
            speedModifier: number;
            /**
             * Color of the particle.
             * @type {Vector4}
             */
            color: Vector4;
            /**
             * Previous states of the particle.
             * @type {LinkedList<RecordState>}
             */
            previous: LinkedList<RecordState>;
            /**
             * UV tile index.
             * @type {number}
             */
            uvTile: number;
            /**
             * Updates the particle state.
             */
            update(): void;
            /**
             * Indicates if the particle has died.
             * @type {boolean}
             */
            get died(): boolean;
            /**
             * Resets the particle properties and clears the previous states.
             */
            reset(): void;
        }

        export declare interface TrailSettings {
            /**
             * Start length of the trail.
             * @type {ValueGenerator | FunctionValueGenerator}
             */
            startLength: ValueGenerator | FunctionValueGenerator;
            /**
             * Whether to follow the local origin.
             * @type {boolean}
             */
            followLocalOrigin: boolean;
        }

        /**
         * Transformation utilities.
         */
        declare class Transform {
            /**
             * position
             */
            position: Vec3;
            /**
             * quaternion
             */
            quaternion: Quaternion_2;
            constructor(options?: {
                /**
                 * position
                 */
                position?: Vec3;
                /**
                 * quaternion
                 */
                quaternion?: Quaternion_2;
            });
            /**
             * Get a global point in local transform coordinates.
             */
            pointToLocal(worldPoint: Vec3, result?: Vec3): Vec3;
            /**
             * Get a local point in global transform coordinates.
             */
            pointToWorld(localPoint: Vec3, result?: Vec3): Vec3;
            /**
             * vectorToWorldFrame
             */
            vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
            /**
             * pointToLocalFrame
             */
            static pointToLocalFrame(position: Vec3, quaternion: Quaternion_2, worldPoint: Vec3, result?: Vec3): Vec3;
            /**
             * pointToWorldFrame
             */
            static pointToWorldFrame(position: Vec3, quaternion: Quaternion_2, localPoint: Vec3, result?: Vec3): Vec3;
            /**
             * vectorToWorldFrame
             */
            static vectorToWorldFrame(quaternion: Quaternion_2, localVector: Vec3, result?: Vec3): Vec3;
            /**
             * vectorToLocalFrame
             */
            static vectorToLocalFrame(position: Vec3, quaternion: Quaternion_2, worldVector: Vec3, result?: Vec3): Vec3;
        }

        export declare const transform: {
            CRSTypes: typeof CRSTypes;
            convert: typeof convert;
            EpsgCrsTypes: typeof EpsgCrsTypes;
            getEpsgParam: typeof getEpsgParam;
            getEpsgCode: typeof getEpsgCode;
        };

        declare class Transformable {
            parent: Transformable;
            x: number;
            y: number;
            scaleX: number;
            scaleY: number;
            skewX: number;
            skewY: number;
            rotation: number;
            /**
             * Will translated the element to the anchor position before applying other transforms.
             */
            anchorX: number;
            anchorY: number;
            /**
             * Origin of scale, rotation, skew
             */
            originX: number;
            originY: number;
            /**
             * Scale ratio
             */
            globalScaleRatio: number;
            transform: matrix.MatrixArray;
            invTransform: matrix.MatrixArray;
            /**
             * Get computed local transform
             */
            getLocalTransform(m?: matrix.MatrixArray): matrix.MatrixArray;
            /**
             * Set position from array
             */
            setPosition(arr: number[]): void;
            /**
             * Set scale from array
             */
            setScale(arr: number[]): void;
            /**
             * Set skew from array
             */
            setSkew(arr: number[]): void;
            /**
             * Set origin from array
             */
            setOrigin(arr: number[]): void;
            /**
             * If needs to compute transform
             */
            needLocalTransform(): boolean;
            /**
             * Update global transform
             */
            updateTransform(): void;
            private _resolveGlobalScaleRatio;
            /**
             * Get computed global transform
             * NOTE: this method will force update transform on all ancestors.
             * Please be aware of the potential performance cost.
             */
            getComputedTransform(): matrix.MatrixArray;
            setLocalTransform(m: vector.VectorArray): void;
            /**
             * 分解`transform`矩阵到`position`, `rotation`, `scale`
             */
            decomposeTransform(): void;
            /**
             * Get global scale
             */
            getGlobalScale(out?: vector.VectorArray): vector.VectorArray;
            /**
             * 变换坐标位置到 shape 的局部坐标空间
             */
            transformCoordToLocal(x: number, y: number): number[];
            /**
             * 变换局部坐标位置到全局坐标空间
             */
            transformCoordToGlobal(x: number, y: number): number[];
            getLineScale(): number;
            copyTransform(source: Transformable): void;
            static getLocalTransform(target: Transformable, m?: matrix.MatrixArray): matrix.MatrixArray;
            private static initDefaultProps;
        }

        declare const TRANSFORMABLE_PROPS: readonly ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];

        /** 变换控制器 */
        export declare class TransformControls<TCamera extends Camera = Camera> extends Object3D {
            readonly isTransformControls = true;
            visible: boolean;
            private domElement;
            private raycaster;
            private gizmo;
            private plane;
            private tempVector;
            private tempVector2;
            private tempQuaternion;
            private unit;
            private pointStart;
            private pointEnd;
            private offset;
            private rotationAxis;
            private startNorm;
            private endNorm;
            private rotationAngle;
            private cameraPosition;
            private cameraQuaternion;
            private cameraScale;
            private parentPosition;
            private parentQuaternion;
            private parentQuaternionInv;
            private parentScale;
            private worldPositionStart;
            private worldQuaternionStart;
            private worldScaleStart;
            private worldPosition;
            private worldQuaternion;
            private worldQuaternionInv;
            private worldScale;
            private eye;
            private positionStart;
            private quaternionStart;
            private scaleStart;
            private camera;
            private object;
            private enabled;
            private axis;
            private mode;
            private translationSnap;
            private rotationSnap;
            private scaleSnap;
            private space;
            private size;
            private dragging;
            private showX;
            private showY;
            private showZ;
            private changeEvent;
            private mouseDownEvent;
            private mouseUpEvent;
            private objectChangeEvent;
            app: App;
            constructor(camera: TCamera, domElement: HTMLElement | undefined, app?: App);
            private intersectObjectWithRay;
            attach: (object: Object3D) => this;
            detach: () => this;
            reset: () => this;
            updateMatrixWorld: () => void;
            private pointerHover;
            private pointerDown;
            private pointerMove;
            private pointerUp;
            private getPointer;
            private onPointerHover;
            private onPointerDown;
            private onPointerMove;
            private onPointerUp;
            getMode: () => TransformControls['mode'];
            setMode: (mode: TransformControls['mode']) => void;
            setTranslationSnap: (translationSnap: number) => void;
            setRotationSnap: (rotationSnap: number) => void;
            setScaleSnap: (scaleSnap: number) => void;
            setSize: (size: number) => void;
            setSpace: (space: string) => void;
            update: () => void;
            connect: (domElement: HTMLElement) => void;
            dispose: () => void;
        }

        export declare class TransformControlsGizmo extends Object3D {
            private isTransformControlsGizmo;
            type: string;
            private tempVector;
            private tempEuler;
            private alignVector;
            private zeroVector;
            private lookAtMatrix;
            private tempQuaternion;
            private tempQuaternion2;
            private identityQuaternion;
            private unitX;
            private unitY;
            private unitZ;
            private gizmo;
            picker: TransformControlsGizmoPrivateGizmos;
            private helper;
            private rotationAxis;
            private cameraPosition;
            private worldPositionStart;
            private worldQuaternionStart;
            private worldPosition;
            private worldQuaternion;
            private eye;
            private camera;
            private enabled;
            private axis;
            private mode;
            private space;
            private size;
            private dragging;
            private showX;
            private showY;
            private showZ;
            constructor();
            updateMatrixWorld: () => void;
        }

        declare type TransformControlsGizmoPrivateGizmos = {
            ['translate']: Object3D;
            ['scale']: Object3D;
            ['rotate']: Object3D;
            ['visible']: boolean;
        };

        export declare class TransformControlsPlane extends Mesh<PlaneGeometry, MeshBasicMaterial> {
            private isTransformControlsPlane;
            type: string;
            constructor();
            private unitX;
            private unitY;
            private unitZ;
            private tempVector;
            private dirVector;
            private alignVector;
            private tempMatrix;
            private identityQuaternion;
            private cameraQuaternion;
            private worldPosition;
            private worldQuaternion;
            private eye;
            private axis;
            private mode;
            private space;
            updateMatrixWorld: () => void;
        }

        export declare interface TransformControlsPointerObject {
            x: number;
            y: number;
            button: number;
        }

        export declare type TransformedTypes<T> = TransformType<TransformType<T, Color, ColorRepresentation>, Vector3, number>;

        /** 变换控制器工具进入选项 */
        export declare interface TransformEnterOptions extends TLEventType {
            /** 要操作的物体或点坐标 */
            target?: Object3D | Vector3;
            /** 坐标轴 */
            axis?: string | null;
            /** 模式 */
            mode?: 'translate' | 'rotate' | 'scale';
            /** 微调平移值 */
            translationSnap?: number;
            /** 微调旋转值 */
            rotationSnap?: number;
            /** 微调缩放值 */
            scaleSnap?: number;
            /** 坐标空间 */
            space?: 'world' | "local";
            /** 辅助线尺寸大小 */
            size?: number;
            /** 显示x轴, 如果指定了模式的话，则只在此模式下显示 */
            showX?: boolean | ('translate' | 'rotate' | 'scale')[];
            /** 显示y轴, 如果指定了模式的话，则只在此模式下显示 */
            showY?: boolean | ('translate' | 'rotate' | 'scale')[];
            /** 显示z轴, 如果指定了模式的话，则只在此模式下显示 */
            showZ?: boolean | ('translate' | 'rotate' | 'scale')[];
            /** 是否可以按 Q 键切换坐标空间  默认true*/
            pressQKeySwitchSpace?: boolean;
            /** 按 shfit 键时进行微调 默认true*/
            pressShiftKeySnap?: boolean;
            /** 是否可以按 W 键切换平移模式  默认true*/
            pressWKeyModeTranslate?: boolean;
            /** 是否可以按 E 键切换平移模式  默认true*/
            pressEKeyModeRotate?: boolean;
            /** 是否可以按 R 键切换平移模式  默认true*/
            pressRKeyModeScale?: boolean;
            /** 是否可以按 X 键对x轴显示或隐藏  默认true*/
            pressXKeyShowX?: boolean;
            /** 是否可以按 Y 键对x轴显示或隐藏  默认true*/
            pressYKeyShowY?: boolean;
            /** 是否可以按 Z 键对x轴显示或隐藏  默认true*/
            pressZKeyShowZ?: boolean;
            /** 查询条件 */
            queryOptions?: EntityQueryOption;
            /** 没有选中实体时退出编辑 默认true */
            clickNoEntityExit?: boolean;
            /** 点击到其他实体时或没有选中实体退出编辑 默认false */
            clickNoSelfEntityExit?: boolean;
            /** 点击判断是否是其他实体的物体对象，默认为控件关联的对象 */
            clickIsEqualObject?: Object3D | Function;
            /** 点击选中新的实体时自动附加到新实体上 默认true */
            clickEntityAttach?: boolean;
            /** 操作是否加入命令组中用于撤销重做 默认true*/
            editAsCommand?: boolean;
            /** 右键退出编辑 默认false */
            rightClickConfirmExit?: boolean;
            /** 回车或esc退出编辑 默认 true */
            enterEscConfirmExit?: boolean;
            /** 大小 */
            transformSize?: number;
            /** 回调 */
            dragCallBack?: (cb: {
                /** 是否重置 */
                isReset: boolean;
                /** 是否一次操作完成 */
                isOnceFinish: boolean;
                position: Vector3;
                scale: Vector3;
                rotation: Euler;
                deltaPosition: Vector3;
                deltaScale: Vector3;
                oldRotation: Euler;
                /** 命令对象，可以加用于撤销或重做的命令以命令方式加入此中 */
                command?: MultiCmdsCommand;
            }) => void;
        }

        declare type TransformOptions = ConstructorParameters<typeof Transform>[0];

        declare type TransformProp = (typeof TRANSFORMABLE_PROPS)[number];

        /** 变换控制器工具 */
        export declare class TransformTool extends StateNode {
            static id: string;
            static initial: string;
            static children: () => (typeof Idle_3)[];
        }

        export declare type TransformType<T, U, V> = {
            [P in keyof T]: T[P] extends U ? T[P] | V : T[P];
        };

        /**
         * 平移变换
         */
        declare function translate(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;

        /**
         * 遍历每个材质对象
         * @param material
         */
        export declare const traverseMaterial: (material: Mesh | Material | Material[], cb: (material: Material) => any) => any;

        declare interface TreeNode {
            bounds: Box3;
            count: number;
            offset: number;
            left?: TreeNode;
            right?: TreeNode;
        }

        export declare function triangle2dArea(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): number;

        declare class TriangleIntersectData {
            intersects: Object;
            triangle: Triangle;
            constructor(tri: Triangle);
            addTriangle(index: number, tri: Triangle): void;
            getIntersectArray(): Array<Triangle>;
        }

        declare class TriangleIntersectionSets {
            addTriangleIntersection(ia: number, tribA: Triangle, ib: number, triB: Triangle): void;
            getTrianglesAsArray(id?: number): Array<Triangle>;
            getTriangleIndices(): Array<number>;
            getIntersectionIndices(id: number): void;
            getIntersectionsAsArray(id?: number, id2?: number): Array<Triangle>;
        }

        declare class TrianglePool {
            getTriangle(): Triangle;
            clear(): void;
            reset(): void;
        }

        declare class TriangleSetHelper extends Group_2 {
            constructor(triangles?: Triangle[]);
            setTriangles(triangles: Triangle[]): void;
        }

        declare class TriangleSplitter {
            trianglePool: TrianglePool;
            triangles: Triangle[];
            normal: Vector3;
            initialize(tri: Triangle): void;
            splitByTriangle(triangle: Triangle): void;
            splitByPlane(plane: Plane, triangle: Triangle, coplanarIndex: number): void;
            reset(): void;
        }

        export declare function triangulate(vertices: number[], holes: number[], dimensions?: number): number[];

        export declare function triangulatFlatten(data: number[][][]): {
            vertices: any[];
            holes: any[];
            dimensions: any;
        };

        /**
         * Finds all deps associated with the target (or a specific property) and
         * triggers the effects stored within.
         *
         * @param target - The reactive object.
         * @param type - Defines the type of the operation that needs to trigger effects.
         * @param key - Can be used to target a specific reactive property in the target object.
         */
        declare function trigger(target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown): void;

        declare const enum TriggerOpTypes {
            SET = "set",
            ADD = "add",
            DELETE = "delete",
            CLEAR = "clear"
        }

        /**
         * Force trigger effects that depends on a shallow ref. This is typically used
         * after making deep mutations to the inner value of a shallow ref.
         *
         * @example
         * ```js
         * const shallow = shallowRef({
         *   greet: 'Hello, world'
         * })
         *
         * // Logs "Hello, world" once for the first run-through
         * watchEffect(() => {
         *   console.log(shallow.value.greet)
         * })
         *
         * // This won't trigger the effect because the ref is shallow
         * shallow.value.greet = 'Hello, universe'
         *
         * // Logs "Hello, universe"
         * triggerRef(shallow)
         * ```
         *
         * @param ref - The ref whose tied effects shall be executed.
         */
        declare function triggerRef(ref: Ref): void;

        /**
         * @param str string to be trimed
         * @return trimed string
         */
        declare function trim(str: string): string;

        /**
         * Trimesh.
         * @example
         *     // How to make a mesh with a single triangle
         *     const vertices = [
         *         0, 0, 0, // vertex 0
         *         1, 0, 0, // vertex 1
         *         0, 1, 0  // vertex 2
         *     ]
         *     const indices = [
         *         0, 1, 2  // triangle 0
         *     ]
         *     const trimeshShape = new CANNON.Trimesh(vertices, indices)
         */
        declare class Trimesh extends Shape {
            /**
             * vertices
             */
            vertices: Float32Array;
            /**
             * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
             */
            indices: Int16Array;
            /**
             * The normals data.
             */
            normals: Float32Array;
            /**
             * The local AABB of the mesh.
             */
            aabb: AABB;
            /**
             * References to vertex pairs, making up all unique edges in the trimesh.
             */
            edges: Int16Array | null;
            /**
             * Local scaling of the mesh. Use .setScale() to set it.
             */
            scale: Vec3;
            /**
             * The indexed triangles. Use .updateTree() to update it.
             */
            tree: Octree;
            constructor(vertices: number[], indices: number[]);
            /**
             * updateTree
             */
            updateTree(): void;
            /**
             * Get triangles in a local AABB from the trimesh.
             * @param result An array of integers, referencing the queried triangles.
             */
            getTrianglesInAABB(aabb: AABB, result: number[]): number[];
            /**
             * setScale
             */
            setScale(scale: Vec3): void;
            /**
             * Compute the normals of the faces. Will save in the `.normals` array.
             */
            updateNormals(): void;
            /**
             * Update the `.edges` property
             */
            updateEdges(): void;
            /**
             * Get an edge vertex
             * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
             * @param vertexStore Where to store the result
             */
            getEdgeVertex(edgeIndex: number, firstOrSecond: number, vertexStore: Vec3): void;
            /**
             * Get a vector along an edge.
             */
            getEdgeVector(edgeIndex: number, vectorStore: Vec3): void;
            /**
             * Get face normal given 3 vertices
             */
            static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;
            /**
             * Get vertex i.
             * @return The "out" vector object
             */
            getVertex(i: number, out: Vec3): Vec3;
            /**
             * Get raw vertex i
             * @return The "out" vector object
             */
            private _getUnscaledVertex;
            /**
             * Get a vertex from the trimesh,transformed by the given position and quaternion.
             * @return The "out" vector object
             */
            getWorldVertex(i: number, pos: Vec3, quat: Quaternion_2, out: Vec3): Vec3;
            /**
             * Get the three vertices for triangle i.
             */
            getTriangleVertices(i: number, a: Vec3, b: Vec3, c: Vec3): void;
            /**
             * Compute the normal of triangle i.
             * @return The "target" vector object
             */
            getNormal(i: number, target: Vec3): Vec3;
            /**
             * @return The "target" vector object
             */
            calculateLocalInertia(mass: number, target: Vec3): Vec3;
            /**
             * Compute the local AABB for the trimesh
             */
            computeLocalAABB(aabb: AABB): void;
            /**
             * Update the `.aabb` property
             */
            updateAABB(): void;
            /**
             * Will update the `.boundingSphereRadius` property
             */
            updateBoundingSphereRadius(): void;
            /**
             * calculateWorldAABB
             */
            calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
            /**
             * Get approximate volume
             */
            volume(): number;
            /**
             * Create a Trimesh instance, shaped as a torus.
             */
            static createTorus(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number): Trimesh;
        }

        export declare type TrimeshParameters = {
            vertices: Float32Array;
            indices: Uint32Array;
        };

        declare class Trochoid extends Path<TrochoidProps> {
            shape: TrochoidShape;
            constructor(opts?: TrochoidProps);
            getDefaultStyle(): {
                stroke: string;
                fill: string;
            };
            getDefaultShape(): TrochoidShape;
            buildPath(ctx: CanvasRenderingContext2D, shape: TrochoidShape): void;
        }

        declare interface TrochoidProps extends PathProps {
            shape?: Partial<TrochoidShape>;
        }

        declare class TrochoidShape {
            cx: number;
            cy: number;
            r: number;
            r0: number;
            d: number;
            location: string;
        }

        declare class TSpan extends Displayable<TSpanProps> {
            style: TSpanStyleProps;
            hasStroke(): boolean;
            hasFill(): boolean;
            /**
             * Create an image style object with default values in it's prototype.
             * @override
             */
            createStyle(obj?: TSpanStyleProps): TSpanStyleProps;
            /**
             * Set bounding rect calculated from Text
             * For reducing time of calculating bounding rect.
             */
            setBoundingRect(rect: BoundingRect): void;
            getBoundingRect(): BoundingRect;
            protected static initDefaultProps: void;
        }

        declare interface TSpanProps extends DisplayableProps {
            style?: TSpanStyleProps;
        }

        declare type TSpanState = Pick<TSpanProps, DisplayableStatePropNames>;

        declare interface TSpanStyleProps extends PathStyleProps {
            x?: number;
            y?: number;
            text?: string;
            font?: string;
            fontSize?: number;
            fontWeight?: FontWeight;
            fontStyle?: FontStyle;
            fontFamily?: string;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }

        export declare type TUiRefreshModes = 'preRender' | 'postRender' | 'preFrame' | 'postFrame';

        /**
         * TupleDictionary
         */
        declare class TupleDictionary {
            data: {
                [id: string]: any;
                keys: string[];
            };
            /** get */
            get(i: number, j: number): any;
            /** set */
            set(i: number, j: number, value: any): void;
            /** delete */
            delete(i: number, j: number): void;
            /** reset */
            reset(): void;
        }

        /**
         * Apply turbulence to particles.
         */
        export declare class TurbulenceField implements Simulation {
            scale: Vector3;
            octaves: number;
            velocityMultiplier: Vector3;
            timeScale: Vector3;
            type: string;
            generator: SimplexNoise;
            timeOffset: Vector3;
            temp: Vector3;
            temp2: Vector3;
            constructor(scale: Vector3, octaves: number, velocityMultiplier: Vector3, timeScale: Vector3);
            initialize(particle: Particle): void;
            update(particle: Particle, delta: number): void;
            toJSON(): any;
            frameUpdate(delta: number): void;
            static fromJSON(json: any): Simulation;
            clone(): Simulation;
            reset(): void;
        }

        /**
         * A Tween represents a series of actions that can be applied to a target object to create animations or sequences of events.
         * @template T - The type of the target object.
         */
        export declare class Tween<T = any> {
            /** The object to apply the tween to. */
            target: T;
            /** Tags used for filtering and management. */
            tags: string[];
            /** Unique identifier. If specified, the old tween with the same id will be stopped. */
            id: string;
            tweenManager: TweenManager;
            runningTween: RunningTween;
            /**
             * @param target - The object to apply the tween to.
             */
            constructor(target: T, tweenManager?: TweenManager);
            /**
             * 为动画设置一个唯一的标识符。如果指定，则停止具有相同id的旧动画
             * @param id The identifier to assign to the Tween.
             * @returns The updated Tween instance.
             */
            setId(id: string): this;
            /**
             * 为动画设置标签，可用于过滤和管理。
             * @param tags - Tags to associate with the Tween.
             * @returns The updated Tween instance.
             */
            setTags(...tags: string[]): this;
            /**
             * 设置动画的目标对象
             * @param target - The object to apply the tween to.
             * @returns The updated Tween instance.
             */
            setTarget(target: T): this;
            /**
             * 控制补间的运动形式及方向, 当启动时，将读取当前属性值并 应用相对值来找出新的最终值
             * @param time - The duration of the motion in milliseconds.
             * @param action - The motion configuration.
             * @param config - Additional motion configuration options.
             * @returns The updated Tween instance.
             */
            to(time: number, action: Motion<T>, config?: MotionConfig<T>): this;
            /**
             * 定义当前状态的相对运动.
             * @param time - The duration of the motion in milliseconds.
             * @param action - The motion configuration.
             * @param config - Additional motion configuration options.
             * @returns The updated Tween instance.
             */
            by(time: number, action: Motion<T>, config?: MotionConfig<T>): this;
            /**
             * 立即定义从当前状态到新状态的移动。
             * @param action - The motion configuration.
             * @returns The updated Tween instance.
             */
            set(action: Motion<T>): this;
            /**
             * 增加回调函数.
             * @param callback - The callback function to execute.
             * @returns The updated Tween instance.
             */
            call(callback: () => void): this;
            /**
             * 延迟执行动画的方法 .delay() , 接受一个参数用于控制延迟的具体时间，表示延迟多少时间后才开始执行动画
             * @param time - The duration of the delay in milliseconds.
             * @returns The updated Tween instance.
             */
            delay(time: number): this;
            /**
             * 使用该方法可以使动画重复执行，它接受一个参数 , 描述需要重复多少次
             * @param times - The number of times to repeat the action.
             * @returns The updated Tween instance.
             */
            repeat(times?: number): this;
            /**
             * 无限期地重复上一个操作
             * @returns The updated Tween instance.
             */
            repeatForever(): this;
            /**
             * 控制补间重复的模式, ,该动画像悠悠球一样来回运动 , 而不是重新开始
             * @param times - The number of times to yoyo the last action.
             * @returns The updated Tween instance.
             */
            yoyo(times?: number): this;
            /**
             * 对最后一个动作应用溜溜球效果，使其无限期地反转运动。
             * @returns The updated Tween instance.
             */
            yoyoForever(): this;
            /**
             * 链接另一个动画以在该动画之后执行。
             * @param tween - The Tween to chain.
             * @returns The updated Tween instance.
             */
            then(tween: Tween<T>): this;
            /**
             * 并行运行多条
             * @param tweens - The Tweens to run in parallel.
             * @returns The updated Tween instance.
             */
            parallel(...tweens: Tween<T>[]): this;
            /**
             * 按顺序运行多条
             * @param tweens - The Tweens to run in sequence.
             * @returns The updated Tween instance.
             */
            sequence(...tweens: Tween<T>[]): this;
            /**
             * 链式补间动画，当我们顺序排列不同的补间动画时，比如我们在上一个补间结束的时候立即启动另外一个补间动画，使用 .chain() 方法来做。.
             *  @param tween - The Tween containing actions to chain.
             * @returns The updated Tween instance.
             */
            chain(tween: Tween<T>): this;
            /**
             * 克隆动画.
             * @returns A new Tween instance with the same configuration.
             */
            clone(): Tween<T>;
            /**
             * 补间动画启动的方法
             * @returns A RunningTween instance that controls the execution of the Tween.
             */
            start(tweenManager?: TweenManager): RunningTween<T>;
        }

        /**
         * This class is responsible for managing and controlling running tweens.
         */
        export declare class TweenManager {
            private _running;
            private _runningChildren;
            /**
             * Stop the running tween with a specific id.
             * @param id Tween identifier.
             */
            stopById(id: string): void;
            /**
             * Stop all running tweens.
             */
            stopAll(): void;
            /**
             * Stop all running tweens with a specific tag.
             * @param tag - The tag to filter running tweens.
             */
            stopAllByTag(tag: string): void;
            /**
             * Complete all running tweens.
             */
            completeAll(): void;
            /**
             * Complete all running tweens with a specific tag.
             * @param tag - The tag to filter running tweens.
             */
            completeAllByTag(tag: string): void;
        }

        /**
         * Mapping of typed array constructors by name
         * @category ArrayBuffer
         */
        export declare const TYPED_ARRAYS: {
            Int8Array: Int8ArrayConstructor;
            Uint8Array: Uint8ArrayConstructor;
            Uint8ClampedArray: Uint8ClampedArrayConstructor;
            Int16Array: Int16ArrayConstructor;
            Uint16Array: Uint16ArrayConstructor;
            Int32Array: Int32ArrayConstructor;
            Uint32Array: Uint32ArrayConstructor;
            Float32Array: Float32ArrayConstructor;
            Float64Array: Float64ArrayConstructor;
        };

        declare class TypedAttributeData {
            groupAttributes: Object[];
            groupCount: number;
            getType(name: String): string;
            getTotalLength(name: String): number;
            getGroupSet(index?: number): Object;
            getGroupAttrArray(name: string, index?: number): Array<number>;
            initializeArray(name: string, type: string): void;
            clear(): void;
            delete(key: string): void;
            reset(): void;
        }

        export declare function uiButton<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare function uiColor<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare function uiConfig<T = any>(uiType?: string, params?: Partial<UiObjectConfig> & {
            params?: TParams<T>;
            group?: string;
        }): PropertyDecorator;

        export declare interface UiConfigContainer<TValue = any, TType extends string = string> extends IUiConfigContainer<TValue, TType> {
            [id: string]: any;
        }

        export declare class UiConfigMethods {
            protected _renderer: UiConfigRendererBase;
            constructor(_renderer: UiConfigRendererBase);
            getBinding(config: UiObjectConfig): [any, string | number];
            getValue<T>(config: UiObjectConfig<T>): T | undefined;
            dispatchOnChangeSync(config: UiObjectConfig, props: {
                last?: boolean;
                config?: UiObjectConfig;
                configPath?: UiObjectConfig[];
            }, ...args: any[]): void;
            setValue<T>(config: UiObjectConfig<T>, value: T, props: {
                last?: boolean;
                config?: UiObjectConfig;
                configPath?: UiObjectConfig[];
            }, forceOnChange?: boolean): Promise<boolean>;
            dispatchOnChange<T>(config: UiObjectConfig<T>, props: {
                last?: boolean;
                config?: UiObjectConfig;
                configPath?: UiObjectConfig[];
            }): Promise<void>;
            getLabel(config: UiObjectConfig): string;
            getChildren(config: UiObjectConfig): UiObjectConfig[];
            clickButton(config: UiObjectConfig, options?: {
                args: any[];
            }): Promise<void>;
            runAtEvent<T>(config: UiObjectConfig, run: () => T | Promise<T>): Promise<T>;
            initUiConfig(config: UiObjectConfig): void;
        }

        export declare abstract class UiConfigRendererBase<TUiNode = any> extends SimpleEventDispatcher<"preFrame" | "preRender" | "postRender" | "postFrame"> {
            readonly methods: UiConfigMethods;
            readonly config: UiObjectConfig<any, "panel">;
            protected constructor(container?: HTMLElement, autoFrameEvents?: boolean, methods?: UiConfigMethods);
            protected _refreshQueue: Record<TUiRefreshModes, Array<[UiObjectConfig, number, string | undefined]>>;
            private _lastModeTime;
            refreshQueue(mode: TUiRefreshModes): void;
            private _addToRefreshQueue;
            dispose(): void;
            appendChild(config?: UiObjectConfig): void;
            removeChild(config: UiObjectConfig): void;
            refreshRoot(deep?: boolean, mode?: TUiRefreshModes | "immediate", delay?: number): void;
            abstract renderUiConfig(uiConfig: UiObjectConfig): void;
            protected _root?: TUiNode;
            /**
             * Disposes the UI associated with a config, doesn't makes change to the object or its parent.
             * @param config
             * @param performDispose
             */
            disposeUiConfig(config?: UiObjectConfig, performDispose?: boolean): void;
            addToRefreshQueue(mode: TUiRefreshModes | "immediate", uiConfig: UiObjectConfig, deep: boolean, delay: number): void;
            protected abstract _refreshUiConfigObject(config: UiObjectConfig): void;
            protected _createUiContainer(): HTMLDivElement;
            private _flattenUiConfig;
        }

        export declare class UiConfigTypeMap {
            static Map: Map<ObjectConstructor, any[]>;
        }

        export declare function uiContainer(label: string, params?: any, type?: string): <T extends new (...args: any[]) => any>(constructor: T) => {
            new (...args: any[]): {
                [x: string]: any;
                uiConfig: UiObjectConfig<any, string, any>;
            };
        } & T;

        export declare function uiDropdown<T = any>(label?: string, children?: UiObjectConfig[], params?: TParams<T>): PropertyDecorator;

        export declare function uiFolderContainer(label: string, params?: any): <T extends new (...args: any[]) => any>(constructor: T) => {
            new (...args: any[]): {
                [x: string]: any;
                uiConfig: UiObjectConfig<any, string, any>;
            };
        } & T;

        export declare function uiImage<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare function uiInput<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare class UiModule extends AppModuleBase implements IAppModuleBase {
            static moduleName: string;
            _controls: Array<IControl>;
            _controlContainer: HTMLElement;
            _controlPositions: Record<string, HTMLElement>;
            options: UiModuleOptions;
            configPane?: any;
            constructor(app?: App, options?: UiModuleOptions);
            onAwake(): void;
            /**
             * 设置光标
             * @param cur 光标名称
             */
            setCursor(cur: string): void;
            setControlMargin(opts: ControlMarginOptions): void;
            /**
             * 增加控件 (会调用 `control.onAdd(this)` ).
             *
             * @param control 需要增加的控件.
             * @param {string} [position] 位置. 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
             */
            addControl(control: IControl, position?: ControlPosition): App;
            /**
             * 移除控件.
             *
             * @param {IControl} control 要移除的控件.

             */
            removeControl(control: IControl): App;
            /**
             * 是否有控件.
             *
             * @param {IControl} control 要查询的控件.
             */
            hasControl(control: IControl): boolean;
            getConfigPane(opts?: {
                /** 是否清空，默认是 */
                isReset?: boolean;
                /** 标题 */
                title?: string;
                /** 样式 */
                style?: Partial<CSSStyleDeclaration>;
            }): Promise<{
                configPane: any;
                rootPane: any;
                element: HTMLElement;
                isInit: boolean;
                setVisible: (b: any) => "" | "none";
                isVisible: () => boolean;
                reset: () => void;
                appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
                renderUiConfig: (uiConfig: UiObjectConfig) => any;
                renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
                uiRefresh(deep?: boolean, mode?: TUiRefreshModes | 'immediate', delay?: number): any;
            }>;
            /**
             * 信息弹窗提示
             * - text（必填）：需要输出的文本
             * - type（可选）：输出类型 默认是 "log"
             * - time（可选）：停留时间 默认是 2500
             */
            logInfo(text: string, type?: logInfoType | number, time?: number): void;
            setupUiConfig(): UiObjectConfig;
        }

        export declare interface UiModuleOptions {
            /** 控件参数 */
            control?: ControlMarginOptions;
            /** 设置面板参数 */
            configPane?: {
                /** 父容器，默认body */
                container?: HTMLElement;
                /** 展表，默认true */
                expanded?: boolean;
                /** 默认true */
                autoPostFrame?: boolean;
                /** 样式 */
                style?: Partial<CSSStyleDeclaration>;
                /** 标题 */
                title?: string;
            };
        }

        export declare function uiMonitor<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare function uiNumber<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare interface UiObjectConfig<T = any, TType extends UiObjectType = UiObjectType, TTarget = any> {
            app?: App;
            /**
             * An optional uuid to identify this object. If not provided, one will be generated during first render.
             * This must be provided if a new UiObjectConfig object is generated each time the config is rendered.
             */
            uuid?: string;
            /**
             * The type of the object. This is used to determine the component to use.
             * Examples: 'button', 'slider', 'dropdown', 'folder', 'input' etc
             */
            type?: TType;
            /**
             * The label to use for the object. This is used as the title for folders, and as the label for inputs.
             * This can be a string or a function that returns a string.
             * If not provided, the label will be determined automatically, by the key of the property or sets to defaults
             */
            label?: ValOrFunc<string>;
            /**
             * Children of this object. This is used for folders and dropdowns.
             * This can be an array of UiObjectConfig objects, or an array of functions that returns an array of UiObjectConfig objects.
             */
            children?: Array<UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>>;
            /**
             * The property to bind to. This is used for inputs.
             * This can be an array of [target, key] or a function that returns an array of [target, key].
             * key can be a number for arrays.
             */
            property?: ValOrFunc<[TTarget, StringKeyOf<TTarget> | number]>;
            /**
             * Alias for property
             */
            binding?: ValOrFunc<[TTarget, StringKeyOf<TTarget>]>;
            /**
             * The value of the object. This is used for inputs, if property is not provided.
             */
            value?: T;
            /**
             * getValue function. This is used for inputs, if property, value is not specified.
             * This is called to get the value of the input on each render/update.
             */
            getValue?: () => T;
            /**
             * setValue function. This is used for inputs, if property, value is not specified.
             * This is called when the value of the input changes.
             * @param value - The value to set
             * @param args - other arguments like the config, renderer, etc. See source code for details.
             */
            setValue?: (value: T, ...args: ChangeArgs) => void;
            /**
             * The Ui element will be hidden if this is true.
             * This can be a boolean or a function that returns a boolean.
             */
            hidden?: ValOrFunc<boolean>;
            /**
             * The Ui input will be disabled if this is true, i.e. the user will not be able to change the value.
             * This can be a boolean or a function that returns a boolean.
             */
            disabled?: ValOrFunc<boolean>;
            /**
             * The Ui input will be read-only if this is true, i.e. the user will not be able to change the value.
             * This can be a boolean or a function that returns a boolean.
             * This can also be achieved by setting specifying a getValue function, but not a setValue function. Or by setting disabled to true.
             */
            readOnly?: ValOrFunc<boolean>;
            /**
             * tags can be added to the config object to be used for filtering, like rendering only objects with a certain tag.
             * This can be a string or an array of strings.
             */
            tags?: ValOrArr<string>;
            /**
             * onChange callbacks can be added to the config object to be called when the value of the object changes.
             * This can be a function or an array of functions.
             */
            onChange?: ValOrArrOp<((...args: ChangeArgs) => void)>;
            /**
             * A function to be called when the Ui element is clicked.
             * Only for buttons. This is an alias of config.value or config.property for buttons.
             * @param args
             */
            onClick?: (...args: any[]) => void;
            /**
             * bounds for the value of the object. This is used for numeric inputs like number and sliders.
             * This can be an array of [min, max] or a function that returns an array of [min, max].
             */
            bounds?: ValOrFunc<number[]>;
            /**
             * stepSize for specifying the min change in the value. This is used for numeric inputs like number and slider.
             * The value will be rounded to the nearest multiple of stepSize.
             * This can be a number or a function that returns a number.
             */
            stepSize?: ValOrFunc<number>;
            /**
             * Only for folders. The Ui element will be expanded if this is true.
             * This can be a boolean or a function that returns a boolean.
             * If this is not set to a function, config.expanded can be read to get the current state.
             */
            expanded?: ValOrFunc<boolean>;
            /**
             * Only for folders. The callback called when a folder is expanded or collapsed.
             * @param c
             */
            onExpand?: (c: UiObjectConfig) => void;
            /**
             * Only for elements with inline picker support
             * This can be a boolean or a function that returns a boolean.
             */
            inlinePicker?: ValOrFunc<boolean>;
            /**
             * Extra HTMLElements to be added to the UI element. This is used for customizing the UI.
             * This can be an array of HTMLElement or a function that returns an array of HTMLElement.
             */
            domChildren?: HTMLElement[] | (() => HTMLElement[]);
            /**
             * After initial rendering, config.uiRef will be set to the instance of the UI component that's created.
             * The type of this will depend on the type of the component and the base UI library used.
             * This can be used to access the UI component directly, for example to add event listeners. Note that the uiRef might change on render.
             */
            uiRef?: any;
            /**
             * The type of the UI component that's referenced by config.uiRef. This is set during rendering and used to re-render the UI if config.type changes.
             */
            uiRefType?: UiObjectType;
            /**
             * After initial rendering, config.uiRefresh will be set to a function that can be used to re-render the UI.
             * @param deep - If true, the UI will be re-rendered recursively, otherwise only the current object will be re-rendered.
             * @param mode - The mode to re-render in. See TUiRefreshModes for details. Use when syncing with custom render loop
             * @param delay - The delay in ms to wait before re-rendering. This is useful if multiple changes are made in quick succession. If another refresh event is in the queue for the same object, it will be postponed by this amount. This is not exact for small values.
             */
            uiRefresh?: (deep?: boolean, mode?: TUiRefreshModes | 'immediate', delay?: number) => void;
            dispatchMode?: TUiRefreshModes | 'immediate';
            /**
             * Individual components can support custom options. These can be added to the config object.
             */
            [id: string]: any;
        }

        export declare type UiObjectType = string;

        export declare function uiPanelContainer(label: string, params?: any): <T extends new (...args: any[]) => any>(constructor: T) => {
            new (...args: any[]): {
                [x: string]: any;
                uiConfig: UiObjectConfig<any, string, any>;
            };
        } & T;

        export declare class UiPanelJsonConfig {
            children: (Controller | UiPanelJsonConfig)[];
            isFolder?: boolean;
            title?: string;
            expanded?: boolean;
            hidden?: boolean;
            constructor();
            /**
             * Adds a controller to the GUI, inferring controller type using the `typeof` operator.
             * @example
             * gui.add( object, 'property' );
             * gui.add( object, 'number', 0, 100, 1 );
             * gui.add( object, 'options', [ 1, 2, 3 ] );
             *
             * @param {object} object The object the controller will modify.
             * @param {string} property Name of the property to control.
             * @param {number|object|Array} [values] Minimum value for number controllers, or the set of
             * selectable values for a dropdown.
             * @param {number} [max] Maximum value for number controllers.
             * @param {number} [step] Step value for number controllers.
             * @returns {Controller}
             */
            add(object: object, property: string, values?: number | object | any[], max?: number, step?: number): Controller;
            addBinding(object: object, property: string, opt_params?: {
                min?: number;
                max?: number;
                step?: number;
                label?: string;
                type?: string;
                view?: string;
                options?: any[] | object;
            }): Controller;
            /**
             * Adds a color controller to the GUI.
             * @example
             * params = {
             * 	cssColor: '#ff00ff',
             * 	rgbColor: { r: 0, g: 0.2, b: 0.4 },
             * 	customRange: [ 0, 127, 255 ],
             * };
             *
             * gui.addColor( params, 'cssColor' );
             * gui.addColor( params, 'rgbColor' );
             * gui.addColor( params, 'customRange', 255 );
             *
             * @param {object} object The object the controller will modify.
             * @param {string} property Name of the property to control.
             * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may
             * need to set this to 255 if your colors are too bright.
             * @returns {Controller}
             */
            addColor(object: object, property: string): Controller;
            /**
             * Adds a folder to the GUI, which is just another GUI. This method returns
             * the nested GUI so you can add controllers to it.
             * @example
             * const folder = gui.addFolder( 'Position' );
             * folder.add( position, 'x' );
             * folder.add( position, 'y' );
             * folder.add( position, 'z' );
             *
             * @param {string} title Name to display in the folder's title bar.
             */
            addFolder(title: string | {
                title: string;
                expanded?: boolean;
            }): UiPanelJsonConfig;
            /**
             * 增加一个按钮
             * @example
             * gui.addButton( "测试", () => console.log(1) );
             *
             * @param {string} title Name to display in the folder's title bar.
             */
            addButton(title: string, cb: Function): Controller;
            /**
             * 增加一个函数
             */
            addFunction(cb: Function): void;
            /**
             * Opens a GUI or folder. GUI and folders are open by default.
             * @param {boolean} open Pass false to close
             * @returns {this}
             * @example
             * gui.open(); // open
             * gui.open( false ); // close
             * gui.open( gui._closed ); // toggle
             */
            open(open?: boolean): this;
            /**
             * Shows the GUI after it's been hidden.
             * @param {boolean} show
             * @returns {this}
             * @example
             * gui.show();
             * gui.show( false ); // hide
             * gui.show( gui._hidden ); // toggle
             */
            show(show?: boolean): this;
            toJson(): any;
        }

        export declare function uiSlider<T = any>(label?: string, bounds?: [number, number], stepSize?: number, params?: TParams<T>): PropertyDecorator;

        export declare function uiToggle<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

        export declare function uiVector<T = any>(label?: string, bounds?: [number, number], stepSize?: number, params?: TParams<T>): PropertyDecorator;

        export declare type Uniform = {
            [key: string]: IUniform<any>;
        };

        declare type UniformMap = {
            [uniform: string]: IUniform<any>;
        };

        declare type UniformProps = {
            [name: string]: UniformValue;
        };

        declare type UniformValue = CubeTexture | Texture | Int32Array | Float32Array | Matrix4 | Matrix3 | Quaternion | Vector4 | Vector3 | Vector2 | Color | number | boolean | Array<any> | null;

        declare type UninitializedUniform<Value> = {
            value: Value | null;
        };

        /**
         * Units utils contains methods to convert data between representations.
         *
         * Multiple methods are used to reprent world coordinates based on the type of data being presented.
         *
         * WGS84 is the most commonly used representation with (latitude, longitude, altitude).
         *
         * EPSG:900913 is used for planar coordinates in (X, Y, Z)
         */
        export declare class UnitsUtils {
            static EARTH_RADIUS: number;
            /**
             * Earth equator perimeter in meters.
             */
            static EARTH_PERIMETER: number;
            /**
             * Earth equator perimeter in meters.
             */
            static EARTH_ORIGIN: number;
            /**
             * Converts coordinates from WGS84 Datum to XY in Spherical Mercator EPSG:900913.
             *
             * @param latitude - Latitude value in degrees.
             * @param longitude - Longitude value in degrees.
             */
            /**
             * Converts XY point from Spherical Mercator EPSG:900913 to WGS84 Datum.
             *
             * @param x - X coordinate.
             * @param y - Y coordinate.
             */
            /**
             * Converts quad tree zoom/x/y to lat/lon in WGS84 Datum.
             *
             * The X and Y start from 0 from the top/left corner of the quadtree up to (4^zoom - 1)
             *
             * @param zoom - Zoom level of the quad tree.
             * @param x - X coordinate.
             * @param y - Y coordinate.
             */
            /**
             * Direction vector to WGS84 coordinates.
             *
             * Can be used to transform surface points of world sphere to coordinates.
             *
             * @param dir - Direction vector.
             * @returns WGS84 coordinates.
             */
            /**
             * Get a direction vector from WGS84 coordinates.
             *
             * The vector obtained will be normalized.
             *
             * @param latitude - Latitude value in degrees.
             * @param longitude - Longitude value in degrees.
             * @returns Direction vector normalized.
             */
            /**
             * Get altitude from RGB color for mapbox altitude encoding
             *
             * https://docs.mapbox.com/data/tilesets/guides/access-elevation-data/~
             *
             * @param color - Color of the pixel
             * @returns The altitude encoded in meters.
             */
            static mapboxAltitude(color: Color): number;
        }

        export declare function unloadParticlePlugin(pluginId: string): void;

        /**
         * 投影参数选项
         * number 深度 (-1近裁剪面 到 1 远裁剪面)
         * boolean undefined根据地图配置决定， false 不用场景数据, true用场景数据
         * Plane 默认xz平面 地图模式xy平面
         * Vector3 点所在的屏幕垂直与相机的平面
         * Object3D[] 指定实体数组
         * object 指定实体数组 或同时指定包含或过滤的实体
         */
        export declare type UnProjectOpts = number | Plane | Vector3 | boolean | Object3D[] | {
            include?: Object3D[];
            exclude: Object3D[];
        };

        /**
         * Returns the inner value if the argument is a ref, otherwise return the
         * argument itself. This is a sugar function for
         * `val = isRef(val) ? val.value : val`.
         *
         * @example
         * ```js
         * function useFoo(x: number | Ref<number>) {
         *   const unwrapped = unref(x)
         *   // unwrapped is guaranteed to be number now
         * }
         * ```
         *
         * @param ref - Ref or plain value to be converted into the plain value.
         */
        declare function unref<T>(ref: MaybeRef<T>): T;

        declare type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>;

        declare type UnwrapRef<T> = T extends ShallowRef<infer V> ? V : T extends Ref<infer V> ? UnwrapRefSimple<V> : UnwrapRefSimple<T>;

        declare type UnwrapRefSimple<T> = T extends Function | CollectionTypes | BaseTypes | Ref | RefUnwrapBailTypes[keyof RefUnwrapBailTypes] | {
            [RawSymbol]?: true;
        } ? T : T extends readonly any[] ? {
            [K in keyof T]: UnwrapRefSimple<T[K]>;
        } : T extends object & {
            [ShallowReactiveMarker]?: never;
        } ? {
            [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>;
        } : T;

        /**
         * Updates the bit at the given position to the given value.
         * @param number - the number to update
         * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
         * @param bitValue - 0 or 1
         */
        export declare function updateBit(number: number, bitPosition: number, bitValue: number): number;

        export declare class UpdateValueCommand<T extends IHasUpdate, K extends keyof T> extends BaseCommand {
            private object;
            private attributeName;
            private newValue;
            private oldValue;
            constructor(object: T, attributeName: K, newValue: T[K], oldValue?: T[K]);
            execute(): void;
            undo(): void;
            redo(): void;
        }

        /**
         * Prompt the user to select a file or directory in the browser.
         * @param multiple - allow multiple files
         * @param directory - allow directory
         * @param accept - file types to accept (default: all), e.g. 'image/*'
         * @category Browser
         */
        export declare function uploadFile(multiple?: boolean, directory?: boolean, accept?: string): Promise<File[]>;

        /** 选择一个文件获取内容 */
        export declare function uploadFileGetContent(accept?: string, asBlob?: number): Promise<any>;

        export declare function useFBO(
        /** Width in pixels */
        width?: number, 
        /** Height in pixels */
        height?: number, 
        /**Settings */
        settings?: FBOSettings): WebGLRenderTarget;

        declare function validateBounds(bvh: MeshBVH): boolean;

        /**
         * Type for a value of type T or an array of values of type T
         */
        export declare type ValOrArr<T> = T | T[];

        /**
         * Type for a value of type `T|undefined` or an array of values of type `T|undefined`
         */
        export declare type ValOrArrOp<T> = ValOrArr<T | undefined>;

        /**
         * Type for a value of type T or a function that returns a value of type T
         */
        export declare type ValOrFunc<T, TArgs extends any[] = any[]> = T | Fof<T, TArgs>;

        export declare interface ValueGenerator {
            type: 'value';
            genValue(): number;
            toJSON(): FunctionJSON;
            clone(): ValueGenerator;
        }

        export declare function ValueGeneratorFromJSON(json: FunctionJSON): FunctionValueGenerator | ValueGenerator;

        declare type ValueType = 0 | 1 | 2 | 3 | 4 | 5 | 6;

        /**
         * @description 绘制变径管道 curve, radiusArr, 20, valuesArr, mapValuesArr, LUT
         * @param curve <CatmullRomCurve3>  轨迹
         * @param radiusArr <Array> [['井深'<Number>,'半径'<Number>]...] 半径数组,
         * @param radialSegments <Number> 管道截面分段数 默认8
         * @param valuesArr <Array> ['值域最小值'<Number>,'值域最大值'<Number>] 半径值域,
         * @param mapValuesArr <Array>  ['映射最小值'<Number>,'映射最大值'<Number>] 半径值域映射
         * @param LUT <Lut> 根据半径给顶点上色
         */
        export declare class VariableTubeGeometry extends BufferGeometry {
            constructor(path: CatmullRomCurve3, radiusArr: [number, number][], radialSegments?: number, valuesArr?: number[], mapValuesArr?: number[], lut?: Lut);
        }

        /**
         * 3-dimensional vector
         * @example
         *     const v = new Vec3(1, 2, 3)
         *     console.log('x=' + v.x) // x=1
         */
        declare class Vec3 {
            x: number;
            y: number;
            z: number;
            static ZERO: Vec3;
            static UNIT_X: Vec3;
            static UNIT_Y: Vec3;
            static UNIT_Z: Vec3;
            constructor(x?: number, y?: number, z?: number);
            /**
             * Vector cross product
             * @param target Optional target to save in.
             */
            cross(vector: Vec3, target?: Vec3): Vec3;
            /**
             * Set the vectors' 3 elements
             */
            set(x: number, y: number, z: number): Vec3;
            /**
             * Set all components of the vector to zero.
             */
            setZero(): void;
            /**
             * Vector addition
             */
            vadd(vector: Vec3): Vec3;
            vadd(vector: Vec3, target: Vec3): void;
            /**
             * Vector subtraction
             * @param target Optional target to save in.
             */
            vsub(vector: Vec3): Vec3;
            vsub(vector: Vec3, target: Vec3): void;
            /**
             * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
             *
             * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
             */
            crossmat(): Mat3;
            /**
             * Normalize the vector. Note that this changes the values in the vector.

             * @return Returns the norm of the vector
             */
            normalize(): number;
            /**
             * Get the version of this vector that is of length 1.
             * @param target Optional target to save in
             * @return Returns the unit vector
             */
            unit(target?: Vec3): Vec3;
            /**
             * Get the length of the vector
             */
            length(): number;
            /**
             * Get the squared length of the vector.
             */
            lengthSquared(): number;
            /**
             * Get distance from this point to another point
             */
            distanceTo(p: Vec3): number;
            /**
             * Get squared distance from this point to another point
             */
            distanceSquared(p: Vec3): number;
            /**
             * Multiply all the components of the vector with a scalar.
             * @param target The vector to save the result in.
             */
            scale(scalar: number, target?: Vec3): Vec3;
            /**
             * Multiply the vector with an other vector, component-wise.
             * @param target The vector to save the result in.
             */
            vmul(vector: Vec3, target?: Vec3): Vec3;
            /**
             * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
             * @param target The vector to save the result in.
             */
            addScaledVector(scalar: number, vector: Vec3, target?: Vec3): Vec3;
            /**
             * Calculate dot product
             * @param vector
             */
            dot(vector: Vec3): number;
            isZero(): boolean;
            /**
             * Make the vector point in the opposite direction.
             * @param target Optional target to save in
             */
            negate(target?: Vec3): Vec3;
            /**
             * Compute two artificial tangents to the vector
             * @param t1 Vector object to save the first tangent in
             * @param t2 Vector object to save the second tangent in
             */
            tangents(t1: Vec3, t2: Vec3): void;
            /**
             * Converts to a more readable format
             */
            toString(): string;
            /**
             * Converts to an array
             */
            toArray(): [number, number, number];
            /**
             * Copies value of source to this vector.
             */
            copy(vector: Vec3): Vec3;
            /**
             * Do a linear interpolation between two vectors
             * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
             */
            lerp(vector: Vec3, t: number, target: Vec3): void;
            /**
             * Check if a vector equals is almost equal to another one.
             */
            almostEquals(vector: Vec3, precision?: number): boolean;
            /**
             * Check if a vector is almost zero
             */
            almostZero(precision?: number): boolean;
            /**
             * Check if the vector is anti-parallel to another vector.
             * @param precision Set to zero for exact comparisons
             */
            isAntiparallelTo(vector: Vec3, precision?: number): boolean;
            /**
             * Clone the vector
             */
            clone(): Vec3;
        }

        /**
         * Vec3Pool
         */
        declare class Vec3Pool extends Pool {
            type: typeof Vec3;
            /**
             * Construct a vector
             */
            constructObject(): Vec3;
        }

        declare namespace vector {
            export {
                create_2 as create,
                copy_2 as copy,
                clone_2 as clone,
                set,
                add,
                scaleAndAdd,
                sub,
                len,
                lenSquare,
                mul_2 as mul,
                div,
                dot,
                scale_2 as scale,
                normalize,
                distance,
                distanceSquare,
                negate,
                lerp_2 as lerp,
                applyTransform,
                min,
                max,
                VectorArray,
                length_2 as length,
                lengthSquare,
                dist,
                distSquare
            }
        }

        declare type VectorArray = number[];

        /**
         * Base class for VFX batches.
         */
        export declare abstract class VFXBatch extends Mesh {
            type: string;
            systems: Set<IParticleSystem>;
            material: ShaderMaterial;
            settings: StoredBatchSettings;
            protected maxParticles: any;
            protected constructor(settings: VFXBatchSettings);
            addSystem(system: IParticleSystem): void;
            removeSystem(system: IParticleSystem): void;
            applyDepthTexture(depthTexture: Texture | null): void;
            abstract setupBuffers(): void;
            abstract expandBuffers(target: number): void;
            abstract rebuildMaterial(): void;
            abstract update(): void;
            abstract dispose(): void;
        }

        /**
         * the settings for rendering a batch of VFX system.
         */
        export declare interface VFXBatchSettings {
            /**
             * Geometry for instancing.
             * @type {BufferGeometry}
             */
            instancingGeometry: BufferGeometry;
            /**
             * Material for rendering.
             * @type {Material}
             */
            material: Material;
            /**
             * Number of horizontal tiles in the texture.
             * @type {number}
             */
            uTileCount: number;
            /**
             * Number of vertical tiles in the texture.
             * @type {number}
             */
            vTileCount: number;
            /**
             * Whether to blend tiles.
             * @type {boolean}
             */
            blendTiles: boolean;
            /**
             * Enable soft particles.
             * @type {boolean}
             */
            softParticles: boolean;
            /**
             * Near fade distance for soft particles.
             * @type {number}
             */
            softNearFade: number;
            /**
             * Far fade distance for soft particles.
             * @type {number}
             */
            softFarFade: number;
            /**
             * Render mode.
             * @type {RenderMode}
             */
            renderMode: RenderMode;
            /**
             * Render order.
             * @type {number}
             */
            renderOrder: number;
            /**
             * layers control visibility of the object.
             * @type {Layers}
             * @see {@link https://threejs.org/docs/index.html#api/en/core/Layers | Official Documentation}
             * @see {@link https://github.com/mrdoob/three.js/blob/master/src/core/Layers.js | Source}
             */
            layers: Layers;
        }

        export declare interface VFXParameters {
            autoDestroy?: boolean;
            looping?: boolean;
            prewarm?: boolean;
            duration?: number;
            emissionGraph: NodeGraph;
            updateGraph: NodeGraph;
            instancingGeometry?: BufferGeometry;
            renderMode?: RenderMode;
            rendererEmitterSettings?: TrailSettings | MeshSettings | BillBoardSettings;
            speedFactor?: number;
            material: Material;
            layers?: Layers;
            renderOrder?: number;
            worldSpace?: boolean;
        }

        declare class VideoLoader extends Loader {
            static autoplay: boolean;
            static preload: "" | "none" | "metadata" | "auto";
            static muted: boolean;
            static loop: boolean;
            constructor(manager?: LoadingManager);
            load(url: string, onLoad?: (video: HTMLVideoElement) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: string | Event) => void): HTMLVideoElement;
        }

        export declare class ViewHelper extends Object3D {
            isViewHelper: boolean;
            animating: boolean;
            center: Vector3;
            viewSize: number;
            render: (renderer: any) => void;
            dispose: () => void;
            handleClick: (event: any) => Promise<boolean>;
            container: HTMLElement;
            constructor(app: App, position?: "leftTop" | "rightTop" | "leftBottom" | "rightBottom", size?: number);
        }

        declare namespace vjmap3d {
            export {
                computeBoundsTree,
                disposeBoundsTree,
                acceleratedRaycast,
                SMAAEffect,
                EdgeDetectionMode,
                FXAAEffect,
                KernelSize,
                PredicationMode,
                SMAAPreset,
                BloomEffect,
                KawaseBlurPass,
                ToneMappingEffect,
                ToneMappingMode,
                DepthOfFieldEffect,
                ChromaticAberrationEffect,
                GlitchEffect,
                GlitchMode,
                GodRaysEffect,
                PixelationEffect,
                SSAOEffect,
                NormalPass,
                OverrideMaterialManager,
                EffectComposer,
                DotScreenEffect,
                DepthPickingPass,
                TextureEffect,
                Effect,
                ColorDepthEffect,
                CopyPass,
                DepthPass,
                BlendFunction,
                ShaderPass,
                EffectAttribute,
                EffectPass,
                OutlineEffect,
                RenderPass,
                Pass,
                SelectiveBloomEffect,
                reactivity,
                render2d,
                __buildDate,
                __buildVersion,
                __buildVerNo,
                __DEV,
                deleteArrItem,
                generateUUID,
                cloneDeep,
                pick,
                bindAll,
                extend,
                strMd5,
                sleep,
                pushObjectStatus,
                throttle,
                debounce,
                applyMixins,
                BidirectionalMap,
                isObjectBehindCamera,
                cameraDistance2NdcZ,
                isObjectOcclude,
                addResourceRefCount,
                disposeObject3D,
                containSkeleton,
                objectTransformToMatrix,
                getBoundingBox,
                getObjectAnchorPoint,
                disableRayQuery,
                disableSelected,
                disableBloom,
                disableOutline,
                disableBloomSelectedRayQuery,
                Anchor3d,
                getObjectRefCount,
                ObjectTransform,
                resetUV,
                cameraWorldDirection,
                randColor,
                randHtmlColor,
                randPoint3D,
                randPoint2D,
                isMapMode,
                createScreenSpaceEntity,
                object2Entity,
                getOwerScene,
                getObjectOwnerEntity,
                getEntityParents,
                IUniformB,
                IUniformN,
                IUniformNArray,
                IUniformV2,
                IUniformV3,
                IUniformV3Array,
                IUniformColor,
                IUniformTexture,
                HighlightMaterialOption,
                traverseMaterial,
                cloneMaterial,
                disposeMaterial,
                setMaterialOpacity,
                enableMaterialVerticeOpacity,
                toWorld,
                fromWorld,
                toDist,
                fromDist,
                clamp,
                lerp,
                lerpEuler,
                approxZero,
                approxEquals,
                maxValue,
                minValue,
                randInt,
                approxArrayEquals,
                roundToStep,
                infinityToMaxNumber,
                maxNumberToInfinity,
                max3,
                min3,
                max2,
                min2,
                smoothPoints,
                toVector3,
                getFilterColorMatrix,
                degToRad,
                radToDeg,
                DEG2RAD,
                RAD2DEG,
                FilterColorOptions,
                expandLine,
                pointDistance,
                lineDistance,
                lineSlice,
                interpolatePointsByRatio,
                BitSet,
                isLeftButton,
                isMiddleButton,
                isRightButton,
                isShiftKeyDown,
                isCtrlKeyDown,
                isAltKeyDown,
                eventKeyCode,
                isEnterKey,
                isEscKey,
                isDeleteKey,
                preventDefaultEvent,
                eventXY,
                textureDataToImageData,
                renderTargetToDataUrl,
                textureToDataUrl,
                textureToCanvas,
                texImageToCanvas,
                exportRenderTarget,
                loadImage,
                DOM,
                addScript,
                ScriptDefaultOptions,
                lerpCoordinates,
                dist2d,
                offsetCoords,
                isPointInPolygon,
                getFullscreenTriangle,
                getSphericalCube,
                getScreenSpaceBox,
                getFrustum,
                getFrustumFromHeight,
                lerpCameras,
                createUnProjectMenu,
                explodeGroup,
                enableSRGBColorSpace,
                optimizeModelRender,
                enableRealisticRender,
                enableShadow,
                getEnvmapFromHDRTexture,
                getEnvmapFromScene,
                flatModel,
                EventDispatcher,
                Logger,
                DependencyError,
                Time,
                ModuleManager,
                AppBaseOptions,
                AppBase,
                IAppModuleBase,
                AppModuleBase,
                AppModuleConstructor,
                AppObject,
                IModuleBase,
                OrderIndex,
                ModuleBase,
                EntityBaseOptions,
                EntityBase,
                InteractiveEvent,
                DispatchEvent,
                IEntityModuleBase,
                EntityModuleBase,
                EntityModuleConstructor,
                findSignalHandlerIndexByHandle,
                findSignalHandlerIndexByHandleAndContext,
                dispatchViaProxy,
                SignalHandler,
                Signal,
                Store,
                CancelledCommandException,
                Scheduler,
                createWorker,
                workerWrap,
                workerProxy,
                workerTransfer,
                workerLink,
                createWorkerWrap,
                geoBounds,
                GeoBounds,
                geoPoint,
                GeoPoint,
                GeoPointLike,
                isGeoPointLike,
                Projection,
                GeoProjection,
                transform,
                InterpolationOptions,
                Interpolation,
                triangulate,
                triangulatFlatten,
                offsetPolygon,
                extrudePolygon,
                extrudePolyline,
                extrudeGeoJSON,
                lineIntersection,
                triangle2dArea,
                simplifyPoints,
                pointToSegmentDistance,
                closestPointOnSegment,
                closestPointOnPolyline,
                closestPointOnPolylines,
                segmentIntersect,
                lineSplit,
                multiLineSplit,
                Screenshot,
                IWebGLRendererModule,
                WebGLRendererModuleOptions,
                WebGLRendererModule,
                ICameraModule,
                CameraOptions,
                CameraModuleOptions,
                CameraModule,
                EnvConfigOption,
                loadResourcesOptions,
                ISceneModule,
                BackgroundTexture,
                BackgroundEnvironmentOptions,
                SceneModuleOptions,
                SceneModule,
                IOrbitControlModule,
                OrbitControlModuleOptions,
                OrbitControlModule,
                IStatModule,
                StatModuleOptions,
                StatModule,
                PostProcessModuleOptions,
                IPostProcessModule,
                PostProcessModule,
                InputModuleOptions,
                IInputModule,
                InputModule,
                ICoordSystemModule,
                CoordSystemOption,
                UnProjectOpts,
                CoordSystemModule,
                ICSS2DRendererModule,
                CSS2DRendererModuleOptions,
                CSS2DRendererModule,
                ICSS3DRendererModule,
                CSS3DRendererModuleOptions,
                CSS3DRendererModule,
                IEntityManagerModule,
                EntityManagerModule,
                EntityOutlineModuleOptions,
                EntityOutlineModule,
                IEntityQueryModule,
                EntityQueryOption,
                InteractiveObject,
                EntityQueryModule,
                IDrawPointEnterOptions,
                IDrawLineEnterOptions,
                IDrawPolygonEnterOptions,
                IDrawEditEnterOptions,
                IPickModule,
                PickPointOptions,
                PickEntityOptions,
                PickModule,
                ICommandModule,
                CommandModuleOptions,
                CommandModule,
                IParticleRenderModule,
                ParticleRenderModuleOptions,
                ParticleRenderModule,
                IRectCollide,
                IRectCollideModule,
                RectCollideModuleOptions,
                RectCollideModule,
                IToolStateModule,
                ToolStateModuleOptions,
                ToolStateModule,
                IPhysicsManagerModule,
                PhysicsManagerModuleOptions,
                PhysicsBodyOption,
                MeshPhysicsObject,
                MeshPhysicsObjectParams,
                PhysicsManagerModule,
                ControlPosition,
                IControl,
                logInfoType,
                IUiModule,
                ControlMarginOptions,
                UiModuleOptions,
                UiModule,
                CameraState,
                CameraControls,
                GridHelperModuleOptions,
                GridHelperModule,
                MeshModuleOption,
                MeshModule,
                InstancedMeshModuleOption,
                DynamicInstancedMesh,
                InstancedMeshModule,
                SymbolItemData,
                SymbolModuleOption,
                BetterRaycastingPoints,
                SymbolModule,
                BillboardModule,
                OutlineModule,
                SpriteAnimatorModule,
                PolylineItemData,
                PolylinesModuleOption,
                PolylinesModule,
                PolygonItemData,
                PolygonsModuleOption,
                PolygonsModule,
                FillExtrusionItemData,
                FillExtrusionsModuleOption,
                FillExtrusionsModule,
                GlLineItemData,
                GlLinesModuleOption,
                GlLinesModule,
                BehaviorModule,
                SpriteMarkerModule,
                SpriteImagesModule,
                SpriteTextsModule,
                ParticleModuleOption,
                ParticleModule,
                AnimatorModuleOptions,
                AnimatorModule,
                ModelModuleOptions,
                ModelModule,
                EventModuleOptions,
                EventModule,
                PhysicsModule,
                PathAnimateModuleOptions,
                PathAnimateModule,
                AppOptions,
                App,
                EntityOptions,
                RayQueryType,
                Entity,
                LoadDetail,
                ResStatus,
                LoadUnit,
                LoaderManagerOptions,
                LoaderManager,
                ILoadModelOption,
                ResourceItem,
                RosourceItemsReturnType,
                ResourceManager,
                LoadManager,
                ResManager,
                AlgorithmPluginType,
                Tiles3dPluginType,
                LoadPluginOpts,
                PluginManager,
                Plugins,
                loadPluginAlgorithm,
                loadPlugin3dtiles,
                IEvent,
                IEventDispatcher,
                ImageCanvasOptions,
                AnyFunction,
                AnyOptions,
                Class,
                IDisposable,
                IJSONSerializable,
                PartialPick,
                PartialRecord,
                StringKeyOf,
                Fof,
                ValOrFunc,
                ValOrArr,
                ValOrArrOp,
                Serializer,
                PointerDragHelper,
                SimpleEventDispatcher,
                createCanvasElement,
                createDiv,
                createImage,
                createStyles,
                createScriptFromURL,
                TYPED_ARRAYS,
                arrayBufferToBase64,
                base64ToArrayBuffer,
                getTypedArray,
                escapeRegExp,
                getFilenameFromPath,
                parseFileExtension,
                replaceAll,
                toTitleCase,
                longestCommonPrefix,
                prettyScrollbar,
                blobToDataURL,
                downloadBlob,
                downloadFile,
                uploadFile,
                mobileAndTabletCheck,
                uploadFileGetContent,
                LinearToSRGB,
                SRGBToLinear,
                colorToDataUrl,
                onChange,
                onChange2,
                onChange3,
                serialize,
                serializable,
                aesGcmDecrypt,
                aesGcmEncrypt,
                embedUrlRefs,
                htmlToCanvas,
                htmlToPng,
                htmlToSvg,
                imageToCanvas,
                imageBitmapToBase64,
                imageUrlToImageData,
                imageDataToCanvas,
                canvasFlipY,
                isWebpExportSupported,
                absMax,
                clearBit,
                updateBit,
                includesAll,
                copyProps,
                getOrCall,
                getPropertyDescriptor,
                isPropertyWritable,
                safeSetProperty,
                deepAccessObject,
                getKeyByValue,
                objectHasOwn,
                makeColorSvg,
                makeTextSvg,
                makeColorSvgCircle,
                svgToCanvas,
                svgToPng,
                timeout,
                now,
                pathJoin,
                getUrlQueryParam,
                setUrlQueryParam,
                remoteWorkerURL,
                css,
                glsl,
                html,
                svgUrl,
                Serialization,
                GridProps,
                GridType,
                Grid,
                ViewHelper,
                ShadertoyMaterialParameters,
                ShadertoyMaterial,
                shaderMaterial,
                convertToMaterialParameters,
                FixedSizeMeshMaterial,
                highlightMaterial,
                SymbolMaterialProps,
                createSymbolMaterial,
                FlowMaterialProps,
                FlowMaterial,
                TextFlowMaterialOptions,
                RenderElementFlowMaterialOptions,
                createRenderElementFlowMaterial,
                createTextFlowMaterial,
                AnimatorFrameMaterialProps,
                AnimatorFrameMaterial,
                createAnimatorFrameSpriteMaterial,
                MeshReflectorMaterialConfig,
                MeshReflectorMaterial,
                ConvolutionMaterial,
                MeshTransmissionMaterialConfig,
                FBOConfig,
                MeshTransmissionMaterial,
                CustomShaderMaterial,
                MaterialConstructor,
                iCSMPatchMap,
                iCSMParams,
                iCSMUpdateParams,
                iCSMInternals,
                Uniform,
                iCSMShader,
                createFlowGradientMaterial,
                RadarMaterialProps,
                RadarMaterial,
                HolographicMaterial,
                ReflectorMaterial,
                ReflectorDudvMaterial,
                Render2dTextureOptions,
                createRender2dTexture,
                useFBO,
                Render3dTextureOptions,
                Render3dTexture,
                ShadertoyTextureItemOptions,
                ShadertoyTextureOptions,
                ShadertoyTexture,
                BufferShader,
                CharInfo,
                AtlasData,
                CharLayoutInfo,
                LayoutInfo,
                FontManagerOptions,
                FontManager,
                LabelMaterial,
                Label,
                LabelPool,
                LabelOptions,
                createLabel,
                ExtrudePath,
                ExtrudeMeshProps,
                ExtrudeMesh,
                MeshLineGeometry,
                MeshLineMaterial,
                MeshLine,
                PathPointList,
                PathGeometry,
                PathTubeGeometry,
                PathTubeEntitiesOptions,
                PathTubeEntities,
                BillboardProps,
                BillboardType,
                Billboard,
                Outlines,
                OutlinesProps,
                OutlinesType,
                TextProps,
                TextType,
                createTextMesh,
                SpriteAnimatorProps,
                SpriteAnimatorType,
                createSpriteAnimator,
                TrailLine,
                Line2,
                LineGeometry,
                LineMaterialParameters,
                LineMaterial,
                LineSegments2,
                LineSegmentsGeometry,
                Wireframe,
                WireframeGeometry2,
                SpriteMarkerOptions,
                SpriteMarker,
                SpriteImageItemData,
                SpriteImageItem,
                SpriteImagesOptions,
                SpriteImages,
                SpriteTextItemData,
                SpriteTextItem,
                SpriteTextsOptions,
                SpriteTexts,
                AnimationClipOptions,
                AnimatorOptions,
                Animator,
                PlaneConfig,
                ScreenQuad,
                BoxHelperOptions,
                BoxHelper,
                HeatmapOptions,
                Heatmap,
                ReflectorBlurMaterial,
                ReflectorObject,
                createReflectorShaderMesh,
                setMeshReflector,
                MeshReflectorOptions,
                MeasureRulerOptions,
                creataMeasureRuler,
                Environment,
                PackedMipMapGenerator,
                FullScreenQuad,
                DynamicEnvConfig,
                DynamicEnvironment,
                createFlyline,
                createMapApp,
                map2dUtils,
                MapThreeLayerOptions,
                MapThreeLayer,
                VariableTubeGeometry,
                HyperbolicHelicoidGeometry,
                SphubeGeometry,
                createWallBufferGeometry,
                MapView,
                LODControl,
                LODRaycast,
                MapProvider,
                MapNodeGeometry,
                MapNodeHeightGeometry,
                MapNode,
                QuadTreePosition,
                MapHeightNode,
                MapPlaneNode,
                UnitsUtils,
                MapUtils,
                CanvasUtils,
                CancelablePromise,
                XHRUtils,
                TextureUtils,
                MapViewEntity,
                AllowedTypes,
                Omitype,
                PickType,
                TransformType,
                TransformedTypes,
                FilteredType,
                Motion,
                MotionConfig,
                EasingFunction,
                Easing,
                DEFAULT_EASING,
                Easings,
                RunningTween,
                Tween,
                TweenManager,
                animation,
                animationAsync,
                MeshEntityOptions,
                MeshEntity,
                InstancedMeshEntityOptions,
                InstancedMeshEntity,
                SymbolEntityOptions,
                SymbolEntity,
                SpriteAnimatorEntityOptions,
                SpriteAnimatorEntity,
                PolylinesEntityOptions,
                PolylinesEntity,
                PolygonsEntityOptions,
                PolygonsEntity,
                FillExtrusionsEntityOptions,
                FillExtrusionsEntity,
                GlLinesEntityOptions,
                GlLinesEntity,
                SpriteMarkerEntityOptions,
                SpriteMarkerEntity,
                SpriteImagesEntityOptions,
                SpriteImagesEntity,
                SpriteTextsEntityOptions,
                SpriteTextsEntity,
                MetaData,
                ParticleEmitter,
                IParticle,
                Particle,
                NodeParticle,
                SpriteParticle,
                RecordState,
                TrailParticle,
                BurstParameters,
                BurstParametersJSON,
                ParticleSystemParameters,
                ParticleSystemJSONParameters,
                JsonMetaData,
                EmissionState,
                ParticleSystem,
                StoredBatchSettings,
                RenderMode,
                VFXBatch,
                SpriteBatch,
                TrailBatch,
                VFXBatchSettings,
                SerializationOptions,
                RendererEmitterSettings,
                StretchedBillBoardSettings,
                BillBoardSettings,
                TrailSettings,
                MeshSettings,
                IParticleSystem,
                BatchedRenderer,
                ParticleLoader,
                Constructable,
                FieldType,
                ParameterType,
                ParameterPair,
                loadParticlePlugin,
                unloadParticlePlugin,
                ParticlePlugin,
                ParticlePlugins,
                getValueFromEmitterMode,
                ShapeJSON,
                EmitterMode,
                EmitterShape,
                ConeEmitterParameters,
                ConeEmitter,
                CircleEmitterParameters,
                CircleEmitter,
                DonutEmitterParameters,
                DonutEmitter,
                PointEmitter,
                SphereEmitterParameters,
                SphereEmitter,
                HemisphereEmitterParameters,
                HemisphereEmitter,
                GridEmitterParameters,
                GridEmitter,
                MeshSurfaceEmitter,
                EmitterFromJSON,
                EmitterShapeParticlePlugin,
                EmitterShapes,
                Bezier,
                ColorGeneratorFromJSON,
                ColorGenerator,
                FunctionColorGenerator,
                MemorizedFunctionColorGenerator,
                ConstantColor,
                ColorRange,
                ConstantValue,
                FunctionJSON,
                Gradient,
                RandomColorBetweenGradient,
                IntervalValue,
                PiecewiseBezier,
                PiecewiseFunction,
                RandomColor,
                ValueGeneratorFromJSON,
                ValueGenerator,
                FunctionValueGenerator,
                RandomQuatGenerator,
                AxisAngleGenerator,
                RotationGeneratorFromJSON,
                RotationGenerator,
                EulerGenerator,
                GeneratorFromJSON,
                ColorOverLife,
                RotationOverLife,
                Rotation3DOverLife,
                ForceOverLife,
                SizeOverLife,
                SpeedOverLife,
                FrameOverLife,
                OrbitOverLife,
                WidthOverLength,
                ApplyForce,
                GravityForce,
                ChangeEmitDirection,
                SubParticleEmitMode,
                EmitSubParticleSystem,
                TurbulenceField,
                Noise,
                ApplySequences,
                setPhysicsResolver,
                getPhysicsResolver,
                ApplyCollision,
                ColorBySpeed,
                SizeBySpeed,
                RotationBySpeed,
                LimitSpeedOverLife,
                SimulationFromJSON,
                Simulation,
                SimulationParticlePlugin,
                SimulationTypes,
                TextureSequencer,
                SequencerFromJSON,
                Sequencer,
                Interpreter,
                NodeData,
                Node_2 as Node,
                ConstInput,
                Wire,
                Adapter,
                NodeTypes,
                OutputNodeTypeNames,
                NodeGraph,
                ExecutionContext,
                NodeTypeSignature,
                NodeType,
                NodeDef,
                GraphNodeType,
                NodeValueType,
                getAlignOfNodeValueType,
                getSizeOfNodeValueType,
                genDefaultForNodeValueType,
                VFXParameters,
                NodeVFX,
                WebGPUCompiler,
                registerShaderChunks,
                CubeEmitterParameters,
                CubeEmitter,
                PathEmitterParameters,
                PathEmitter,
                SetEmitDirection,
                ApplyRoute,
                BehaviorContext,
                BehaviorStatus,
                Behavior,
                AbstractDecoratorBehavior,
                ConditionalBehavior,
                LogMessageBehavior,
                SendEventBehavior,
                ActionBehavior,
                DelayBehavior,
                ParallelBehaviorPolicy,
                ParallelBehavior,
                SequenceBehavior,
                DestoryBehavior,
                PromiseBehavior,
                SucceedingBehavior,
                FailingBehavior,
                RepeatBehavior,
                WaitForEventBehavior,
                BranchBehavior,
                FilterBehavior,
                RepeatUntilFailureBehavior,
                CompositeBehavior,
                IgnoreFailureBehavior,
                RepeatUntilSuccessBehavior,
                ConditionBehavior,
                InvertStatusBehavior,
                SelectorBehavior,
                RotationBehavior,
                AnimationTrackPlayback,
                AnimationTrack,
                AnimationBehavior,
                TLEventHandler,
                TLEventType,
                TLEnterEventHandler,
                TLExitEventHandler,
                TLStateNodeConstructor,
                StateNode,
                DefaultTool,
                DrawShapeTool,
                TransformControlsPointerObject,
                TransformControls,
                TransformControlsGizmo,
                TransformControlsPlane,
                TransformEnterOptions,
                TransformTool,
                PickEnterOptions,
                PickTool,
                ICommand,
                ICommandCallback,
                BaseCommand,
                SetMaterialMapCommand,
                IHasUpdate,
                SetValueCommand,
                UpdateValueCommand,
                CallFunctionCommand,
                SetMultipleValuesCommand,
                CommandHistory,
                MultiCmdsCommand,
                SetRotationCommand,
                SetPositionCommand,
                PushValueCommand,
                SetScaleCommand,
                IHasDataEntity,
                SetDataCommand,
                AddObject3DCommand,
                Anchor,
                anchorTranslate,
                anchorOrigin,
                Marker2dOptions,
                createDefaultMarkerElement,
                Marker2D,
                PopopOffset,
                PopupOptions,
                Popup2D,
                Marker3dOptions,
                Marker3D,
                AnimateMarkerType,
                AnimateMarkerLayerOption,
                AnimateMarkerBase,
                BreathingApertureMarker,
                DiffusedApertureMarker,
                FluorescenceMarker,
                HaloRingMarker,
                RotatingApertureMarker,
                RotatingTextBorderMarker,
                ContextMenuSubItemOptions,
                ContextMenuOptions,
                ContextMenu,
                ButtonGroupControlOptions,
                ButtonGroupControl,
                MousePositionControlOption,
                MousePositionControl,
                FullscreenControlOptions,
                FullscreenControl,
                MiniMapControlOption,
                MiniMapControl,
                UiConfigRendererBase,
                UiConfigMethods,
                UiConfigContainer,
                IUiConfigContainer,
                UiObjectConfig,
                UiObjectType,
                TUiRefreshModes,
                ChangeArgs,
                ChangeEvent,
                uiConfig,
                uiContainer,
                uiMonitor,
                uiSlider,
                uiVector,
                uiDropdown,
                uiButton,
                uiInput,
                uiColor,
                uiImage,
                uiToggle,
                uiNumber,
                uiPanelContainer,
                uiFolderContainer,
                generateUiConfig,
                generateUiFolder,
                UiConfigTypeMap,
                TParams,
                UiPanelJsonConfig,
                makeObject3DUiConfig,
                makeSamplerUi,
                getEmptyMeta,
                iMaterialUI,
                makeBasicMaterialUiConfig,
                makePhongMaterialUiConfig,
                makePhysicalMaterialUiConfig,
                makeMaterialUiConfig,
                makeGeomertyUiConfig,
                makeCameraUiConfig,
                makeLightUiConfig,
                encryptToBase64,
                decryptFromBase64,
                tea,
                MapOpenWay,
                IMapStyleParam,
                IOpenMapBaseParam,
                IOpenMapParam,
                IUpdateMapParam,
                IOpenMapResponse,
                ITileUrlParam,
                IQueryBaseFeatures,
                IPointQueryFeatures,
                IRectQueryFeatures,
                IExprQueryFeatures,
                IConditionQueryFeatures,
                IMapLayer,
                IUpdateStyle,
                ISliceLayer,
                ISliceCacheZoom,
                IWmsTileUrl,
                IDeleteStyle,
                IDeleteCache,
                IExportLayout,
                IMatchObject,
                IComposeNewMap,
                IMapDiff,
                ICreateEntitiesGeomData,
                IWorkspace,
                openMapDarkStyle,
                openMapLightStyle,
                Service,
                Config,
                Response_2 as Response,
                IRequest,
                httpHelper,
                loadPhysicsEngine,
                CANNON,
                BoxParameters,
                CylinderParameters,
                SphereParameters,
                ConvexPolyhedronParameters,
                TrimeshParameters,
                ShapeType2,
                ShapeOptions,
                ShapeParameters,
                ShapeResult,
                getShapeParameters,
                threeToCannon
            }
        }
        export default vjmap3d;

        declare namespace vjmap3d_2 {
            export {
                vjmap3d as default,
                computeBoundsTree,
                disposeBoundsTree,
                acceleratedRaycast,
                SMAAEffect,
                EdgeDetectionMode,
                FXAAEffect,
                KernelSize,
                PredicationMode,
                SMAAPreset,
                BloomEffect,
                KawaseBlurPass,
                ToneMappingEffect,
                ToneMappingMode,
                DepthOfFieldEffect,
                ChromaticAberrationEffect,
                GlitchEffect,
                GlitchMode,
                GodRaysEffect,
                PixelationEffect,
                SSAOEffect,
                NormalPass,
                OverrideMaterialManager,
                EffectComposer,
                DotScreenEffect,
                DepthPickingPass,
                TextureEffect,
                Effect,
                ColorDepthEffect,
                CopyPass,
                DepthPass,
                BlendFunction,
                ShaderPass,
                EffectAttribute,
                EffectPass,
                OutlineEffect,
                RenderPass,
                Pass,
                SelectiveBloomEffect,
                reactivity,
                render2d,
                __buildDate,
                __buildVersion,
                __buildVerNo,
                __DEV,
                deleteArrItem,
                generateUUID,
                cloneDeep,
                pick,
                bindAll,
                extend,
                strMd5,
                sleep,
                pushObjectStatus,
                throttle,
                debounce,
                applyMixins,
                BidirectionalMap,
                isObjectBehindCamera,
                cameraDistance2NdcZ,
                isObjectOcclude,
                addResourceRefCount,
                disposeObject3D,
                containSkeleton,
                objectTransformToMatrix,
                getBoundingBox,
                getObjectAnchorPoint,
                disableRayQuery,
                disableSelected,
                disableBloom,
                disableOutline,
                disableBloomSelectedRayQuery,
                Anchor3d,
                getObjectRefCount,
                ObjectTransform,
                resetUV,
                cameraWorldDirection,
                randColor,
                randHtmlColor,
                randPoint3D,
                randPoint2D,
                isMapMode,
                createScreenSpaceEntity,
                object2Entity,
                getOwerScene,
                getObjectOwnerEntity,
                getEntityParents,
                IUniformB,
                IUniformN,
                IUniformNArray,
                IUniformV2,
                IUniformV3,
                IUniformV3Array,
                IUniformColor,
                IUniformTexture,
                HighlightMaterialOption,
                traverseMaterial,
                cloneMaterial,
                disposeMaterial,
                setMaterialOpacity,
                enableMaterialVerticeOpacity,
                toWorld,
                fromWorld,
                toDist,
                fromDist,
                clamp,
                lerp,
                lerpEuler,
                approxZero,
                approxEquals,
                maxValue,
                minValue,
                randInt,
                approxArrayEquals,
                roundToStep,
                infinityToMaxNumber,
                maxNumberToInfinity,
                max3,
                min3,
                max2,
                min2,
                smoothPoints,
                toVector3,
                getFilterColorMatrix,
                degToRad,
                radToDeg,
                DEG2RAD,
                RAD2DEG,
                FilterColorOptions,
                expandLine,
                pointDistance,
                lineDistance,
                lineSlice,
                interpolatePointsByRatio,
                BitSet,
                isLeftButton,
                isMiddleButton,
                isRightButton,
                isShiftKeyDown,
                isCtrlKeyDown,
                isAltKeyDown,
                eventKeyCode,
                isEnterKey,
                isEscKey,
                isDeleteKey,
                preventDefaultEvent,
                eventXY,
                textureDataToImageData,
                renderTargetToDataUrl,
                textureToDataUrl,
                textureToCanvas,
                texImageToCanvas,
                exportRenderTarget,
                loadImage,
                DOM,
                addScript,
                ScriptDefaultOptions,
                lerpCoordinates,
                dist2d,
                offsetCoords,
                isPointInPolygon,
                getFullscreenTriangle,
                getSphericalCube,
                getScreenSpaceBox,
                getFrustum,
                getFrustumFromHeight,
                lerpCameras,
                createUnProjectMenu,
                explodeGroup,
                enableSRGBColorSpace,
                optimizeModelRender,
                enableRealisticRender,
                enableShadow,
                getEnvmapFromHDRTexture,
                getEnvmapFromScene,
                flatModel,
                EventDispatcher,
                Logger,
                DependencyError,
                Time,
                ModuleManager,
                AppBaseOptions,
                AppBase,
                IAppModuleBase,
                AppModuleBase,
                AppModuleConstructor,
                AppObject,
                IModuleBase,
                OrderIndex,
                ModuleBase,
                EntityBaseOptions,
                EntityBase,
                InteractiveEvent,
                DispatchEvent,
                IEntityModuleBase,
                EntityModuleBase,
                EntityModuleConstructor,
                findSignalHandlerIndexByHandle,
                findSignalHandlerIndexByHandleAndContext,
                dispatchViaProxy,
                SignalHandler,
                Signal,
                Store,
                CancelledCommandException,
                Scheduler,
                createWorker,
                workerWrap,
                workerProxy,
                workerTransfer,
                workerLink,
                createWorkerWrap,
                geoBounds,
                GeoBounds,
                geoPoint,
                GeoPoint,
                GeoPointLike,
                isGeoPointLike,
                Projection,
                GeoProjection,
                transform,
                InterpolationOptions,
                Interpolation,
                triangulate,
                triangulatFlatten,
                offsetPolygon,
                extrudePolygon,
                extrudePolyline,
                extrudeGeoJSON,
                lineIntersection,
                triangle2dArea,
                simplifyPoints,
                pointToSegmentDistance,
                closestPointOnSegment,
                closestPointOnPolyline,
                closestPointOnPolylines,
                segmentIntersect,
                lineSplit,
                multiLineSplit,
                Screenshot,
                IWebGLRendererModule,
                WebGLRendererModuleOptions,
                WebGLRendererModule,
                ICameraModule,
                CameraOptions,
                CameraModuleOptions,
                CameraModule,
                EnvConfigOption,
                loadResourcesOptions,
                ISceneModule,
                BackgroundTexture,
                BackgroundEnvironmentOptions,
                SceneModuleOptions,
                SceneModule,
                IOrbitControlModule,
                OrbitControlModuleOptions,
                OrbitControlModule,
                IStatModule,
                StatModuleOptions,
                StatModule,
                PostProcessModuleOptions,
                IPostProcessModule,
                PostProcessModule,
                InputModuleOptions,
                IInputModule,
                InputModule,
                ICoordSystemModule,
                CoordSystemOption,
                UnProjectOpts,
                CoordSystemModule,
                ICSS2DRendererModule,
                CSS2DRendererModuleOptions,
                CSS2DRendererModule,
                ICSS3DRendererModule,
                CSS3DRendererModuleOptions,
                CSS3DRendererModule,
                IEntityManagerModule,
                EntityManagerModule,
                EntityOutlineModuleOptions,
                EntityOutlineModule,
                IEntityQueryModule,
                EntityQueryOption,
                InteractiveObject,
                EntityQueryModule,
                IDrawPointEnterOptions,
                IDrawLineEnterOptions,
                IDrawPolygonEnterOptions,
                IDrawEditEnterOptions,
                IPickModule,
                PickPointOptions,
                PickEntityOptions,
                PickModule,
                ICommandModule,
                CommandModuleOptions,
                CommandModule,
                IParticleRenderModule,
                ParticleRenderModuleOptions,
                ParticleRenderModule,
                IRectCollide,
                IRectCollideModule,
                RectCollideModuleOptions,
                RectCollideModule,
                IToolStateModule,
                ToolStateModuleOptions,
                ToolStateModule,
                IPhysicsManagerModule,
                PhysicsManagerModuleOptions,
                PhysicsBodyOption,
                MeshPhysicsObject,
                MeshPhysicsObjectParams,
                PhysicsManagerModule,
                ControlPosition,
                IControl,
                logInfoType,
                IUiModule,
                ControlMarginOptions,
                UiModuleOptions,
                UiModule,
                CameraState,
                CameraControls,
                GridHelperModuleOptions,
                GridHelperModule,
                MeshModuleOption,
                MeshModule,
                InstancedMeshModuleOption,
                DynamicInstancedMesh,
                InstancedMeshModule,
                SymbolItemData,
                SymbolModuleOption,
                BetterRaycastingPoints,
                SymbolModule,
                BillboardModule,
                OutlineModule,
                SpriteAnimatorModule,
                PolylineItemData,
                PolylinesModuleOption,
                PolylinesModule,
                PolygonItemData,
                PolygonsModuleOption,
                PolygonsModule,
                FillExtrusionItemData,
                FillExtrusionsModuleOption,
                FillExtrusionsModule,
                GlLineItemData,
                GlLinesModuleOption,
                GlLinesModule,
                BehaviorModule,
                SpriteMarkerModule,
                SpriteImagesModule,
                SpriteTextsModule,
                ParticleModuleOption,
                ParticleModule,
                AnimatorModuleOptions,
                AnimatorModule,
                ModelModuleOptions,
                ModelModule,
                EventModuleOptions,
                EventModule,
                PhysicsModule,
                PathAnimateModuleOptions,
                PathAnimateModule,
                AppOptions,
                App,
                EntityOptions,
                RayQueryType,
                Entity,
                LoadDetail,
                ResStatus,
                LoadUnit,
                LoaderManagerOptions,
                LoaderManager,
                ILoadModelOption,
                ResourceItem,
                RosourceItemsReturnType,
                ResourceManager,
                LoadManager,
                ResManager,
                AlgorithmPluginType,
                Tiles3dPluginType,
                LoadPluginOpts,
                PluginManager,
                Plugins,
                loadPluginAlgorithm,
                loadPlugin3dtiles,
                IEvent,
                IEventDispatcher,
                ImageCanvasOptions,
                AnyFunction,
                AnyOptions,
                Class,
                IDisposable,
                IJSONSerializable,
                PartialPick,
                PartialRecord,
                StringKeyOf,
                Fof,
                ValOrFunc,
                ValOrArr,
                ValOrArrOp,
                Serializer,
                PointerDragHelper,
                SimpleEventDispatcher,
                createCanvasElement,
                createDiv,
                createImage,
                createStyles,
                createScriptFromURL,
                TYPED_ARRAYS,
                arrayBufferToBase64,
                base64ToArrayBuffer,
                getTypedArray,
                escapeRegExp,
                getFilenameFromPath,
                parseFileExtension,
                replaceAll,
                toTitleCase,
                longestCommonPrefix,
                prettyScrollbar,
                blobToDataURL,
                downloadBlob,
                downloadFile,
                uploadFile,
                mobileAndTabletCheck,
                uploadFileGetContent,
                LinearToSRGB,
                SRGBToLinear,
                colorToDataUrl,
                onChange,
                onChange2,
                onChange3,
                serialize,
                serializable,
                aesGcmDecrypt,
                aesGcmEncrypt,
                embedUrlRefs,
                htmlToCanvas,
                htmlToPng,
                htmlToSvg,
                imageToCanvas,
                imageBitmapToBase64,
                imageUrlToImageData,
                imageDataToCanvas,
                canvasFlipY,
                isWebpExportSupported,
                absMax,
                clearBit,
                updateBit,
                includesAll,
                copyProps,
                getOrCall,
                getPropertyDescriptor,
                isPropertyWritable,
                safeSetProperty,
                deepAccessObject,
                getKeyByValue,
                objectHasOwn,
                makeColorSvg,
                makeTextSvg,
                makeColorSvgCircle,
                svgToCanvas,
                svgToPng,
                timeout,
                now,
                pathJoin,
                getUrlQueryParam,
                setUrlQueryParam,
                remoteWorkerURL,
                css,
                glsl,
                html,
                svgUrl,
                Serialization,
                GridProps,
                GridType,
                Grid,
                ViewHelper,
                ShadertoyMaterialParameters,
                ShadertoyMaterial,
                shaderMaterial,
                convertToMaterialParameters,
                FixedSizeMeshMaterial,
                highlightMaterial,
                SymbolMaterialProps,
                createSymbolMaterial,
                FlowMaterialProps,
                FlowMaterial,
                TextFlowMaterialOptions,
                RenderElementFlowMaterialOptions,
                createRenderElementFlowMaterial,
                createTextFlowMaterial,
                AnimatorFrameMaterialProps,
                AnimatorFrameMaterial,
                createAnimatorFrameSpriteMaterial,
                MeshReflectorMaterialConfig,
                MeshReflectorMaterial,
                ConvolutionMaterial,
                MeshTransmissionMaterialConfig,
                FBOConfig,
                MeshTransmissionMaterial,
                CustomShaderMaterial,
                MaterialConstructor,
                iCSMPatchMap,
                iCSMParams,
                iCSMUpdateParams,
                iCSMInternals,
                Uniform,
                iCSMShader,
                createFlowGradientMaterial,
                RadarMaterialProps,
                RadarMaterial,
                HolographicMaterial,
                ReflectorMaterial,
                ReflectorDudvMaterial,
                Render2dTextureOptions,
                createRender2dTexture,
                useFBO,
                Render3dTextureOptions,
                Render3dTexture,
                ShadertoyTextureItemOptions,
                ShadertoyTextureOptions,
                ShadertoyTexture,
                BufferShader,
                CharInfo,
                AtlasData,
                CharLayoutInfo,
                LayoutInfo,
                FontManagerOptions,
                FontManager,
                LabelMaterial,
                Label,
                LabelPool,
                LabelOptions,
                createLabel,
                ExtrudePath,
                ExtrudeMeshProps,
                ExtrudeMesh,
                MeshLineGeometry,
                MeshLineMaterial,
                MeshLine,
                PathPointList,
                PathGeometry,
                PathTubeGeometry,
                PathTubeEntitiesOptions,
                PathTubeEntities,
                BillboardProps,
                BillboardType,
                Billboard,
                Outlines,
                OutlinesProps,
                OutlinesType,
                TextProps,
                TextType,
                createTextMesh,
                SpriteAnimatorProps,
                SpriteAnimatorType,
                createSpriteAnimator,
                TrailLine,
                Line2,
                LineGeometry,
                LineMaterialParameters,
                LineMaterial,
                LineSegments2,
                LineSegmentsGeometry,
                Wireframe,
                WireframeGeometry2,
                SpriteMarkerOptions,
                SpriteMarker,
                SpriteImageItemData,
                SpriteImageItem,
                SpriteImagesOptions,
                SpriteImages,
                SpriteTextItemData,
                SpriteTextItem,
                SpriteTextsOptions,
                SpriteTexts,
                AnimationClipOptions,
                AnimatorOptions,
                Animator,
                PlaneConfig,
                ScreenQuad,
                BoxHelperOptions,
                BoxHelper,
                HeatmapOptions,
                Heatmap,
                ReflectorBlurMaterial,
                ReflectorObject,
                createReflectorShaderMesh,
                setMeshReflector,
                MeshReflectorOptions,
                MeasureRulerOptions,
                creataMeasureRuler,
                Environment,
                PackedMipMapGenerator,
                FullScreenQuad,
                DynamicEnvConfig,
                DynamicEnvironment,
                createFlyline,
                createMapApp,
                map2dUtils,
                MapThreeLayerOptions,
                MapThreeLayer,
                VariableTubeGeometry,
                HyperbolicHelicoidGeometry,
                SphubeGeometry,
                createWallBufferGeometry,
                MapView,
                LODControl,
                LODRaycast,
                MapProvider,
                MapNodeGeometry,
                MapNodeHeightGeometry,
                MapNode,
                QuadTreePosition,
                MapHeightNode,
                MapPlaneNode,
                UnitsUtils,
                MapUtils,
                CanvasUtils,
                CancelablePromise,
                XHRUtils,
                TextureUtils,
                MapViewEntity,
                AllowedTypes,
                Omitype,
                PickType,
                TransformType,
                TransformedTypes,
                FilteredType,
                Motion,
                MotionConfig,
                EasingFunction,
                Easing,
                DEFAULT_EASING,
                Easings,
                RunningTween,
                Tween,
                TweenManager,
                animation,
                animationAsync,
                MeshEntityOptions,
                MeshEntity,
                InstancedMeshEntityOptions,
                InstancedMeshEntity,
                SymbolEntityOptions,
                SymbolEntity,
                SpriteAnimatorEntityOptions,
                SpriteAnimatorEntity,
                PolylinesEntityOptions,
                PolylinesEntity,
                PolygonsEntityOptions,
                PolygonsEntity,
                FillExtrusionsEntityOptions,
                FillExtrusionsEntity,
                GlLinesEntityOptions,
                GlLinesEntity,
                SpriteMarkerEntityOptions,
                SpriteMarkerEntity,
                SpriteImagesEntityOptions,
                SpriteImagesEntity,
                SpriteTextsEntityOptions,
                SpriteTextsEntity,
                MetaData,
                ParticleEmitter,
                IParticle,
                Particle,
                NodeParticle,
                SpriteParticle,
                RecordState,
                TrailParticle,
                BurstParameters,
                BurstParametersJSON,
                ParticleSystemParameters,
                ParticleSystemJSONParameters,
                JsonMetaData,
                EmissionState,
                ParticleSystem,
                StoredBatchSettings,
                RenderMode,
                VFXBatch,
                SpriteBatch,
                TrailBatch,
                VFXBatchSettings,
                SerializationOptions,
                RendererEmitterSettings,
                StretchedBillBoardSettings,
                BillBoardSettings,
                TrailSettings,
                MeshSettings,
                IParticleSystem,
                BatchedRenderer,
                ParticleLoader,
                Constructable,
                FieldType,
                ParameterType,
                ParameterPair,
                loadParticlePlugin,
                unloadParticlePlugin,
                ParticlePlugin,
                ParticlePlugins,
                getValueFromEmitterMode,
                ShapeJSON,
                EmitterMode,
                EmitterShape,
                ConeEmitterParameters,
                ConeEmitter,
                CircleEmitterParameters,
                CircleEmitter,
                DonutEmitterParameters,
                DonutEmitter,
                PointEmitter,
                SphereEmitterParameters,
                SphereEmitter,
                HemisphereEmitterParameters,
                HemisphereEmitter,
                GridEmitterParameters,
                GridEmitter,
                MeshSurfaceEmitter,
                EmitterFromJSON,
                EmitterShapeParticlePlugin,
                EmitterShapes,
                Bezier,
                ColorGeneratorFromJSON,
                ColorGenerator,
                FunctionColorGenerator,
                MemorizedFunctionColorGenerator,
                ConstantColor,
                ColorRange,
                ConstantValue,
                FunctionJSON,
                Gradient,
                RandomColorBetweenGradient,
                IntervalValue,
                PiecewiseBezier,
                PiecewiseFunction,
                RandomColor,
                ValueGeneratorFromJSON,
                ValueGenerator,
                FunctionValueGenerator,
                RandomQuatGenerator,
                AxisAngleGenerator,
                RotationGeneratorFromJSON,
                RotationGenerator,
                EulerGenerator,
                GeneratorFromJSON,
                ColorOverLife,
                RotationOverLife,
                Rotation3DOverLife,
                ForceOverLife,
                SizeOverLife,
                SpeedOverLife,
                FrameOverLife,
                OrbitOverLife,
                WidthOverLength,
                ApplyForce,
                GravityForce,
                ChangeEmitDirection,
                SubParticleEmitMode,
                EmitSubParticleSystem,
                TurbulenceField,
                Noise,
                ApplySequences,
                setPhysicsResolver,
                getPhysicsResolver,
                ApplyCollision,
                ColorBySpeed,
                SizeBySpeed,
                RotationBySpeed,
                LimitSpeedOverLife,
                SimulationFromJSON,
                Simulation,
                SimulationParticlePlugin,
                SimulationTypes,
                TextureSequencer,
                SequencerFromJSON,
                Sequencer,
                Interpreter,
                NodeData,
                Node_2 as Node,
                ConstInput,
                Wire,
                Adapter,
                NodeTypes,
                OutputNodeTypeNames,
                NodeGraph,
                ExecutionContext,
                NodeTypeSignature,
                NodeType,
                NodeDef,
                GraphNodeType,
                NodeValueType,
                getAlignOfNodeValueType,
                getSizeOfNodeValueType,
                genDefaultForNodeValueType,
                VFXParameters,
                NodeVFX,
                WebGPUCompiler,
                registerShaderChunks,
                CubeEmitterParameters,
                CubeEmitter,
                PathEmitterParameters,
                PathEmitter,
                SetEmitDirection,
                ApplyRoute,
                BehaviorContext,
                BehaviorStatus,
                Behavior,
                AbstractDecoratorBehavior,
                ConditionalBehavior,
                LogMessageBehavior,
                SendEventBehavior,
                ActionBehavior,
                DelayBehavior,
                ParallelBehaviorPolicy,
                ParallelBehavior,
                SequenceBehavior,
                DestoryBehavior,
                PromiseBehavior,
                SucceedingBehavior,
                FailingBehavior,
                RepeatBehavior,
                WaitForEventBehavior,
                BranchBehavior,
                FilterBehavior,
                RepeatUntilFailureBehavior,
                CompositeBehavior,
                IgnoreFailureBehavior,
                RepeatUntilSuccessBehavior,
                ConditionBehavior,
                InvertStatusBehavior,
                SelectorBehavior,
                RotationBehavior,
                AnimationTrackPlayback,
                AnimationTrack,
                AnimationBehavior,
                TLEventHandler,
                TLEventType,
                TLEnterEventHandler,
                TLExitEventHandler,
                TLStateNodeConstructor,
                StateNode,
                DefaultTool,
                DrawShapeTool,
                TransformControlsPointerObject,
                TransformControls,
                TransformControlsGizmo,
                TransformControlsPlane,
                TransformEnterOptions,
                TransformTool,
                PickEnterOptions,
                PickTool,
                ICommand,
                ICommandCallback,
                BaseCommand,
                SetMaterialMapCommand,
                IHasUpdate,
                SetValueCommand,
                UpdateValueCommand,
                CallFunctionCommand,
                SetMultipleValuesCommand,
                CommandHistory,
                MultiCmdsCommand,
                SetRotationCommand,
                SetPositionCommand,
                PushValueCommand,
                SetScaleCommand,
                IHasDataEntity,
                SetDataCommand,
                AddObject3DCommand,
                Anchor,
                anchorTranslate,
                anchorOrigin,
                Marker2dOptions,
                createDefaultMarkerElement,
                Marker2D,
                PopopOffset,
                PopupOptions,
                Popup2D,
                Marker3dOptions,
                Marker3D,
                AnimateMarkerType,
                AnimateMarkerLayerOption,
                AnimateMarkerBase,
                BreathingApertureMarker,
                DiffusedApertureMarker,
                FluorescenceMarker,
                HaloRingMarker,
                RotatingApertureMarker,
                RotatingTextBorderMarker,
                ContextMenuSubItemOptions,
                ContextMenuOptions,
                ContextMenu,
                ButtonGroupControlOptions,
                ButtonGroupControl,
                MousePositionControlOption,
                MousePositionControl,
                FullscreenControlOptions,
                FullscreenControl,
                MiniMapControlOption,
                MiniMapControl,
                UiConfigRendererBase,
                UiConfigMethods,
                UiConfigContainer,
                IUiConfigContainer,
                UiObjectConfig,
                UiObjectType,
                TUiRefreshModes,
                ChangeArgs,
                ChangeEvent,
                uiConfig,
                uiContainer,
                uiMonitor,
                uiSlider,
                uiVector,
                uiDropdown,
                uiButton,
                uiInput,
                uiColor,
                uiImage,
                uiToggle,
                uiNumber,
                uiPanelContainer,
                uiFolderContainer,
                generateUiConfig,
                generateUiFolder,
                UiConfigTypeMap,
                TParams,
                UiPanelJsonConfig,
                makeObject3DUiConfig,
                makeSamplerUi,
                getEmptyMeta,
                iMaterialUI,
                makeBasicMaterialUiConfig,
                makePhongMaterialUiConfig,
                makePhysicalMaterialUiConfig,
                makeMaterialUiConfig,
                makeGeomertyUiConfig,
                makeCameraUiConfig,
                makeLightUiConfig,
                encryptToBase64,
                decryptFromBase64,
                tea,
                MapOpenWay,
                IMapStyleParam,
                IOpenMapBaseParam,
                IOpenMapParam,
                IUpdateMapParam,
                IOpenMapResponse,
                ITileUrlParam,
                IQueryBaseFeatures,
                IPointQueryFeatures,
                IRectQueryFeatures,
                IExprQueryFeatures,
                IConditionQueryFeatures,
                IMapLayer,
                IUpdateStyle,
                ISliceLayer,
                ISliceCacheZoom,
                IWmsTileUrl,
                IDeleteStyle,
                IDeleteCache,
                IExportLayout,
                IMatchObject,
                IComposeNewMap,
                IMapDiff,
                ICreateEntitiesGeomData,
                IWorkspace,
                openMapDarkStyle,
                openMapLightStyle,
                Service,
                Config,
                Response_2 as Response,
                IRequest,
                httpHelper,
                loadPhysicsEngine,
                CANNON,
                BoxParameters,
                CylinderParameters,
                SphereParameters,
                ConvexPolyhedronParameters,
                TrimeshParameters,
                ShapeType2,
                ShapeOptions,
                ShapeParameters,
                ShapeResult,
                getShapeParameters,
                threeToCannon
            }
        }

        export declare class WaitForEventBehavior extends Behavior {
            #private;
            event: string;
            data: any;
            target: any;
            detected: boolean;
            constructor();
            fromJSON(json: {
                event: string;
                target?: any;
            }): void;
            /**
             *
             * @param json
             * @return {WaitForEventBehavior}
             */
            static fromJSON(json: {
                event: string;
                target?: any;
            }): WaitForEventBehavior;
            tick(timeDelta?: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
            /**
             * @private
             */
            listener(): void;
            initialize(context: BehaviorContext): void;
            finalize(): void;
        }

        declare function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;

        declare function watch<T extends Readonly<MultiWatchSources>, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;

        declare function watch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;

        declare function watch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;

        declare type WatchCallback<V = any, OV = any> = (value: V, oldValue: OV, onCleanup: OnCleanup) => any;

        declare type WatchEffect = (onCleanup: OnCleanup) => void;

        declare function watchEffect(effect: WatchEffect, options?: WatchOptionsBase): WatchStopHandle;

        declare interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
            immediate?: Immediate;
            deep?: boolean;
        }

        declare interface WatchOptionsBase {
            flush?: "pre" | "sync";
        }

        declare type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T);

        declare type WatchStopHandle = () => void;

        declare function watchSyncEffect(effect: WatchEffect): WatchStopHandle;

        declare type WeakCollections = WeakMap<any, any> | WeakSet<any>;

        export declare class WebGLRendererModule extends AppModuleBase implements IAppModuleBase {
            #private;
            static moduleName: string;
            options: WebGLRendererModuleOptions;
            _commonUniforms: {
                time: Uniform_2<Vector4>;
                resolution: Uniform_2<Vector2>;
                iGlobalTime: Uniform_2<number>;
                iTime: Uniform_2<number>;
                iTimeDelta: Uniform_2<number>;
                iResolution: Uniform_2<Vector3>;
                iMouse: Uniform_2<Vector4>;
                iFrame: Uniform_2<number>;
                iDate: Uniform_2<Vector4>;
                iSampleRate: Uniform_2<number>;
                iChannelTime: Uniform_2<[number, number, number, number]>;
            };
            constructor(app?: App, options?: WebGLRendererModuleOptions);
            getScreenshot(params?: Screenshot): Promise<unknown>;
            get renderer(): any;
            get isMapMode(): boolean;
            get commonUniforms(): {
                time: Uniform_2<Vector4>;
                resolution: Uniform_2<Vector2>;
                iGlobalTime: Uniform_2<number>;
                iTime: Uniform_2<number>;
                iTimeDelta: Uniform_2<number>;
                iResolution: Uniform_2<Vector3>;
                iMouse: Uniform_2<Vector4>;
                iFrame: Uniform_2<number>;
                iDate: Uniform_2<Vector4>;
                iSampleRate: Uniform_2<number>;
                iChannelTime: Uniform_2<[number, number, number, number]>;
            };
            onAwake(): void;
            onAppRender(time: Time): void;
            setupUiConfig(): UiObjectConfig;
        }

        export declare interface WebGLRendererModuleOptions extends WebGLRendererParameters {
            clearColor?: ColorRepresentation;
            clearColorAlpha?: number;
            pixelRatio?: number;
            renderUpdate?: boolean;
            autoClear?: boolean;
            stylePosition?: string;
        }

        export declare class WebGPUCompiler extends BaseCompiler {
            run(graph: NodeGraph, context: ExecutionContext): void;
            constructor();
            protected nodeResult: Map<Node_2, string>;
            particleInstanceByteSize: number;
            hasRandom: boolean;
            private calculateMemoryLayout;
            private buildPredefinedStructs;
            private buildHeader;
            private buildFooter;
            private buildWebGPUCode;
            private buildDataFlow;
            build(graph: NodeGraph, context: ExecutionContext): string;
            private buildFromValue;
            private getTypeFromNodeType;
            private buildFromAdapter;
            private getResult;
        }

        /**
         * WheelInfo
         */
        declare class WheelInfo {
            /**
             * Max travel distance of the suspension, in meters.
             * @default 1
             */
            maxSuspensionTravel: number;
            /**
             * Speed to apply to the wheel rotation when the wheel is sliding.
             * @default -0.1
             */
            customSlidingRotationalSpeed: number;
            /**
             * If the customSlidingRotationalSpeed should be used.
             * @default false
             */
            useCustomSlidingRotationalSpeed: boolean;
            /**
             * sliding
             */
            sliding: boolean;
            /**
             * Connection point, defined locally in the chassis body frame.
             */
            chassisConnectionPointLocal: Vec3;
            /**
             * chassisConnectionPointWorld
             */
            chassisConnectionPointWorld: Vec3;
            /**
             * directionLocal
             */
            directionLocal: Vec3;
            /**
             * directionWorld
             */
            directionWorld: Vec3;
            /**
             * axleLocal
             */
            axleLocal: Vec3;
            /**
             * axleWorld
             */
            axleWorld: Vec3;
            /**
             * suspensionRestLength
             * @default 1
             */
            suspensionRestLength: number;
            /**
             * suspensionMaxLength
             * @default 2
             */
            suspensionMaxLength: number;
            /**
             * radius
             * @default 1
             */
            radius: number;
            /**
             * suspensionStiffness
             * @default 100
             */
            suspensionStiffness: number;
            /**
             * dampingCompression
             * @default 10
             */
            dampingCompression: number;
            /**
             * dampingRelaxation
             * @default 10
             */
            dampingRelaxation: number;
            /**
             * frictionSlip
             * @default 10.5
             */
            frictionSlip: number;
            /** forwardAcceleration */
            forwardAcceleration: number;
            /** sideAcceleration */
            sideAcceleration: number;
            /**
             * steering
             * @default 0
             */
            steering: number;
            /**
             * Rotation value, in radians.
             * @default 0
             */
            rotation: number;
            /**
             * deltaRotation
             * @default 0
             */
            deltaRotation: number;
            /**
             * rollInfluence
             * @default 0.01
             */
            rollInfluence: number;
            /**
             * maxSuspensionForce
             */
            maxSuspensionForce: number;
            /**
             * engineForce
             */
            engineForce: number;
            /**
             * brake
             */
            brake: number;
            /**
             * isFrontWheel
             * @default true
             */
            isFrontWheel: boolean;
            /**
             * clippedInvContactDotSuspension
             * @default 1
             */
            clippedInvContactDotSuspension: number;
            /**
             * suspensionRelativeVelocity
             * @default 0
             */
            suspensionRelativeVelocity: number;
            /**
             * suspensionForce
             * @default 0
             */
            suspensionForce: number;
            /**
             * slipInfo
             */
            slipInfo: number;
            /**
             * skidInfo
             * @default 0
             */
            skidInfo: number;
            /**
             * suspensionLength
             * @default 0
             */
            suspensionLength: number;
            /**
             * sideImpulse
             */
            sideImpulse: number;
            /**
             * forwardImpulse
             */
            forwardImpulse: number;
            /**
             * The result from raycasting.
             */
            raycastResult: WheelRaycastResult;
            /**
             * Wheel world transform.
             */
            worldTransform: Transform;
            /**
             * isInContact
             */
            isInContact: boolean;
            constructor(options?: {
                /**
                 * Connection point, defined locally in the chassis body frame.
                 */
                chassisConnectionPointLocal?: Vec3;
                /**
                 * chassisConnectionPointWorld
                 */
                chassisConnectionPointWorld?: Vec3;
                /**
                 * directionLocal
                 */
                directionLocal?: Vec3;
                /**
                 * directionWorld
                 */
                directionWorld?: Vec3;
                /**
                 * axleLocal
                 */
                axleLocal?: Vec3;
                /**
                 * axleWorld
                 */
                axleWorld?: Vec3;
                /**
                 * suspensionRestLength
                 * @default 1
                 */
                suspensionRestLength?: number;
                /**
                 * suspensionMaxLength
                 * @default 2
                 */
                suspensionMaxLength?: number;
                /**
                 * radius
                 * @default 1
                 */
                radius?: number;
                /**
                 * suspensionStiffness
                 * @default 100
                 */
                suspensionStiffness?: number;
                /**
                 * dampingCompression
                 * @default 10
                 */
                dampingCompression?: number;
                /**
                 * dampingRelaxation
                 * @default 10
                 */
                dampingRelaxation?: number;
                /**
                 * frictionSlip
                 * @default 10.5
                 */
                frictionSlip?: number;
                /** forwardAcceleration */
                forwardAcceleration?: number;
                /** sideAcceleration */
                sideAcceleration?: number;
                /**
                 * steering
                 * @default 0
                 */
                steering?: number;
                /**
                 * Rotation value, in radians.
                 * @default 0
                 */
                rotation?: number;
                /**
                 * deltaRotation
                 * @default 0
                 */
                deltaRotation?: number;
                /**
                 * rollInfluence
                 * @default 0.01
                 */
                rollInfluence?: number;
                /**
                 * maxSuspensionForce
                 */
                maxSuspensionForce?: number;
                /**
                 * isFrontWheel
                 * @default true
                 */
                isFrontWheel?: boolean;
                /**
                 * clippedInvContactDotSuspension
                 * @default 1
                 */
                clippedInvContactDotSuspension?: number;
                /**
                 * suspensionRelativeVelocity
                 * @default 0
                 */
                suspensionRelativeVelocity?: number;
                /**
                 * suspensionForce
                 * @default 0
                 */
                suspensionForce?: number;
                /**
                 * slipInfo
                 */
                slipInfo?: number;
                /**
                 * skidInfo
                 * @default 0
                 */
                skidInfo?: number;
                /**
                 * suspensionLength
                 * @default 0
                 */
                suspensionLength?: number;
                /**
                 * Max travel distance of the suspension, in meters.
                 * @default 1
                 */
                maxSuspensionTravel?: number;
                /**
                 * If the customSlidingRotationalSpeed should be used.
                 * @default false
                 */
                useCustomSlidingRotationalSpeed?: boolean;
                /**
                 * Speed to apply to the wheel rotation when the wheel is sliding.
                 * @default -0.1
                 */
                customSlidingRotationalSpeed?: number;
            });
            updateWheel(chassis: Body_2): void;
        }

        declare type WheelInfoOptions = ConstructorParameters<typeof WheelInfo>[0];

        declare type WheelRaycastResult = RaycastResult & Partial<{
            suspensionLength: number;
            directionWorld: Vec3;
            groundObject: number;
        }>;

        /**
         * Apply width to particles based on their length.
         */
        export declare class WidthOverLength implements Simulation {
            width: FunctionValueGenerator;
            type: string;
            initialize(particle: Particle): void;
            constructor(width: FunctionValueGenerator);
            update(particle: Particle): void;
            frameUpdate(delta: number): void;
            toJSON(): any;
            static fromJSON(json: any): Simulation;
            clone(): Simulation;
            reset(): void;
        }

        export declare class Wire {
            input: Node_2 | Adapter;
            inputIndex: number;
            output: Node_2 | Adapter;
            outputIndex: number;
            constructor(input: Node_2 | Adapter, inputIndex: number, output: Node_2 | Adapter, outputIndex: number);
        }

        export declare class Wireframe extends Mesh {
            constructor(geometry?: LineSegmentsGeometry, material?: LineMaterial);
            computeLineDistances(): this;
        }

        export declare class WireframeGeometry2 extends LineSegmentsGeometry {
            constructor(geometry: any);
        }

        declare type WithThisType<Func extends (...args: any) => any, This> = (this: This, ...args: Parameters<Func>) => ReturnType<Func>;

        export declare function workerLink(): any;

        export declare function workerProxy(obj: any): any;

        export declare function workerTransfer(obj: any, transfers: any): any;

        export declare function workerWrap(ep: Worker, target?: any): any;

        /**
         * The physics world
         */
        declare class World extends EventTarget_2 {
            /**
             * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
             */
            dt: number;
            /**
             * Makes bodies go to sleep when they've been inactive.
             * @default false
             */
            allowSleep: boolean;
            /**
             * All the current contacts (instances of ContactEquation) in the world.
             */
            contacts: ContactEquation[];
            frictionEquations: FrictionEquation[];
            /**
             * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
             * @default 0
             */
            quatNormalizeSkip: number;
            /**
             * Set to true to use fast quaternion normalization. It is often enough accurate to use.
             * If bodies tend to explode, set to false.
             * @default false
             */
            quatNormalizeFast: boolean;
            /**
             * The wall-clock time since simulation start.
             */
            time: number;
            /**
             * Number of timesteps taken since start.
             */
            stepnumber: number;
            /**
             * Default and last timestep sizes.
             */
            default_dt: number;
            nextId: number;
            /**
             * The gravity of the world.
             */
            gravity: Vec3;
            /**
             * Gravity to use when approximating the friction max force (mu \* mass \* gravity).
             * If undefined, global gravity will be used.
             * Use to enable friction in a World with a null gravity vector (no gravity).
             */
            frictionGravity?: Vec3;
            /**
             * The broadphase algorithm to use.
             * @default NaiveBroadphase
             */
            broadphase: Broadphase;
            /**
             * All bodies in this world
             */
            bodies: Body_2[];
            /**
             * True if any bodies are not sleeping, false if every body is sleeping.
             */
            hasActiveBodies: boolean;
            /**
             * The solver algorithm to use.
             * @default GSSolver
             */
            solver: Solver;
            constraints: Constraint[];
            narrowphase: Narrowphase;
            /**
             * collisionMatrix
             */
            collisionMatrix: ArrayCollisionMatrix;
            /**
             * CollisionMatrix from the previous step.
             */
            collisionMatrixPrevious: ArrayCollisionMatrix;
            bodyOverlapKeeper: OverlapKeeper;
            shapeOverlapKeeper: OverlapKeeper;
            /**
             * All added contactmaterials.
             */
            contactmaterials: ContactMaterial[];
            /**
             * Used to look up a ContactMaterial given two instances of Material.
             */
            contactMaterialTable: TupleDictionary;
            /**
             * The default material of the bodies.
             */
            defaultMaterial: Material_2;
            /**
             * This contact material is used if no suitable contactmaterial is found for a contact.
             */
            defaultContactMaterial: ContactMaterial;
            doProfiling: boolean;
            profile: {
                solve: number;
                makeContactConstraints: number;
                broadphase: number;
                integrate: number;
                narrowphase: number;
            };
            /**
             * Time accumulator for interpolation.
             * @see https://gafferongames.com/game-physics/fix-your-timestep/
             */
            accumulator: number;
            subsystems: any[];
            /**
             * Dispatched after a body has been added to the world.
             */
            addBodyEvent: {
                type: 'addBody';
                body: Body_2 | null;
            };
            /**
             * Dispatched after a body has been removed from the world.
             */
            removeBodyEvent: {
                type: 'removeBody';
                body: Body_2 | null;
            };
            idToBodyMap: {
                [id: number]: Body_2;
            };
            lastCallTime?: number;
            constructor(options?: {
                /**
                 * The gravity of the world.
                 */
                gravity?: Vec3;
                /**
                 * Gravity to use when approximating the friction max force (mu*mass*gravity).
                 * If undefined, global gravity will be used.
                 */
                frictionGravity?: Vec3;
                /**
                 * Makes bodies go to sleep when they've been inactive.
                 * @default false
                 */
                allowSleep?: boolean;
                /**
                 * The broadphase algorithm to use.
                 * @default NaiveBroadphase
                 */
                broadphase?: Broadphase;
                /**
                 * The solver algorithm to use.
                 * @default GSSolver
                 */
                solver?: Solver;
                /**
                 * Set to true to use fast quaternion normalization. It is often enough accurate to use.
                 * If bodies tend to explode, set to false.
                 * @default false
                 */
                quatNormalizeFast?: boolean;
                /**
                 * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
                 * @default 0
                 */
                quatNormalizeSkip?: number;
            });
            /**
             * Get the contact material between materials m1 and m2
             * @return The contact material if it was found.
             */
            getContactMaterial(m1: Material_2, m2: Material_2): ContactMaterial;
            /**
             * Store old collision state info
             */
            collisionMatrixTick(): void;
            /**
             * Add a constraint to the simulation.
             */
            addConstraint(c: Constraint): void;
            /**
             * Removes a constraint
             */
            removeConstraint(c: Constraint): void;
            /**
             * Raycast test
             * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
             */
            rayTest(from: Vec3, to: Vec3, result: RaycastResult | RaycastCallback): void;
            /**
             * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
             * @return True if any body was hit.
             */
            raycastAll(from?: Vec3, to?: Vec3, options?: RayOptions, callback?: RaycastCallback): boolean;
            /**
             * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
             * @return True if any body was hit.
             */
            raycastAny(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
            /**
             * Ray cast, and return information of the closest hit.
             * @return True if any body was hit.
             */
            raycastClosest(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
            /**
             * Add a rigid body to the simulation.
             * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
             * @todo Adding an array of bodies should be possible. This would save some loops too
             */
            addBody(body: Body_2): void;
            /**
             * Remove a rigid body from the simulation.
             */
            removeBody(body: Body_2): void;
            getBodyById(id: number): Body_2;
            /**
             * @todo Make a faster map
             */
            getShapeById(id: number): Shape | null;
            /**
             * Adds a contact material to the World
             */
            addContactMaterial(cmat: ContactMaterial): void;
            /**
             * Removes a contact material from the World.
             */
            removeContactMaterial(cmat: ContactMaterial): void;
            /**
             * Step the simulation forward keeping track of last called time
             * to be able to step the world at a fixed rate, independently of framerate.
             *
             * @param dt The fixed time step size to use (default: 1 / 60).
             * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
             * @see https://gafferongames.com/post/fix_your_timestep/
             * @example
             *     // Run the simulation independently of framerate every 1 / 60 ms
             *     world.fixedStep()
             */
            fixedStep(dt?: number, maxSubSteps?: number): void;
            /**
             * Step the physics world forward in time.
             *
             * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
             *
             * @param dt The fixed time step size to use.
             * @param timeSinceLastCalled The time elapsed since the function was last called.
             * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
             * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
             * @example
             *     // fixed timestepping without interpolation
             *     world.step(1 / 60)
             */
            step(dt: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
            internalStep(dt: number): void;
            emitContactEvents(): void;
            /**
             * Sets all body forces in the world to zero.
             */
            clearForces(): void;
        }

        declare type WorldOptions = ConstructorParameters<typeof World>[0];

        declare interface WritableArrayLike<T> {
            readonly length: number;
            [n: number]: T;
        }

        declare interface WritableComputedOptions<T> {
            get: ComputedGetter<T>;
            set: ComputedSetter<T>;
        }

        declare interface WritableComputedRef<T> extends Ref<T> {
            readonly effect: ReactiveEffect<T>;
        }

        /**
         * XHR utils contains public static methods to allow easy access to services via XHR.
         */
        export declare class XHRUtils {
            /**
             * Get file data from URL as text, using a XHR call.
             *
             * @param url - Target for the request.
             * @param onLoad - On load callback.
             * @param onError - On progress callback.
             */
            static get(url: string): Promise<any>;
            /**
             * Get raw file data from URL, using a XHR call.
             *
             * @param url - Target for the request.
             * @param onLoad - On load callback.
             * @param onError - On progress callback.
             */
            static getRaw(url: string): Promise<ArrayBuffer>;
            /**
             * Perform a request with the specified configuration.
             *
             * Syncronous request should be avoided unless they are strictly necessary.
             *
             * @param url - Target for the request.
             * @param type - Resquest type (POST, GET, ...)
             * @param header - Object with data to be added to the request header.
             * @param body - Data to be sent in the resquest.
             * @param onLoad - On load callback, receives data (String or Object) and XHR as arguments.
             * @param onError - XHR onError callback.
             */
            static request(url: string, type: string, header?: any, body?: any, onLoad?: Function, onError?: Function, onProgress?: Function): XMLHttpRequest;
        }

        declare type ZREventProperties = {
            zrX: number;
            zrY: number;
            zrDelta: number;
            zrEventControl: 'no_globalout' | 'only_globalout';
            zrByTouch: boolean;
        };

        declare class ZRImage extends Displayable<ImageProps> {
            style: ImageStyleProps;
            __image: ImageLike;
            __imageSrc: string;
            onload: (image: ImageLike) => void;
            /**
             * Create an image style object with default values in it's prototype.
             * @override
             */
            createStyle(obj?: ImageStyleProps): ImageStyleProps;
            private _getSize;
            getWidth(): number;
            getHeight(): number;
            getAnimationStyleProps(): MapToType<ImageProps, boolean>;
            getBoundingRect(): BoundingRect;
        }

        declare type ZRRawEvent = ZRRawMouseEvent | ZRRawTouchEvent | ZRRawPointerEvent;

        declare type ZRRawMouseEvent = MouseEvent & ZREventProperties;

        declare type ZRRawPointerEvent = TouchEvent & ZREventProperties;

        declare type ZRRawTouchEvent = TouchEvent & ZREventProperties;

        declare interface ZRText {
            animate(key?: '', loop?: boolean): Animator_2<this>;
            animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
            getState(stateName: string): TextState;
            ensureState(stateName: string): TextState;
            states: Dictionary<TextState>;
            stateProxy: (stateName: string) => TextState;
        }

        declare class ZRText extends Displayable<TextProps_2> implements GroupLike {
            type: string;
            style: TextStyleProps;
            /**
             * How to handling label overlap
             *
             * hidden:
             */
            overlap: 'hidden' | 'show' | 'blur';
            /**
             * Will use this to calculate transform matrix
             * instead of Element itseelf if it's give.
             * Not exposed to developers
             */
            innerTransformable: Transformable;
            private _children;
            private _childCursor;
            private _defaultStyle;
            constructor(opts?: TextProps_2);
            childrenRef(): (ZRImage | Rect | TSpan)[];
            update(): void;
            updateTransform(): void;
            getLocalTransform(m?: MatrixArray): MatrixArray;
            getComputedTransform(): MatrixArray;
            private _updateSubTexts;
            addSelfToZr(zr: Render2dType): void;
            removeSelfFromZr(zr: Render2dType): void;
            getBoundingRect(): BoundingRect;
            setDefaultTextStyle(defaultTextStyle: DefaultTextStyle): void;
            setTextContent(textContent: never): void;
            protected _mergeStyle(targetStyle: TextStyleProps, sourceStyle: TextStyleProps): TextStyleProps;
            private _mergeRich;
            getAnimationStyleProps(): MapToType<TextProps_2, boolean>;
            private _getOrCreateChild;
            private _updatePlainTexts;
            private _updateRichTexts;
            private _placeToken;
            private _renderBackground;
            static makeFont(style: TextStylePropsPart): string;
        }

        declare namespace zrUtil {
            export {
                guid,
                logError,
                clone_3 as clone,
                merge,
                mergeAll,
                extend_2 as extend,
                defaults,
                indexOf,
                inherits,
                mixin,
                isArrayLike,
                each,
                map,
                reduce,
                filter,
                find,
                keys,
                isArray,
                isFunction,
                isString,
                isStringSafe,
                isNumber,
                isObject,
                isBuiltInObject,
                isTypedArray,
                isDom,
                isGradientObject,
                isImagePatternObject,
                isRegExp,
                eqNaN,
                retrieve,
                retrieve2,
                retrieve3,
                slice,
                normalizeCssArray,
                assert,
                trim,
                setAsPrimitive,
                isPrimitive,
                createHashMap,
                concatArray,
                createObject,
                disableUserSelect,
                hasOwn,
                noop,
                createCanvas,
                Bind1,
                Bind2,
                Bind3,
                Bind4,
                Bind5,
                bind,
                Curry1,
                Curry2,
                Curry3,
                Curry4,
                curry,
                HashMap,
                RADIAN_TO_DEGREE
            }
        }

        export { }

    }
    

declare namespace THREE {
// log handlers
export function warn(message?: any, ...optionalParams: any[]): void;
export function error(message?: any, ...optionalParams: any[]): void;
export function log(message?: any, ...optionalParams: any[]): void;

// typed array parameters
export type TypedArray =
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array;
import {
  WebGLRenderTarget,
  WebGLRenderTargetOptions,
} from './WebGLRenderTarget';

export class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );
}
import {
  WebGLRenderTargetOptions,
  WebGLRenderTarget,
} from './WebGLRenderTarget';
import { WebGLRenderer } from './WebGLRenderer';
import { Texture } from '../textures/Texture';

export class WebGLRenderTargetCube extends WebGLRenderTarget {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );

  fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
}
import { Vector4 } from '../math/Vector4';
import { Texture } from '../textures/Texture';
import { DepthTexture } from '../textures/DepthTexture';
import { EventDispatcher } from '../core/EventDispatcher';
import { Wrapping, TextureFilter, TextureDataType } from '../constants';

export interface WebGLRenderTargetOptions {
  wrapS?: Wrapping;
  wrapT?: Wrapping;
  magFilter?: TextureFilter;
  minFilter?: TextureFilter;
  format?: number; // RGBAFormat;
  type?: TextureDataType; // UnsignedByteType;
  anisotropy?: number; // 1;
  depthBuffer?: boolean; // true;
  stencilBuffer?: boolean; // true;
  generateMipmaps?: boolean; // true;
  depthTexture?: DepthTexture;
}

export class WebGLRenderTarget extends EventDispatcher {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );

  uuid: string;
  width: number;
  height: number;
  scissor: Vector4;
  scissorTest: boolean;
  viewport: Vector4;
  texture: Texture;
  depthBuffer: boolean;
  stencilBuffer: boolean;
  depthTexture: DepthTexture;
  /**
   * @deprecated Use {@link Texture#wrapS texture.wrapS} instead.
   */
  wrapS: any;
  /**
   * @deprecated Use {@link Texture#wrapT texture.wrapT} instead.
   */
  wrapT: any;
  /**
   * @deprecated Use {@link Texture#magFilter texture.magFilter} instead.
   */
  magFilter: any;
  /**
   * @deprecated Use {@link Texture#minFilter texture.minFilter} instead.
   */
  minFilter: any;
  /**
   * @deprecated Use {@link Texture#anisotropy texture.anisotropy} instead.
   */
  anisotropy: any;
  /**
   * @deprecated Use {@link Texture#offset texture.offset} instead.
   */
  offset: any;
  /**
   * @deprecated Use {@link Texture#repeat texture.repeat} instead.
   */
  repeat: any;
  /**
   * @deprecated Use {@link Texture#format texture.format} instead.
   */
  format: any;
  /**
   * @deprecated Use {@link Texture#type texture.type} instead.
   */
  type: any;
  /**
   * @deprecated Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.
   */
  generateMipmaps: any;

  setSize(width: number, height: number): void;
  clone(): this;
  copy(source: WebGLRenderTarget): this;
  dispose(): void;
}
import { Scene } from '../scenes/Scene';
import { Camera } from '../cameras/Camera';
import { WebGLExtensions } from './webgl/WebGLExtensions';
import { WebGLInfo } from './webgl/WebGLInfo';
import { WebGLShadowMap } from './webgl/WebGLShadowMap';
import { WebGLCapabilities } from './webgl/WebGLCapabilities';
import { WebGLProperties } from './webgl/WebGLProperties';
import { WebGLRenderLists } from './webgl/WebGLRenderLists';
import { WebGLState } from './webgl/WebGLState';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Color } from '../math/Color';
import { WebGLRenderTarget } from './WebGLRenderTarget';
import { Object3D } from '../core/Object3D';
import { Material } from '../materials/Material';
import { Fog } from '../scenes/Fog';
import { ToneMapping, ShadowMapType, CullFace } from '../constants';
import { WebVRManager } from '../renderers/webvr/WebVRManager';
import { RenderTarget } from './webgl/WebGLRenderLists';
import { Geometry } from '../core/Geometry';
import { BufferGeometry } from '../core/BufferGeometry';
import { Texture } from '../textures/Texture';

export interface Renderer {
  domElement: HTMLCanvasElement;

  render(scene: Scene, camera: Camera): void;
  setSize(width: number, height: number, updateStyle?: boolean): void;
}

export interface WebGLRendererParameters {
  /**
   * A Canvas where the renderer draws its output.
   */
  canvas?: HTMLCanvasElement | OffscreenCanvas;

  /**
   * A WebGL Rendering Context.
   * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
   *	Default is null
   */
  context?: WebGLRenderingContext;

  /**
   *	shader precision. Can be "highp", "mediump" or "lowp".
   */
  precision?: string;

  /**
   * default is true.
   */
  alpha?: boolean;

  /**
   * default is true.
   */
  premultipliedAlpha?: boolean;

  /**
   * default is false.
   */
  antialias?: boolean;

  /**
   * default is true.
   */
  stencil?: boolean;

  /**
   * default is false.
   */
  preserveDrawingBuffer?: boolean;

  /**
   *	Can be "high-performance", "low-power" or "default"
   */
  powerPreference?: string;

  /**
   * default is true.
   */
  depth?: boolean;

  /**
   * default is false.
   */
  logarithmicDepthBuffer?: boolean;
}

export interface WebGLDebug {
  /**
   * Enables error checking and reporting when shader programs are being compiled.
   */
  checkShaderErrors: boolean;
}

/**
 * The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.
 * This renderer has way better performance than CanvasRenderer.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js">src/renderers/WebGLRenderer.js</a>
 */
export class WebGLRenderer implements Renderer {
  /**
   * parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.
   */
  constructor(parameters?: WebGLRendererParameters);

  /**
   * A Canvas where the renderer draws its output.
   * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
   */
  domElement: HTMLCanvasElement;

  /**
   * The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.
   */
  context: WebGLRenderingContext;

  /**
   * Defines whether the renderer should automatically clear its output before rendering.
   */
  autoClear: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
   */
  autoClearColor: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
   */
  autoClearDepth: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
   */
  autoClearStencil: boolean;

  /**
   * Debug configurations.
   */
  debug: WebGLDebug;

  /**
   * Defines whether the renderer should sort objects. Default is true.
   */
  sortObjects: boolean;

  clippingPlanes: any[];
  localClippingEnabled: boolean;

  extensions: WebGLExtensions;

  /**
   * Default is false.
   */
  gammaInput: boolean;

  /**
   * Default is false.
   */
  gammaOutput: boolean;

  physicallyCorrectLights: boolean;
  toneMapping: ToneMapping;
  toneMappingExposure: number;
  toneMappingWhitePoint: number;

  /**
   * Default is false.
   */
  shadowMapDebug: boolean;

  /**
   * Default is 8.
   */
  maxMorphTargets: number;

  /**
   * Default is 4.
   */
  maxMorphNormals: number;

  info: WebGLInfo;

  shadowMap: WebGLShadowMap;

  pixelRatio: number;

  capabilities: WebGLCapabilities;
  properties: WebGLProperties;
  renderLists: WebGLRenderLists;
  state: WebGLState;

  vr: WebVRManager;

  /**
   * Return the WebGL context.
   */
  getContext(): WebGLRenderingContext;
  getContextAttributes(): any;
  forceContextLoss(): void;

  /**
   * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
   */
  getMaxAnisotropy(): number;

  /**
   * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
   */
  getPrecision(): string;

  getPixelRatio(): number;
  setPixelRatio(value: number): void;

  getDrawingBufferSize(target: Vector2): Vector2;
  setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;

  getSize(target: Vector2): Vector2;

  /**
   * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
   */
  setSize(width: number, height: number, updateStyle?: boolean): void;

  getCurrentViewport(target: Vector4): Vector4;

  /**
   * Copies the viewport into target.
   */
  getViewport(target: Vector4): Vector4;

  /**
   * Sets the viewport to render from (x, y) to (x + width, y + height).
   * (x, y) is the lower-left corner of the region.
   */
  setViewport(
    x: Vector4 | number,
    y?: number,
    width?: number,
    height?: number,
  ): void;

  /**
   * Copies the scissor area into target.
   */
  getScissor(target: Vector4): Vector4;

  /**
   * Sets the scissor area from (x, y) to (x + width, y + height).
   */
  setScissor(
    x: Vector4 | number,
    y?: number,
    width?: number,
    height?: number,
  ): void;

  /**
   * Returns true if scissor test is enabled; returns false otherwise.
   */
  getScissorTest(): boolean;

  /**
   * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
   */
  setScissorTest(enable: boolean): void;

  /**
   * Returns a THREE.Color instance with the current clear color.
   */
  getClearColor(): Color;

  /**
   * Sets the clear color, using color for the color and alpha for the opacity.
   */
  setClearColor(color: Color, alpha?: number): void;
  setClearColor(color: string, alpha?: number): void;
  setClearColor(color: number, alpha?: number): void;

  /**
   * Returns a float with the current clear alpha. Ranges from 0 to 1.
   */
  getClearAlpha(): number;

  setClearAlpha(alpha: number): void;

  /**
   * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
   * Arguments default to true
   */
  clear(color?: boolean, depth?: boolean, stencil?: boolean): void;

  clearColor(): void;
  clearDepth(): void;
  clearStencil(): void;
  clearTarget(
    renderTarget: WebGLRenderTarget,
    color: boolean,
    depth: boolean,
    stencil: boolean,
  ): void;

  /**
   * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
   */
  resetGLState(): void;
  dispose(): void;

  /**
   * Tells the shadow map plugin to update using the passed scene and camera parameters.
   *
   * @param scene an instance of Scene
   * @param camera — an instance of Camera
   */
  renderBufferImmediate(
    object: Object3D,
    program: Object,
    material: Material,
  ): void;

  renderBufferDirect(
    camera: Camera,
    fog: Fog,
    geometry: Geometry | BufferGeometry,
    material: Material,
    object: Object3D,
    geometryGroup: any,
  ): void;

  /**
   * A build in function that can be used instead of requestAnimationFrame. For WebVR projects this function must be used.
   * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
   */
  setAnimationLoop(callback: Function | null): void;

  /**
   * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
   */
  animate(callback: Function): void;

  /**
   * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.
   */
  compile(scene: Scene, camera: Camera): void;

  /**
   * Render a scene using a camera.
   * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
   * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
   *
   * By default render buffers are cleared before rendering but you can prevent this by setting the property
   * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
   * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
   * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
   * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
   */
  render(scene: Scene, camera: Camera): void;

  /**
   * Returns the current active cube face.
   */
  getActiveCubeFace(): number;

  /**
   * Returns the current active mipmap level.
   */
  getActiveMipmapLevel(): number;

  /**
   * Returns the current render target. If no render target is set, null is returned.
   */
  getRenderTarget(): RenderTarget | null;

  /**
   * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
   */
  getCurrentRenderTarget(): RenderTarget | null;

  /**
   * Sets the active render target.
   *
   * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
   * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLRenderTargetCube}.
   * @param activeMipmapLevel Specifies the active mipmap level.
   */
  setRenderTarget(
    renderTarget: RenderTarget | null,
    activeCubeFace?: number,
    activeMipmapLevel?: number,
  ): void;

  readRenderTargetPixels(
    renderTarget: RenderTarget,
    x: number,
    y: number,
    width: number,
    height: number,
    buffer: any,
    activeCubeFaceIndex?: number,
  ): void;

  /**
   * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
   * This region is defined by the size of the destination texture's mip level, offset by the input position.
   *
   * @param position Specifies the pixel offset from which to copy out of the framebuffer.
   * @param texture Specifies the destination texture.
   * @param level Specifies the destination mipmap level of the texture.
   */
  copyFramebufferToTexture(
    position: Vector2,
    texture: Texture,
    level?: number,
  ): void;

  /**
   * Copies srcTexture to the specified level of dstTexture, offset by the input position.
   *
   * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
   * @param srcTexture Specifies the source texture.
   * @param dstTexture Specifies the destination texture.
   * @param level Specifies the destination mipmap level of the texture.
   */
  copyTextureToTexture(
    position: Vector2,
    srcTexture: Texture,
    dstTexture: Texture,
    level?: number,
  ): void;

  /**
   * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @param texture The texture to Initialize.
   */
  initTexture(texture: Texture): void;

  /**
   * @deprecated
   */
  gammaFactor: number;

  /**
   * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
   */
  shadowMapEnabled: boolean;

  /**
   * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
   */
  shadowMapType: ShadowMapType;

  /**
   * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
   */
  shadowMapCullFace: CullFace;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
   */
  supportsFloatTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
   */
  supportsHalfFloatTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
   */
  supportsStandardDerivatives(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
   */
  supportsCompressedTextureS3TC(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
   */
  supportsCompressedTexturePVRTC(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
   */
  supportsBlendMinMax(): any;

  /**
   * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
   */
  supportsVertexTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
   */
  supportsInstancedArrays(): any;

  /**
   * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
   */
  enableScissorTest(boolean: any): any;
}
import { IUniform } from './UniformsLib';

export interface Shader {
  uniforms: { [uniform: string]: IUniform };
  vertexShader: string;
  fragmentShader: string;
}

export let ShaderLib: {
  [name: string]: Shader;
  basic: Shader;
  lambert: Shader;
  phong: Shader;
  standard: Shader;
  matcap: Shader;
  points: Shader;
  dashed: Shader;
  depth: Shader;
  normal: Shader;
  sprite: Shader;
  background: Shader;
  cube: Shader;
  equirect: Shader;
  distanceRGBA: Shader;
  shadow: Shader;
  physical: Shader;
};
export interface IUniform {
  value: any;
}

export let UniformsLib: {
  common: {
    diffuse: IUniform;
    opacity: IUniform;
    map: IUniform;
    uvTransform: IUniform;
    alphaMap: IUniform;
  };
  specularmap: {
    specularMap: IUniform;
  };
  envmap: {
    envMap: IUniform;
    flipEnvMap: IUniform;
    reflectivity: IUniform;
    refractionRatio: IUniform;
    maxMipLevel: IUniform;
  };
  aomap: {
    aoMap: IUniform;
    aoMapIntensity: IUniform;
  };
  lightmap: {
    lightMap: IUniform;
    lightMapIntensity: IUniform;
  };
  emissivemap: {
    emissiveMap: IUniform;
  };
  bumpmap: {
    bumpMap: IUniform;
    bumpScale: IUniform;
  };
  normalmap: {
    normalMap: IUniform;
    normalScale: IUniform;
  };
  displacementmap: {
    displacementMap: IUniform;
    displacementScale: IUniform;
    displacementBias: IUniform;
  };
  roughnessmap: {
    roughnessMap: IUniform;
  };
  metalnessmap: {
    metalnessMap: IUniform;
  };
  gradientmap: {
    gradientMap: IUniform;
  };
  fog: {
    fogDensity: IUniform;
    fogNear: IUniform;
    fogFar: IUniform;
    fogColor: IUniform;
  };
  lights: {
    ambientLightColor: IUniform;
    directionalLights: {
      value: any[];
      properties: {
        direction: {};
        color: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    directionalShadowMap: IUniform;
    directionalShadowMatrix: IUniform;
    spotLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        direction: {};
        distance: {};
        coneCos: {};
        penumbraCos: {};
        decay: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    spotShadowMap: IUniform;
    spotShadowMatrix: IUniform;
    pointLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        decay: {};
        distance: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    pointShadowMap: IUniform;
    pointShadowMatrix: IUniform;
    hemisphereLights: {
      value: any[];
      properties: {
        direction: {};
        skycolor: {};
        groundColor: {};
      };
    };
    rectAreaLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        width: {};
        height: {};
      };
    };
  };
  points: {
    diffuse: IUniform;
    opacity: IUniform;
    size: IUniform;
    scale: IUniform;
    map: IUniform;
    uvTransform: IUniform;
  };
};
export function cloneUniforms(uniforms_src: any): any;
export function mergeUniforms(uniforms: any[]): any;

export namespace UniformsUtils {
  export { mergeUniforms as merge, cloneUniforms as clone };
}
// Renderers / Shaders /////////////////////////////////////////////////////////////////////
export let ShaderChunk: {
  [name: string]: string;

  alphamap_fragment: string;
  alphamap_pars_fragment: string;
  alphatest_fragment: string;
  aomap_fragment: string;
  aomap_pars_fragment: string;
  begin_vertex: string;
  beginnormal_vertex: string;
  bsdfs: string;
  bumpmap_pars_fragment: string;
  clipping_planes_fragment: string;
  clipping_planes_pars_fragment: string;
  clipping_planes_pars_vertex: string;
  clipping_planes_vertex: string;
  color_fragment: string;
  color_pars_fragment: string;
  color_pars_vertex: string;
  color_vertex: string;
  common: string;
  cube_frag: string;
  cube_vert: string;
  cube_uv_reflection_fragment: string;
  defaultnormal_vertex: string;
  depth_frag: string;
  depth_vert: string;
  distanceRGBA_frag: string;
  distanceRGBA_vert: string;
  displacementmap_vertex: string;
  displacementmap_pars_vertex: string;
  emissivemap_fragment: string;
  emissivemap_pars_fragment: string;
  encodings_pars_fragment: string;
  encodings_fragment: string;
  envmap_fragment: string;
  envmap_common_pars_fragment: string;
  envmap_pars_fragment: string;
  envmap_pars_vertex: string;
  envmap_vertex: string;
  equirect_frag: string;
  equirect_vert: string;
  fog_fragment: string;
  fog_pars_fragment: string;
  linedashed_frag: string;
  linedashed_vert: string;
  lightmap_fragment: string;
  lightmap_pars_fragment: string;
  lights_lambert_vertex: string;
  lights_pars_begin: string;
  envmap_physical_pars_fragment: string;
  lights_pars_map: string;
  lights_phong_fragment: string;
  lights_phong_pars_fragment: string;
  lights_physical_fragment: string;
  lights_physical_pars_fragment: string;
  lights_fragment_begin: string;
  lights_fragment_maps: string;
  lights_fragment_end: string;
  logdepthbuf_fragment: string;
  logdepthbuf_pars_fragment: string;
  logdepthbuf_pars_vertex: string;
  logdepthbuf_vertex: string;
  map_fragment: string;
  map_pars_fragment: string;
  map_particle_fragment: string;
  map_particle_pars_fragment: string;
  meshbasic_frag: string;
  meshbasic_vert: string;
  meshlambert_frag: string;
  meshlambert_vert: string;
  meshphong_frag: string;
  meshphong_vert: string;
  meshphysical_frag: string;
  meshphysical_vert: string;
  metalnessmap_fragment: string;
  metalnessmap_pars_fragment: string;
  morphnormal_vertex: string;
  morphtarget_pars_vertex: string;
  morphtarget_vertex: string;
  normal_flip: string;
  normal_frag: string;
  normal_fragment_begin: string;
  normal_fragment_maps: string;
  normal_vert: string;
  normalmap_pars_fragment: string;
  clearcoat_normal_fragment_begin: string;
  clearcoat_normal_fragment_maps: string;
  clearcoat_normalmap_pars_fragment: string;
  packing: string;
  points_frag: string;
  points_vert: string;
  shadow_frag: string;
  shadow_vert: string;

  premultiplied_alpha_fragment: string;
  project_vertex: string;
  roughnessmap_fragment: string;
  roughnessmap_pars_fragment: string;
  shadowmap_pars_fragment: string;
  shadowmap_pars_vertex: string;
  shadowmap_vertex: string;
  shadowmask_pars_fragment: string;
  skinbase_vertex: string;
  skinning_pars_vertex: string;
  skinning_vertex: string;
  skinnormal_vertex: string;
  specularmap_fragment: string;
  specularmap_pars_fragment: string;
  tonemapping_fragment: string;
  tonemapping_pars_fragment: string;
  uv2_pars_fragment: string;
  uv2_pars_vertex: string;
  uv2_vertex: string;
  uv_pars_fragment: string;
  uv_pars_vertex: string;
  uv_vertex: string;
  worldpos_vertex: string;
};
import { Color } from '../math/Color';
import { IFog } from './Fog';
/**
 * This class contains the parameters that define linear fog, i.e., that grows exponentially denser with the distance.
 */
export class FogExp2 implements IFog {
  constructor(hex: number | string, density?: number);

  name: string;
  color: Color;

  /**
   * Defines how fast the fog will grow dense.
   * Default is 0.00025.
   */
  density: number;

  clone(): this;
  toJSON(): any;
}
import { Color } from '../math/Color';

export interface IFog {
  name: string;
  color: Color;
  clone(): this;
  toJSON(): any;
}

/**
 * This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.
 */
export class Fog implements IFog {
  constructor(hex: number, near?: number, far?: number);

  name: string;

  /**
   * Fog color.
   */
  color: Color;

  /**
   * The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
   */
  near: number;

  /**
   * The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.
   * Default is 1000.
   */
  far: number;

  clone(): this;
  toJSON(): any;
}
import { IFog } from './Fog';
import { Material } from '../materials/Material';
import { Object3D } from '../core/Object3D';
import { Color } from '../math/Color';
import { Texture } from '../textures/Texture';
// Scenes /////////////////////////////////////////////////////////////////////

/**
 * Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
 */
export class Scene extends Object3D {
  constructor();

  type: 'Scene';

  /**
   * A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.
   */
  fog: IFog | null;

  /**
   * If not null, it will force everything in the scene to be rendered with that material. Default is null.
   */
  overrideMaterial: Material | null;
  autoUpdate: boolean;
  background: null | Color | Texture;

  toJSON(meta?: any): any;
  dispose(): void;
}
import { Vector2 } from '../math/Vector2';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { Intersection } from '../core/Raycaster';
import { SpriteMaterial } from '../materials/Materials';
import { BufferGeometry } from '../core/BufferGeometry';

export class Sprite extends Object3D {
  constructor(material?: SpriteMaterial);

  type: 'Sprite';
  isSprite: true;

  geometry: BufferGeometry;
  material: SpriteMaterial;
  center: Vector2;

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  copy(source: this): this;
}
import { Object3D } from '../core/Object3D';
import { Raycaster } from '../core/Raycaster';
import { Camera } from '../cameras/Camera';
import { Intersection } from '../core/Raycaster';

export class LOD extends Object3D {
  constructor();

  type: 'LOD';

  levels: { distance: number; object: Object3D }[];

  addLevel(object: Object3D, distance?: number): this;
  getObjectForDistance(distance: number): Object3D;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  update(camera: Camera): void;
  toJSON(meta: any): any;

  /**
   * @deprecated Use {@link LOD#levels .levels} instead.
   */
  objects: any[];
}
import { Geometry } from '../core/Geometry';
import { BufferGeometry } from '../core/BufferGeometry';
import { Material } from '../materials/Material';
import { BufferAttribute } from '../core/BufferAttribute.js.js';
import { Mesh } from './Mesh';
import { Matrix4 } from '../math/Matrix4';

export class InstancedMesh extends Mesh {
  constructor(
    geometry: Geometry | BufferGeometry,
    material: Material | Material[],
    count: number,
  );

  count: number;
  instanceMatrix: BufferAttribute;
  isInstancedMesh: true;

  setMatrixAt(index: number, matrix: Matrix4): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Matrix4 } from '../math/Matrix4';
import { Skeleton } from './Skeleton';
import { Mesh } from './Mesh';
import { BufferGeometry } from '../core/BufferGeometry';

export class SkinnedMesh extends Mesh {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    useVertexTexture?: boolean,
  );

  bindMode: string;
  bindMatrix: Matrix4;
  bindMatrixInverse: Matrix4;
  skeleton: Skeleton;

  bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
  pose(): void;
  normalizeSkinWeights(): void;
  updateMatrixWorld(force?: boolean): void;
}
import { Bone } from './Bone';
import { Matrix4 } from '../math/Matrix4';
import { DataTexture } from '../textures/DataTexture';

/**
 * @deprecated Use {@link Points THREE.Points} instead.
 */
/**
 * @deprecated Use {@link Points THREE.Points} instead.
 */

export class Skeleton {
  constructor(bones: Bone[], boneInverses?: Matrix4[]);

  /**
   * @deprecated This property has been removed completely.
   */
  useVertexTexture: boolean;
  identityMatrix: Matrix4;
  bones: Bone[];
  boneTextureWidth: number;
  boneTextureHeight: number;
  boneMatrices: Float32Array;
  boneTexture: DataTexture;
  boneInverses: Matrix4[];

  calculateInverses(bone: Bone): void;
  pose(): void;
  update(): void;
  clone(): this;
}
import { Object3D } from '../core/Object3D';

// Objects //////////////////////////////////////////////////////////////////////////////////

export class Bone extends Object3D {
  constructor();
  isBone: true;
  type: 'Bone';
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';
import { TrianglesDrawModes } from '../constants';

export class Mesh extends Object3D {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  geometry: Geometry | BufferGeometry;
  material: Material | Material[];
  drawMode: TrianglesDrawModes;
  morphTargetInfluences?: number[];
  morphTargetDictionary?: { [key: string]: number };
  isMesh: true;
  type: string;

  setDrawMode(drawMode: TrianglesDrawModes): void;
  updateMorphTargets(): void;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Line } from './Line';
import { BufferGeometry } from '../core/BufferGeometry';

/**
 * @deprecated
 */
export const LineStrip: number;
/**
 * @deprecated
 */
export const LinePieces: number;

export class LineSegments extends Line {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    mode?: number,
  );

  type: 'LineSegments';
  isLineSegments: true;
}
import { Line } from './Line';
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { BufferGeometry } from '../core/BufferGeometry';

export class LineLoop extends Line {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  type: 'LineLoop';
  isLineLoop: true;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';

export class Line extends Object3D {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    mode?: number,
  );

  geometry: Geometry | BufferGeometry;
  material: Material | Material[];

  type: 'Line' | 'LineLoop' | 'LineSegments';
  isLine: true;

  computeLineDistances(): this;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';

/**
 * A class for displaying particles in the form of variable size points. For example, if using the WebGLRenderer, the particles are displayed using GL_POINTS.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/objects/ParticleSystem.js">src/objects/ParticleSystem.js</a>
 */
export class Points extends Object3D {
  /**
   * @param geometry An instance of Geometry or BufferGeometry.
   * @param material An instance of Material (optional).
   */
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  type: 'Points';
  morphTargetInfluences?: number[];
  morphTargetDictionary?: { [key: string]: number };
  isPoints: true;

  /**
   * An instance of Geometry or BufferGeometry, where each vertex designates the position of a particle in the system.
   */
  geometry: Geometry | BufferGeometry;

  /**
   * An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour.
   */
  material: Material | Material[];

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  updateMorphTargets(): void;
}
import { Object3D } from '../core/Object3D';

export class Group extends Object3D {
  constructor();
  type: 'Group';
  isGroup: true;
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
} from '../constants';

export class VideoTexture extends Texture {
  constructor(
    video: HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
  );
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';
import { TypedArray } from '../polyfills';

export class DataTexture extends Texture {
  constructor(
    data: TypedArray,
    width: number,
    height: number,
    format?: PixelFormat,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  image: ImageData;
}
import { Texture } from './Texture';
import { TypedArray } from '../polyfills';

export class DataTexture3D extends Texture {
  constructor(data: TypedArray, width: number, height: number, depth: number);
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  CompressedPixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

export class CompressedTexture extends Texture {
  constructor(
    mipmaps: ImageData[],
    width: number,
    height: number,
    format?: CompressedPixelFormat,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  image: { width: number; height: number };
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

export class CubeTexture extends Texture {
  constructor(
    images?: any[], // HTMLImageElement or HTMLCanvasElement
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  images: any; // returns and sets the value of Texture.image in the codde ?
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
} from '../constants';

export class CanvasTexture extends Texture {
  constructor(
    canvas: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
  );
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  TextureDataType,
} from '../constants';

export class DepthTexture extends Texture {
  constructor(
    width: number,
    heighht: number,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
  );

  image: { width: number; height: number };
}
import { Vector2, Vector } from '../math/Vector2';
import { EventDispatcher } from '../core/EventDispatcher';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

// Textures /////////////////////////////////////////////////////////////////////
export let TextureIdCount: number;

export class Texture extends EventDispatcher {
  constructor(
    image?: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  id: number;
  uuid: string;
  name: string;
  sourceFile: string;
  image: any; // HTMLImageElement or ImageData or { width: number, height: number } in some children;
  mipmaps: ImageData[];
  mapping: Mapping;
  wrapS: Wrapping;
  wrapT: Wrapping;
  magFilter: TextureFilter;
  minFilter: TextureFilter;
  anisotropy: number;
  format: PixelFormat;
  type: TextureDataType;
  offset: Vector2;
  repeat: Vector2;
  center: Vector2;
  rotation: number;
  generateMipmaps: boolean;
  premultiplyAlpha: boolean;
  flipY: boolean;
  unpackAlignment: number;
  encoding: TextureEncoding;
  version: number;
  needsUpdate: boolean;
  onUpdate: () => void;
  static DEFAULT_IMAGE: any;
  static DEFAULT_MAPPING: any;

  clone(): this;
  copy(source: Texture): this;
  toJSON(meta: any): any;
  dispose(): void;
  transformUv(uv: Vector): void;
}
export * from './WireframeGeometry';
export * from './ParametricGeometry';
export * from './TetrahedronGeometry';
export * from './OctahedronGeometry';
export * from './IcosahedronGeometry';
export * from './DodecahedronGeometry';
export * from './PolyhedronGeometry';
export * from './TubeGeometry';
export * from './TorusKnotGeometry';
export * from './TorusGeometry';
export * from './TextGeometry';
export * from './SphereGeometry';
export * from './RingGeometry';
export * from './PlaneGeometry';
export * from './LatheGeometry';
export * from './ShapeGeometry';
export * from './ExtrudeGeometry';
export * from './EdgesGeometry';
export * from './ConeGeometry';
export * from './CylinderGeometry';
export * from './CircleGeometry';
export * from './BoxGeometry';
export * from './ShadowMaterial';
export * from './SpriteMaterial';
export * from './RawShaderMaterial';
export * from './ShaderMaterial';
export * from './PointsMaterial';
export * from './MeshPhysicalMaterial';
export * from './MeshStandardMaterial';
export * from './MeshPhongMaterial';
export * from './MeshToonMaterial';
export * from './MeshNormalMaterial';
export * from './MeshLambertMaterial';
export * from './MeshDepthMaterial';
export * from './MeshDistanceMaterial';
export * from './MeshBasicMaterial';
export * from './MeshMatcapMaterial';
export * from './LineDashedMaterial';
export * from './LineBasicMaterial';
export * from './Material';
import { LoadingManager } from './LoadingManager';
import { Loader } from './Loader';
import { AnimationClip } from '../animation/AnimationClip';

export class AnimationLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
  parse(json: any): AnimationClip[];
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { CompressedTexture } from '../textures/CompressedTexture';

export class CompressedTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (texture: CompressedTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { DataTexture } from '../textures/DataTexture';

export class DataTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (dataTexture: DataTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { CubeTexture } from '../textures/CubeTexture';

export class CubeTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    urls: Array<string>,
    onLoad?: (texture: CubeTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): CubeTexture;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Texture } from '../textures/Texture';

/**
 * Class for loading a texture.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
export class TextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (texture: Texture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): Texture;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Object3D } from '../core/Object3D';
import { Texture } from '../textures/Texture';
import { Material } from '../materials/Material';
import { AnimationClip } from '../animation/AnimationClip';

export class ObjectLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: <ObjectType extends Object3D>(object: ObjectType) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: Error | ErrorEvent) => void,
  ): void;
  parse<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void): T;
  parseGeometries(json: any): any[]; // Array of BufferGeometry or Geometry or Geometry2.
  parseMaterials(json: any, textures: Texture[]): Material[]; // Array of Classes that inherits from Matrial.
  parseAnimations(json: any): AnimationClip[];
  parseImages(
    json: any,
    onLoad: () => void,
  ): { [key: string]: HTMLImageElement };
  parseTextures(json: any, images: any): Texture[];
  parseObject<T extends Object3D>(
    data: any,
    geometries: any[],
    materials: Material[],
  ): T;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Texture } from '../textures/Texture';
import { Material } from '../materials/Material';

export class MaterialLoader extends Loader {
  constructor(manager?: LoadingManager);

  textures: { [key: string]: Texture };

  load(
    url: string,
    onLoad: (material: Material) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: Error | ErrorEvent) => void,
  ): void;
  setTextures(textures: { [key: string]: Texture }): this;
  parse(json: any): Material;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { BufferGeometry } from '../core/BufferGeometry';

export class BufferGeometryLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (bufferGeometry: BufferGeometry) => void,
    onProgress?: (event: any) => void,
    onError?: (event: any) => void,
  ): void;
  parse(json: any): BufferGeometry;
}
import { Loader } from './Loader';

export const DefaultLoadingManager: LoadingManager;

/**
 * Handles and keeps track of loaded and pending data.
 */
export class LoadingManager {
  constructor(
    onLoad?: () => void,
    onProgress?: (url: string, loaded: number, total: number) => void,
    onError?: (url: string) => void,
  );

  onStart?: (url: string, loaded: number, total: number) => void;

  /**
   * Will be called when load starts.
   * The default is a function with empty body.
   */
  onLoad: () => void;

  /**
   * Will be called while load progresses.
   * The default is a function with empty body.
   */
  onProgress: (item: any, loaded: number, total: number) => void;

  /**
   * Will be called when each element in the scene completes loading.
   * The default is a function with empty body.
   */
  onError: (url: string) => void;

  /**
   * If provided, the callback will be passed each resource URL before a request is sent.
   * The callback may return the original URL, or a new URL to override loading behavior.
   * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
   * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
   */
  setURLModifier(callback?: (url: string) => string): this;

  /**
   * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
   * If no URL modifier is set, returns the original URL.
   * @param url the url to load
   */
  resolveURL(url: string): string;

  itemStart(url: string): void;
  itemEnd(url: string): void;
  itemError(url: string): void;

  // handlers

  addHandler(regex: RegExp, loader: Loader): this;
  removeHandler(regex: RegExp): this;
  getHandler(file: string): Loader | null;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

/**
 * A loader for loading an image.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
export class ImageLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (image: HTMLImageElement) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): HTMLImageElement;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager.js.js';

export class ImageBitmapLoader extends Loader {
  constructor(manager?: LoadingManager);

  options: undefined | object;

  setOptions(options: object): ImageBitmapLoader;
  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Font } from '../extras/core/Font';

export class FontLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (responseFont: Font) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
  parse(json: any): Font;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

export class FileLoader extends Loader {
  constructor(manager?: LoadingManager);

  mimeType: undefined | MimeType;
  responseType: undefined | string;
  withCredentials: undefined | string;
  requestHeader: undefined | { [header: string]: string };

  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
  setMimeType(mimeType: MimeType): FileLoader;
  setResponseType(responseType: string): FileLoader;
  setWithCredentials(value: string): FileLoader;
  setRequestHeader(value: { [header: string]: string }): FileLoader;
}
import { LoadingManager } from './LoadingManager';

/**
 * Base class for implementing loaders.
 */
export class Loader {
  constructor(manager?: LoadingManager);

  crossOrigin: string;
  path: string;
  resourcePath: string;
  manager: LoadingManager;

  /*
	load(): void;
	parse(): void;
	*/

  setCrossOrigin(crossOrigin: string): this;
  setPath(path: string): this;
  setResourcePath(resourcePath: string): this;
}
import { TypedArray } from '../polyfills';

export class LoaderUtils {
  static decodeText(array: TypedArray): string;
  static extractUrlBase(url: string): string;
}
export namespace Cache {
  export let enabled: boolean;
  export let files: any;

  export function add(key: string, file: any): void;
  export function get(key: string): any;
  export function remove(key: string): void;
  export function clear(): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

export class AudioLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: Function,
    onPrgress: Function,
    onError: Function,
  ): void;
}
import { PerspectiveCamera } from '../cameras/PerspectiveCamera';
import { LightShadow } from './LightShadow';

export class SpotLightShadow extends LightShadow {
  camera: PerspectiveCamera;
}
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';
import { SpotLightShadow } from './SpotLightShadow';
import { Light } from './Light';

/**
 * A point light that can cast shadow in one direction.
 */
export class SpotLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    distance?: number,
    angle?: number,
    exponent?: number,
    decay?: number,
  );

  /**
   * Spotlight focus points at target.position.
   * Default position — (0,0,0).
   */
  target: Object3D;

  /**
   * Light's intensity.
   * Default — 1.0.
   */
  intensity: number;

  /**
   * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
   * Default — 0.0.
   */
  distance: number;

  /*
   * Maximum extent of the spotlight, in radians, from its direction.
   * Default — Math.PI/2.
   */
  angle: number;

  /**
   * Rapidity of the falloff of light from its target direction.
   * Default — 10.0.
   */
  exponent: number;

  decay: number;
  shadow: SpotLightShadow;
  power: number;
  penumbra: number;
}
import { Color } from '../math/Color';
import { Light } from './Light';
import { PerspectiveCamera } from '../cameras/PerspectiveCamera';
import { LightShadow } from './LightShadow';

export class PointLightShadow extends LightShadow {
  camera: PerspectiveCamera;
}

/**
 * Affects objects using {@link MeshLambertMaterial} or {@link MeshPhongMaterial}.
 *
 * @example
 * var light = new THREE.PointLight( 0xff0000, 1, 100 );
 * light.position.set( 50, 50, 50 );
 * scene.add( light );
 */
export class PointLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    distance?: number,
    decay?: number,
  );

  /*
   * Light's intensity.
   * Default - 1.0.
   */
  intensity: number;

  /**
   * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
   * Default — 0.0.
   */
  distance: number;

  decay: number;
  shadow: PointLightShadow;
  power: number;
}
import { Light } from './Light';
import { Color } from '../math/Color';

export class RectAreaLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    width?: number,
    height?: number,
  );

  type: string;
  width: number;
  height: number;
  intensity: number;
}
import { Color } from '../math/Color';
import { Light } from './Light';

export class HemisphereLight extends Light {
  constructor(
    skyColor?: Color | string | number,
    groundColor?: Color | string | number,
    intensity?: number,
  );

  skyColor: Color;
  groundColor: Color;
  intensity: number;
}
import { OrthographicCamera } from '../cameras/OrthographicCamera';
import { LightShadow } from './LightShadow';

export class DirectionalLightShadow extends LightShadow {
  camera: OrthographicCamera;
}
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';
import { DirectionalLightShadow } from './DirectionalLightShadow';
import { Light } from './Light';

/**
 * Affects objects using MeshLambertMaterial or MeshPhongMaterial.
 *
 * @example
 * // White directional light at half intensity shining from the top.
 * var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
 * directionalLight.position.set( 0, 1, 0 );
 * scene.add( directionalLight );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/lights/DirectionalLight.js">src/lights/DirectionalLight.js</a>
 */
export class DirectionalLight extends Light {
  constructor(color?: Color | string | number, intensity?: number);

  /**
   * Target used for shadow camera orientation.
   */
  target: Object3D;

  /**
   * Light's intensity.
   * Default — 1.0.
   */
  intensity: number;

  shadow: DirectionalLightShadow;
}
import { Color } from '../math/Color';
import { Light } from './Light';

/**
 * This light's color gets applied to all the objects in the scene globally.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/lights/AmbientLight.js
 */
export class AmbientLight extends Light {
  /**
   * This creates a Ambientlight with a color.
   * @param color Numeric value of the RGB component of the color or a Color instance.
   */
  constructor(color?: Color | string | number, intensity?: number);

  castShadow: boolean;
}
import { Camera } from '../cameras/Camera';
import { Light } from '../lights/Light';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Matrix4 } from '../math/Matrix4';
import { RenderTarget } from '../renderers/webgl/WebGLRenderLists';

export class LightShadow {
  constructor(camera: Camera);

  camera: Camera;
  bias: number;
  radius: number;
  mapSize: Vector2;
  map: RenderTarget;
  mapPass: RenderTarget;
  matrix: Matrix4;

  copy(source: LightShadow): this;
  clone(recursive?: boolean): this;
  toJSON(): any;
  getFrustum(): number;
  updateMatrices(light: Light, viewportIndex?: number): void;
  getViewport(viewportIndex: number): Vector4;
  getFrameExtents(): Vector2;
}
import { Color } from '../math/Color';
import { LightShadow } from './LightShadow';
import { Object3D } from '../core/Object3D';

// Lights //////////////////////////////////////////////////////////////////////////////////

/**
 * Abstract base class for lights.
 */
export class Light extends Object3D {
  constructor(hex?: number | string, intensity?: number);

  color: Color;
  intensity: number;
  isLight: true;
  receiveShadow: boolean;
  shadow: LightShadow;
  /**
   * @deprecated Use shadow.camera.fov instead.
   */
  shadowCameraFov: any;
  /**
   * @deprecated Use shadow.camera.left instead.
   */
  shadowCameraLeft: any;
  /**
   * @deprecated Use shadow.camera.right instead.
   */
  shadowCameraRight: any;
  /**
   * @deprecated Use shadow.camera.top instead.
   */
  shadowCameraTop: any;
  /**
   * @deprecated Use shadow.camera.bottom instead.
   */
  shadowCameraBottom: any;
  /**
   * @deprecated Use shadow.camera.near instead.
   */
  shadowCameraNear: any;
  /**
   * @deprecated Use shadow.camera.far instead.
   */
  shadowCameraFar: any;
  /**
   * @deprecated Use shadow.bias instead.
   */
  shadowBias: any;
  /**
   * @deprecated Use shadow.mapSize.width instead.
   */
  shadowMapWidth: any;
  /**
   * @deprecated Use shadow.mapSize.height instead.
   */
  shadowMapHeight: any;
}
import { Color } from '../math/Color';
import { LightProbe } from './LightProbe';

export class AmbientLightProbe extends LightProbe {
  constructor(color?: Color | string | number, intensity?: number);

  isAmbientLightProbe: true;
}
import { Color } from '../math/Color';
import { LightProbe } from './LightProbe';

export class HemisphereLightProbe extends LightProbe {
  constructor(
    skyColor?: Color | string | number,
    groundColor?: Color | string | number,
    intensity?: number,
  );

  isHemisphereLightProbe: true;
}
import { SphericalHarmonics3 } from '../math/SphericalHarmonics3';
import { Light } from './Light';

export class LightProbe extends Light {
  constructor(sh?: SphericalHarmonics3, intensity?: number);

  isLightProbe: true;
  sh: SphericalHarmonics3;
}
import { PerspectiveCamera } from './PerspectiveCamera';
import { Camera } from './Camera';

export class StereoCamera extends Camera {
  constructor();

  type: 'StereoCamera';

  aspect: number;
  eyeSep: number;
  cameraL: PerspectiveCamera;
  cameraR: PerspectiveCamera;

  update(camera: PerspectiveCamera): void;
}
import { Camera } from './Camera';

/**
 * Camera with perspective projection.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/cameras/PerspectiveCamera.js
 */
export class PerspectiveCamera extends Camera {
  /**
   * @param fov Camera frustum vertical field of view. Default value is 50.
   * @param aspect Camera frustum aspect ratio. Default value is 1.
   * @param near Camera frustum near plane. Default value is 0.1.
   * @param far Camera frustum far plane. Default value is 2000.
   */
  constructor(fov?: number, aspect?: number, near?: number, far?: number);

  type: 'PerspectiveCamera';

  isPerspectiveCamera: true;

  zoom: number;

  /**
   * Camera frustum vertical field of view, from bottom to top of view, in degrees.
   */
  fov: number;

  /**
   * Camera frustum aspect ratio, window width divided by window height.
   */
  aspect: number;

  /**
   * Camera frustum near plane.
   */
  near: number;

  /**
   * Camera frustum far plane.
   */
  far: number;

  focus: number;
  view: null | {
    enabled: boolean;
    fullWidth: number;
    fullHeight: number;
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
  };
  filmGauge: number;
  filmOffset: number;

  setFocalLength(focalLength: number): void;
  getFocalLength(): number;
  getEffectiveFOV(): number;
  getFilmWidth(): number;
  getFilmHeight(): number;

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:
   *
   *		 +---+---+---+
   *		 | A | B | C |
   *		 +---+---+---+
   *		 | D | E | F |
   *		 +---+---+---+
   *
   * then for each monitor you would call it like this:
   *
   *		 var w = 1920;
   *		 var h = 1080;
   *		 var fullWidth = w * 3;
   *		 var fullHeight = h * 2;
   *
   *		 // A
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *		 // B
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *		 // C
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *		 // D
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *		 // E
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *		 // F
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param fullWidth full width of multiview setup
   * @param fullHeight full height of multiview setup
   * @param x horizontal offset of subcamera
   * @param y vertical offset of subcamera
   * @param width width of subcamera
   * @param height height of subcamera
   */
  setViewOffset(
    fullWidth: number,
    fullHeight: number,
    x: number,
    y: number,
    width: number,
    height: number,
  ): void;
  clearViewOffset(): void;

  /**
   * Updates the camera projection matrix. Must be called after change of parameters.
   */
  updateProjectionMatrix(): void;
  toJSON(meta?: any): any;

  /**
   * @deprecated Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.
   */
  setLens(focalLength: number, frameHeight?: number): void;
}
import { Camera } from './Camera';

/**
 * Camera with orthographic projection
 *
 * @example
 * var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
 * scene.add( camera );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/cameras/OrthographicCamera.js">src/cameras/OrthographicCamera.js</a>
 */
export class OrthographicCamera extends Camera {
  /**
   * @param left Camera frustum left plane.
   * @param right Camera frustum right plane.
   * @param top Camera frustum top plane.
   * @param bottom Camera frustum bottom plane.
   * @param near Camera frustum near plane.
   * @param far Camera frustum far plane.
   */
  constructor(
    left: number,
    right: number,
    top: number,
    bottom: number,
    near?: number,
    far?: number,
  );

  type: 'OrthographicCamera';

  isOrthographicCamera: true;

  zoom: number;
  view: null | {
    enabled: boolean;
    fullWidth: number;
    fullHeight: number;
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
  };

  /**
   * Camera frustum left plane.
   */
  left: number;

  /**
   * Camera frustum right plane.
   */
  right: number;

  /**
   * Camera frustum top plane.
   */
  top: number;

  /**
   * Camera frustum bottom plane.
   */
  bottom: number;

  /**
   * Camera frustum near plane.
   */
  near: number;

  /**
   * Camera frustum far plane.
   */
  far: number;

  /**
   * Updates the camera projection matrix. Must be called after change of parameters.
   */
  updateProjectionMatrix(): void;
  setViewOffset(
    fullWidth: number,
    fullHeight: number,
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
  ): void;
  clearViewOffset(): void;
  toJSON(meta?: any): any;
}
import { WebGLRenderTargetCube } from '../renderers/WebGLRenderTargetCube';
import { WebGLRenderTargetOptions } from '../renderers/WebGLRenderTarget';
import { Scene } from '../scenes/Scene';
import { WebGLRenderer } from '../renderers/WebGLRenderer';
import { Object3D } from '../core/Object3D';

export class CubeCamera extends Object3D {
  constructor(
    near?: number,
    far?: number,
    cubeResolution?: number,
    options?: WebGLRenderTargetOptions,
  );

  type: 'CubeCamera';

  renderTarget: WebGLRenderTargetCube;

  update(renderer: WebGLRenderer, scene: Scene): void;

  clear(
    renderer: WebGLRenderer,
    color: boolean,
    depth: boolean,
    stencil: boolean,
  ): void;
}
import { PerspectiveCamera } from './PerspectiveCamera';

export class ArrayCamera extends PerspectiveCamera {
  constructor(cameras?: PerspectiveCamera[]);

  cameras: PerspectiveCamera[];
  isArrayCamera: true;
}
import { Matrix4 } from '../math/Matrix4';
import { Vector3 } from '../math/Vector3';
import { Object3D } from '../core/Object3D';

// Cameras ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Abstract base class for cameras. This class should always be inherited when you build a new camera.
 */
export class Camera extends Object3D {
  /**
   * This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.
   */
  constructor();

  /**
   * This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.
   */
  matrixWorldInverse: Matrix4;

  /**
   * This is the matrix which contains the projection.
   */
  projectionMatrix: Matrix4;

  /**
   * This is the inverse of projectionMatrix.
   */
  projectionMatrixInverse: Matrix4;

  isCamera: true;

  getWorldDirection(target: Vector3): Vector3;

  updateMatrixWorld(force?: boolean): void;
}
import { Object3D } from '../core/Object3D';
import { AudioContext } from './AudioContext';

export class AudioListener extends Object3D {
  constructor();

  type: 'AudioListener';
  context: AudioContext;
  gain: GainNode;
  filter: null | any;

  getInput(): GainNode;
  removeFilter(): void;
  setFilter(value: any): void;
  getFilter(): any;
  setMasterVolume(value: number): void;
  getMasterVolume(): number;
  updateMatrixWorld(force?: boolean): void;
}
import { AudioListener } from './AudioListener';
import { Audio } from './Audio';

export class PositionalAudio extends Audio {
  constructor(listener: AudioListener);

  panner: PannerNode;

  setRefDistance(value: number): this;
  getRefDistance(): number;
  setRolloffFactor(value: number): this;
  getRolloffFactor(): number;
  setDistanceModel(value: string): this;
  getDistanceModel(): string;
  setMaxDistance(value: number): this;
  getMaxDistance(): number;
  setDirectionalCone(
    coneInnerAngle: number,
    coneOuterAngle: number,
    coneOuterGain: number,
  ): this;
}
export const AudioContext: AudioContext;
export class AudioAnalyser {
  constructor(audio: any, fftSize: number);

  analyser: any;
  data: Uint8Array;

  getFrequencyData(): Uint8Array;
  getAverageFrequency(): number;

  /**
   * @deprecated Use {@link AudioAnalyser#getFrequencyData .getFrequencyData()} instead.
   */
  getData(file: any): any;
}
import { Object3D } from '../core/Object3D';
import { AudioListener } from './AudioListener';
import { AudioContext } from './AudioContext';

// Extras / Audio /////////////////////////////////////////////////////////////////////

export class Audio extends Object3D {
  constructor(listener: AudioListener);
  type: 'Audio';

  context: AudioContext;
  gain: GainNode;
  autoplay: boolean;
  buffer: null | Audio;
  detune: number;
  loop: boolean;
  offset: number;
  duration: number | undefined;
  playbackRate: number;
  isPlaying: boolean;
  hasPlaybackControl: boolean;
  sourceType: string;
  source: AudioBufferSourceNode;
  filters: any[];

  getOutput(): GainNode;
  setNodeSource(audioNode: AudioBufferSourceNode): this;
  setMediaElementSource(mediaElement: HTMLMediaElement): this;
  setMediaStreamSource(mediaStream: MediaStream): this;
  setBuffer(audioBuffer: AudioBuffer): this;
  play(delay?: number): this;
  onEnded(): void;
  pause(): this;
  stop(): this;
  connect(): this;
  disconnect(): this;
  setDetune(value: number): this;
  getDetune(): number;
  getFilters(): any[];
  setFilter(value: any[]): this;
  getFilter(): any;
  setFilter(filter: any): this;
  setPlaybackRate(value: number): this;
  getPlaybackRate(): number;
  getLoop(): boolean;
  setLoop(value: boolean): this;
  setLoopStart(value: number): this;
  setLoopEnd(value: number): this;
  getVolume(): number;
  setVolume(value: number): this;
  /**
   * @deprecated Use {@link AudioLoader} instead.
   */
  load(file: string): Audio;
}

export class AudioBuffer {
  constructor(context: any);

  context: any;
  ready: boolean;
  readyCallbacks: Function[];

  load(file: string): AudioBuffer;
  onReady(callback: Function): void;
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class VectorKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class StringKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class QuaternionKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class NumberKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class ColorKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';

export class BooleanKeyframeTrack extends KeyframeTrack {
  constructor(name: string, times: any[], values: any[]);
}
export class PropertyMixer {
  constructor(binding: any, typeName: string, valueSize: number);

  binding: any;
  valueSize: number;
  buffer: any;
  cumulativeWeight: number;
  useCount: number;
  referenceCount: number;

  accumulate(accuIndex: number, weight: number): void;
  apply(accuIndex: number): void;
  saveOriginalState(): void;
  restoreOriginalState(): void;
}
export class PropertyBinding {
  constructor(rootNode: any, path: string, parsedPath?: any);

  path: string;
  parsedPath: any;
  node: any;
  rootNode: any;

  getValue(targetArray: any, offset: number): any;
  setValue(sourceArray: any, offset: number): void;
  bind(): void;
  unbind(): void;

  BindingType: { [bindingType: string]: number };
  Versioning: { [versioning: string]: number };

  GetterByBindingType: Function[];
  SetterByBindingTypeAndVersioning: Array<Function[]>;

  static create(
    root: any,
    path: any,
    parsedPath?: any,
  ): PropertyBinding | PropertyBinding.Composite;
  static parseTrackName(trackName: string): any;
  static findNode(root: any, nodeName: string): any;
}

export namespace PropertyBinding {
  export class Composite {
    constructor(targetGroup: any, path: any, parsedPath?: any);

    getValue(array: any, offset: number): any;
    setValue(array: any, offset: number): void;
    bind(): void;
    unbind(): void;
  }
}
import { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant';
import { LinearInterpolant } from '../math/interpolants/LinearInterpolant';
import { CubicInterpolant } from '../math/interpolants/CubicInterpolant';
import { InterpolationModes } from '../constants';

export class KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );

  name: string;
  times: Float32Array;
  values: Float32Array;

  ValueTypeName: string;
  TimeBufferType: Float32Array;
  ValueBufferType: Float32Array;

  DefaultInterpolation: InterpolationModes;

  InterpolantFactoryMethodDiscrete(result: any): DiscreteInterpolant;
  InterpolantFactoryMethodLinear(result: any): LinearInterpolant;
  InterpolantFactoryMethodSmooth(result: any): CubicInterpolant;

  setInterpolation(interpolation: InterpolationModes): void;
  getInterpolation(): InterpolationModes;

  getValuesize(): number;

  shift(timeOffset: number): KeyframeTrack;
  scale(timeScale: number): KeyframeTrack;
  trim(startTime: number, endTime: number): KeyframeTrack;
  validate(): boolean;
  optimize(): KeyframeTrack;

  static parse(json: any): KeyframeTrack;
  static toJSON(track: KeyframeTrack): any;
}
import { AnimationClip } from './AnimationClip';

export namespace AnimationUtils {
  export function arraySlice(array: any, from: number, to: number): any;
  export function convertArray(array: any, type: any, forceClone: boolean): any;
  export function isTypedArray(object: any): boolean;
  export function getKeyFrameOrder(times: number): number[];
  export function sortedArray(
    values: any[],
    stride: number,
    order: number[],
  ): any[];
  export function flattenJSON(
    jsonKeys: string[],
    times: any[],
    values: any[],
    valuePropertyName: string,
  ): void;
  export function subclip(
    sourceClip: AnimationClip,
    name: string,
    startFrame: number,
    endFrame: number,
    fps?: number,
  ): AnimationClip;
}
export class AnimationObjectGroup {
  constructor(...args: any[]);

  uuid: string;
  stats: {
    bindingsPerObject: number;
    objects: {
      total: number;
      inUse: number;
    };
  };

  add(...args: any[]): void;
  remove(...args: any[]): void;
  uncache(...args: any[]): void;
}
import { AnimationClip } from './AnimationClip';
import { AnimationAction } from './AnimationAction';
import { EventDispatcher } from '../core/EventDispatcher';

export class AnimationMixer extends EventDispatcher {
  constructor(root: any);

  time: number;
  timeScale: number;

  clipAction(clip: AnimationClip, root?: any): AnimationAction;
  existingAction(clip: AnimationClip, root?: any): AnimationAction;
  stopAllAction(): AnimationMixer;
  update(deltaTime: number): AnimationMixer;
  setTime(timeInSeconds: number): AnimationMixer;
  getRoot(): any;
  uncacheClip(clip: AnimationClip): void;
  uncacheRoot(root: any): void;
  uncacheAction(clip: AnimationClip, root?: any): void;
}
import { KeyframeTrack } from './KeyframeTrack';
import { Bone } from '../objects/Bone';
import { MorphTarget } from '../core/Geometry';

export class AnimationClip {
  constructor(name?: string, duration?: number, tracks?: KeyframeTrack[]);

  name: string;
  tracks: KeyframeTrack[];
  duration: number;
  uuid: string;
  results: any[];

  resetDuration(): void;
  trim(): AnimationClip;
  optimize(): AnimationClip;

  static CreateFromMorphTargetSequence(
    name: string,
    morphTargetSequence: MorphTarget[],
    fps: number,
    noLoop: boolean,
  ): AnimationClip;
  static findByName(clipArray: AnimationClip[], name: string): AnimationClip;
  static CreateClipsFromMorphTargetSequences(
    morphTargets: MorphTarget[],
    fps: number,
    noLoop: boolean,
  ): AnimationClip[];
  static parse(json: any): AnimationClip;
  static parseAnimation(
    animation: any,
    bones: Bone[],
    nodeName: string,
  ): AnimationClip;
  static toJSON(): any;
}
import { AnimationMixer } from './AnimationMixer';
import { AnimationClip } from './AnimationClip';
import { AnimationActionLoopStyles } from '../constants';
// Animation ////////////////////////////////////////////////////////////////////////////////////////

export class AnimationAction {
  loop: AnimationActionLoopStyles;
  time: number;
  timeScale: number;
  weight: number;
  repetitions: number;
  paused: boolean;
  enabled: boolean;
  clampWhenFinished: boolean;
  zeroSlopeAtStart: boolean;
  zeroSlopeAtEnd: boolean;

  play(): AnimationAction;
  stop(): AnimationAction;
  reset(): AnimationAction;
  isRunning(): boolean;
  isScheduled(): boolean;
  startAt(time: number): AnimationAction;
  setLoop(
    mode: AnimationActionLoopStyles,
    repetitions: number,
  ): AnimationAction;
  setEffectiveWeight(weight: number): AnimationAction;
  getEffectiveWeight(): number;
  fadeIn(duration: number): AnimationAction;
  fadeOut(duration: number): AnimationAction;
  crossFadeFrom(
    fadeOutAction: AnimationAction,
    duration: number,
    warp: boolean,
  ): AnimationAction;
  crossFadeTo(
    fadeInAction: AnimationAction,
    duration: number,
    warp: boolean,
  ): AnimationAction;
  stopFading(): AnimationAction;
  setEffectiveTimeScale(timeScale: number): AnimationAction;
  getEffectiveTimeScale(): number;
  setDuration(duration: number): AnimationAction;
  syncWith(action: AnimationAction): AnimationAction;
  halt(duration: number): AnimationAction;
  warp(
    statTimeScale: number,
    endTimeScale: number,
    duration: number,
  ): AnimationAction;
  stopWarping(): AnimationAction;
  getMixer(): AnimationMixer;
  getClip(): AnimationClip;
  getRoot(): any;
}
export class Uniform {
  constructor(value: any);
  /**
   * @deprecated
   */
  constructor(type: string, value: any);
  /**
   * @deprecated
   */
  type: string;
  value: any;
  /**
   * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
   */
  dynamic: boolean;
  onUpdateCallback: Function;

  /**
   * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
   */
  onUpdate(callback: Function): Uniform;
}
import { BufferGeometry } from './BufferGeometry';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferGeometry.js">src/core/InstancedBufferGeometry.js</a>
 */
export class InstancedBufferGeometry extends BufferGeometry {
  constructor();

  groups: { start: number; count: number; instances: number }[];
  maxInstancedCount: number;

  addGroup(start: number, count: number, instances: number): void;
}
import { BufferAttribute } from './BufferAttribute';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Matrix4 } from '../math/Matrix4';
import { Vector2 } from '../math/Vector2';
import { Vector3 } from '../math/Vector3';
import { Object3D } from './Object3D';
import { Geometry } from './Geometry';
import { DirectGeometry } from './DirectGeometry';
import { EventDispatcher } from './EventDispatcher';
import { InterleavedBufferAttribute } from './InterleavedBufferAttribute';

/**
 * This is a superefficent class for geometries because it saves all data in buffers.
 * It reduces memory costs and cpu cycles. But it is not as easy to work with because of all the nessecary buffer calculations.
 * It is mainly interesting when working with static objects.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js">src/core/BufferGeometry.js</a>
 */
export class BufferGeometry extends EventDispatcher {
  /**
   * This creates a new BufferGeometry. It also sets several properties to an default value.
   */
  constructor();

  static MaxIndex: number;

  /**
   * Unique number of this buffergeometry instance
   */
  id: number;
  uuid: string;
  name: string;
  type: string;
  index: BufferAttribute;
  attributes: {
    [name: string]: BufferAttribute | InterleavedBufferAttribute;
  };
  morphAttributes: {
    [name: string]: (BufferAttribute | InterleavedBufferAttribute)[];
  };
  groups: { start: number; count: number; materialIndex?: number }[];
  boundingBox: Box3;
  boundingSphere: Sphere;
  drawRange: { start: number; count: number };
  userData: { [key: string]: any };
  isBufferGeometry: boolean;

  getIndex(): BufferAttribute;
  setIndex(index: BufferAttribute | number[]): void;

  setAttribute(
    name: string,
    attribute: BufferAttribute | InterleavedBufferAttribute,
  ): BufferGeometry;
  getAttribute(name: string): BufferAttribute | InterleavedBufferAttribute;
  deleteAttribute(name: string): BufferGeometry;

  addGroup(start: number, count: number, materialIndex?: number): void;
  clearGroups(): void;

  setDrawRange(start: number, count: number): void;

  /**
   * Bakes matrix transform directly into vertex coordinates.
   */
  applyMatrix(matrix: Matrix4): BufferGeometry;

  rotateX(angle: number): BufferGeometry;
  rotateY(angle: number): BufferGeometry;
  rotateZ(angle: number): BufferGeometry;
  translate(x: number, y: number, z: number): BufferGeometry;
  scale(x: number, y: number, z: number): BufferGeometry;
  lookAt(v: Vector3): void;

  center(): BufferGeometry;

  setFromObject(object: Object3D): BufferGeometry;
  setFromPoints(points: Vector3[] | Vector2[]): BufferGeometry;
  updateFromObject(object: Object3D): void;

  fromGeometry(geometry: Geometry, settings?: any): BufferGeometry;

  fromDirectGeometry(geometry: DirectGeometry): BufferGeometry;

  /**
   * Computes bounding box of the geometry, updating Geometry.boundingBox attribute.
   * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingBox(): void;

  /**
   * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
   * Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingSphere(): void;

  /**
   * Computes vertex normals by averaging face normals.
   */
  computeVertexNormals(): void;

  merge(geometry: BufferGeometry, offset: number): BufferGeometry;
  normalizeNormals(): void;

  toNonIndexed(): BufferGeometry;

  toJSON(): any;
  clone(): this;
  copy(source: BufferGeometry): this;

  /**
   * Disposes the object from memory.
   * You need to call this when you want the bufferGeometry removed while the application is running.
   */
  dispose(): void;

  /**
   * @deprecated Use {@link BufferGeometry#groups .groups} instead.
   */
  drawcalls: any;

  /**
   * @deprecated Use {@link BufferGeometry#groups .groups} instead.
   */
  offsets: any;

  /**
   * @deprecated Use {@link BufferGeometry#setIndex .setIndex()} instead.
   */
  addIndex(index: any): void;

  /**
   * @deprecated Use {@link BufferGeometry#addGroup .addGroup()} instead.
   */
  addDrawCall(start: any, count: any, indexOffset?: any): void;

  /**
   * @deprecated Use {@link BufferGeometry#clearGroups .clearGroups()} instead.
   */
  clearDrawCalls(): void;

  /**
   * @deprecated Use {@link BufferGeometry#setAttribute .setAttribute()} instead.
   */
  addAttribute(
    name: string,
    attribute: BufferAttribute | InterleavedBufferAttribute,
  ): BufferGeometry;

  /**
   * @deprecated Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.
   */
  removeAttribute(name: string): BufferGeometry;

  addAttribute(name: any, array: any, itemSize: any): any;
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';
import { Face3 } from './Face3';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Matrix4 } from '../math/Matrix4';
import { BufferGeometry } from './BufferGeometry';
import { Matrix } from '../math/Matrix3';
import { Mesh } from '../objects/Mesh';
import { Bone } from '../objects/Bone';
import { AnimationClip } from '../animation/AnimationClip';
import { EventDispatcher } from './EventDispatcher';

/**
 * @deprecated Use {@link Face3} instead.
 */

export interface MorphTarget {
  name: string;
  vertices: Vector3[];
}

export interface MorphColor {
  name: string;
  colors: Color[];
}

export interface MorphNormals {
  name: string;
  normals: Vector3[];
}

export let GeometryIdCount: number;

/**
 * Base class for geometries
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/core/Geometry.js
 */
export class Geometry extends EventDispatcher {
  constructor();

  /**
   * Unique number of this geometry instance
   */
  id: number;

  uuid: string;

  isGeometry: boolean;

  /**
   * Name for this geometry. Default is an empty string.
   */
  name: string;

  type: string;

  /**
   * The array of vertices hold every position of points of the model.
   * To signal an update in this array, Geometry.verticesNeedUpdate needs to be set to true.
   */
  vertices: Vector3[];

  /**
   * Array of vertex colors, matching number and order of vertices.
   * Used in ParticleSystem, Line and Ribbon.
   * Meshes use per-face-use-of-vertex colors embedded directly in faces.
   * To signal an update in this array, Geometry.colorsNeedUpdate needs to be set to true.
   */
  colors: Color[];

  /**
   * Array of triangles or/and quads.
   * The array of faces describe how each vertex in the model is connected with each other.
   * To signal an update in this array, Geometry.elementsNeedUpdate needs to be set to true.
   */
  faces: Face3[];

  /**
   * Array of face UV layers.
   * Each UV layer is an array of UV matching order and number of vertices in faces.
   * To signal an update in this array, Geometry.uvsNeedUpdate needs to be set to true.
   */
  faceVertexUvs: Vector2[][][];

  /**
   * Array of morph targets. Each morph target is a Javascript object:
   *
   *		 { name: "targetName", vertices: [ new THREE.Vector3(), ... ] }
   *
   * Morph vertices match number and order of primary vertices.
   */
  morphTargets: MorphTarget[];

  /**
   * Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:
   *
   *		 morphNormal = { name: "NormalName", normals: [ new THREE.Vector3(), ... ] }
   */
  morphNormals: MorphNormals[];

  /**
   * Array of skinning weights, matching number and order of vertices.
   */
  skinWeights: Vector4[];

  /**
   * Array of skinning indices, matching number and order of vertices.
   */
  skinIndices: Vector4[];

  /**
   *
   */
  lineDistances: number[];

  /**
   * Bounding box.
   */
  boundingBox: Box3;

  /**
   * Bounding sphere.
   */
  boundingSphere: Sphere;

  /**
   * Set to true if the vertices array has been updated.
   */
  verticesNeedUpdate: boolean;

  /**
   * Set to true if the faces array has been updated.
   */
  elementsNeedUpdate: boolean;

  /**
   * Set to true if the uvs array has been updated.
   */
  uvsNeedUpdate: boolean;

  /**
   * Set to true if the normals array has been updated.
   */
  normalsNeedUpdate: boolean;

  /**
   * Set to true if the colors array has been updated.
   */
  colorsNeedUpdate: boolean;

  /**
   * Set to true if the linedistances array has been updated.
   */
  lineDistancesNeedUpdate: boolean;

  /**
   *
   */
  groupsNeedUpdate: boolean;

  /**
   * Bakes matrix transform directly into vertex coordinates.
   */
  applyMatrix(matrix: Matrix4): Geometry;

  rotateX(angle: number): Geometry;
  rotateY(angle: number): Geometry;
  rotateZ(angle: number): Geometry;

  translate(x: number, y: number, z: number): Geometry;
  scale(x: number, y: number, z: number): Geometry;
  lookAt(vector: Vector3): void;

  fromBufferGeometry(geometry: BufferGeometry): Geometry;

  center(): Geometry;

  normalize(): Geometry;

  /**
   * Computes face normals.
   */
  computeFaceNormals(): void;

  /**
   * Computes vertex normals by averaging face normals.
   * Face normals must be existing / computed beforehand.
   */
  computeVertexNormals(areaWeighted?: boolean): void;

  /**
   * Compute vertex normals, but duplicating face normals.
   */
  computeFlatVertexNormals(): void;

  /**
   * Computes morph normals.
   */
  computeMorphNormals(): void;

  /**
   * Computes bounding box of the geometry, updating {@link Geometry.boundingBox} attribute.
   */
  computeBoundingBox(): void;

  /**
   * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
   * Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingSphere(): void;

  merge(
    geometry: Geometry,
    matrix?: Matrix,
    materialIndexOffset?: number,
  ): void;

  mergeMesh(mesh: Mesh): void;

  /**
   * Checks for duplicate vertices using hashmap.
   * Duplicated vertices are removed and faces' vertices are updated.
   */
  mergeVertices(): number;

  setFromPoints(points: Array<Vector2> | Array<Vector3>): this;

  sortFacesByMaterialIndex(): void;

  toJSON(): any;

  /**
   * Creates a new clone of the Geometry.
   */
  clone(): this;

  copy(source: Geometry): this;

  /**
   * Removes The object from memory.
   * Don't forget to call this method when you remove an geometry because it can cuase meomory leaks.
   */
  dispose(): void;

  // These properties do not exist in a normal Geometry class, but if you use the instance that was passed by JSONLoader, it will be added.
  bones: Bone[];
  animation: AnimationClip;
  animations: AnimationClip[];
}
import { InterleavedBuffer } from './InterleavedBuffer';
/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBufferAttribute.js">src/core/InterleavedBufferAttribute.js</a>
 */
export class InterleavedBufferAttribute {
  constructor(
    interleavedBuffer: InterleavedBuffer,
    itemSize: number,
    offset: number,
    normalized?: boolean,
  );

  uuid: string;
  data: InterleavedBuffer;
  itemSize: number;
  offset: number;
  count: number;
  normalized: boolean;
  array: any[];

  getX(index: number): number;
  setX(index: number, x: number): InterleavedBufferAttribute;
  getY(index: number): number;
  setY(index: number, y: number): InterleavedBufferAttribute;
  getZ(index: number): number;
  setZ(index: number, z: number): InterleavedBufferAttribute;
  getW(index: number): number;
  setW(index: number, z: number): InterleavedBufferAttribute;
  setXY(index: number, x: number, y: number): InterleavedBufferAttribute;
  setXYZ(
    index: number,
    x: number,
    y: number,
    z: number,
  ): InterleavedBufferAttribute;
  setXYZW(
    index: number,
    x: number,
    y: number,
    z: number,
    w: number,
  ): InterleavedBufferAttribute;
  /**
   * @deprecated Use {@link InterleavedBufferAttribute#count .count} instead.
   */
  length: number;
}
import { InterleavedBuffer } from './InterleavedBuffer';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedInterleavedBuffer.js">src/core/InstancedInterleavedBuffer.js</a>
 */
export class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(
    array: ArrayLike<number>,
    stride: number,
    meshPerAttribute?: number,
  );

  meshPerAttribute: number;
}
import { InterleavedBufferAttribute } from './InterleavedBufferAttribute';
import { Usage } from '../constants';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBuffer.js">src/core/InterleavedBuffer.js</a>
 */
export class InterleavedBuffer {
  constructor(array: ArrayLike<number>, stride: number);

  array: ArrayLike<number>;
  stride: number;
  usage: Usage;
  updateRange: { offset: number; count: number };
  version: number;
  length: number;
  count: number;
  needsUpdate: boolean;

  setUsage(usage: Usage): InterleavedBuffer;
  clone(): this;
  copy(source: InterleavedBuffer): this;
  copyAt(
    index1: number,
    attribute: InterleavedBufferAttribute,
    index2: number,
  ): InterleavedBuffer;
  set(value: ArrayLike<number>, index: number): InterleavedBuffer;
}
import { BufferGeometry } from './BufferGeometry';
import { BufferAttribute } from './BufferAttribute';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/BufferGeometryUtils.js">examples/js/BufferGeometryUtils.js</a>
 */
export namespace BufferGeometryUtils {
  export function mergeBufferGeometries(
    geometries: BufferGeometry[],
  ): BufferGeometry;
  export function computeTangents(geometry: BufferGeometry): null;
  export function mergeBufferAttributes(
    attributes: BufferAttribute[],
  ): BufferAttribute;
}

/**
 * @deprecated
 */
export namespace GeometryUtils {
  /**
   * @deprecated Use {@link Geometry#merge geometry.merge( geometry2, matrix, materialIndexOffset )} instead.
   */
  export function merge(
    geometry1: any,
    geometry2: any,
    materialIndexOffset?: any,
  ): any;
  /**
   * @deprecated Use {@link Geometry#center geometry.center()} instead.
   */
  export function center(geometry: any): any;
}

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferAttribute.js">src/core/InstancedBufferAttribute.js</a>
 */
export class InstancedBufferAttribute extends BufferAttribute {
  constructor(
    array: ArrayLike<number>,
    itemSize: number,
    normalized?: boolean,
    meshPerAttribute?: number,
  );

  meshPerAttribute: number;
}
import { Usage } from '../constants';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferAttribute.js">src/core/BufferAttribute.js</a>
 */
export class BufferAttribute {
  constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean); // array parameter should be TypedArray.

  name: string;
  array: ArrayLike<number>;
  itemSize: number;
  usage: Usage;
  updateRange: { offset: number; count: number };
  version: number;
  normalized: boolean;
  needsUpdate: boolean;
  count: number;
  onUpload: Function;

  setUsage(usage: Usage): BufferAttribute;
  clone(): this;
  copy(source: BufferAttribute): this;
  copyAt(
    index1: number,
    attribute: BufferAttribute,
    index2: number,
  ): BufferAttribute;
  copyArray(array: ArrayLike<number>): BufferAttribute;
  copyColorsArray(
    colors: { r: number; g: number; b: number }[],
  ): BufferAttribute;
  copyVector2sArray(vectors: { x: number; y: number }[]): BufferAttribute;
  copyVector3sArray(
    vectors: { x: number; y: number; z: number }[],
  ): BufferAttribute;
  copyVector4sArray(
    vectors: { x: number; y: number; z: number; w: number }[],
  ): BufferAttribute;
  set(
    value: ArrayLike<number> | ArrayBufferView,
    offset?: number,
  ): BufferAttribute;
  getX(index: number): number;
  setX(index: number, x: number): BufferAttribute;
  getY(index: number): number;
  setY(index: number, y: number): BufferAttribute;
  getZ(index: number): number;
  setZ(index: number, z: number): BufferAttribute;
  getW(index: number): number;
  setW(index: number, z: number): BufferAttribute;
  setXY(index: number, x: number, y: number): BufferAttribute;
  setXYZ(index: number, x: number, y: number, z: number): BufferAttribute;
  setXYZW(
    index: number,
    x: number,
    y: number,
    z: number,
    w: number,
  ): BufferAttribute;
  /**
   * @deprecated Use {@link BufferAttribute#count .count} instead.
   */
  length: number;
}

/**
 * @deprecated THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.
 */
export class Int8Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.
 */
export class Uint8Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.
 */
export class Uint8ClampedAttribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.
 */
export class Int16Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.
 */
export class Uint16Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.
 */
export class Int32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.
 */
export class Uint32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.
 */
export class Float32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.
 */
export class Float64Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

export class Int8BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint8BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Int16BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint16BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Int32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Float32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Float64BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';

export interface Event {
  type: string;
  target?: any;
  [attachment: string]: any;
}

/**
 * Triangle face.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/core/Face3.js
 */
export class Face3 {
  /**
   * @param a Vertex A index.
   * @param b Vertex B index.
   * @param c Vertex C index.
   * @param normal Face normal or array of vertex normals.
   * @param color Face color or array of vertex colors.
   * @param materialIndex Material index.
   */
  constructor(
    a: number,
    b: number,
    c: number,
    normal?: Vector3,
    color?: Color,
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    normal?: Vector3,
    vertexColors?: Color[],
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    vertexNormals?: Vector3[],
    color?: Color,
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    vertexNormals?: Vector3[],
    vertexColors?: Color[],
    materialIndex?: number,
  );

  /**
   * Vertex A index.
   */
  a: number;

  /**
   * Vertex B index.
   */
  b: number;

  /**
   * Vertex C index.
   */
  c: number;

  /**
   * Face normal.
   */
  normal: Vector3;

  /**
   * Array of 4 vertex normals.
   */
  vertexNormals: Vector3[];

  /**
   * Face color.
   */
  color: Color;

  /**
   * Array of 4 vertex normals.
   */
  vertexColors: Color[];

  /**
   * Material index (points to {@link Geometry.materials}).
   */
  materialIndex: number;

  clone(): this;
  copy(source: Face3): this;
}
import { Vector3 } from '../math/Vector3';
import { Euler } from '../math/Euler';
import { Quaternion } from '../math/Quaternion';
import { Matrix4 } from '../math/Matrix4';
import { Matrix3 } from '../math/Matrix3';
import { Layers } from './Layers';
import { WebGLRenderer } from '../renderers/WebGLRenderer';
import { Scene } from '../scenes/Scene';
import { Camera } from '../cameras/Camera';
import { Geometry } from './Geometry';
import { Material } from '../materials/Material';
import { Group } from '../objects/Group';
import { Raycaster } from './Raycaster';
import { EventDispatcher } from './EventDispatcher';
import { BufferGeometry } from './BufferGeometry';
import { Intersection } from './Raycaster';

export let Object3DIdCount: number;

/**
 * Base class for scene graph objects
 */
export class Object3D extends EventDispatcher {
  constructor();

  /**
   * Unique number of this object instance.
   */
  id: number;

  /**
   *
   */
  uuid: string;

  /**
   * Optional name of the object (doesn't need to be unique).
   */
  name: string;

  type: string;

  /**
   * Object's parent in the scene graph.
   */
  parent: Object3D | null;

  /**
   * Array with object's children.
   */
  children: Object3D[];

  /**
   * Up direction.
   */
  up: Vector3;

  /**
   * Object's local position.
   */
  position: Vector3;

  /**
   * Object's local rotation (Euler angles), in radians.
   */
  rotation: Euler;

  /**
   * Global rotation.
   */
  quaternion: Quaternion;

  /**
   * Object's local scale.
   */
  scale: Vector3;

  modelViewMatrix: Matrix4;

  normalMatrix: Matrix3;

  /**
   * Local transform.
   */
  matrix: Matrix4;

  /**
   * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.
   */
  matrixWorld: Matrix4;

  /**
   * When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property.
   */
  matrixAutoUpdate: boolean;

  /**
   * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
   */
  matrixWorldNeedsUpdate: boolean;

  layers: Layers;
  /**
   * Object gets rendered if true.
   */
  visible: boolean;

  /**
   * Gets rendered into shadow map.
   */
  castShadow: boolean;

  /**
   * Material gets baked in shadow receiving.
   */
  receiveShadow: boolean;

  /**
   * When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible.
   */
  frustumCulled: boolean;

  /**
   * Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder. Opaque and transparent objects remain sorted independently though. When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.
   */
  renderOrder: number;

  /**
   * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.
   */
  userData: { [key: string]: any };

  /**
   * Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.
   * When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in
   * the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a
   * transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.
   */
  customDepthMaterial: Material;

  /**
   * Same as customDepthMaterial, but used with PointLight.
   */
  customDistanceMaterial: Material;

  /**
   * Used to check whether this or derived classes are Object3Ds. Default is true.
   * You should not change this, as it is used internally for optimisation.
   */
  isObject3D: true;

  /**
   * Calls before rendering object
   */
  onBeforeRender: (
    renderer: WebGLRenderer,
    scene: Scene,
    camera: Camera,
    geometry: Geometry | BufferGeometry,
    material: Material,
    group: Group,
  ) => void;

  /**
   * Calls after rendering object
   */
  onAfterRender: (
    renderer: WebGLRenderer,
    scene: Scene,
    camera: Camera,
    geometry: Geometry | BufferGeometry,
    material: Material,
    group: Group,
  ) => void;

  static DefaultUp: Vector3;
  static DefaultMatrixAutoUpdate: boolean;

  /**
   * This updates the position, rotation and scale with the matrix.
   */
  applyMatrix(matrix: Matrix4): void;

  applyQuaternion(quaternion: Quaternion): this;

  /**
   *
   */
  setRotationFromAxisAngle(axis: Vector3, angle: number): void;

  /**
   *
   */
  setRotationFromEuler(euler: Euler): void;

  /**
   *
   */
  setRotationFromMatrix(m: Matrix4): void;

  /**
   *
   */
  setRotationFromQuaternion(q: Quaternion): void;

  /**
   * Rotate an object along an axis in object space. The axis is assumed to be normalized.
   * @param axis	A normalized vector in object space.
   * @param angle	The angle in radians.
   */
  rotateOnAxis(axis: Vector3, angle: number): this;

  /**
   * Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.
   * @param axis	A normalized vector in object space.
   * @param angle	The angle in radians.
   */
  rotateOnWorldAxis(axis: Vector3, angle: number): this;

  /**
   *
   * @param angle
   */
  rotateX(angle: number): this;

  /**
   *
   * @param angle
   */
  rotateY(angle: number): this;

  /**
   *
   * @param angle
   */
  rotateZ(angle: number): this;

  /**
   * @param axis	A normalized vector in object space.
   * @param distance	The distance to translate.
   */
  translateOnAxis(axis: Vector3, distance: number): this;

  /**
   * Translates object along x axis by distance.
   * @param distance Distance.
   */
  translateX(distance: number): this;

  /**
   * Translates object along y axis by distance.
   * @param distance Distance.
   */
  translateY(distance: number): this;

  /**
   * Translates object along z axis by distance.
   * @param distance Distance.
   */
  translateZ(distance: number): this;

  /**
   * Updates the vector from local space to world space.
   * @param vector A local vector.
   */
  localToWorld(vector: Vector3): Vector3;

  /**
   * Updates the vector from world space to local space.
   * @param vector A world vector.
   */
  worldToLocal(vector: Vector3): Vector3;

  /**
   * Rotates object to face point in space.
   * @param vector A world vector to look at.
   */
  lookAt(vector: Vector3 | number, y?: number, z?: number): void;

  /**
   * Adds object as child of this object.
   */
  add(...object: Object3D[]): this;

  /**
   * Removes object as child of this object.
   */
  remove(...object: Object3D[]): this;

  /**
   * Adds object as a child of this, while maintaining the object's world transform.
   */
  attach(object: Object3D): this;

  /**
   * Searches through the object's children and returns the first with a matching id.
   * @param id	Unique number of the object instance
   */
  getObjectById(id: number): Object3D | undefined;

  /**
   * Searches through the object's children and returns the first with a matching name.
   * @param name	String to match to the children's Object3d.name property.
   */
  getObjectByName(name: string): Object3D | undefined;

  getObjectByProperty(name: string, value: string): Object3D | undefined;

  getWorldPosition(target: Vector3): Vector3;
  getWorldQuaternion(target: Quaternion): Quaternion;
  getWorldScale(target: Vector3): Vector3;
  getWorldDirection(target: Vector3): Vector3;

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;

  traverse(callback: (object: Object3D) => any): void;

  traverseVisible(callback: (object: Object3D) => any): void;

  traverseAncestors(callback: (object: Object3D) => any): void;

  /**
   * Updates local transform.
   */
  updateMatrix(): void;

  /**
   * Updates global transform of the object and its children.
   */
  updateMatrixWorld(force?: boolean): void;

  updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;

  toJSON(meta?: {
    geometries: any;
    materials: any;
    textures: any;
    images: any;
  }): any;

  clone(recursive?: boolean): this;

  /**
   *
   * @param object
   * @param recursive
   */
  copy(source: this, recursive?: boolean): this;
}
import { Vector3 } from '../math/Vector3';
import { Face3 } from './Face3';
import { Object3D } from './Object3D';
import { Vector2 } from '../math/Vector2';
import { Ray } from '../math/Ray';
import { Camera } from '../cameras/Camera';

export interface Intersection {
  distance: number;
  distanceToRay?: number;
  point: Vector3;
  index?: number;
  face?: Face3 | null;
  faceIndex?: number;
  object: Object3D;
  uv?: Vector2;
}

export interface RaycasterParameters {
  Mesh?: any;
  Line?: any;
  LOD?: any;
  Points?: { threshold: number };
  Sprite?: any;
}

export class Raycaster {
  /**
   * This creates a new raycaster object.
   * @param origin The origin vector where the ray casts from.
   * @param direction The direction vector that gives direction to the ray. Should be normalized.
   * @param near All results returned are further away than near. Near can't be negative. Default value is 0.
   * @param far All results returned are closer then far. Far can't be lower then near . Default value is Infinity.
   */
  constructor(
    origin?: Vector3,
    direction?: Vector3,
    near?: number,
    far?: number,
  );

  /** The Ray used for the raycasting. */
  ray: Ray;

  /**
   * The near factor of the raycaster. This value indicates which objects can be discarded based on the
   * distance. This value shouldn't be negative and should be smaller than the far property.
   */
  near: number;

  /**
   * The far factor of the raycaster. This value indicates which objects can be discarded based on the
   * distance. This value shouldn't be negative and should be larger than the near property.
   */
  far: number;

  /**
   * The camera to use when raycasting against view-dependent objects such as billboarded objects like Sprites. This field
   * can be set manually or is set when calling "setFromCamera".
   */
  camera: Camera;

  params: RaycasterParameters;

  /**
   * The precision factor of the raycaster when intersecting Line objects.
   */
  linePrecision: number;

  /**
   * Updates the ray with a new origin and direction.
   * @param origin The origin vector where the ray casts from.
   * @param direction The normalized direction vector that gives direction to the ray.
   */
  set(origin: Vector3, direction: Vector3): void;

  /**
   * Updates the ray with a new origin and direction.
   * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
   * @param camera camera from which the ray should originate
   */
  setFromCamera(coords: { x: number; y: number }, camera: Camera): void;

  /**
   * Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.
   * @param object The object to check for intersection with the ray.
   * @param recursive If true, it also checks all descendants. Otherwise it only checks intersecton with the object. Default is false.
   * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
   */
  intersectObject(
    object: Object3D,
    recursive?: boolean,
    optionalTarget?: Intersection[],
  ): Intersection[];

  /**
   * Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by .intersectObject.
   * @param objects The objects to check for intersection with the ray.
   * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersecton with the objects. Default is false.
   * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
   */
  intersectObjects(
    objects: Object3D[],
    recursive?: boolean,
    optionalTarget?: Intersection[],
  ): Intersection[];
}
export class Layers {
  constructor();

  mask: number;

  set(channel: number): void;
  enable(channel: number): void;
  enableAll(): void;
  toggle(channel: number): void;
  disable(channel: number): void;
  disableAll(): void;
  test(layers: Layers): boolean;
}
import { Event } from './Face3';

/**
 * JavaScript events for custom objects
 *
 * @source src/core/EventDispatcher.js
 */
export class EventDispatcher {
  /**
   * Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
   */
  constructor();

  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(type: string, listener: (event: Event) => void): void;

  /**
   * Checks if listener is added to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  hasEventListener(type: string, listener: (event: Event) => void): boolean;

  /**
   * Removes a listener from an event type.
   * @param type The type of the listener that gets removed.
   * @param listener The listener function that gets removed.
   */
  removeEventListener(type: string, listener: (event: Event) => void): void;

  /**
   * Fire an event type.
   * @param type The type of event that gets fired.
   */
  dispatchEvent(event: { type: string; [attachment: string]: any }): void;
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Geometry } from './Geometry';
import { MorphTarget } from './Geometry';
/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/DirectGeometry.js">src/core/DirectGeometry.js</a>
 */
export class DirectGeometry {
  constructor();

  id: number;
  uuid: string;
  name: string;
  type: string;
  indices: number[];
  vertices: Vector3[];
  normals: Vector3[];
  colors: Color[];
  uvs: Vector2[];
  uvs2: Vector2[];
  groups: { start: number; materialIndex: number }[];
  morphTargets: MorphTarget[];
  skinWeights: Vector4[];
  skinIndices: Vector4[];
  boundingBox: Box3;
  boundingSphere: Sphere;
  verticesNeedUpdate: boolean;
  normalsNeedUpdate: boolean;
  colorsNeedUpdate: boolean;
  uvsNeedUpdate: boolean;
  groupsNeedUpdate: boolean;

  computeBoundingBox(): void;
  computeBoundingSphere(): void;
  computeGroups(geometry: Geometry): void;
  fromGeometry(geometry: Geometry): DirectGeometry;
  dispose(): void;
}
/**
 * Object for keeping track of time.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/Clock.js">src/core/Clock.js</a>
 */
export class Clock {
  /**
   * @param autoStart Automatically start the clock.
   */
  constructor(autoStart?: boolean);

  /**
   * If set, starts the clock automatically when the first update is called.
   */
  autoStart: boolean;

  /**
   * When the clock is running, It holds the starttime of the clock.
   * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
   */
  startTime: number;

  /**
   * When the clock is running, It holds the previous time from a update.
   * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
   */
  oldTime: number;

  /**
   * When the clock is running, It holds the time elapsed between the start of the clock to the previous update.
   * This parameter is in seconds of three decimal places.
   */
  elapsedTime: number;

  /**
   * This property keeps track whether the clock is running or not.
   */
  running: boolean;

  /**
   * Starts clock.
   */
  start(): void;

  /**
   * Stops clock.
   */
  stop(): void;

  /**
   * Get the seconds passed since the clock started.
   */
  getElapsedTime(): number;

  /**
   * Get the seconds passed since the last call to this method.
   */
  getDelta(): number;
}
import { Interpolant } from '../Interpolant';

export class QuaternionLinearInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class LinearInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class DiscreteInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class CubicInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
export abstract class Interpolant {
  constructor(
    parameterPositions: any,
    sampleValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  parameterPositions: any;
  sampleValues: any;
  valueSize: number;
  resultBuffer: any;

  evaluate(time: number): any;
}
import { Vector2 } from './Vector2';
import { Vector3 } from './Vector3';
import { Plane } from './Plane';
import { Box3 } from './Box3';

export interface SplineControlPoint {
  x: number;
  y: number;
  z: number;
}

export class Triangle {
  constructor(a?: Vector3, b?: Vector3, c?: Vector3);

  a: Vector3;
  b: Vector3;
  c: Vector3;

  set(a: Vector3, b: Vector3, c: Vector3): Triangle;
  setFromPointsAndIndices(
    points: Vector3[],
    i0: number,
    i1: number,
    i2: number,
  ): Triangle;
  clone(): this;
  copy(triangle: Triangle): this;
  getArea(): number;
  getMidpoint(target: Vector3): Vector3;
  getNormal(target: Vector3): Vector3;
  getPlane(target: Plane): Plane;
  getBarycoord(point: Vector3, target: Vector3): Vector3;
  getUV(
    point: Vector3,
    uv1: Vector2,
    uv2: Vector2,
    uv3: Vector2,
    target: Vector2,
  ): Vector2;
  containsPoint(point: Vector3): boolean;
  intersectsBox(box: Box3): boolean;
  isFrontFacing(direction: Vector3): boolean;
  closestPointToPoint(point: Vector3, target: Vector3): Vector3;
  equals(triangle: Triangle): boolean;

  static getNormal(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    target: Vector3,
  ): Vector3;
  static getBarycoord(
    point: Vector3,
    a: Vector3,
    b: Vector3,
    c: Vector3,
    target: Vector3,
  ): Vector3;
  static containsPoint(
    point: Vector3,
    a: Vector3,
    b: Vector3,
    c: Vector3,
  ): boolean;
  static getUV(
    point: Vector3,
    p1: Vector3,
    p2: Vector3,
    p3: Vector3,
    uv1: Vector2,
    uv2: Vector2,
    uv3: Vector2,
    target: Vector2,
  ): Vector2;
  static isFrontFacing(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    direction: Vector3,
  ): boolean;
}
import { Vector3 } from './Vector3';

export class Spherical {
  constructor(radius?: number, phi?: number, theta?: number);

  radius: number;
  phi: number;
  theta: number;

  set(radius: number, phi: number, theta: number): this;
  clone(): this;
  copy(other: Spherical): this;
  makeSafe(): this;
  setFromVector3(v: Vector3): this;
  setFromCartesianCoords(x: number, y: number, z: number): this;
}
import { Vector3 } from './Vector3';

export class Cylindrical {
  constructor(radius?: number, theta?: number, y?: number);

  radius: number;
  theta: number;
  y: number;

  clone(): this;
  copy(other: Cylindrical): this;
  set(radius: number, theta: number, y: number): this;
  setFromVector3(vec3: Vector3): this;
  setFromCartesianCoords(x: number, y: number, z: number): this;
}
import { Vector3 } from './Vector3';
import { Sphere } from './Sphere';
import { Line3 } from './Line3';
import { Box3 } from './Box3';
import { Matrix4 } from './Matrix4';
import { Matrix3 } from './Matrix3';

export class Plane {
  constructor(normal?: Vector3, constant?: number);

  normal: Vector3;
  constant: number;

  set(normal: Vector3, constant: number): Plane;
  setComponents(x: number, y: number, z: number, w: number): Plane;
  setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
  setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
  clone(): this;
  copy(plane: Plane): this;
  normalize(): Plane;
  negate(): Plane;
  distanceToPoint(point: Vector3): number;
  distanceToSphere(sphere: Sphere): number;
  projectPoint(point: Vector3, target: Vector3): Vector3;
  orthoPoint(point: Vector3, target: Vector3): Vector3;
  intersectLine(line: Line3, target: Vector3): Vector3;
  intersectsLine(line: Line3): boolean;
  intersectsBox(box: Box3): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  coplanarPoint(target: Vector3): Vector3;
  applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
  translate(offset: Vector3): Plane;
  equals(plane: Plane): boolean;

  /**
   * @deprecated Use {@link Plane#intersectsLine .intersectsLine()} instead.
   */
  isIntersectionLine(l: any): any;
}
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';
import { Object3D } from '../core/Object3D';
import { Sprite } from '../objects/Sprite';
import { Sphere } from './Sphere';
import { Box3 } from './Box3';
import { Vector3 } from './Vector3';

/**
 * Frustums are used to determine what is inside the camera's field of view. They help speed up the rendering process.
 */
export class Frustum {
  constructor(
    p0?: Plane,
    p1?: Plane,
    p2?: Plane,
    p3?: Plane,
    p4?: Plane,
    p5?: Plane,
  );

  /**
   * Array of 6 vectors.
   */
  planes: Plane[];

  set(
    p0?: number,
    p1?: number,
    p2?: number,
    p3?: number,
    p4?: number,
    p5?: number,
  ): Frustum;
  clone(): this;
  copy(frustum: Frustum): this;
  setFromMatrix(m: Matrix4): Frustum;
  intersectsObject(object: Object3D): boolean;
  intersectsSprite(sprite: Sprite): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsBox(box: Box3): boolean;
  containsPoint(point: Vector3): boolean;
}
import { Vector3 } from './Vector3';
import { Box3 } from './Box3';
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';

export class Sphere {
  constructor(center?: Vector3, radius?: number);

  center: Vector3;
  radius: number;

  set(center: Vector3, radius: number): Sphere;
  setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
  clone(): this;
  copy(sphere: Sphere): this;
  empty(): boolean;
  containsPoint(point: Vector3): boolean;
  distanceToPoint(point: Vector3): number;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsBox(box: Box3): boolean;
  intersectsPlane(plane: Plane): boolean;
  clampPoint(point: Vector3, target: Vector3): Vector3;
  getBoundingBox(target: Box3): Box3;
  applyMatrix4(matrix: Matrix4): Sphere;
  translate(offset: Vector3): Sphere;
  equals(sphere: Sphere): boolean;
}
import { Vector3 } from './Vector3';
import { Sphere } from './Sphere';
import { Plane } from './Plane';
import { Box3 } from './Box3';
import { Matrix4 } from './Matrix4';

export class Ray {
  constructor(origin?: Vector3, direction?: Vector3);

  origin: Vector3;
  direction: Vector3;

  set(origin: Vector3, direction: Vector3): Ray;
  clone(): this;
  copy(ray: Ray): this;
  at(t: number, target: Vector3): Vector3;
  lookAt(v: Vector3): Vector3;
  recast(t: number): Ray;
  closestPointToPoint(point: Vector3, target: Vector3): Vector3;
  distanceToPoint(point: Vector3): number;
  distanceSqToPoint(point: Vector3): number;
  distanceSqToSegment(
    v0: Vector3,
    v1: Vector3,
    optionalPointOnRay?: Vector3,
    optionalPointOnSegment?: Vector3,
  ): number;
  intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
  intersectsSphere(sphere: Sphere): boolean;
  distanceToPlane(plane: Plane): number;
  intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
  intersectsPlane(plane: Plane): boolean;
  intersectBox(box: Box3, target: Vector3): Vector3 | null;
  intersectsBox(box: Box3): boolean;
  intersectTriangle(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    backfaceCulling: boolean,
    target: Vector3,
  ): Vector3 | null;
  applyMatrix4(matrix4: Matrix4): Ray;
  equals(ray: Ray): boolean;

  /**
   * @deprecated Use {@link Ray#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;

  /**
   * @deprecated Use {@link Ray#intersectsPlane .intersectsPlane()} instead.
   */
  isIntersectionPlane(p: any): any;

  /**
   * @deprecated Use {@link Ray#intersectsSphere .intersectsSphere()} instead.
   */
  isIntersectionSphere(s: any): any;
}
import { Vector3 } from './Vector3';
import { Euler } from './Euler';
import { Quaternion } from './Quaternion';
import { BufferAttribute } from '../core/BufferAttribute';
import { Matrix } from './Matrix3';
/**
 * A 4x4 Matrix.
 *
 * @example
 * // Simple rig for rotating around 3 axes
 * var m = new THREE.Matrix4();
 * var m1 = new THREE.Matrix4();
 * var m2 = new THREE.Matrix4();
 * var m3 = new THREE.Matrix4();
 * var alpha = 0;
 * var beta = Math.PI;
 * var gamma = Math.PI/2;
 * m1.makeRotationX( alpha );
 * m2.makeRotationY( beta );
 * m3.makeRotationZ( gamma );
 * m.multiplyMatrices( m1, m2 );
 * m.multiply( m3 );
 */
export class Matrix4 implements Matrix {
  constructor();

  /**
   * Array with matrix values.
   */
  elements: number[];

  /**
   * Sets all fields of this matrix.
   */
  set(
    n11: number,
    n12: number,
    n13: number,
    n14: number,
    n21: number,
    n22: number,
    n23: number,
    n24: number,
    n31: number,
    n32: number,
    n33: number,
    n34: number,
    n41: number,
    n42: number,
    n43: number,
    n44: number,
  ): Matrix4;

  /**
   * Resets this matrix to identity.
   */
  identity(): Matrix4;
  clone(): this;
  copy(m: Matrix4): this;
  copyPosition(m: Matrix4): Matrix4;
  extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
  makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;

  /**
   * Copies the rotation component of the supplied matrix m into this matrix rotation component.
   */
  extractRotation(m: Matrix4): Matrix4;
  makeRotationFromEuler(euler: Euler): Matrix4;
  makeRotationFromQuaternion(q: Quaternion): Matrix4;
  /**
   * Constructs a rotation matrix, looking from eye towards center with defined up vector.
   */
  lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4;

  /**
   * Multiplies this matrix by m.
   */
  multiply(m: Matrix4): Matrix4;

  premultiply(m: Matrix4): Matrix4;

  /**
   * Sets this matrix to a x b.
   */
  multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4;

  /**
   * Sets this matrix to a x b and stores the result into the flat array r.
   * r can be either a regular Array or a TypedArray.
   *
   * @deprecated This method has been removed completely.
   */
  multiplyToArray(a: Matrix4, b: Matrix4, r: number[]): Matrix4;

  /**
   * Multiplies this matrix by s.
   */
  multiplyScalar(s: number): Matrix4;

  /**
   * @deprecated Use {@link Matrix4#applyToBufferAttribute matrix4.applyToBufferAttribute( attribute )} instead.
   */
  applyToBuffer(
    buffer: BufferAttribute,
    offset?: number,
    length?: number,
  ): BufferAttribute;

  applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute;

  /**
   * Computes determinant of this matrix.
   * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
   */
  determinant(): number;

  /**
   * Transposes this matrix.
   */
  transpose(): Matrix4;

  /**
   * Sets the position component for this matrix from vector v.
   */
  setPosition(v: Vector3 | number, y?: number, z?: number): Matrix4;

  /**
   * Sets this matrix to the inverse of matrix m.
   * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm.
   */
  getInverse(m: Matrix4, throwOnDegeneratee?: boolean): Matrix4;

  /**
   * Multiplies the columns of this matrix by vector v.
   */
  scale(v: Vector3): Matrix4;

  getMaxScaleOnAxis(): number;
  /**
   * Sets this matrix as translation transform.
   */
  makeTranslation(x: number, y: number, z: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around x axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationX(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around y axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationY(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around z axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationZ(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around axis by angle radians.
   * Based on http://www.gamedev.net/reference/articles/article1199.asp.
   *
   * @param axis Rotation axis.
   * @param theta Rotation angle in radians.
   */
  makeRotationAxis(axis: Vector3, angle: number): Matrix4;

  /**
   * Sets this matrix as scale transform.
   */
  makeScale(x: number, y: number, z: number): Matrix4;

  /**
   * Sets this matrix to the transformation composed of translation, rotation and scale.
   */
  compose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;

  /**
   * Decomposes this matrix into the translation, rotation and scale components.
   * If parameters are not passed, new instances will be created.
   */
  decompose(
    translation?: Vector3,
    rotation?: Quaternion,
    scale?: Vector3,
  ): Object[]; // [Vector3, Quaternion, Vector3]

  /**
   * Creates a frustum matrix.
   */
  makePerspective(
    left: number,
    right: number,
    bottom: number,
    top: number,
    near: number,
    far: number,
  ): Matrix4;

  /**
   * Creates a perspective projection matrix.
   */
  makePerspective(
    fov: number,
    aspect: number,
    near: number,
    far: number,
  ): Matrix4;

  /**
   * Creates an orthographic projection matrix.
   */
  makeOrthographic(
    left: number,
    right: number,
    top: number,
    bottom: number,
    near: number,
    far: number,
  ): Matrix4;
  equals(matrix: Matrix4): boolean;

  /**
   * Sets the values of this matrix from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): Matrix4;

  /**
   * Sets the values of this matrix from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): Matrix4;

  /**
   * Returns an array with the values of this matrix, or copies them into the provided array.
   * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies he values of this matrix into the provided array-like.
   * @param array array-like to store the matrix to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * @deprecated Use {@link Matrix4#copyPosition .copyPosition()} instead.
   */
  extractPosition(m: Matrix4): Matrix4;

  /**
   * @deprecated Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.
   */
  setRotationFromQuaternion(q: Quaternion): Matrix4;

  /**
   * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  multiplyVector3(v: any): any;

  /**
   * @deprecated Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  multiplyVector4(v: any): any;

  /**
   * @deprecated This method has been removed completely.
   */
  multiplyVector3Array(array: number[]): number[];

  /**
   * @deprecated Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.
   */
  rotateAxis(v: any): void;

  /**
   * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  crossVector(v: any): void;

  /**
   * @deprecated Use {@link Matrix4#toArray .toArray()} instead.
   */
  flattenToArrayOffset(array: number[], offset: number): number[];
}
import { Matrix4 } from './Matrix4';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector3 } from './Vector3';

/**
 * ( interface Matrix&lt;T&gt; )
 */
export interface Matrix {
  /**
   * Array with matrix values.
   */
  elements: number[];

  /**
   * identity():T;
   */
  identity(): Matrix;

  /**
   * copy(m:T):T;
   */
  copy(m: this): this;

  /**
   * multiplyScalar(s:number):T;
   */
  multiplyScalar(s: number): Matrix;

  determinant(): number;

  /**
   * getInverse(matrix:T, throwOnInvertible?:boolean):T;
   */
  getInverse(matrix: Matrix, throwOnInvertible?: boolean): Matrix;

  /**
   * transpose():T;
   */
  transpose(): Matrix;

  /**
   * clone():T;
   */
  clone(): this;
}

/**
 * ( class Matrix3 implements Matrix&lt;Matrix3&gt; )
 */
export class Matrix3 implements Matrix {
  /**
   * Creates an identity matrix.
   */
  constructor();

  /**
   * Array with matrix values.
   */
  elements: number[];

  set(
    n11: number,
    n12: number,
    n13: number,
    n21: number,
    n22: number,
    n23: number,
    n31: number,
    n32: number,
    n33: number,
  ): Matrix3;
  identity(): Matrix3;
  clone(): this;
  copy(m: Matrix3): this;
  setFromMatrix4(m: Matrix4): Matrix3;

  /**
   * @deprecated Use {@link Matrix3#applyToBufferAttribute matrix3.applyToBufferAttribute( attribute )} instead.
   */
  applyToBuffer(
    buffer: BufferAttribute,
    offset?: number,
    length?: number,
  ): BufferAttribute;

  applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute;

  multiplyScalar(s: number): Matrix3;
  determinant(): number;
  getInverse(matrix: Matrix3, throwOnDegenerate?: boolean): Matrix3;

  /**
   * Transposes this matrix in place.
   */
  transpose(): Matrix3;
  getNormalMatrix(matrix4: Matrix4): Matrix3;

  /**
   * Transposes this matrix into the supplied array r, and returns itself.
   */
  transposeIntoArray(r: number[]): number[];

  setUvTransform(
    tx: number,
    ty: number,
    sx: number,
    sy: number,
    rotation: number,
    cx: number,
    cy: number,
  ): Matrix3;

  scale(sx: number, sy: number): Matrix3;

  rotate(theta: number): Matrix3;

  translate(tx: number, ty: number): Matrix3;

  equals(matrix: Matrix3): boolean;

  /**
   * Sets the values of this matrix from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): Matrix3;

  /**
   * Sets the values of this matrix from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): Matrix3;

  /**
   * Returns an array with the values of this matrix, or copies them into the provided array.
   * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies he values of this matrix into the provided array-like.
   * @param array array-like to store the matrix to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * Multiplies this matrix by m.
   */
  multiply(m: Matrix3): Matrix3;

  premultiply(m: Matrix3): Matrix3;

  /**
   * Sets this matrix to a x b.
   */
  multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3;

  /**
   * @deprecated Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.
   */
  multiplyVector3(vector: Vector3): any;

  /**
   * @deprecated This method has been removed completely.
   */
  multiplyVector3Array(a: any): any;
  getInverse(matrix: Matrix4, throwOnDegenerate?: boolean): Matrix3;

  /**
   * @deprecated Use {@link Matrix3#toArray .toArray()} instead.
   */
  flattenToArrayOffset(array: number[], offset: number): number[];
}
import { Vector3 } from './Vector3';
import { Object3D } from '../core/Object3D';
import { Sphere } from './Sphere';
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';
import { Triangle } from './Triangle';

export class Box3 {
  constructor(min?: Vector3, max?: Vector3);

  max: Vector3;
  min: Vector3;

  set(min: Vector3, max: Vector3): this;
  setFromArray(array: ArrayLike<number>): this;
  setFromPoints(points: Vector3[]): this;
  setFromCenterAndSize(center: Vector3, size: Vector3): this;
  setFromObject(object: Object3D): this;
  clone(): this;
  copy(box: Box3): this;
  makeEmpty(): this;
  isEmpty(): boolean;
  getCenter(target: Vector3): Vector3;
  getSize(target: Vector3): Vector3;
  expandByPoint(point: Vector3): this;
  expandByVector(vector: Vector3): this;
  expandByScalar(scalar: number): this;
  expandByObject(object: Object3D): this;
  containsPoint(point: Vector3): boolean;
  containsBox(box: Box3): boolean;
  getParameter(point: Vector3): Vector3;
  intersectsBox(box: Box3): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsPlane(plane: Plane): boolean;
  intersectsTriangle(triangle: Triangle): boolean;
  clampPoint(point: Vector3, target: Vector3): Vector3;
  distanceToPoint(point: Vector3): number;
  getBoundingSphere(target: Sphere): Sphere;
  intersect(box: Box3): this;
  union(box: Box3): this;
  applyMatrix4(matrix: Matrix4): this;
  translate(offset: Vector3): this;
  equals(box: Box3): boolean;
  /**
   * @deprecated Use {@link Box3#isEmpty .isEmpty()} instead.
   */
  empty(): any;
  /**
   * @deprecated Use {@link Box3#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;
  /**
   * @deprecated Use {@link Box3#intersectsSphere .intersectsSphere()} instead.
   */
  isIntersectionSphere(s: any): any;
}
import { Vector2 } from './Vector2';

// Math //////////////////////////////////////////////////////////////////////////////////

export class Box2 {
  constructor(min?: Vector2, max?: Vector2);

  max: Vector2;
  min: Vector2;

  set(min: Vector2, max: Vector2): Box2;
  setFromPoints(points: Vector2[]): Box2;
  setFromCenterAndSize(center: Vector2, size: Vector2): Box2;
  clone(): this;
  copy(box: Box2): this;
  makeEmpty(): Box2;
  isEmpty(): boolean;
  getCenter(target: Vector2): Vector2;
  getSize(target: Vector2): Vector2;
  expandByPoint(point: Vector2): Box2;
  expandByVector(vector: Vector2): Box2;
  expandByScalar(scalar: number): Box2;
  containsPoint(point: Vector2): boolean;
  containsBox(box: Box2): boolean;
  getParameter(point: Vector2): Vector2;
  intersectsBox(box: Box2): boolean;
  clampPoint(point: Vector2, target: Vector2): Vector2;
  distanceToPoint(point: Vector2): number;
  intersect(box: Box2): Box2;
  union(box: Box2): Box2;
  translate(offset: Vector2): Box2;
  equals(box: Box2): boolean;
  /**
   * @deprecated Use {@link Box2#isEmpty .isEmpty()} instead.
   */
  empty(): any;
  /**
   * @deprecated Use {@link Box2#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;
}
import { Vector3 } from './Vector3';
import { Matrix4 } from './Matrix4';

export class Line3 {
  constructor(start?: Vector3, end?: Vector3);

  start: Vector3;
  end: Vector3;

  set(start?: Vector3, end?: Vector3): Line3;
  clone(): this;
  copy(line: Line3): this;
  getCenter(target: Vector3): Vector3;
  delta(target: Vector3): Vector3;
  distanceSq(): number;
  distance(): number;
  at(t: number, target: Vector3): Vector3;
  closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
  closestPointToPoint(
    point: Vector3,
    clampToLine: boolean,
    target: Vector3,
  ): Vector3;
  applyMatrix4(matrix: Matrix4): Line3;
  equals(line: Line3): boolean;
}
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Vector3 } from './Vector3';

export class Euler {
  constructor(x?: number, y?: number, z?: number, order?: string);

  x: number;
  y: number;
  z: number;
  order: string;
  _onChangeCallback: Function;

  set(x: number, y: number, z: number, order?: string): Euler;
  clone(): this;
  copy(euler: Euler): this;
  setFromRotationMatrix(m: Matrix4, order?: string): Euler;
  setFromQuaternion(q: Quaternion, order?: string): Euler;
  setFromVector3(v: Vector3, order?: string): Euler;
  reorder(newOrder: string): Euler;
  equals(euler: Euler): boolean;
  fromArray(xyzo: any[]): Euler;
  toArray(array?: number[], offset?: number): number[];
  toVector3(optionalResult?: Vector3): Vector3;
  _onChange(callback: Function): this;

  static RotationOrders: string[];
  static DefaultOrder: string;
}
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Matrix3 } from './Matrix3';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector } from './Vector2';

/**
 * 4D vector.
 *
 * ( class Vector4 implements Vector<Vector4> )
 */
export class Vector4 implements Vector {
  constructor(x?: number, y?: number, z?: number, w?: number);

  x: number;
  y: number;
  z: number;
  w: number;
  width: number;
  height: number;
  isVector4: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number, z: number, w: number): this;

  /**
   * Sets all values of this vector.
   */
  setScalar(scalar: number): this;

  /**
   * Sets X component of this vector.
   */
  setX(x: number): this;

  /**
   * Sets Y component of this vector.
   */
  setY(y: number): this;

  /**
   * Sets Z component of this vector.
   */
  setZ(z: number): this;

  /**
   * Sets w component of this vector.
   */
  setW(w: number): this;

  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  /**
   * Clones this vector.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector4): this;

  /**
   * Adds v to this vector.
   */
  add(v: Vector4, w?: Vector4): this;

  addScalar(scalar: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector4, b: Vector4): this;

  addScaledVector(v: Vector4, s: number): this;
  /**
   * Subtracts v from this vector.
   */
  sub(v: Vector4): this;

  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector4, b: Vector4): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(s: number): this;

  applyMatrix4(m: Matrix4): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  /**
   * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
   * @param q is assumed to be normalized
   */
  setAxisAngleFromQuaternion(q: Quaternion): this;

  /**
   * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
   * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
   */
  setAxisAngleFromRotationMatrix(m: Matrix3): this;

  min(v: Vector4): this;
  max(v: Vector4): this;
  clamp(min: Vector4, max: Vector4): this;
  clampScalar(min: number, max: number): this;
  floor(): this;
  ceil(): this;
  round(): this;
  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector4): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;
  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(length: number): this;

  /**
   * Linearly interpolate between this vector and v with alpha factor.
   */
  lerp(v: Vector4, alpha: number): this;

  lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector4): boolean;

  /**
   * Sets this vector's x, y, z and w value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x, y, z and w value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y, z and w into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  fromBufferAttribute(
    attribute: BufferAttribute,
    index: number,
    offset?: number,
  ): this;
}
import { Euler } from './Euler';
import { Matrix3 } from './Matrix3';
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Camera } from '../cameras/Camera';
import { Spherical } from './Spherical';
import { Cylindrical } from './Cylindrical';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector } from './Vector2';
/**
 * 3D vector.
 *
 * @example
 * var a = new THREE.Vector3( 1, 0, 0 );
 * var b = new THREE.Vector3( 0, 1, 0 );
 * var c = new THREE.Vector3();
 * c.crossVectors( a, b );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js">src/math/Vector3.js</a>
 *
 * ( class Vector3 implements Vector<Vector3> )
 */
export class Vector3 implements Vector {
  constructor(x?: number, y?: number, z?: number);

  x: number;
  y: number;
  z: number;
  isVector3: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number, z: number): this;

  /**
   * Sets all values of this vector.
   */
  setScalar(scalar: number): this;

  /**
   * Sets x value of this vector.
   */
  setX(x: number): Vector3;

  /**
   * Sets y value of this vector.
   */
  setY(y: number): Vector3;

  /**
   * Sets z value of this vector.
   */
  setZ(z: number): Vector3;

  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  /**
   * Clones this vector.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector3): this;

  /**
   * Adds v to this vector.
   */
  add(a: Vector3, b?: Vector3): this;

  addScalar(s: number): this;

  addScaledVector(v: Vector3, s: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector3, b: Vector3): this;

  /**
   * Subtracts v from this vector.
   */
  sub(a: Vector3): this;

  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector3, b: Vector3): this;

  multiply(v: Vector3): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(s: number): this;

  multiplyVectors(a: Vector3, b: Vector3): this;

  applyEuler(euler: Euler): this;

  applyAxisAngle(axis: Vector3, angle: number): this;

  applyMatrix3(m: Matrix3): this;

  applyMatrix4(m: Matrix4): this;

  applyQuaternion(q: Quaternion): this;

  project(camera: Camera): this;

  unproject(camera: Camera): this;

  transformDirection(m: Matrix4): this;

  divide(v: Vector3): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  min(v: Vector3): this;

  max(v: Vector3): this;

  clamp(min: Vector3, max: Vector3): this;

  clampScalar(min: number, max: number): this;

  clampLength(min: number, max: number): this;

  floor(): this;

  ceil(): this;

  round(): this;

  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector3): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * Computes Manhattan length of this vector.
   * http://en.wikipedia.org/wiki/Taxicab_geometry
   *
   * @deprecated Use {@link Vector3#manhattanLength .manhattanLength()} instead.
   */
  lengthManhattan(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector3} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector3): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;

  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(l: number): this;
  lerp(v: Vector3, alpha: number): this;

  lerpVectors(v1: Vector3, v2: Vector3, alpha: number): this;

  /**
   * Sets this vector to cross product of itself and v.
   */
  cross(a: Vector3, w?: Vector3): this;

  /**
   * Sets this vector to cross product of a and b.
   */
  crossVectors(a: Vector3, b: Vector3): this;
  projectOnVector(v: Vector3): this;
  projectOnPlane(planeNormal: Vector3): this;
  reflect(vector: Vector3): this;
  angleTo(v: Vector3): number;

  /**
   * Computes distance of this vector to v.
   */
  distanceTo(v: Vector3): number;

  /**
   * Computes squared distance of this vector to v.
   */
  distanceToSquared(v: Vector3): number;

  /**
   * @deprecated Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.
   */
  distanceToManhattan(v: Vector3): number;

  setFromSpherical(s: Spherical): this;
  setFromSphericalCoords(r: number, phi: number, theta: number): this;
  setFromCylindrical(s: Cylindrical): this;
  setFromCylindricalCoords(radius: number, theta: number, y: number): this;
  setFromMatrixPosition(m: Matrix4): this;
  setFromMatrixScale(m: Matrix4): this;
  setFromMatrixColumn(matrix: Matrix4, index: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector3): boolean;

  /**
   * Sets this vector's x, y and z value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x, y and z value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z], or copies x, y and z into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y and z into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  fromBufferAttribute(
    attribute: BufferAttribute,
    index: number,
    offset?: number,
  ): this;
}
import { Matrix3 } from './Matrix3';
import { BufferAttribute } from '../core/BufferAttribute';

/**
 * ( interface Vector&lt;T&gt; )
 *
 * Abstract interface of Vector2, Vector3 and Vector4.
 * Currently the members of Vector is NOT type safe because it accepts different typed vectors.
 * Those definitions will be changed when TypeScript innovates Generics to be type safe.
 *
 * @example
 * var v:THREE.Vector = new THREE.Vector3();
 * v.addVectors(new THREE.Vector2(0, 1), new THREE.Vector2(2, 3));		// invalid but compiled successfully
 */
export interface Vector {
  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  set(...args: number[]): this;

  setScalar(scalar: number): this;

  /**
   * copy(v:T):T;
   */
  copy(v: Vector): this;

  /**
   * NOTE: The second argument is deprecated.
   *
   * add(v:T):T;
   */
  add(v: Vector, w?: Vector): this;

  /**
   * addVectors(a:T, b:T):T;
   */
  addVectors(a: Vector, b: Vector): this;

  addScaledVector(vector: Vector, scale: number): this;

  /**
   * Adds the scalar value s to this vector's values.
   */
  addScalar(scalar: number): this;

  /**
   * sub(v:T):T;
   */
  sub(v: Vector): this;

  /**
   * subVectors(a:T, b:T):T;
   */
  subVectors(a: Vector, b: Vector): this;

  /**
   * multiplyScalar(s:number):T;
   */
  multiplyScalar(s: number): this;

  /**
   * divideScalar(s:number):T;
   */
  divideScalar(s: number): this;

  /**
   * negate():T;
   */
  negate(): this;

  /**
   * dot(v:T):T;
   */
  dot(v: Vector): number;

  /**
   * lengthSq():number;
   */
  lengthSq(): number;

  /**
   * length():number;
   */
  length(): number;

  /**
   * normalize():T;
   */
  normalize(): this;

  /**
   * NOTE: Vector4 doesn't have the property.
   *
   * distanceTo(v:T):number;
   */
  distanceTo?(v: Vector): number;

  /**
   * NOTE: Vector4 doesn't have the property.
   *
   * distanceToSquared(v:T):number;
   */
  distanceToSquared?(v: Vector): number;

  /**
   * setLength(l:number):T;
   */
  setLength(l: number): this;

  /**
   * lerp(v:T, alpha:number):T;
   */
  lerp(v: Vector, alpha: number): this;

  /**
   * equals(v:T):boolean;
   */
  equals(v: Vector): boolean;

  /**
   * clone():T;
   */
  clone(): this;
}

/**
 * 2D vector.
 *
 * ( class Vector2 implements Vector<Vector2> )
 */
export class Vector2 implements Vector {
  constructor(x?: number, y?: number);

  x: number;
  y: number;
  width: number;
  height: number;
  isVector2: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number): this;

  /**
   * Sets the x and y values of this vector both equal to scalar.
   */
  setScalar(scalar: number): this;

  /**
   * Sets X component of this vector.
   */
  setX(x: number): this;

  /**
   * Sets Y component of this vector.
   */
  setY(y: number): this;

  /**
   * Sets a component of this vector.
   */
  setComponent(index: number, value: number): this;

  /**
   * Gets a component of this vector.
   */
  getComponent(index: number): number;

  /**
   * Returns a new Vector2 instance with the same `x` and `y` values.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector2): this;

  /**
   * Adds v to this vector.
   */
  add(v: Vector2, w?: Vector2): this;

  /**
   * Adds the scalar value s to this vector's x and y values.
   */
  addScalar(s: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector2, b: Vector2): this;

  /**
   * Adds the multiple of v and s to this vector.
   */
  addScaledVector(v: Vector2, s: number): this;

  /**
   * Subtracts v from this vector.
   */
  sub(v: Vector2): this;

  /**
   * Subtracts s from this vector's x and y components.
   */
  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector2, b: Vector2): this;

  /**
   * Multiplies this vector by v.
   */
  multiply(v: Vector2): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(scalar: number): this;

  /**
   * Divides this vector by v.
   */
  divide(v: Vector2): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
   */
  applyMatrix3(m: Matrix3): this;

  /**
   * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
   */
  min(v: Vector2): this;

  /**
   * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
   */
  max(v: Vector2): this;

  /**
   * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
   * @param min the minimum x and y values.
   * @param max the maximum x and y values in the desired range.
   */
  clamp(min: Vector2, max: Vector2): this;

  /**
   * If this vector's x or y values are greater than the max value, they are replaced by the max value.
   * If this vector's x or y values are less than the min value, they are replaced by the min value.
   * @param min the minimum value the components will be clamped to.
   * @param max the maximum value the components will be clamped to.
   */
  clampScalar(min: number, max: number): this;

  /**
   * If this vector's length is greater than the max value, it is replaced by the max value.
   * If this vector's length is less than the min value, it is replaced by the min value.
   * @param min the minimum value the length will be clamped to.
   * @param max the maximum value the length will be clamped to.
   */
  clampLength(min: number, max: number): this;

  /**
   * The components of the vector are rounded down to the nearest integer value.
   */
  floor(): this;

  /**
   * The x and y components of the vector are rounded up to the nearest integer value.
   */
  ceil(): this;

  /**
   * The components of the vector are rounded to the nearest integer value.
   */
  round(): this;

  /**
   * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
   */
  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector2): number;

  /**
   * Computes cross product of this vector and v.
   */
  cross(v: Vector2): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * @deprecated Use {@link Vector2#manhattanLength .manhattanLength()} instead.
   */
  lengthManhattan(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;

  /**
   * computes the angle in radians with respect to the positive x-axis
   */
  angle(): number;

  /**
   * Computes distance of this vector to v.
   */
  distanceTo(v: Vector2): number;

  /**
   * Computes squared distance of this vector to v.
   */
  distanceToSquared(v: Vector2): number;

  /**
   * @deprecated Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.
   */
  distanceToManhattan(v: Vector2): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector2} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector2): number;

  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(length: number): this;

  /**
   * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
   * @param v vector to interpolate towards.
   * @param alpha interpolation factor in the closed interval [0, 1].
   */
  lerp(v: Vector2, alpha: number): this;

  /**
   * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
   * @param v1 the starting vector.
   * @param v2 vector to interpolate towards.
   * @param alpha interpolation factor in the closed interval [0, 1].
   */
  lerpVectors(v1: Vector2, v2: Vector2, alpha: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector2): boolean;

  /**
   * Sets this vector's x and y value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x and y value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y], or copies x and y into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x and y into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * Sets this vector's x and y values from the attribute.
   * @param attribute the source attribute.
   * @param index index in the attribute.
   */
  fromBufferAttribute(attribute: BufferAttribute, index: number): this;

  /**
   * Rotates the vector around center by angle radians.
   * @param center the point around which to rotate.
   * @param angle the angle to rotate, in radians.
   */
  rotateAround(center: Vector2, angle: number): this;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector2} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector2): number;
}
import { Euler } from './Euler';
import { Vector3 } from './Vector3';
import { Matrix4 } from './Matrix4';

/**
 * Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.
 *
 * @example
 * var quaternion = new THREE.Quaternion();
 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
 * var vector = new THREE.Vector3( 1, 0, 0 );
 * vector.applyQuaternion( quaternion );
 */
export class Quaternion {
  /**
   * @param x x coordinate
   * @param y y coordinate
   * @param z z coordinate
   * @param w w coordinate
   */
  constructor(x?: number, y?: number, z?: number, w?: number);

  x: number;
  y: number;
  z: number;
  w: number;

  /**
   * Sets values of this quaternion.
   */
  set(x: number, y: number, z: number, w: number): Quaternion;

  /**
   * Clones this quaternion.
   */
  clone(): this;

  /**
   * Copies values of q to this quaternion.
   */
  copy(q: Quaternion): this;

  /**
   * Sets this quaternion from rotation specified by Euler angles.
   */
  setFromEuler(euler: Euler): Quaternion;

  /**
   * Sets this quaternion from rotation specified by axis and angle.
   * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
   * Axis have to be normalized, angle is in radians.
   */
  setFromAxisAngle(axis: Vector3, angle: number): Quaternion;

  /**
   * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
   */
  setFromRotationMatrix(m: Matrix4): Quaternion;
  setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
  angleTo(q: Quaternion): number;
  rotateTowards(q: Quaternion, step: number): Quaternion;

  /**
   * Inverts this quaternion.
   */
  inverse(): Quaternion;

  conjugate(): Quaternion;
  dot(v: Quaternion): number;
  lengthSq(): number;

  /**
   * Computes length of this quaternion.
   */
  length(): number;

  /**
   * Normalizes this quaternion.
   */
  normalize(): Quaternion;

  /**
   * Multiplies this quaternion by b.
   */
  multiply(q: Quaternion): Quaternion;
  premultiply(q: Quaternion): Quaternion;

  /**
   * Sets this quaternion to a x b
   * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
   */
  multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;

  slerp(qb: Quaternion, t: number): Quaternion;
  equals(v: Quaternion): boolean;

  /**
   * Sets this quaternion's x, y, z and w value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this quaternion's x, y, z and w value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
   * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y, z and w into the provided array-like.
   * @param array array-like to store the quaternion to.
   * @param offset (optional) optional offset into the array.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  _onChange(callback: Function): Quaternion;
  _onChangeCallback: Function;

  /**
   * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/.
   */
  static slerp(
    qa: Quaternion,
    qb: Quaternion,
    qm: Quaternion,
    t: number,
  ): Quaternion;

  static slerpFlat(
    dst: number[],
    dstOffset: number,
    src0: number[],
    srcOffset: number,
    src1: number[],
    stcOffset1: number,
    t: number,
  ): Quaternion;

  /**
   * @deprecated Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.
   */
  multiplyVector3(v: any): any;
}
/**
 * @author Joe Pea / http://github.com/trusktr
 */

export interface HSL {
  h: number;
  s: number;
  l: number;
}

/**
 * Represents a color. See also {@link ColorUtils}.
 *
 * @example
 * var color = new THREE.Color( 0xff0000 );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Color.js">src/math/Color.js</a>
 */
export class Color {
  constructor(color?: Color | string | number);
  constructor(r: number, g: number, b: number);

  isColor: boolean;

  /**
   * Red channel value between 0 and 1. Default is 1.
   */
  r: number;

  /**
   * Green channel value between 0 and 1. Default is 1.
   */
  g: number;

  /**
   * Blue channel value between 0 and 1. Default is 1.
   */
  b: number;

  set(color: Color): Color;
  set(color: number): Color;
  set(color: string): Color;
  setScalar(scalar: number): Color;
  setHex(hex: number): Color;

  /**
   * Sets this color from RGB values.
   * @param r Red channel value between 0 and 1.
   * @param g Green channel value between 0 and 1.
   * @param b Blue channel value between 0 and 1.
   */
  setRGB(r: number, g: number, b: number): Color;

  /**
   * Sets this color from HSL values.
   * Based on MochiKit implementation by Bob Ippolito.
   *
   * @param h Hue channel value between 0 and 1.
   * @param s Saturation value channel between 0 and 1.
   * @param l Value channel value between 0 and 1.
   */
  setHSL(h: number, s: number, l: number): Color;

  /**
   * Sets this color from a CSS context style string.
   * @param contextStyle Color in CSS context style format.
   */
  setStyle(style: string): Color;

  /**
   * Sets this color from a color name.
   * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
   * @param style Color name in X11 format.
   */
  setColorName(style: string): Color;

  /**
   * Clones this color.
   */
  clone(): this;

  /**
   * Copies given color.
   * @param color Color to copy.
   */
  copy(color: Color): this;

  /**
   * Copies given color making conversion from gamma to linear space.
   * @param color Color to copy.
   */
  copyGammaToLinear(color: Color, gammaFactor?: number): Color;

  /**
   * Copies given color making conversion from linear to gamma space.
   * @param color Color to copy.
   */
  copyLinearToGamma(color: Color, gammaFactor?: number): Color;

  /**
   * Converts this color from gamma to linear space.
   */
  convertGammaToLinear(gammaFactor?: number): Color;

  /**
   * Converts this color from linear to gamma space.
   */
  convertLinearToGamma(gammaFactor?: number): Color;

  /**
   * Copies given color making conversion from sRGB to linear space.
   * @param color Color to copy.
   */
  copySRGBToLinear(color: Color): Color;

  /**
   * Copies given color making conversion from linear to sRGB space.
   * @param color Color to copy.
   */
  copyLinearToSRGB(color: Color): Color;

  /**
   * Converts this color from sRGB to linear space.
   */
  convertSRGBToLinear(): Color;

  /**
   * Converts this color from linear to sRGB space.
   */
  convertLinearToSRGB(): Color;

  /**
   * Returns the hexadecimal value of this color.
   */
  getHex(): number;

  /**
   * Returns the string formated hexadecimal value of this color.
   */
  getHexString(): string;

  getHSL(target: HSL): HSL;

  /**
   * Returns the value of this color in CSS context style.
   * Example: rgb(r, g, b)
   */
  getStyle(): string;

  offsetHSL(h: number, s: number, l: number): this;

  add(color: Color): this;
  addColors(color1: Color, color2: Color): this;
  addScalar(s: number): this;
  sub(color: Color): this;
  multiply(color: Color): this;
  multiplyScalar(s: number): this;
  lerp(color: Color, alpha: number): this;
  lerpHSL(color: Color, alpha: number): this;
  equals(color: Color): boolean;

  /**
   * Sets this color's red, green and blue value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this color's red, green and blue value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
   * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies red, green and blue into the provided array-like.
   * @param array array-like to store the color to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * List of X11 color names.
   */
  static NAMES: Record<string, number>;
}
import { Vector3 } from './Vector3.js.js';

export class SphericalHarmonics3 {
  constructor();

  coefficients: Vector3[];
  isSphericalHarmonics3: boolean;

  set(coefficients: Vector3[]): SphericalHarmonics3;
  zero(): SphericalHarmonics3;
  add(sh: SphericalHarmonics3): SphericalHarmonics3;
  scale(s: number): SphericalHarmonics3;
  lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
  equals(sh: SphericalHarmonics3): boolean;
  copy(sh: SphericalHarmonics3): SphericalHarmonics3;
  clone(): SphericalHarmonics3;

  /**
   * Sets the values of this spherical harmonics from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets the values of this spherical harmonics from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array with the values of this spherical harmonics, or copies them into the provided array.
   * @param array (optional) array to store the spherical harmonics to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.
   * @param array array-like to store the spherical harmonics to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  getAt(normal: Vector3, target: Vector3): Vector3;
  getIrradianceAt(normal: Vector3, target: Vector3): Vector3;

  static getBasisAt(normal: Vector3, shBasis: number[]): void;
}
import { Object3D } from '../../core/Object3D';
import { Material } from '../../materials/Material';

// Extras / Objects /////////////////////////////////////////////////////////////////////

export class ImmediateRenderObject extends Object3D {
  constructor(material: Material);

  material: Material;
  render(renderCallback: Function): void;
}
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

export class VertexNormalsHelper extends LineSegments {
  constructor(
    object: Object3D,
    size?: number,
    hex?: number,
    linewidth?: number,
  );

  object: Object3D;
  size: number;

  update(object?: Object3D): void;
}
import { Light } from '../lights/Light';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

export class SpotLightHelper extends Object3D {
  constructor(light: Light, color?: Color | string | number);

  light: Light;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;
  color: Color | string | number | undefined;
  cone: LineSegments;

  dispose(): void;
  update(): void;
}
import { Object3D } from '../core/Object3D';
import { Bone } from '../objects/Bone';
import { LineSegments } from '../objects/LineSegments';

export class SkeletonHelper extends LineSegments {
  constructor(bone: Object3D);

  bones: Bone[];
  root: Object3D;

  getBoneList(object: Object3D): Bone[];
  update(): void;
}
import { PointLight } from '../lights/PointLight';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';

export class PointLightHelper extends Object3D {
  constructor(
    light: PointLight,
    sphereSize?: number,
    color?: Color | string | number,
  );

  light: PointLight;
  color: Color | string | number | undefined;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;

  dispose(): void;
  update(): void;
}
import { RectAreaLight } from '../lights/RectAreaLight';
import { Color } from '../math/Color';
import { Line } from '../objects/Line';

export class RectAreaLightHelper extends Line {
  constructor(light: RectAreaLight, color?: Color | string | number);

  light: RectAreaLight;
  color: Color | string | number | undefined;

  update(): void;
  dispose(): void;
}
import { HemisphereLight } from '../lights/HemisphereLight';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { MeshBasicMaterial } from '../materials/MeshBasicMaterial';
import { Object3D } from '../core/Object3D';

export class HemisphereLightHelper extends Object3D {
  constructor(
    light: HemisphereLight,
    size: number,
    color?: Color | number | string,
  );

  light: HemisphereLight;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;
  material: MeshBasicMaterial;

  color: Color | string | number | undefined;

  dispose(): void;
  update(): void;
}
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class GridHelper extends LineSegments {
  constructor(
    size: number,
    divisions: number,
    color1?: Color | number,
    color2?: Color | number,
  );
  /**
   * @deprecated Colors should be specified in the constructor.
   */
  setColors(color1?: Color | number, color2?: Color | number): void;
}
import { LineSegments } from '../objects/LineSegments';
import { Color } from '../math/Color';

export class PolarGridHelper extends LineSegments {
  constructor(
    radius: number,
    radials: number,
    circles: number,
    divisions: number,
    color1: Color | string | number | undefined,
    color2: Color | string | number | undefined,
  );
}
import { PositionalAudio } from '../audio/PositionalAudio';
import { Line } from '../objects/Line';

export class PositionalAudioHelper extends Line {
  constructor(
    audio: PositionalAudio,
    range?: number,
    divisionsInnerAngle?: number,
    divisionsOuterAngle?: number,
  );

  audio: PositionalAudio;
  range: number;
  divisionsInnerAngle: number;
  divisionsOuterAngle: number;

  dispose(): void;
  update(): void;
}
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

/**
 * @deprecated Use {@link EdgesGeometry THREE.EdgesGeometry}
 */
// export class EdgesHelper extends LineSegments {
//	 constructor(object: Object3D, hex?: number, thresholdAngle?: number);
// }

export class FaceNormalsHelper extends LineSegments {
  constructor(
    object: Object3D,
    size?: number,
    hex?: number,
    linewidth?: number,
  );

  object: Object3D;
  size: number;

  update(object?: Object3D): void;
}
import { DirectionalLight } from '../lights/DirectionalLight';
import { Color } from '../math/Color';
import { Line } from '../objects/Line';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';

export class DirectionalLightHelper extends Object3D {
  constructor(
    light: DirectionalLight,
    size?: number,
    color?: Color | string | number,
  );

  light: DirectionalLight;
  lightPlane: Line;
  targetPlane: Line;
  color: Color | string | number | undefined;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;

  dispose(): void;
  update(): void;
}
import { Camera } from '../cameras/Camera';
import { LineSegments } from '../objects/LineSegments';

export class CameraHelper extends LineSegments {
  constructor(camera: Camera);

  camera: Camera;
  pointMap: { [id: string]: number[] };

  update(): void;
}
import { Object3D } from '../core/Object3D';
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class BoxHelper extends LineSegments {
  constructor(object: Object3D, color?: Color);

  update(object?: Object3D): void;

  setFromObject(object: Object3D): this;
}
import { Box3 } from '../math/Box3';
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class Box3Helper extends LineSegments {
  constructor(box: Box3, color?: Color);

  box: Box3;
}
import { Plane } from '../math/Plane';
import { LineSegments } from '../objects/LineSegments';

export class PlaneHelper extends LineSegments {
  constructor(plane: Plane, size?: number, hex?: number);

  plane: Plane;
  size: number;

  updateMatrixWorld(force?: boolean): void;
}
import { Vector3 } from '../math/Vector3';
import { Line } from '../objects/Line';
import { Mesh } from '../objects/Mesh';
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';

// Extras / Helpers /////////////////////////////////////////////////////////////////////

export class ArrowHelper extends Object3D {
  constructor(
    dir: Vector3,
    origin?: Vector3,
    length?: number,
    hex?: number,
    headLength?: number,
    headWidth?: number,
  );

  line: Line;
  cone: Mesh;

  setDirection(dir: Vector3): void;
  setLength(length: number, headLength?: number, headWidth?: number): void;
  setColor(color: Color | string | number): void;
}
import { LineSegments } from '../objects/LineSegments';

export class AxesHelper extends LineSegments {
  constructor(size?: number);
}
export * from './ArcCurve';
export * from './CatmullRomCurve3';
export * from './CubicBezierCurve';
export * from './CubicBezierCurve3';
export * from './EllipseCurve';
export * from './LineCurve';
export * from './LineCurve3';
export * from './QuadraticBezierCurve';
export * from './QuadraticBezierCurve3';
export * from './SplineCurve';
import { Vector2 } from '../../math/Vector2';
import { Path } from './Path';
import { ExtrudeGeometry } from '../../geometries/ExtrudeGeometry';
import { ShapeGeometry } from '../../geometries/ShapeGeometry';

/**
 * Defines a 2d shape plane using paths.
 */
export class Shape extends Path {
  constructor(points?: Vector2[]);

  holes: Path[];

  /**
   * @deprecated Use {@link ExtrudeGeometry ExtrudeGeometry()} instead.
   */
  extrude(options?: any): ExtrudeGeometry;

  /**
   * @deprecated Use {@link ShapeGeometry ShapeGeometry()} instead.
   */
  makeGeometry(options?: any): ShapeGeometry;
  getPointsHoles(divisions: number): Vector2[][];

  /**
   * @deprecated Use {@link Shape#extractPoints .extractPoints()} instead.
   */
  extractAllPoints(
    divisions: number,
  ): {
    shape: Vector2[];
    holes: Vector2[][];
  };
  extractPoints(
    divisions: number,
  ): {
    shape: Vector2[];
    holes: Vector2[][];
  };
}
import { Vector2 } from '../../math/Vector2';
import { CurvePath } from './CurvePath';

export enum PathActions {
  MOVE_TO,
  LINE_TO,
  QUADRATIC_CURVE_TO, // Bezier quadratic curve
  BEZIER_CURVE_TO, // Bezier cubic curve
  CSPLINE_THRU, // Catmull-rom spline
  ARC, // Circle
  ELLIPSE,
}

export interface PathAction {
  action: PathActions;
  args: any;
}

/**
 * a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
 */
export class Path extends CurvePath<Vector2> {
  constructor(points?: Vector2[]);

  currentPoint: Vector2;

  /**
   * @deprecated Use {@link Path#setFromPoints .setFromPoints()} instead.
   */
  fromPoints(vectors: Vector2[]): this;
  setFromPoints(vectors: Vector2[]): this;
  moveTo(x: number, y: number): this;
  lineTo(x: number, y: number): this;
  quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
  bezierCurveTo(
    aCP1x: number,
    aCP1y: number,
    aCP2x: number,
    aCP2y: number,
    aX: number,
    aY: number,
  ): this;
  splineThru(pts: Vector2[]): this;
  arc(
    aX: number,
    aY: number,
    aRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
  ): this;
  absarc(
    aX: number,
    aY: number,
    aRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
  ): this;
  ellipse(
    aX: number,
    aY: number,
    xRadius: number,
    yRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
    aRotation: number,
  ): this;
  absellipse(
    aX: number,
    aY: number,
    xRadius: number,
    yRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
    aRotation: number,
  ): this;
}
import { Vector2 } from '../../math/Vector2';
import { Shape } from './Shape';

export class ShapePath {
  constructor();

  subPaths: any[];
  currentPath: any;

  moveTo(x: number, y: number): this;
  lineTo(x: number, y: number): this;
  quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
  bezierCurveTo(
    aCP1x: number,
    aCP1y: number,
    aCP2x: number,
    aCP2y: number,
    aX: number,
    aY: number,
  ): this;
  splineThru(pts: Vector2[]): this;
  toShapes(isCCW: boolean, noHoles?: boolean): Shape[];
}
export class Font {
  constructor(jsondata: any);

  data: string;

  generateShapes(text: string, size: number, divisions: number): any[];
}
import { Curve } from './Curve';
import { Geometry } from '../../core/Geometry';
import { Vector } from '../../math/Vector2';

export class CurvePath<T extends Vector> extends Curve<T> {
  constructor();

  curves: Curve<T>[];
  autoClose: boolean;

  add(curve: Curve<T>): void;
  checkConnection(): boolean;
  closePath(): void;
  getPoint(t: number): T;
  getLength(): number;
  updateArcLengths(): void;
  getCurveLengths(): number[];
  getSpacedPoints(divisions?: number): T[];
  getPoints(divisions?: number): T[];

  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createPointsGeometry(divisions: number): Geometry;
  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createSpacedPointsGeometry(divisions: number): Geometry;
  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createGeometry(points: T[]): Geometry;
}
import { Vector } from '../../math/Vector2';

// Extras / Core /////////////////////////////////////////////////////////////////////

/**
 * An extensible curve object which contains methods for interpolation
 * class Curve&lt;T extends Vector&gt;
 */
export class Curve<T extends Vector> {
  /**
   * This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.
   * To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.
   * Default is 200.
   */
  arcLengthDivisions: number;

  /**
   * Returns a vector for point t of the curve where t is between 0 and 1
   * getPoint(t: number): T;
   */
  getPoint(t: number, optionalTarget?: T): T;

  /**
   * Returns a vector for point at relative position in curve according to arc length
   * getPointAt(u: number): T;
   */
  getPointAt(u: number, optionalTarget?: T): T;

  /**
   * Get sequence of points using getPoint( t )
   * getPoints(divisions?: number): T[];
   */
  getPoints(divisions?: number): T[];

  /**
   * Get sequence of equi-spaced points using getPointAt( u )
   * getSpacedPoints(divisions?: number): T[];
   */
  getSpacedPoints(divisions?: number): T[];

  /**
   * Get total curve arc length
   */
  getLength(): number;

  /**
   * Get list of cumulative segment lengths
   */
  getLengths(divisions?: number): number[];

  /**
   * Update the cumlative segment distance cache
   */
  updateArcLengths(): void;

  /**
   * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
   */
  getUtoTmapping(u: number, distance: number): number;

  /**
   * Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation
   * getTangent(t: number): T;
   */
  getTangent(t: number): T;

  /**
   * Returns tangent at equidistance point u on the curve
   * getTangentAt(u: number): T;
   */
  getTangentAt(u: number): T;

  /**
   * @deprecated since r84.
   */
  static create(constructorFunc: Function, getPointFunc: Function): Function;
}
import { Mapping } from '../constants';
import { Texture } from '../textures/Texture';

export namespace ImageUtils {
  export function getDataURL(image: any): string;

  /**
   * @deprecated
   */
  export let crossOrigin: string;

  /**
   * @deprecated Use {@link TextureLoader THREE.TextureLoader()} instead.
   */
  export function loadTexture(
    url: string,
    mapping?: Mapping,
    onLoad?: (texture: Texture) => void,
    onError?: (message: string) => void,
  ): Texture;

  /**
   * @deprecated Use {@link CubeTextureLoader THREE.CubeTextureLoader()} instead.
   */
  export function loadTextureCube(
    array: string[],
    mapping?: Mapping,
    onLoad?: (texture: Texture) => void,
    onError?: (message: string) => void,
  ): Texture;
}
interface Vec2 {
  x: number;
  y: number;
}

export namespace ShapeUtils {
  export function area(contour: Vec2[]): number;
  export function triangulateShape(
    contour: Vec2[],
    holes: Vec2[][],
  ): number[][];
  export function isClockWise(pts: Vec2[]): boolean;
}
// Renderers / WebGL /////////////////////////////////////////////////////////////////////
export class WebGLBufferRenderer {
  constructor(_gl: WebGLRenderingContext, extensions: any, _infoRender: any);

  setMode(value: any): void;
  render(start: any, count: number): void;
  renderInstances(geometry: any): void;
}
export interface WebGLCapabilitiesParameters {
  precision?: any;
  logarithmicDepthBuffer?: any;
}

export class WebGLCapabilities {
  constructor(
    gl: WebGLRenderingContext,
    extensions: any,
    parameters: WebGLCapabilitiesParameters,
  );

  isWebGL2: boolean;
  precision: any;
  logarithmicDepthBuffer: any;
  maxTextures: any;
  maxVertexTextures: any;
  maxTextureSize: any;
  maxCubemapSize: any;
  maxAttributes: any;
  maxVertexUniforms: any;
  maxVaryings: any;
  maxFragmentUniforms: any;
  vertexTextures: any;
  floatFragmentTextures: any;
  floatVertexTextures: any;

  getMaxAnisotropy(): number;
  getMaxPrecision(precision: string): string;
}
import { Camera } from '../../cameras/Camera';

export class WebGLClipping {
  uniform: { value: any; needsUpdate: boolean };
  numPlanes: number;

  init(planes: any[], enableLocalClipping: boolean, camera: Camera): boolean;
  beginShadows(): void;
  endShadows(): void;
  setState(
    planes: any[],
    clipShadows: boolean,
    camera: Camera,
    cache: boolean,
    fromCache: boolean,
  ): void;
}
export class WebGLExtensions {
  constructor(gl: WebGLRenderingContext);

  get(name: string): any;
}
export class WebGLGeometries {
  constructor(gl: WebGLRenderingContext, attributes: any, info: any);

  get(object: any, geometry: any): any;
  update(geometry: any): any;
  getWireframeAttribute(geometry: any): any;
}
export class WebGLIndexedBufferRenderer {
  constructor(
    gl: WebGLRenderingContext,
    extensions: any,
    info: any,
    capabilities: any,
  );

  setMode(value: any): void;
  setIndex(index: any): void;
  render(start: any, count: number): void;
  renderInstances(
    geometry: any,
    start: any,
    count: number,
    primcount: number,
  ): void;
}
import { WebGLProgram } from './WebGLProgram';

/**
 * An object with a series of statistical information about the graphics board memory and the rendering process.
 */
export class WebGLInfo {
  constructor(gl: WebGLRenderingContext);

  autoReset: boolean;
  memory: {
    geometries: number;
    textures: number;
  };
  programs: WebGLProgram[] | null;
  render: {
    calls: number;
    frame: number;
    lines: number;
    points: number;
    triangles: number;
  };
  update(count: any, mode: any, instanceCount: any): void;
  reset(): void;
}
export class WebGLLights {
  constructor(gl: WebGLRenderingContext, properties: any, info: any);

  state: {
    version: number;

    hash: {
      directionalLength: number;
      pointLength: number;
      spotLength: number;
      rectAreaLength: number;
      hemiLength: number;

      numDirectionalShadows: number;
      numPointShadows: number;
      numSpotShadows: number;
    };

    ambient: Array<number>;
    probe: Array<any>;
    directional: Array<any>;
    directionalShadowMap: Array<any>;
    directionalShadowMatrix: Array<any>;
    spot: Array<any>;
    spotShadowMap: Array<any>;
    spotShadowMatrix: Array<any>;
    rectArea: Array<any>;
    point: Array<any>;
    pointShadowMap: Array<any>;
    pointShadowMatrix: Array<any>;
    hemi: Array<any>;

    numDirectionalShadows: number;
    numPointShadows: number;
    numSpotShadows: number;
  };

  get(light: any): any;
  setup(lights: any, shadows: any, camera: any): void;
}
export class WebGLObjects {
  constructor(
    gl: WebGLRenderingContext,
    geometries: any,
    attributes: any,
    info: any,
  );

  update(object: any): any;
  dispose(): void;
}
import { WebGLRenderer, WebGLRendererParameters } from '../WebGLRenderer';
import { ShaderMaterial } from '../../materials/ShaderMaterial';
import { WebGLShader } from './WebGLShader';
import { WebGLExtensions } from './WebGLExtensions';
import { WebGLUniforms } from './WebGLUniforms';

export class WebGLProgram {
  constructor(
    renderer: WebGLRenderer,
    extensions: WebGLExtensions,
    cacheKey: string,
    material: ShaderMaterial,
    shader: WebGLShader,
    parameters: WebGLRendererParameters,
  );

  id: number;
  cacheKey: string; // unique identifier for this program, used for looking up compiled programs from cache.
  usedTimes: number;
  program: any;
  vertexShader: WebGLShader;
  fragmentShader: WebGLShader;
  /**
   * @deprecated Use {@link WebGLProgram#getUniforms getUniforms()} instead.
   */
  uniforms: any;
  /**
   * @deprecated Use {@link WebGLProgram#getAttributes getAttributes()} instead.
   */
  attributes: any;

  getUniforms(): WebGLUniforms;
  getAttributes(): any;
  destroy(): void;
}
import { WebGLRenderer } from '../WebGLRenderer';
import { WebGLProgram } from './WebGLProgram';
import { WebGLCapabilities } from './WebGLCapabilities';
import { WebGLExtensions } from './WebGLExtensions';
import { Material } from '../../materials/Material';

export class WebGLPrograms {
  constructor(
    renderer: WebGLRenderer,
    extensions: WebGLExtensions,
    capabilities: WebGLCapabilities,
  );

  programs: WebGLProgram[];

  getParameters(
    material: Material,
    lights: any,
    fog: any,
    nClipPlanes: number,
    object: any,
  ): any;
  getProgramCacheKey(material: Material, parameters: any): string;
  acquireProgram(
    material: Material,
    parameters: any,
    cacheKey: string,
  ): WebGLProgram;
  releaseProgram(program: WebGLProgram): void;
}
export class WebGLProperties {
  constructor();

  get(object: any): any;
  remove(object: any): void;
  update(object: any, key: any, value: any): any;
  dispose(): void;
}
import { Object3D } from '../../core/Object3D';
import { Material } from '../../materials/Material';
import { WebGLProgram } from './WebGLProgram';
import { Group } from '../../objects/Group';
import { Scene } from '../../scenes/Scene';
import { Camera } from '../../cameras/Camera';
import { BufferGeometry } from '../../core/BufferGeometry';

export interface RenderTarget {} // not defined in the code, used in LightShadow and WebGRenderer classes

export interface RenderItem {
  id: number;
  object: Object3D;
  geometry: BufferGeometry | null;
  material: Material;
  program: WebGLProgram;
  groupOrder: number;
  renderOrder: number;
  z: number;
  group: Group | null;
}

export class WebGLRenderList {
  opaque: Array<RenderItem>;
  transparent: Array<RenderItem>;
  init(): void;
  push(
    object: Object3D,
    geometry: BufferGeometry | null,
    material: Material,
    groupOrder: number,
    z: number,
    group: Group | null,
  ): void;
  unshift(
    object: Object3D,
    geometry: BufferGeometry | null,
    material: Material,
    groupOrder: number,
    z: number,
    group: Group | null,
  ): void;
  sort(): void;
}

export class WebGLRenderLists {
  dispose(): void;
  get(scene: Scene, camera: Camera): WebGLRenderList;
}
export class WebGLShader {
  constructor(gl: WebGLRenderingContext, type: string, string: string);
}
import { Scene } from '../../scenes/Scene';
import { Camera } from '../../cameras/Camera';
import { WebGLRenderer } from '../WebGLRenderer';
import { ShadowMapType } from '../../constants';

export class WebGLShadowMap {
  constructor(
    _renderer: WebGLRenderer,
    _lights: any[],
    _objects: any[],
    capabilities: any,
  );

  enabled: boolean;
  autoUpdate: boolean;
  needsUpdate: boolean;
  type: ShadowMapType;

  render(scene: Scene, camera: Camera): void;

  /**
   * @deprecated Use {@link WebGLShadowMap#renderReverseSided .shadowMap.renderReverseSided} instead.
   */
  cullFace: any;
}
import {
  CullFace,
  Blending,
  BlendingEquation,
  BlendingSrcFactor,
  BlendingDstFactor,
  DepthModes,
} from '../../constants';
import { WebGLCapabilities } from './WebGLCapabilities';
import { WebGLExtensions } from './WebGLExtensions';
import { Material } from '../../materials/Material';
import { Vector4 } from '../../math/Vector4';

export class WebGLColorBuffer {
  constructor();

  setMask(colorMask: boolean): void;
  setLocked(lock: boolean): void;
  setClear(
    r: number,
    g: number,
    b: number,
    a: number,
    premultipliedAlpha: boolean,
  ): void;
  reset(): void;
}

export class WebGLDepthBuffer {
  constructor();

  setTest(depthTest: boolean): void;
  setMask(depthMask: boolean): void;
  setFunc(depthFunc: DepthModes): void;
  setLocked(lock: boolean): void;
  setClear(depth: number): void;
  reset(): void;
}

export class WebGLStencilBuffer {
  constructor();

  setTest(stencilTest: boolean): void;
  setMask(stencilMask: number): void;
  setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
  setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
  setLocked(lock: boolean): void;
  setClear(stencil: number): void;
  reset(): void;
}

export class WebGLState {
  constructor(
    gl: WebGLRenderingContext,
    extensions: WebGLExtensions,
    capabilities: WebGLCapabilities,
  );

  buffers: {
    color: WebGLColorBuffer;
    depth: WebGLDepthBuffer;
    stencil: WebGLStencilBuffer;
  };

  initAttributes(): void;
  enableAttribute(attribute: number): void;
  enableAttributeAndDivisor(attribute: number, meshPerAttribute: number): void;
  disableUnusedAttributes(): void;
  enable(id: number): void;
  disable(id: number): void;
  useProgram(program: any): boolean;
  setBlending(
    blending: Blending,
    blendEquation?: BlendingEquation,
    blendSrc?: BlendingSrcFactor,
    blendDst?: BlendingDstFactor,
    blendEquationAlpha?: BlendingEquation,
    blendSrcAlpha?: BlendingSrcFactor,
    blendDstAlpha?: BlendingDstFactor,
    premultiplyAlpha?: boolean,
  ): void;
  setMaterial(material: Material, frontFaceCW: boolean): void;
  setFlipSided(flipSided: boolean): void;
  setCullFace(cullFace: CullFace): void;
  setLineWidth(width: number): void;
  setPolygonOffset(polygonoffset: boolean, factor: number, units: number): void;
  setScissorTest(scissorTest: boolean): void;
  activeTexture(webglSlot: number): void;
  bindTexture(webglType: number, webglTexture: any): void;
  unbindTexture(): void;
  // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
  compressedTexImage2D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    border: number,
    data: ArrayBufferView,
  ): void;
  // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
  texImage2D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    border: number,
    format: number,
    type: number,
    pixels: ArrayBufferView | null,
  ): void;
  texImage2D(
    target: number,
    level: number,
    internalformat: number,
    format: number,
    type: number,
    source: any,
  ): void;
  texImage3D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    depth: number,
    border: number,
    format: number,
    type: number,
    pixels: any,
  ): void;
  scissor(scissor: Vector4): void;
  viewport(viewport: Vector4): void;
  reset(): void;
}
import { WebGLExtensions } from './WebGLExtensions.js.js';
import { WebGLState } from './WebGLState.js.js';
import { WebGLProperties } from './WebGLProperties.js.js';
import { WebGLCapabilities } from './WebGLCapabilities.js.js';
import { WebGLUtils } from './WebGLUtils.js.js';
import { WebGLInfo } from './WebGLInfo.js.js';

export class WebGLTextures {
  constructor(
    gl: WebGLRenderingContext,
    extensions: WebGLExtensions,
    state: WebGLState,
    properties: WebGLProperties,
    capabilities: WebGLCapabilities,
    utils: WebGLUtils,
    info: WebGLInfo,
  );

  allocateTextureUnit(): void;
  resetTextureUnits(): void;
  setTexture2D(texture: any, slot: number): void;
  setTexture2DArray(texture: any, slot: number): void;
  setTexture3D(texture: any, slot: number): void;
  setTextureCube(texture: any, slot: number): void;
  setTextureCubeDynamic(texture: any, slot: number): void;
  setupRenderTarget(renderTarget: any): void;
  updateRenderTargetMipmap(renderTarget: any): void;
  updateMultisampleRenderTarget(renderTarget: any): void;
  safeSetTexture2D(texture: any, slot: number): void;
  safeSetTextureCube(texture: any, slot: number): void;
}
import { WebGLProgram } from './WebGLProgram';
import { WebGLTextures } from './WebGLTextures';

export class WebGLUniforms {
  constructor(gl: WebGLRenderingContext, program: WebGLProgram);

  setValue(
    gl: WebGLRenderingContext,
    name: string,
    value: any,
    textures: WebGLTextures,
  ): void;
  setOptional(gl: WebGLRenderingContext, object: any, name: string): void;

  static upload(
    gl: WebGLRenderingContext,
    seq: any,
    values: any[],
    textures: WebGLTextures,
  ): void;
  static seqWithValue(seq: any, values: any[]): any[];
}
import { Object3D } from '../../core/Object3D';
import { Group } from '../../objects/Group';
import { PerspectiveCamera } from '../../cameras/PerspectiveCamera';
import { ArrayCamera } from '../../cameras/ArrayCamera';
import { Matrix4 } from '../../math/Matrix4';

export class WebVRManager {
  constructor(renderer: any);

  enabled: boolean;
  getController(id: number): Group;
  getDevice(): VRDisplay | null;
  setDevice(device: VRDisplay | null): void;
  setFramebufferScaleFactor(value: number): void;
  setReferenceSpaceType(value: string): void;
  setPoseTarget(object: Object3D | null): void;
  getCamera(camera: PerspectiveCamera): PerspectiveCamera | ArrayCamera;
  getStandingMatrix(): Matrix4;
  isPresenting: () => boolean;
  setAnimationLoop(callback: Function): void;
  submitFrame(): void;
  dispose(): void;
}
export const REVISION: string;

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
export enum MOUSE {
  LEFT,
  MIDDLE,
  RIGHT,
  ROTATE,
  DOLLY,
  PAN,
}

export enum TOUCH {
  ROTATE,
  PAN,
  DOLLY_PAN,
  DOLLY_ROTATE,
}

// GL STATE CONSTANTS
export enum CullFace {}
export const CullFaceNone: CullFace;
export const CullFaceBack: CullFace;
export const CullFaceFront: CullFace;
export const CullFaceFrontBack: CullFace;

export enum FrontFaceDirection {}
export const FrontFaceDirectionCW: FrontFaceDirection;
export const FrontFaceDirectionCCW: FrontFaceDirection;

// Shadowing Type
export enum ShadowMapType {}
export const BasicShadowMap: ShadowMapType;
export const PCFShadowMap: ShadowMapType;
export const PCFSoftShadowMap: ShadowMapType;
export const VSMShadowMap: ShadowMapType;

// MATERIAL CONSTANTS

// side
export enum Side {}
export const FrontSide: Side;
export const BackSide: Side;
export const DoubleSide: Side;

// shading
export enum Shading {}
export const FlatShading: Shading;
export const SmoothShading: Shading;

// colors
export enum Colors {}
export const NoColors: Colors;
export const FaceColors: Colors;
export const VertexColors: Colors;

// blending modes
export enum Blending {}
export const NoBlending: Blending;
export const NormalBlending: Blending;
export const AdditiveBlending: Blending;
export const SubtractiveBlending: Blending;
export const MultiplyBlending: Blending;
export const CustomBlending: Blending;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)
export enum BlendingEquation {}
export const AddEquation: BlendingEquation;
export const SubtractEquation: BlendingEquation;
export const ReverseSubtractEquation: BlendingEquation;
export const MinEquation: BlendingEquation;
export const MaxEquation: BlendingEquation;

// custom blending destination factors
export enum BlendingDstFactor {}
export const ZeroFactor: BlendingDstFactor;
export const OneFactor: BlendingDstFactor;
export const SrcColorFactor: BlendingDstFactor;
export const OneMinusSrcColorFactor: BlendingDstFactor;
export const SrcAlphaFactor: BlendingDstFactor;
export const OneMinusSrcAlphaFactor: BlendingDstFactor;
export const DstAlphaFactor: BlendingDstFactor;
export const OneMinusDstAlphaFactor: BlendingDstFactor;
export const DstColorFactor: BlendingDstFactor;
export const OneMinusDstColorFactor: BlendingDstFactor;

// custom blending src factors
export enum BlendingSrcFactor {}
export const SrcAlphaSaturateFactor: BlendingSrcFactor;

// depth modes
export enum DepthModes {}
export const NeverDepth: DepthModes;
export const AlwaysDepth: DepthModes;
export const LessDepth: DepthModes;
export const LessEqualDepth: DepthModes;
export const EqualDepth: DepthModes;
export const GreaterEqualDepth: DepthModes;
export const GreaterDepth: DepthModes;
export const NotEqualDepth: DepthModes;

// TEXTURE CONSTANTS
// Operations
export enum Combine {}
export const MultiplyOperation: Combine;
export const MixOperation: Combine;
export const AddOperation: Combine;

// Tone Mapping modes
export enum ToneMapping {}
export const NoToneMapping: ToneMapping;
export const LinearToneMapping: ToneMapping;
export const ReinhardToneMapping: ToneMapping;
export const Uncharted2ToneMapping: ToneMapping;
export const CineonToneMapping: ToneMapping;
export const ACESFilmicToneMapping: ToneMapping;

// Mapping modes
export enum Mapping {}
export const UVMapping: Mapping;
export const CubeReflectionMapping: Mapping;
export const CubeRefractionMapping: Mapping;
export const EquirectangularReflectionMapping: Mapping;
export const EquirectangularRefractionMapping: Mapping;
export const SphericalReflectionMapping: Mapping;
export const CubeUVReflectionMapping: Mapping;
export const CubeUVRefractionMapping: Mapping;

// Wrapping modes
export enum Wrapping {}
export const RepeatWrapping: Wrapping;
export const ClampToEdgeWrapping: Wrapping;
export const MirroredRepeatWrapping: Wrapping;

// Filters
export enum TextureFilter {}
export const NearestFilter: TextureFilter;
export const NearestMipmapNearestFilter: TextureFilter;
export const NearestMipMapNearestFilter: TextureFilter;
export const NearestMipmapLinearFilter: TextureFilter;
export const NearestMipMapLinearFilter: TextureFilter;
export const LinearFilter: TextureFilter;
export const LinearMipmapNearestFilter: TextureFilter;
export const LinearMipMapNearestFilter: TextureFilter;
export const LinearMipmapLinearFilter: TextureFilter;
export const LinearMipMapLinearFilter: TextureFilter;

// Data types
export enum TextureDataType {}
export const UnsignedByteType: TextureDataType;
export const ByteType: TextureDataType;
export const ShortType: TextureDataType;
export const UnsignedShortType: TextureDataType;
export const IntType: TextureDataType;
export const UnsignedIntType: TextureDataType;
export const FloatType: TextureDataType;
export const HalfFloatType: TextureDataType;

// Pixel types
export enum PixelType {}
export const UnsignedShort4444Type: PixelType;
export const UnsignedShort5551Type: PixelType;
export const UnsignedShort565Type: PixelType;
export const UnsignedInt248Type: PixelType;

// Pixel formats
export enum PixelFormat {}
export const AlphaFormat: PixelFormat;
export const RGBFormat: PixelFormat;
export const RGBAFormat: PixelFormat;
export const LuminanceFormat: PixelFormat;
export const LuminanceAlphaFormat: PixelFormat;
export const RGBEFormat: PixelFormat;
export const DepthFormat: PixelFormat;
export const DepthStencilFormat: PixelFormat;
export const RedFormat: PixelFormat;

// Compressed texture formats
// DDS / ST3C Compressed texture formats
export enum CompressedPixelFormat {}
export const RGB_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT3_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT5_Format: CompressedPixelFormat;

// PVRTC compressed './texture formats
export const RGB_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGB_PVRTC_2BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_2BPPV1_Format: CompressedPixelFormat;

// ETC compressed texture formats
export const RGB_ETC1_Format: CompressedPixelFormat;

// ASTC compressed texture formats
export const RGBA_ASTC_4x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x12_Format: CompressedPixelFormat;

// Loop styles for AnimationAction
export enum AnimationActionLoopStyles {}
export const LoopOnce: AnimationActionLoopStyles;
export const LoopRepeat: AnimationActionLoopStyles;
export const LoopPingPong: AnimationActionLoopStyles;

// Interpolation
export enum InterpolationModes {}
export const InterpolateDiscrete: InterpolationModes;
export const InterpolateLinear: InterpolationModes;
export const InterpolateSmooth: InterpolationModes;

// Interpolant ending modes
export enum InterpolationEndingModes {}
export const ZeroCurvatureEnding: InterpolationEndingModes;
export const ZeroSlopeEnding: InterpolationEndingModes;
export const WrapAroundEnding: InterpolationEndingModes;

// Triangle Draw modes
export enum TrianglesDrawModes {}
export const TrianglesDrawMode: TrianglesDrawModes;
export const TriangleStripDrawMode: TrianglesDrawModes;
export const TriangleFanDrawMode: TrianglesDrawModes;

// Texture Encodings
export enum TextureEncoding {}
export const LinearEncoding: TextureEncoding;
export const sRGBEncoding: TextureEncoding;
export const GammaEncoding: TextureEncoding;
export const RGBEEncoding: TextureEncoding;
export const LogLuvEncoding: TextureEncoding;
export const RGBM7Encoding: TextureEncoding;
export const RGBM16Encoding: TextureEncoding;
export const RGBDEncoding: TextureEncoding;

// Depth packing strategies
export enum DepthPackingStrategies {}
export const BasicDepthPacking: DepthPackingStrategies;
export const RGBADepthPacking: DepthPackingStrategies;

// Normal Map types
export enum NormalMapTypes {}
export const TangentSpaceNormalMap: NormalMapTypes;
export const ObjectSpaceNormalMap: NormalMapTypes;

// Stencil Op types
export enum StencilOp {}
export const ZeroStencilOp: StencilOp;
export const KeepStencilOp: StencilOp;
export const ReplaceStencilOp: StencilOp;
export const IncrementStencilOp: StencilOp;
export const DecrementStencilOp: StencilOp;
export const IncrementWrapStencilOp: StencilOp;
export const DecrementWrapStencilOp: StencilOp;
export const InvertStencilOp: StencilOp;

// Stencil Func types
export enum StencilFunc {}
export const NeverStencilFunc: StencilFunc;
export const LessStencilFunc: StencilFunc;
export const EqualStencilFunc: StencilFunc;
export const LessEqualStencilFunc: StencilFunc;
export const GreaterStencilFunc: StencilFunc;
export const NotEqualStencilFunc: StencilFunc;
export const GreaterEqualStencilFunc: StencilFunc;
export const AlwaysStencilFunc: StencilFunc;

// usage types
export enum Usage {}
export const StaticDrawUsage: Usage;
export const DynamicDrawUsage: Usage;
export const StreamDrawUsage: Usage;
export const StaticReadUsage: Usage;
export const DynamicReadUsage: Usage;
export const StreamReadUsage: Usage;
export const StaticCopyUsage: Usage;
export const DynamicCopyUsage: Usage;
export const StreamCopyUsage: Usage;
import { Geometry } from './core/Geometry';
import { Material } from './materials/Material';
import { Object3D } from './core/Object3D';
import { Scene } from './scenes/Scene';

export namespace SceneUtils {
  export function createMultiMaterialObject(
    geometry: Geometry,
    materials: Material[],
  ): Object3D;
  export function detach(child: Object3D, parent: Object3D, scene: Scene): void;
  export function attach(child: Object3D, scene: Scene, parent: Object3D): void;
}



}
 export as namespace THREE;


/// <reference types="geojson" />


export as namespace vjmap;

declare namespace vjmap {
/**
 * 将脚本注入.
 * 脚本选项信息:
 *   `strategy`: 用于运行 JavaScript 的策略。可以是`inject`、`eval` 或`href`。默认自动检测.
 *   `injectLocation`: 用于注入资源的位置的 `document.querySelector` 参数。默认为 `head`.
 *   `async`: 异步加载脚本
 *   `src`: 脚本的来源
 * @method
 * @async
 * @param {typeof defaultOptions |  Array<typeof defaultOptions>} scripts - Options for a script
 * @return {Promise<void>}
 * @example
 * // you can add multiple loads
 * awit addScript([{
 *  src: "https://code.jquery.com/jquery-3.5.0.js"
 * }, {
 *  src: "https://code.jquery.com/jquery-3.2.0.js",
 *  async: true
 * }, {
 *  src: "https://code.jquery.com/jquery-3.3.0.js",
 *  async: true,
 *  injectLocation: '#main div.test',
 * }, {
 *  src: "https://code.jquery.com/jquery-3.4.0.js",
 *  strategy: 'eval',
 * }, {
 * // link tag
 * // css autodetected
 *  src: "https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap-grid.min.css",
 * }])
 */
export  function addScript(scripts: ScriptDefaultOptions | ScriptDefaultOptions[]): Promise<unknown[]>;

export  const angle: (a: Point23D, b?: Point23D) => number;

/**
 * 动画标记图层.
 */
export  class AnimateMarkerLayer extends Evented {
    private map;
    private options;
    private features;
    private type;
    private width;
    private height;
    private colors;
    private textFontSize;
    private textColor;
    private textField;
    private _markersElement;
    private markers;
    private marker;
    constructor(features: FeatureCollection, options?: AnimateMarkerLayerOption);
    addTo(map: Map): void;
    remove(): void;
    getMarkers(): Marker[];
    private _initalizeOptions;
    private _initalizeMarkerLayer;
    private _createMarker;
    setType(type: AnimateMarkerType, options?: AnimateMarkerLayerOption): void;
    _getMarkerElement(): void;
    clearMarkerLayer(): void;
    render(): void;
}

export  interface AnimateMarkerLayerOption {
    type?: AnimateMarkerType;
    width?: number;
    height?: number;
    colors?: string[];
    textFontSize?: number;
    textColor?: string;
    textField?: string;
}

/**
 * breathingAperture 呼吸的光圈.
 * rotatingAperture 旋转的光环
 * haloRing 发光的光环
 * diffusedAperture 扩散的点
 * rotatingTextBorder 旋转的文本框
 * fluorescence 荧光点
 */
export  type AnimateMarkerType = "breathingAperture" | 'rotatingAperture' | 'haloRing' | 'diffusedAperture' | 'rotatingTextBorder' | 'fluorescence';

/**
 * 创建矢量图层动画图层
 * @param map 地图对象
 * @param layerId 矢量图层id
 * @param options 选项
 * @param layerType 图层类型 0 线 1 填充 2 符号点
 */
export  const animateVectorLayer: (map: Map, layerId: string, options?: IAnimateVectorLayerOptions, layerType?: number | undefined) => IAnimateVectorLayerResult;

 interface Animation_2<V> {
    next: (t: number) => {
        value: V;
        done: boolean;
    };
    flipTarget: () => void;
}
export { Animation_2 as Animation }

export  type AnimationOps<V> = PlaybackOptions<V> & (DecayOptions | KeyframeOptions<V> | SpringOptions);

export  interface AnimationState<V> {
    value: V;
    done: boolean;
}

export  const anticipate: Easing;

/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods and properties into.
 * @param baseCtors - Class to take all methods and properties from.
 */
export  function applyMixins(derivedCtor: any, baseCtors: any[]): void;

/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods into.
 * @param baseCtors - Class to take all methods from.
 */
export  function applyMixinsWithoutProperties(derivedCtor: any, baseCtors: any[]): void;

/**
 * Apply offset
 * A function that, given a value, will get the offset from `from`
 * and apply it to `to`
 * @param  {number} from
 * @param  {number} to
 * @return {function}
 */
export  const applyOffset: (from: number, to?: number | undefined) => (v: number) => number | undefined;

export  const attract: (constant: number, origin: number, v: number) => number;

export  const attractExpo: (constant: number, origin: number, v: number) => number;

/**
 * 创建一个背景图层.
 *
 **/
export  class BackgroundLayer extends OverlayLayerBase {
    options: BackgroundLayerOptions;
    constructor(options: BackgroundLayerOptions);
    addTo(map: Map, beforeId?: string): void;
    setBackgroundColor(value: PropertyValueSpecificationEx<ColorSpecification>): this;
    getBackgroundColor(): PropertyValueSpecificationEx<ColorSpecification>;
    setBackgroundPattern(value: PropertyValueSpecificationEx<ResolvedImageSpecification>): this;
    getBackgroundPattern(): PropertyValueSpecificationEx<ResolvedImageSpecification>;
    setBackgroundOpacity(value: PropertyValueSpecificationEx<number>): this;
    getBackgroundOpacity(): PropertyValueSpecificationEx<number>;
}

export  interface BackgroundLayerOptions extends OverlayLayerBaseOptions {
    backgroundColor?: PropertyValueSpecificationEx<ColorSpecification>;
    backgroundPattern?: PropertyValueSpecificationEx<ResolvedImageSpecification>;
    backgroundOpacity?: PropertyValueSpecificationEx<number>;
}

export  type BackgroundLayerSpecification = {
    id: string;
    type: "background";
    metadata?: unknown;
    minzoom?: number;
    maxzoom?: number;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "background-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "background-pattern"?: PropertyValueSpecificationEx<ResolvedImageSpecification>;
        "background-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  const backIn: Easing;

export  const backInOut: Easing;

export  const backOut: Easing;

 type BBox = BBox2d | BBox3d;

/**
 * Bounding box
 *
 * https://tools.ietf.org/html/rfc7946#section-5
 * A GeoJSON object MAY have a member named 'bbox' to include information on the coordinate range for its Geometries, Features, or FeatureCollections.
 * The value of the bbox member MUST be an array of length 2*n where n is the number of dimensions represented in the contained geometries,
 * with all axes of the most southwesterly point followed by all axes of the more northeasterly point.
 * The axes order of a bbox follows the axes order of geometries.
 */
 type BBox2d = [number, number, number, number];

 type BBox3d = [number, number, number, number, number, number];

/**
 * [起始点, 贝塞尔曲线段, ...]
 * 下一段贝塞尔曲线的起始点是上一段的结束点
 */
 type BezierCurve = [CurvePoint, BezierCurveSegment, ...BezierCurveSegment[]];

/**
 * [控制点1，控制点2，结束点]
 */
 type BezierCurveSegment = [CurvePoint, CurvePoint, CurvePoint];

/**
 * @description 将 bezierCurve 转换为折线 [理想情况下，计算结果中相邻的两个点的距离等于设置的精度（单位 px）]
 * @param {BezierCurve} bezierCurve 贝塞尔曲线
 * @param {number} precision       想要的精度（并非总是可以实现）[建议精度 5-10。设置的精度通常是达不到的，除非设置较高的迭代次数，计算成本较高。]
 * @param {number} recursiveCount   递归计数
 */
export  function bezierCurveToPolyline(bezierCurve: BezierCurve, precision?: number, recursiveCount?: number): CurvePoint[];

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param fns list of member function names
 * @param context the context value
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
export  function bindAll(fns: string[], context: Object): void;

export  const bounceIn: Easing;

export  const bounceInOut: (p: number) => number;

export  const bounceOut: (p: number) => number;

/**
 * 呼吸的光圈.
 */
export  class BreathingApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    _createMarker(): void;
    private _createMakerElement;
    setMarkersWidth(width: number, index?: number): void;
    private _setBreathingApertureWidth;
    setDotSize(size: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
}

/**
 * 取一个凸环并通过在其周围应用缓冲区将其向外扩展。 此功能假定环是顺时针缠绕的。
 * @param ring
 * @param buffer
 * @return {any[]}
 */
export  function bufferConvexPolygon(ring: GeoPoint[], buffer: number): GeoPoint[];

/**
 * 根据多条多段线，建立topo
 * @param lines 坐标，请转成几何坐标，再传入
 * @param precision 误差，小数点后几位， 以为相同, 如果两个点的坐标距离小于此值，则认为是同一个节点
 * @param hasDirection 是否考虑方向
 * @return {{topo: any, graph: {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => NodeId[], addNode: (node: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => NodeId[], shortestPath: (source: NodeId, destination: NodeId) => NodeId[] & {weight?: EdgeWeight}, setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => NodeId[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, ...}}}
 */
export  function buildTopoGraph(lines: Array<{
    points: GeoPoint[];
    id?: string;
    weight?: number;
}>, precision?: number, hasDirection?: boolean): {
    graph: {
        addNode: (node: string) => any;
        removeNode: (node: string) => any;
        nodes: () => string[];
        adjacent: (node: string) => string[];
        addEdge: (u: string, v: string, weight?: number | undefined) => any;
        removeEdge: (u: string, v: string) => any;
        hasEdge: (u: string, v: string) => boolean;
        setEdgeWeight: (u: string, v: string, weight: number) => any;
        getEdgeWeight: (u: string, v: string) => number;
        indegree: (node: string) => number;
        outdegree: (node: string) => number;
        depthFirstSearch: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
        hasCycle: () => boolean;
        lowestCommonAncestors: (node1: string, node2: string) => string[];
        topologicalSort: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean) => string[];
        shortestPath: (source: string, destination: string) => string[] & {
            weight?: number | undefined;
        };
        serialize: () => Serialized;
        deserialize: (serialized: Serialized) => any;
    };
    topo: any;
};

/**
 * The algoritm is learnt from
 * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
 * And we made some optimization for matrix inversion.
 * Other similar approaches:
 * "cv::getPerspectiveTransform", "Direct Linear Transformation".
 */
/**
 * Usage:
 * ```js
 * const transformer = buildTransformer(
 *     [10, 44, 100, 44, 100, 300, 10, 300],
 *     [50, 54, 130, 14, 140, 330, 14, 220]
 * );
 * ```
 *
 * @param src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @param dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @return transformer If fail, return null/undefined.
 */
export  function buildTransformer(src: number[], dest: number[]): number[] | undefined;

/**
 * 透视投影转3d css 矩阵
 * Usage:
 * ```js
 * const transformer = buildTransformerMatrix3d(
 *     [10, 44, 100, 44, 100, 300, 10, 300],
 *     [50, 54, 130, 14, 140, 330, 14, 220]
 * );
 * ```
 *
 * @param src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @param dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 */
export  function buildTransformerMatrix3d(src: number[], dest: number[]): string | undefined;

export  class ButtonGroupControl {
    constructor(options?: Record<string, any>);
    onAdd(map: Map): HTMLElement;
    onRemove(): void;
}

/**
 * 计算多边形面积
 * @param points
 * @return {number}
 */
export  function calcPolygonArea(points: GeoPoint[]): number;

/**
 * 返回多边形的有符号的面积。正区域为外环，具有顺时针绕组。负区域为内环，按逆时针顺序排列。
 * @param ring
 * @return {number}
 */
export  function calculateSignedArea(ring: GeoPoint[]): number;

export  type CameraFunctionSpecificationEx<T> = {
    type: "exponential";
    stops: Array<[number, T]>;
} | {
    type: "interval";
    stops: Array<[number, T]>;
};

export  const circIn: Easing;

export  const circInOut: Easing;

/**
 * 创建圆符号图层.
 *
 **/
export  class Circle extends OverlayLayerBase {
    options: CircleOptions;
    constructor(options: CircleOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setCircleSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleSortKey(): DataDrivenPropertyValueSpecification<number>;
    setVisibility(value: "visible" | "none"): this;
    getVisibility(): "visible" | "none";
    setCircleRadius(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleRadius(): DataDrivenPropertyValueSpecification<number>;
    setCircleColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getCircleColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setCircleBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleBlur(): DataDrivenPropertyValueSpecification<number>;
    setCircleOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleOpacity(): DataDrivenPropertyValueSpecification<number>;
    setCircleTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getCircleTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setCircleTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCircleTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCirclePitchScale(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCirclePitchScale(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCirclePitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCirclePitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCircleStrokeWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleStrokeWidth(): DataDrivenPropertyValueSpecification<number>;
    setCircleStrokeColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getCircleStrokeColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setCircleStrokeOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleStrokeOpacity(): DataDrivenPropertyValueSpecification<number>;
}

/**
 * 创建只有边框的圆或圆弧
 *
 **/
export  class CircleEdge extends Polyline {
    constructor(options: CircleEdgeOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /** 设置中心点。 */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /** 得到中心点。 */
    getCenter(): GeoPointLike;
    /** 设置半径。 */
    setRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到半径。 */
    getRadius(): number;
    /** 设置开始角度。 */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到开始角度。 */
    getStartAngle(): number;
    /** 设置结束角度。 */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到结束角度。 */
    getEndAngle(): number;
    /** 设置离散化的点的个数。 */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /** 得到离散化的点的个数。 */
    getPoints(): number;
}

export  interface CircleEdgeOptions extends PolylineOptions {
    /** 中心点 */
    center: GeoPointLike;
    /** 半径 */
    radius: number;
    /** 开始角度 */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /** 属性数据 */
    properties?: object;
}

/**
 * 创建填充的圆或圆弧
 *
 **/
export  class CircleFill extends Polygon {
    constructor(options: CircleFillOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /** 设置中心点。 */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /** 得到中心点。 */
    getCenter(): GeoPointLike;
    /** 设置半径。 */
    setRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到半径。 */
    getRadius(): number;
    /** 设置开始角度。 */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到开始角度。 */
    getStartAngle(): number;
    /** 设置结束角度。 */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到结束角度。 */
    getEndAngle(): number;
    /** 设置离散化的点的个数。 */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /** 得到离散化的点的个数。 */
    getPoints(): number;
}

export  interface CircleFillOptions extends PolygonOptions {
    /** 中心点 */
    center: GeoPointLike;
    /** 半径 */
    radius: number;
    /** 开始角度 */
    startAngle?: number;
    /** 终止角度 */
    endAngle?: number;
    /** 离散化的点的个数 */
    points?: number;
    /** 属性数据 */
    properties?: object;
}

export  type CircleLayerSpecification = {
    id: string;
    type: "circle";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "circle-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "circle-radius"?: DataDrivenPropertyValueSpecification<number>;
        "circle-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "circle-blur"?: DataDrivenPropertyValueSpecification<number>;
        "circle-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "circle-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "circle-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-pitch-scale"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-stroke-width"?: DataDrivenPropertyValueSpecification<number>;
        "circle-stroke-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "circle-stroke-opacity"?: DataDrivenPropertyValueSpecification<number>;
    };
};

export  type CircleLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    circleSortKey?: DataDrivenPropertyValueSpecification<number>;
    visibility?: "visible" | "none";
    circleRadius?: DataDrivenPropertyValueSpecification<number>;
    circleColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleBlur?: DataDrivenPropertyValueSpecification<number>;
    circleOpacity?: DataDrivenPropertyValueSpecification<number>;
    circleTranslate?: PropertyValueSpecificationEx<[number, number]>;
    circleTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchScale?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport">;
    circleStrokeWidth?: DataDrivenPropertyValueSpecification<number>;
    circleStrokeColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleStrokeOpacity?: DataDrivenPropertyValueSpecification<number>;
};

export  interface CircleOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    circleSortKey?: DataDrivenPropertyValueSpecification<number>;
    circleRadius?: DataDrivenPropertyValueSpecification<number>;
    circleColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleBlur?: DataDrivenPropertyValueSpecification<number>;
    circleOpacity?: DataDrivenPropertyValueSpecification<number>;
    circleTranslate?: PropertyValueSpecificationEx<[number, number]>;
    circleTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchScale?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport">;
    circleStrokeWidth?: DataDrivenPropertyValueSpecification<number>;
    circleStrokeColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleStrokeOpacity?: DataDrivenPropertyValueSpecification<number>;
}

export  const circOut: Easing;

export  const clamp: (min: number, max: number, v: number) => number;

/**
 * 根据范围裁剪多边形
 * @param points
 * @param bounds
 * @return {GeoPoint[]}
 */
export  function clipPolygon(points: GeoPoint[], bounds: GeoBounds): GeoPoint[];

/**
 * 根据范围裁剪线段
 * @param a
 * @param b
 * @param bounds
 * @return {GeoPoint[] | boolean}
 */
export  function clipSegment(a: GeoPoint, b: GeoPoint, bounds: GeoBounds): GeoPoint[] | Boolean;

/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
export  function cloneDeep<T>(obj: T): T;

/**
 * 闭合多边形
 * @param points
 * @return points
 */
export  function closePolygon(points: GeoPoint[]): GeoPoint[];

/**
 * 点到多段线的最近点
 * @param p
 * @param points
 */
export  function closestPointOnPolyline(p: GeoPoint, points: GeoPoint[]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPrePointDist: number;
};

/**
 * 点到多条线的最近点
 * @param p
 * @param lines
 */
export  function closestPointOnPolylines(p: GeoPoint, lines: GeoPoint[][]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPointIndex: number;
    closestPrePointDist: number;
};

/**
 * 点到线段的最近点
 * @param p
 * @param p1
 * @param p2
 * @return {GeoPoint}
 */
export  function closestPointOnSegment(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): GeoPoint;

export  type ColorSpecification = string;

export  class Compare extends Evented {
    constructor(a: Map, b: Map, container: Element | string, options?: {
        mousemove: boolean;
        orientation: 'vertical' | 'horizontal';
    });
    private _setPointerEvents;
    private _onDown;
    private _setPosition;
    private _onMove;
    private _onMouseUp;
    private _onTouchEnd;
    private _getX;
    private _getY;
    setSlider(x: number): void;
    remove(): void;
}

export  type CompositeFunctionSpecification<T> = {
    type: "exponential";
    stops: Array<[{
        zoom: number;
        value: number;
    }, T]>;
    property: string;
    default?: T;
} | {
    type: "interval";
    stops: Array<[{
        zoom: number;
        value: number;
    }, T]>;
    property: string;
    default?: T;
} | {
    type: "categorical";
    stops: Array<[{
        zoom: number;
        value: string | number | boolean;
    }, T]>;
    property: string;
    default?: T;
};

export  interface Config<T = unknown> {
    url?: string;
    method: keyof Methods;
    data?: Document | BodyInit;
    headers: {
        [key: string]: string;
    };
    dump: (data: T) => string;
    load: (str: string) => T;
    xmlHttpRequest: () => XMLHttpRequest;
    promise: (fn: () => Promise<unknown>) => Promise<unknown>;
    abort?: any;
    params?: string[][] | Record<string, string> | string | URLSearchParams;
    withCredentials: boolean;
    raw?: boolean;
    events?: {
        [key: string]: () => void;
    };
}

/**
 * 上下文菜单.
 *
 **/
export  class ContextMenu {
    private options;
    private menuControl;
    private position;
    /**
     * Creates a new ContextMenu menu
     * @param {object} opts options which build the menu e.g. position and items
     * @param {number} opts.width sets the width of the menu including children
     * @param {object} opts.event 事件对象
     * @param {theme} opts.theme 自定义的样式主题，支持dark和light，默认dark
     * @param {boolean} opts.isSticky sets how the menu apears, follow the mouse or sticky
     * @param {Array<ContextMenuItem>} opts.items sets the default items in the menu
     */
    constructor(opts: ContextMenuOptions);
    /**
     * Adds item to this ContextMenu menu instance
     * @param {ContextMenuItem} item item to add to the ContextMenu menu
     */
    add(item: any): void;
    /**
     * Makes this ContextMenu menu visible
     */
    show(): void;
    /**
     * Hides this ContextMenu menu
     */
    hide(): void;
    /**
     * Toggle visibility of menu
     */
    toggle(): void;
}

/**
 * 上下文菜单选项.
 *
 **/
export  interface ContextMenuOptions {
    /** 事件对象. */
    event: Event;
    /** 菜单宽度（包括子菜单),像素，默认150px. */
    width?: string;
    /** 菜单主题色.(dark和light,默认dark)*/
    theme?: string;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小宽 可通过 map.getContainer().getBoundingClientRect().width来设置 */
    innerWidth?: number;
    /** 菜单外面容器的内部宽，用于菜单超时范围时自动调位置，默认是window大小高 可通过 map.getContainer().getBoundingClientRect().height来设置 */
    innerHeight?: number;
    /** 子项 */
    items: ContextMenuSubItemOptions[];
}

/**
 * 上下文菜单子项选项.
 *
 **/
export  interface ContextMenuSubItemOptions {
    /** 子菜单类型. */
    type?: "custom" | "multi" | "Button" | "seperator" | "submenu" | "hovermenu" | "normal";
    /** 类型为'custom'时的自定义html内容 */
    markup?: string;
    /** 类型为'multi'时子菜单项*/
    items?: ContextMenuSubItemOptions[];
    /** 点击事件*/
    onClick?: Function;
    /** 菜单名称*/
    label?: string;
    /** 快捷菜单*/
    shortcut?: string;
    /** 是否能用*/
    enabled?: boolean;
    /** css图标*/
    cssIcon?: string;
    /** 图标*/
    icon?: string;
}

/**
 * transform
 *
 * @param {geojson|GeoPointLike|GeoPointLike[]|string} input
 * @returns {geojson|GeoPointLike | GeoPointLike[]} output
 */
 function convert<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(input: T | string, crsFrom: ((pt: GeoPoint) => GeoPoint) | CRSTypes, crsTo?: CRSTypes): T;

/**
 * 通过四参数进行坐标转换
 * @param pt 点
 * @param param 四参数
 * @return {GeoPoint}
 */
export  function coordTransfromByFourParamter(pt: GeoPoint, param: {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
}): GeoPoint;

/**
 * 通过四参数反算进行坐标转换
 * @param pt 点
 * @param param 四参数
 * @return {GeoPoint}
 */
export  function coordTransfromByInvFourParamter(pt: GeoPoint, param: {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
}): GeoPoint;

/**
 * 坐标转换得到四参数
 * @param srcArr 原始点数组
 * @param destArr 目标点数组
 * @param isSetRotateZero 是否设置旋转为零，默认false,如果为true,则只考虑平移和缩放
 * @param isConsiderPointOrder 不考虑点的次序(这样旋转角度方向总是上面，在-180,180之间）
 * @returns {{rotate: number, dx: number, dy: number, scale: number}}
 */
export  function coordTransfromGetFourParamter(srcArr: GeoPoint[], destArr: GeoPoint[], isSetRotateZero: boolean, isConsiderPointOrder?: boolean): {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
};

/**
 * 创建多边形动画图层
 * @param map 地图对象
 * @param path 线坐标(lngLat)
 * @param options 选项
 */
export  function createAnimateFillLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: IAnimateFillLayerOptions): ICreateFillAnimateLayerResult;

/**
 * 创建动画图片集
 * @param options 选项
 */
export  function createAnimateImages(options?: ICreateAnimateImagesOptions): Array<ImageData>;

/**
 * 创建多段线动画图层
 * @param map 地图对象
 * @param path 线坐标(lngLat)
 * @param options 选项
 */
export  function createAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: IAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * 创建符号动画图层
 * @param map 地图对象
 * @param path 符号坐标(lngLat)
 * @param options 选项
 */
export  function createAnimateSymbolLayer(map: Map, path: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any, options?: IAnimateSymbolLayerOptions): ICreateSymbolAnimateLayerResult;

export  function createAnimation<V = number>({ from, autoplay, driver, elapsed, repeat: repeatMax, repeatType, repeatDelay, onPlay, onStop, onComplete, onRepeat, onUpdate, ...options }: any): {
    stop: () => void;
    start: (reset?: boolean | undefined) => void;
};

export  const createAnticipate: (power: number) => Easing;

/**
 * 创建蚂蚁线动画图像集
 * @param options 选项
 */
export  function createAntPathAnimateImages(options?: ICreateAntPathAnimateLineLayerOptions): ImageData[];

/**
 * 创建蚂蚁线动画线图层
 * @param map 地图对象
 * @param path 线坐标(lngLat)
 * @param options 选项
 */
export  function createAntPathAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: ICreateAntPathAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * 创建箭头动画图像集
 * @param options 选项
 */
export  function createArrowAnimateImages(options?: ICreateArrowAnimateLineLayerOptions): ImageData[];

/**
 * 创建箭头动画线图层
 * @param map 地图对象
 * @param path 线坐标(lngLat)
 * @param options 选项
 */
export  function createArrowAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: ICreateArrowAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * Creates an attractor that, given a strength constant, origin and value,
 * will calculate value as attracted to origin.
 */
export  const createAttractor: (alterDisplacement?: Function) => (constant: number, origin: number, v: number) => number;

export  const createBackIn: (power: number) => Easing;

export  const createExpoIn: (power: number) => Easing;

/**
 * 创建一个 FrameAnimation 对象来启动和停止你的动画功能.
 * @example
 * const count = 0;
 *
 * const animation = createFrameAnimation(() => {
 *   context.clearRect(0, 0, width, height);
 *   context.font = "4rem monospace";
 *   context.textAlign = 'center';
 *   context.fillText(count, width / 2, height / 2);
 *
 *   count++;
 * });
 *
 * animation.start();
 * @param {function():void} callback - 处理动画的回调,如果返回true，表示结束动画，返回false表示继续动画， .
 * @returns {{readonly running: boolean, stop: () => void, start: () => void} | boolean}
 * @param stopCallBack 结束动画的回调，参数表示是取消（true)，还是正常结束(false)
 * @param fps 一秒运行多少帧，用来控制速度，如为0，则默认为系统帧率
 */
export  function createFrameAnimation(callback: (status: FrameAnimationStatus) => boolean, fps?: number, stopCallBack?: (status: FrameAnimationStatus) => void): FrameAnimation;

/**
 * 创建geoson格式的线
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createLineGeoJson(input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any): GeoJsonGeomertry;

/**
 * 创建一个Makrer对象，相当于new Marker()
 */
export  function createMarker(options?: createMarkerOptions): Marker;

export  interface createMarkerOptions extends MarkerOptions {
    /** LngLat值. */
    lngLat?: LngLatLike;
    /** 显示的最小级别. */
    minZoom?: number;
    /** 显示的最大级别. */
    maxZoom?: number;
    /** 设置能缩放的最大级别。如果小于这个级别，div将根据缩小级别自动缩小比例。默认不会自动缩放 */
    scaleMaxZoom?: number;
    /** 高度值. */
    height?: number;
    /** 设置当marker不在当前地图视图范围内时，将自动移除。进入视图范围内时，将自动增加上*/
    removeWhenNoInMapView?: boolean;
    /** 设置当marker不在当前地图视图范围内时，将自动移除。范围向外扩的像素范围，默认500px，向视图范围往外扩些像素，在平移的时候，能看到marker，体验效果好些。*/
    removeWhenNoInMapViewPadding?: number;
}

export  function createObjectOffset(): {
    offsetLines(dist: number): any;
    offset(dist: number): any;
    margin(dist: number): any;
    padding(dist: number): any;
    data(vertices: any): any;
};

export  function createObjectPolygonUtil(): {
    diff(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
    union(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
    intersection(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
};

/**
 * 创建geoson格式的点
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createPointGeoJson(input: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): GeoJsonGeomertry;

/**
 * 创建geoson格式的多边形
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createPolygonGeoJson(input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any): GeoJsonGeomertry;

 enum CRSTypes {
    WGS84 = "WGS84",
    WGS1984 = "WGS84",
    EPSG4326 = "WGS84",
    GCJ02 = "GCJ02",
    AMap = "GCJ02",
    BD09 = "BD09",
    BD09LL = "BD09",
    Baidu = "BD09",
    BMap = "BD09",
    BD09MC = "BD09MC",
    BD09Meter = "BD09MC",
    EPSG3857 = "EPSG3857",
    EPSG900913 = "EPSG3857",
    EPSG102100 = "EPSG3857",
    WebMercator = "EPSG3857",
    WM = "EPSG3857"
}

export  function cubicBezier(mX1: number, mY1: number, mX2: number, mY2: number): any;

 type CurvePoint = [number, number];

export  type DataDrivenPropertyValueSpecification<T> = T | CameraFunctionSpecificationEx<T> | SourceFunctionSpecification<T> | CompositeFunctionSpecification<T> | ExpressionSpecificationEx;

/**
 * `Db2dPolyline` 二维多段线实体.
 *
 */
export  class Db2dPolyline extends DbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 高程. */
    elevation?: number;
    /** 2d折线类型*/
    polyType?: Poly2dType;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDb2dPolyline);
}

/**
 * `Db2LineAngularDimension` 角度标注[两条线]实体.
 *
 */
export  class Db2LineAngularDimension extends DbDimension {
    /** 圆弧点位置. */
    arcPoint?: Array<[number, number, number?]>;
    /** 线1起点. */
    xLine1Start?: Array<[number, number, number?]>;
    /** 线1终点. */
    xLine1End?: Array<[number, number, number?]>;
    /** 线2起点. */
    xLine2Start?: Array<[number, number, number?]>;
    /** 线2终点. */
    xLine2End?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDb2LineAngularDimension);
}

/**
 * `Db3dPolyline` 三维多段线实体.
 *
 */
export  class Db3dPolyline extends DbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 3d折线类型*/
    polyType?: Poly3dType;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDb3dPolyline);
}

/**
 * `Db3PointAngularDimension` 角度标注[三点]实体.
 *
 */
export  class Db3PointAngularDimension extends DbDimension {
    /** 圆弧点位置. */
    arcPoint?: Array<[number, number, number?]>;
    /** 中点. */
    centerPoint?: Array<[number, number, number?]>;
    /** 点1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 点2. */
    xLine2Point?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDb3PointAngularDimension);
}

/**
 * `DbAlignedDimension` 对齐标注实体.
 *
 */
export  class DbAlignedDimension extends DbDimension {
    /** 线1点. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线2点. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 设置定义此dimension实体尺寸线位置的WCS点. */
    dimLinePoint?: Array<[number, number, number?]>;
    /** 设置此实体的符号高度。. */
    jogSymbolHeight?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbAlignedDimension);
}

/**
 * `DbArc` 圆弧实体.
 *
 */
export  class DbArc extends DbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 半径. */
    radius?: number;
    /** 开始弧度. */
    startAngle?: number;
    /** 结束弧度. */
    endAngle?: number;
    /** 厚度. */
    thickness?: number;
    /** 法向量. */
    normal?: [number, number, number?];
    /**
     * 构造函数
     */
    constructor(prop?: IDbArc);
}

/**
 * `DbArcDimension` 圆弧标注实体.
 *
 */
export  class DbArcDimension extends DbDimension {
    /** 线1点. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线2点. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 中心点. */
    centerPoint?: Array<[number, number, number?]>;
    /** 圆弧点. */
    arcPoint?: Array<[number, number, number?]>;
    /** 文本中使用的弧符号的类型。 0 弧符号在文本前面;   1 弧线符号在文字上方;   2  没有符号. */
    arcSymbolType?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbArcDimension);
}

/**
 * `DbText` 属性定义实体.
 *
 */
export  class DbAttributeDefinition extends DbText {
    /** 属性名. */
    tag?: string;
    /** 属性提示. */
    prompt?: string;
    /**
     * 构造函数
     */
    constructor(prop?: IDbText);
}

/**
 * `DbBlock` 块定义.
 *
 */
export  class DbBlock {
    /** 块名称. */
    name?: string;
    /** 设置此块的参照的缩放特征. */
    scaling?: number;
    /** 设置此块的块插入单位 . */
    insertUnits?: number;
    /** 原点。 . */
    origin?: [number, number, number?];
    /** 备注. */
    comments?: string;
    /** 是否可炸开. */
    explodable?: boolean;
    /** 由哪些实体创建而成. */
    entitys?: IDbEntity[];
    /**
     * 构造函数
     */
    constructor(prop?: IDbBlock);
}

/**
 * `DbBlockReference` 块参照实体.
 *
 */
export  class DbBlockReference extends DbEntity {
    /** 块名称. */
    blockname?: string;
    /** 参考外部图形，形式为 mapid/version,如 exam/v1. */
    ref?: string;
    /** 坐标. */
    position?: [number, number, number?];
    /** 法向量. */
    normal?: [number, number, number?];
    /** 旋转角度. */
    rotation?: number;
    /** 缩放因子. [x方向，y方向,z方向]*/
    scaleFactors?: [number, number, number?];
    /** 属性字段值*/
    attribute?: Record<string, string | number | DbText>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbBlockReference);
}

/**
 * `DbCircle` 圆实体.
 *
 */
export  class DbCircle extends DbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 半径. */
    radius?: number;
    /** 厚度. */
    thickness?: number;
    /** 法向量. */
    normal?: [number, number, number?];
    /**
     * 构造函数
     */
    constructor(prop?: IDbCircle);
}

/**
 * `DbCurve` 曲线实体.
 *
 */
export  class DbCurve extends DbEntity {
    /**
     * 构造函数
     */
    constructor(prop?: IDbCurve);
}

/**
 * `DbDiametricDimension` 直径标注实体.
 *
 */
export  class DbDiametricDimension extends DbDimension {
    /** 圆上1点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 圆上2点. */
    farChordPoint?: Array<[number, number, number?]>;
    /** 引线长度. */
    leaderLength?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbDiametricDimension);
}

/**
 * `DbDimension` 标注实体.
 *
 */
export  class DbDimension extends DbEntity {
    /** 标注样式. */
    dimStyle?: string;
    /** 文字位置. */
    textPosition?: Array<[number, number, number?]>;
    /** 文字高度. */
    textHeight?: number;
    /** 文字旋转角度. */
    textRotation?: number;
    /** 注记比例. */
    dimScale?: number;
    /** 设置标注主单位显示的小数位位数. */
    dimDec?: number;
    /** 箭头大小. */
    arrowSize?: number;
    /** 所有标注距离舍入到指定值. */
    dimRnd?: number;
    /** 文本颜色. */
    textColor?: number;
    /** 箭头颜色. */
    arrowColor?: number;
    /** 引线颜色. */
    lineColor?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbDimension);
}

/**
 * `DbDocument` 地图数据库文档.
 *
 */
export  class DbDocument {
    /** 来源于哪个图，会在此图的上面进行修改或新增删除，格式如 形式为 mapid/version,如 exam/v1 . */
    from?: string;
    /** 来源于哪个图时有效，表示从此图中选择指定的图层，不在指定的图层将不会显示 */
    pickLayers?: string[];
    /** 来源于哪个图时有效，表示从此图中选择指定的实体ID，不在指定的实体ID将不会显示 */
    pickEntitys?: string[];
    /** 来源于哪个图时有效，使用表达式，表示从此图中选择指定的实体ID，不在指定的实体ID将不会显示 结果与pickEntitys的取并 */
    pickExpr?: string;
    isClearFromDb?: boolean;
    /** 文档环境，用于设置是否显示线宽等设置, 设置线宽为 LWDISPLAY ,true显示或 false不显示线宽*/
    environment?: Record<string, any>;
    /** 实体集. */
    entitys?: IDbEntity[];
    /** 图层集. */
    layers?: IDbLayer[];
    /** 文字样式. */
    textStyles?: IDbTextStyle[];
    /** 标注样式. */
    dimStyles?: IDbDimStyle[];
    /** 线型. */
    linetypes?: IDbLinetype[];
    /** 块定义. */
    blocks?: IDbBlock[];
    /** 来源于其他图的实体时，如果块定义重复，则自动重命名 ，默认true */
    isRenameBlockNameIfExist?: boolean;
    /**
     * 构造函数
     */
    constructor(prop?: IDbDocument);
    /**
     * 增加实体
     * @param entity
     */
    appendEntity(entity: IDbEntity | IDbEntity[]): void;
    /**
     * 增加图层
     * @param layer
     */
    appendLayer(layer: IDbLayer | IDbLayer[]): void;
    /**
     * 增加样式样式
     * @param textStyle
     */
    appendTextStyle(textStyle: IDbTextStyle | IDbTextStyle[]): void;
    /**
     * 增加标注样式
     * @param dimStyle
     */
    appendDimStyle(dimStyle: IDbDimStyle | IDbDimStyle[]): void;
    /**
     * 增加线型
     * @param linetype
     */
    appendLinetype(linetype: IDbLinetype | IDbLinetype[]): void;
    /**
     * 增加块
     * @param block
     */
    appendBlock(block: IDbBlock | IDbBlock[]): void;
    /**
     * 转成文档字符串
     * @param content 如果传入了内容，则以content为主。json格式
     * @return {string}
     */
    toDoc(content?: string): string;
}

/**
 * `DbEllipse` 椭圆实体.
 *
 */
export  class DbEllipse extends DbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 主轴方向. */
    minorAxis?: [number, number, number?];
    /** 开始弧度. */
    startAngle?: number;
    /** 结束弧度. */
    endAngle?: number;
    /** 短轴和长轴的比例. */
    radiusRatio?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbEllipse);
}

/**
 * `DbEntity` 实体基类.
 *
 */
export  abstract class DbEntity implements IDbEntity {
    /** 类型. */
    typename?: string;
    /** 颜色. */
    color?: number;
    /** 颜色索引. 0 随块. 1 Red.  2 Yellow. 3   Green.  4 Cyan.  5  Blue. 6   Magenta. 256 表示随层*/
    colorIndex?: number;
    /** 图层. */
    layer?: string;
    /** 线型. */
    linetype?: string;
    /** 线型比例. */
    linetypeScale?: number;
    /** 线宽. */
    lineWidth?: number;
    /** 透明度. [0-255][0完全透明,255完全不透明]*/
    alpha?: number;
    /** 可见. */
    visibility?: boolean;
    /** 矩阵. */
    matrix?: IDbMatrixOp[];
    /** 扩展数据. */
    xdata?: string;
    /** 克隆的实体ID，DbDocument有from图形来源字段时有效. */
    cloneObjectId?: string;
    /** 克隆的实体ID来源的图形，如为空，则取DbDocument中from的图形。也可以指定另外的图形*/
    cloneFromDb?: string;
    /**
    * 构造函数
    * @param prop
    */
    protected constructor(prop?: IDbEntity);
}

/**
 * `DbHatch` 图案实体.
 *
 */
export  class DbHatch extends DbEntity {
    /** 高程. */
    elevation?: number;
    /** 填充图案, 缺省 SOLID */
    pattern?: string;
    /** 填充角度 */
    patternAngle?: number;
    /** 指定用户定义的图案填充是否双向填充 */
    patternDouble?: boolean;
    /** 填充间距 */
    patternSpace?: number;
    /** 填充比例 */
    patternScale?: number;
    /** 是否关联 */
    patternAssociative?: boolean;
    /** 填充原点坐标 */
    patternOrigin?: [number, number];
    /** 填充背景色 */
    patternBackgroundColor?: number;
    /** 坐标. */
    points?: Array<[number, number, number?]> | Array<Array<[number, number, number?]>>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbHatch);
}

/**
 * `DbLayer` 图层.
 *
 */
export  class DbLayer {
    /** 图层名称. 如果要对所有图层进行修改时，请使用 \*all_layers\* */
    name?: string;
    /** 图层颜色索引. */
    color?: number;
    /** 图层线型，缺省 CONTINUOUS . */
    linetype?: string;
    /** 图层开关. */
    isOff?: boolean;
    /** 图层锁定. */
    isLocked?: boolean;
    /** 图层冻结. */
    isFrozen?: boolean;
    /**
     * 构造函数
     */
    constructor(prop?: IDbLayer);
}

/**
 * `DbLine` 线实体.
 *
 */
export  class DbLine extends DbEntity implements IDbLine {
    /** 起点. */
    start?: [number, number, number?];
    /** 终点. */
    end?: [number, number, number?];
    /** 厚度. */
    thickness?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbLine);
}

/**
 * `DbLineType` 线型.
 *
 */
export  class DbLineType {
    /** 线型名称. */
    name?: string;
    /** 评论. */
    comments?: string;
    /** 线型样式 . */
    style?: IDbLinetypeStyle[];
    /**
     * 构造函数
     */
    constructor(prop?: IDbLinetype);
}

/**
 * `DbMLeader` 多重引线.
 *
 */
export  class DbMLeader extends DbEntity {
    /** 文本宽. */
    textWidth?: number;
    /** 文本高. */
    height?: number;
    /** 文本旋转角度. */
    textRotation?: number;
    /** 文本高. */
    textHeight?: number;
    /** 文本内容. */
    contents?: string;
    /** 文本位置. */
    textLocation?: [number, number, number?];
    /** 文本对齐方式. */
    textAttachment?: MTextAttachmentPoint;
    /** 文本样式. */
    textStyle?: string;
    /** 文本对齐方向. 0 水平 1 垂直*/
    textAttachmentDirection?: 0 | 1;
    /** 文本对齐类型. type(0-10) value(0-4) [type1, value1, type2, value2....]*/
    textAttachmentType?: number[];
    /** 引线位置. */
    leaderLinePoint?: [number, number, number?];
    /** 引线顶点位置数组. */
    leaderVertexPoints?: [number, number, number?][];
    enableDogleg?: boolean;
    landingGap?: number;
    doglegLength?: number;
    blockScale?: [number, number, number];
    blockPosition?: [number, number, number?];
    arrowSize?: number;
    blockRotation?: number;
    blockConnectionType?: 0 | 1;
    /**
     * 构造函数
     */
    constructor(prop?: IDbMText);
}

/**
 * `DbMText` 多行文本实体.
 *
 */
export  class DbMText extends DbEntity {
    /** 宽. */
    width?: number;
    /** 高. */
    height?: number;
    /** 旋转角度. */
    rotation?: number;
    /** 文本高. */
    textHeight?: number;
    /** 文本内容. */
    contents?: string;
    /** 位置. */
    location?: [number, number, number?];
    /** 对齐方式. */
    attachment?: MTextAttachmentPoint;
    /** 文本样式. */
    textStyle?: string;
    /**
     * 构造函数
     */
    constructor(prop?: IDbMText);
}

/**
 * `DbOrdinateDimension`  坐标标注实体.
 *
 */
export  class DbOrdinateDimension extends DbDimension {
    /** 基点. */
    origin?: Array<[number, number, number?]>;
    /** 定义点. */
    definingPoint?: Array<[number, number, number?]>;
    /** 引线点. */
    leaderEndPoint?: Array<[number, number, number?]>;
    /** 是否用X轴. */
    useXAxis?: boolean;
    /**
     * 构造函数
     */
    constructor(prop?: IDbOrdinateDimension);
}

/**
 * `DbPolyline` 多段线实体.
 *
 */
export  class DbPolyline extends DbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 高程. */
    elevation?: number;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
    /** 凸度. */
    bulge?: number[];
    /** 起点宽. */
    startWidth?: number[];
    /** 终点宽. */
    endWidth?: number[];
    /**
     * 构造函数
     */
    constructor(prop?: IDbPolyline);
}

/**
 * `DbRadialDimension` 半径标注实体
 *
 */
export  class DbRadialDimension extends DbDimension {
    /** 中心点. */
    center?: Array<[number, number, number?]>;
    /** 圆上点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 引线长度. */
    leaderLength?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbRadialDimension);
}

/**
 * `DbRadialDimensionLarge` 半径折线标注实体.
 *
 */
export  class DbRadialDimensionLarge extends DbDimension {
    /** 中心点. */
    center?: Array<[number, number, number?]>;
    /** 圆上点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 设置由该Dimension实体确定尺寸的弧的WCS覆盖中心。. */
    overrideCenter?: Array<[number, number, number?]>;
    /** 设置此Dimension实体的折角点。. */
    jogPoint?: Array<[number, number, number?]>;
    /** 设置此Dimension实体的折角。. */
    jogAngle?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbRadialDimensionLarge);
}

/**
 * `DbRasterImage` 栅格图像实体.
 *
 */
export  class DbRasterImage extends DbEntity {
    /** 明亮度 [0.0 .. 100.0] */
    brightness?: number;
    /** 图片url地址. */
    sourceHttpUrl?: string;
    /** 源图片宽. */
    pixelWidth?: number;
    /** 源图片高. */
    pixelHeight?: number;
    /** 单位. */
    units?: RasterImageUnits;
    /** x轴每像素代表长度. */
    xPelsPerUnit?: number;
    /** y轴每像素代表长度. */
    yPelsPerUnit?: number;
    /** 宽比例. */
    widthRatio?: number;
    /** 高比例.. */
    heightRatio?: number;
    /** 位置. */
    position?: [number, number, number?];
    /** 是否显示. */
    imageDisplayOptShow?: boolean;
    /** 是否裁剪. */
    imageDisplayOptClip?: boolean;
    /** 是否对齐. */
    imageDisplayOptShowUnAligned?: boolean;
    /** 是否透明. */
    imageDisplayOptTransparent?: boolean;
    /**
     * 构造函数
     */
    constructor(prop?: IDbRasterImage);
}

/**
 * `DbRotatedDimension` 转角标注实体.
 *
 */
export  class DbRotatedDimension extends DbDimension {
    /** 线上点1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线上点2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 设置定义此dimension实体尺寸线位置的WCS点。. */
    dimLinePoint?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbRotatedDimension);
}

/**
 * `DbShape` 型实体
 *
 */
export  class DbShape extends DbEntity {
    /** 旋转角度. */
    rotation?: number;
    /** 位置. */
    position?: [number, number, number?];
    /** 大小. */
    size?: number;
    /** 法向量. */
    normal?: [number, number, number?];
    /** 型名称. */
    name?: string;
    /**
     * 构造函数
     */
    constructor(prop?: IDbShape);
}

/**
 * `DbSpline` 样条曲线实体.
 *
 */
export  class DbSpline extends DbCurve {
    /** the curve fitting tolerance for this Spline entity. */
    fitTol?: number;
    /** Increased the degree of this spline to the specified value. */
    degree?: number;
    /** 拟合点. */
    fitPoints?: Array<[number, number, number?]>;
    /** 控制点. */
    controlPoints?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbSpline);
}

/**
 * `DbBlockReference` 块参照实体.
 *
 */
export  class DbTable extends DbBlockReference {
    /** 表样式名称. */
    tableStyleName?: string;
    /** 表格列数. */
    numColumns?: number;
    /** 表格行数. */
    numRows?: number;
    /** 列宽. */
    columnWidth?: number;
    /** 行高. */
    rowHeight?: number;
    /** 是否禁用标题. */
    disableTitle?: boolean;
    /** 表格方向是否从上至上. */
    directionBottomToTop?: boolean;
    /** 文字高度(所有单元格). */
    textHeight?: number;
    /** 显示网格线.第二个参数(kHorzTop(1), kHorzInside(2), kHorzBottom(4), kVertLeft(8), kVertInside(16), kVertRight(32);  第三个参数 kTitleRow(1), kHeaderRow(2), kDataRow(4) */
    gridVisibility?: [boolean, number, number];
    /** 背景颜色(所有单元格). */
    backgroundColor?: number;
    /** 文字颜色(所有单元格). */
    contentColor?: number;
    /** 网格线颜色(所有单元格). */
    gridColor?: number;
    /** 单元格对齐方式(所有单元格). */
    alignment?: TableCellAlignment;
    /** 水平方向单元格边距. */
    horzCellMargin?: number;
    /** 竖直方向单元格边距. */
    vertCellMargin?: number;
    /** 需要合并的单元格 [[minRow, maxRow,minColumn, maxColumn], ...]  */
    mergeCells?: Array<[number, number, number, number]>;
    /** 数据. */
    data?: Array<Array<string | {
        /** 单元格文本内容. */
        text: string;
        /** 单元格对齐方式. */
        alignment: TableCellAlignment;
        /** 单元格背景色. */
        backgroundColor: number;
        /** 单元格网格线颜色. */
        gridColor: number;
        /** 单元格文本颜色. */
        contentColor: number;
        /** 单元格文本高度. */
        textHeight: number;
        /** 是否显示单元格网格线. */
        gridVisibility: boolean;
    }>>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbTable);
}

/**
 * `DbText` 文本实体.
 *
 */
export  class DbText extends DbEntity {
    /** 高. */
    height?: number;
    /** 旋转角度. */
    rotation?: number;
    /** 文本内容， 同contents. */
    text?: string;
    /** 文本内容， 同text. */
    contents?: string;
    /** 位置. */
    position?: [number, number, number?];
    /** 文本样式. */
    textStyle?: string;
    /** 水平模式. */
    horizontalMode?: DbTextHorzMode;
    /** 垂直模式. */
    verticalMode?: DbTextVertMode;
    /**
     * 构造函数
     */
    constructor(prop?: IDbText);
}

export  enum DbTextHorzMode {
    kTextLeft = 0,
    kTextCenter = 1,
    kTextRight = 2,
    kTextAlign = 3,
    kTextMid = 4,
    kTextFit = 5
}

/**
 * `DbTextStyle` 文字样式.
 *
 */
export  class DbTextStyle {
    /** 文字样式名称. */
    name?: string;
    /** 是否型文件. */
    isShapeFile?: boolean;
    /** 文本大小 . */
    textSize?: number;
    /** x轴缩放 . */
    xScale?: number;
    /** 设置最近使用此文本样式创建的文本的先前大小 . */
    priorSize?: number;
    /** 设置字母的倾斜角度。正角度顺时针（向右）倾斜字母。负值使字母逆时针倾斜（向左）。通过将值2*PI相加，将负值转换为其正当量。 默认情况下，初始值为0.0. */
    obliquingAngle?: number;
    /** 字体文件名 . */
    fileName?: string;
    /** 字体 . */
    typeFace?: string;
    /** 是否粗体 . */
    bold?: boolean;
    /** 是否斜体 . */
    italic?: boolean;
    /** 字符集标识符，缺省0 . */
    charset?: number;
    /** 字符间距和族，缺省34 . */
    pitchAndFamily?: number;
    /**
     * 构造函数
     */
    constructor(prop?: IDbTextStyle);
}

export  enum DbTextVertMode {
    kTextBase = 0,
    kTextBottom = 1,
    kTextVertMid = 2,
    kTextTop = 3
}

/**
 * `DbWipeout` 遮罩实体.
 *
 */
export  class DbWipeout extends DbRasterImage {
    /** 坐标. */
    points?: Array<[number, number, number?]>;
    /**
     * 构造函数
     */
    constructor(prop?: IDbWipeout);
}

export  function decay({ velocity, from, power, timeConstant, restDelta, modifyTarget }: DecayOptions): any;

export  interface DecayOptions {
    from?: number;
    to?: number;
    velocity?: number;
    power?: number;
    timeConstant?: number;
    modifyTarget?: (target: number) => number;
    restDelta?: number;
}

/**
 * deck.gl图层.
 *
 **/
export  class DeckLayer extends Evented implements CustomLayerInterface {
    id: string;
    deckNs: object;
    layer: object;
    type: "custom";
    renderingMode?: "2d" | "3d" | undefined;
    constructor(props: any);
    onAdd(map: any, gl: any): void;
    onRemove(): void;
    setProps(props: any): void;
    render(gl: any, matrix: any): void;
}

export  const degreesToRadians: (degrees: number) => number;

/**
 * 角度转弧度
 * @param a
 * @return {number}
 */
export  function degToRad(a: number): number;

/**
 * 扩散的点.
 */
export  class DiffusedApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
}

 type Direction = "start" | "end";

export  function distance<P extends Point23D | number>(a: P, b: P): number;

/**
 * 在一个地理范围内创建一个随缩放而缩放的div的覆盖物
 * 注：如果是svg，则需设置为 viewBox="0 0 width height" preserveAspectRatio="xMinYMin meet", updateDivSize选项设置为true
 **/
export  class DivOverlay {
    options: DivOverlayOptions;
    _map?: Map;
    isShow: boolean;
    minZoom: number;
    maxZoom: number;
    maxPitch: number;
    isRemoved: boolean;
    parentContainer?: HTMLElement;
    constructor(options: DivOverlayOptions);
    addTo(map: Map, insertId?: string | HTMLElement): void;
    private _isShow;
    private _add;
    private _remove;
    /**
     * 设置是否显示隐藏
     * @param visible 是否显示
     * @param isDisplay true的话，表示用style的display去控制隐藏显示，dom还在文档中。false的话，会从文档动态清空增加
     */
    setVisible(visible?: boolean, isDisplay?: boolean): void;
    remove(): void;
    updateBounds(bounds: [GeoPointLike, GeoPointLike, GeoPointLike, GeoPointLike] | GeoBounds): void;
    updateSize(width: number, height: number): void;
    private _updateZoom;
    private _updateDivSize;
    private _adjustCoord;
    private _update;
}

export  interface DivOverlayOptions {
    /** 范围，四个点坐标 */
    bounds: [GeoPointLike, GeoPointLike, GeoPointLike, GeoPointLike] | GeoBounds;
    /** html元素 */
    element: HTMLElement;
    /** 元素宽 */
    width: number;
    /** 元素高 */
    height: number;
    /** 显示最大级别 */
    minZoom?: number;
    /** 显示最小级别 */
    maxZoom?: number;
    /** 显示最大倾斜角 */
    maxPitch?: number;
    /** 自动更新div大小，（如果需要svg放大，需要设置为true) */
    updateDivSize?: boolean;
    /** 放大div时，最大的div大小，超过了就像素放大了 */
    maxDivSize?: number;
}

export  namespace Dom {
    export function create(tagName: string, className?: string, container?: HTMLElement): HTMLElement;
    export function createNS(namespaceURI: string, tagName: string): Element;
    export function disableDrag(): void;
    export function enableDrag(): void;
    export function setTransform(el: HTMLElement, value: string): void;
    export function addEventListener(target: any, type: any, callback: any, options?: {
        passive?: boolean;
        capture?: boolean;
    }): void;
    export function removeEventListener(target: any, type: any, callback: any, options?: {
        passive?: boolean;
        capture?: boolean;
    }): void;
    export function suppressClick(): void;
    export function mousePos(el: HTMLElement, e: MouseEvent | WheelEvent): GeoPoint;
    export function touchPos(el: HTMLElement, touches: TouchList): GeoPoint[];
    export function mouseButton(e: MouseEvent): number;
    export function remove(node: HTMLElement): void;
    export function hasClass(el: HTMLElement, name: string): boolean;
    export function addClass(el: HTMLElement, name: string): void;
    export function removeClass(el: HTMLElement, name: string): void;
    export function setClass(el: HTMLElement, name: string): void;
    export function getClass(el: HTMLElement): any;
    export type Anchor = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    const anchorTranslate: Record<Anchor, string>;
}

export  const Draw: {
    /** 工具类. */
    Tool: new (options?: IDrawOptions | undefined) => IDrawTool;
    /** 缺省配置项. */
    defaultOptions: () => any;
    /** 模式. */
    modes: Record<string, any>;
    /** 绘制动作. */
    actionDraw: (map: any, modename: string, options?: Record<string, any> | undefined) => any;
    /** 绘制圆动作. */
    actionDrawCircle: (map: any, options?: Record<string, any> | undefined) => any;
    /** 绘制线动作. */
    actionDrawLineSting: (map: any, options?: Record<string, any> | undefined) => any;
    /** 绘制点动作. */
    actionDrawPoint: (map: any, options?: Record<string, any> | undefined) => any;
    /** 绘制多边形动作. */
    actionDrawPolygon: (map: any, options?: Record<string, any> | undefined) => any;
    /** 绘制矩形动作. */
    actionDrawRectangle: (map: any, options?: Record<string, any> | undefined) => any;
    /** 绘制斜矩形动作. */
    actionDrawSlantRectangle: (map: any, options?: Record<string, any> | undefined) => any;
    /** 选择实体. 如果只能选择一个实体，options选项请输入selectSingle为true*/
    actionSelect: (map: any, draw: any, options?: Record<string, any> | undefined) => any;
};

export  type Driver = (update: Update) => DriverControls;

/**
 * Drivers accept a update function and call it at an interval. This interval
 * could be a synchronous loop, a setInterval, or tied to the device's framerate.
 */
export  interface DriverControls {
    start: () => void;
    stop: () => void;
}

export  const easeIn: Easing;

export  const easeInOut: Easing;

export  const easeOut: Easing;

export  type Easing = (v: number) => number;

export  type EasingModifier = (easing: Easing) => Easing;

 type EdgeWeight = number;

/**
 * 创建只有边框的椭圆或椭圆弧
 *
 **/
export  class EllipseEdge extends Polyline {
    constructor(options: EllipseEdgeOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /** 设置中心点。 */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /** 得到中心点。 */
    getCenter(): GeoPointLike;
    /** 设置长轴半径。 */
    setMajorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到长轴半径。 */
    getMajorAxisRadius(): number;
    /** 设置短轴半径。 */
    setMinorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到短轴半径。 */
    getMinorAxisRadius(): number;
    /** 设置开始角度。 */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到开始角度。 */
    getStartAngle(): number;
    /** 设置结束角度。 */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到结束角度。 */
    getEndAngle(): number;
    /** 设置离散化的点的个数。 */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /** 得到离散化的点的个数。 */
    getPoints(): number;
}

export  interface EllipseEdgeOptions extends PolylineOptions {
    /** 中心点 */
    center: GeoPointLike;
    /** 长轴半径 */
    majorAxisRadius: number;
    /** 短轴半径 */
    minorAxisRadius: number;
    /** 开始角度 */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /** 属性数据 */
    properties?: object;
}

/**
 * 创建填充的的椭圆或椭圆弧
 *
 **/
export  class EllipseFill extends Polygon {
    constructor(options: EllipseFillOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /** 设置中心点。 */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /** 得到中心点。 */
    getCenter(): GeoPointLike;
    /** 设置长轴半径。 */
    setMajorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到长轴半径。 */
    getMajorAxisRadius(): number;
    /** 设置短轴半径。 */
    setMinorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /** 得到短轴半径。 */
    getMinorAxisRadius(): number;
    /** 设置开始角度。 */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到开始角度。 */
    getStartAngle(): number;
    /** 设置结束角度。 */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /** 得到结束角度。 */
    getEndAngle(): number;
    /** 设置离散化的点的个数。 */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /** 得到离散化的点的个数。 */
    getPoints(): number;
}

export  interface EllipseFillOptions extends PolygonOptions {
    /** 中心点 */
    center: GeoPointLike;
    /** 长轴半径 */
    majorAxisRadius: number;
    /** 短轴半径 */
    minorAxisRadius: number;
    /** 开始角度 */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /** 属性数据 */
    properties?: object;
}

/**
 * 实体颜色转html颜色
 * @param color 实体颜色
 * @param darkMode  样式是否为暗黑框
 * @param alpha 透明度的值
 * @return {string}
 */
export  function entColorToHtmlColor(color: number | string, darkMode?: boolean, alpha?: number): string;

 enum EpsgCrsTypes {
    Beijing54 = "Beijing54",
    Xian80 = "Xian80",
    CGCS2000 = "CGCS2000",
    Wgs84 = "Wgs84",
    Merc3857 = "Merc3857",
    NewBeijing54 = "NewBeijing54"
}

export  const EPSILON = 1e-8;

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
export  function equals(a: number, b: number): boolean;

export  const EVENTS: {
    READY_STATE_CHANGE: string;
    LOAD_START: string;
    PROGRESS: string;
    ABORT: string;
    ERROR: string;
    LOAD: string;
    TIMEOUT: string;
    LOAD_END: string;
};

export  interface Events {
    READY_STATE_CHANGE: "readystatechange";
    LOAD_START: "loadstart";
    PROGRESS: "progress";
    ABORT: "abort";
    ERROR: "error";
    LOAD: "load";
    TIMEOUT: "timeout";
    LOAD_END: "loadend";
}

export  type ExpressionSpecificationEx = Array<unknown>;

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 *
 * @param dest destination object
 * @param sources sources from which properties are pulled
 * @private
 */
export  function extend(dest: Object, ...sources: Object[]): Object;

/**
 * Feature
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * A Feature object represents a spatially bounded thing.
 * Every Feature object is a GeoJSON object no matter where it occurs in a GeoJSON text.
 */
 interface Feature<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
    type: "Feature";
    geometry: G;
    /**
     * A value that uniquely identifies this feature in a
     * https://tools.ietf.org/html/rfc7946#section-3.2.
     */
    id?: Id;
    /**
     * Properties associated with this feature.
     */
    properties: P;
}

/**
 * Feature Collection
 *
 * https://tools.ietf.org/html/rfc7946#section-3.3
 * A GeoJSON object with the type 'FeatureCollection' is a FeatureCollection object.
 * A FeatureCollection object has a member with the name 'features'.
 * The value of 'features' is a JSON array. Each element of the array is a Feature object as defined above.
 * It is possible for this array to be empty.
 */
 interface FeatureCollection<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
    type: "FeatureCollection";
    features: Array<Feature<G, P>>;
}

/**
 * 创建拉伸的多边形.
 *
 **/
export  class FillExtrusion extends OverlayLayerBase {
    options: FillExtrusionOptions;
    constructor(options: FillExtrusionOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setFillExtrusionOpacity(value: PropertyValueSpecificationEx<number>): this;
    getFillExtrusionOpacity(): PropertyValueSpecificationEx<number>;
    setFillExtrusionColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getFillExtrusionColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setFillExtrusionTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getFillExtrusionTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setFillExtrusionTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getFillExtrusionTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setFillExtrusionPattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getFillExtrusionPattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setFillExtrusionHeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getFillExtrusionHeight(): DataDrivenPropertyValueSpecification<number>;
    setFillExtrusionBase(value: DataDrivenPropertyValueSpecification<number>): this;
    getFillExtrusionBase(): DataDrivenPropertyValueSpecification<number>;
    setFillExtrusionVerticalGradient(value: PropertyValueSpecificationEx<boolean>): this;
    getFillExtrusionVerticalGradient(): PropertyValueSpecificationEx<boolean>;
}

export  type FillExtrusionLayerSpecification = {
    id: string;
    type: "fill-extrusion";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "fill-extrusion-opacity"?: PropertyValueSpecificationEx<number>;
        "fill-extrusion-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-extrusion-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "fill-extrusion-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "fill-extrusion-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "fill-extrusion-height"?: DataDrivenPropertyValueSpecification<number>;
        "fill-extrusion-base"?: DataDrivenPropertyValueSpecification<number>;
        "fill-extrusion-vertical-gradient"?: PropertyValueSpecificationEx<boolean>;
    };
};

export  type FillExtrusionLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    fillExtrusionOpacity?: PropertyValueSpecificationEx<number>;
    fillExtrusionColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillExtrusionTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillExtrusionTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillExtrusionPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    fillExtrusionHeight?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionBase?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionVerticalGradient?: PropertyValueSpecificationEx<boolean>;
};

export  interface FillExtrusionOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    fillExtrusionOpacity?: PropertyValueSpecificationEx<number>;
    fillExtrusionColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillExtrusionTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillExtrusionTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillExtrusionPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    fillExtrusionHeight?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionBase?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionVerticalGradient?: PropertyValueSpecificationEx<boolean>;
}

export  type FillLayerSpecification = {
    id: string;
    type: "fill";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "fill-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "fill-antialias"?: PropertyValueSpecificationEx<boolean>;
        "fill-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "fill-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-outline-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "fill-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "fill-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    };
};

export  type FillLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    fillSortKey?: DataDrivenPropertyValueSpecification<number>;
    fillAntialias?: PropertyValueSpecificationEx<boolean>;
    fillOpacity?: DataDrivenPropertyValueSpecification<number>;
    fillColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillOutlineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
};

export  type FilterSpecification = ["has", string] | ["!has", string] | ["==", string, string | number | boolean] | ["!=", string, string | number | boolean] | [">", string, string | number | boolean] | [">=", string, string | number | boolean] | ["<", string, string | number | boolean] | ["<=", string, string | number | boolean] | Array<string | FilterSpecification>;

/**
 * 给定所有路线、起始点、终点生成最短路径
 * @param startPoint 起点
 * @param endPoint 终点
 * @param lines 坐标，请转成几何坐标，再传入
 * @param precision 误差，小数点后几位， 以为相同, 如果两个点的坐标距离小于此值，则认为是同一个节点
 * @param hasDirection 是否考虑方向
 */
export  function findShortestPath(startPoint: GeoPoint, endPoint: GeoPoint, lines: Array<{
    points: GeoPoint[];
    id?: string;
    weight?: number;
}>, precision?: number, hasDirection?: boolean): {
    startPoint: {
        closestLength: number;
        closestPoint: GeoPoint;
        closestIndex: number;
        closestPointIndex: number;
        closestPrePointDist: number;
    };
    endPoint: {
        closestLength: number;
        closestPoint: GeoPoint;
        closestIndex: number;
        closestPointIndex: number;
        closestPrePointDist: number;
    };
    route: any[];
    routeDetail: {
        points: any[];
        index: any;
        reverse: boolean;
    }[];
    error?: undefined;
} | {
    error: any;
    startPoint?: undefined;
    endPoint?: undefined;
    route?: undefined;
    routeDetail?: undefined;
};

/**
 * 荧光点.
 */
export  class FluorescenceMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _setFluorescenceWidth;
    private _setFluorescenceColor;
}

export  type FogSpecification = {
    range?: PropertyValueSpecificationEx<[number, number]>;
    color?: PropertyValueSpecificationEx<ColorSpecification>;
    "horizon-blend"?: PropertyValueSpecificationEx<number>;
};

export  type FormattedSpecification = string;

/**
 * @property {Boolean} running - Getter that indicates if animation is running.
 * @property {function():void} stop - Stops the animation.
 * @property {function():void} start - Starts the animation.
 */
export  interface FrameAnimation {
    /**
     * A getter property that indicates if animation is running.
     */
    readonly running: boolean;
    /**
     * A getter property that indicates if animation is running.
     */
    readonly status: FrameAnimationStatus;
    /**
     * Stops the animation.
     */
    stop: () => void;
    /**
     * Starts the animation.
     */
    start: () => void;
    /**
     * pause the animation.
     */
    pause: () => void;
    /**
     * 一秒运行多少帧，用来控制速度
     */
    changeFps: (fps: number) => void;
}

export  enum FrameAnimationStatus {
    /** 运行. */
    Run = 0,
    /** 停止（用户主动调用stop). */
    Stop = 1,
    /** 暂停. */
    Pause = 2,
    /** 结束 (回调函数中返回true). */
    End = 3
}

/**
 * `GeoBounds` 地理范围.
 */
export  class GeoBounds {
    min: GeoPoint;
    max: GeoPoint;
    constructor(min?: GeoPoint, max?: GeoPoint);
    /**
     * 根据数组创建 `GeoBounds`.
     *
     * Example:
     * ```typescript
     * const b = GeoBounds.fromArray([left, bottom, right, top]);
     * ```
     */
    static fromArray(input: [number, number, number, number]): GeoBounds;
    /**
     * 根据数组创建 `GeoBounds`.
     *
     * Example:
     * ```typescript
     * const b = GeoBounds.fromString("[1,2,3,4]");
     * ```
     */
    static fromString(input: string): GeoBounds;
    /**
     * 根据数据范围来生成bounds
     * @param input
     * @return {GeoBounds}
     */
    static fromDataExtent(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoBounds;
    /**
     * 根据中心点和长，宽生成bounds
     * @return {GeoBounds}
     * @param center 中心点
     * @param width 宽
     * @param height 高，不输入时与宽一样
     */
    static fromCenterWH(center: GeoPointLike, width: number, height?: number): GeoBounds;
    /**
     * 设置包围盒范围
     *
     * @param min 最小值
     * @param max 最大值
     */
    set(min: GeoPoint, max: GeoPoint): void;
    /**
     * 得到中心点
     * @return {GeoPoint}
     */
    center(): GeoPoint;
    /**
     * 得到左上角
     * @return {GeoPoint}
     */
    leftTop(): GeoPoint;
    /**
     * 得到左下角
     * @return {GeoPoint}
     */
    leftBottom(): GeoPoint;
    /**
     * 得到右上角
     * @return {GeoPoint}
     */
    rightTop(): GeoPoint;
    /**
     * 得到右下角
     * @return {GeoPoint}
     */
    rightBottom(): GeoPoint;
    /**
     * 生成一个随机点
     * @return {GeoPoint}
     * @param xRatio x轴范围比例 缺省 0.6
     * @param yRatio y轴范围比例 缺省 0.6
     */
    randomPoint(xRatio?: number, yRatio?: number): GeoPoint;
    /**
     * 生成一个随机点序列
     * @return {GeoPoint}
     * @param xRatio x轴范围比例 缺省 0.6
     * @param yRatio y轴范围比例 缺省 0.6
     * @param minPointCount 最少的点数
     * @param maxPointCount 最多的点数
     */
    randomPoints(minPointCount: number, maxPointCount: number, xRatio?: number, yRatio?: number): GeoPoint[];
    /**
     * 生成一个随机geojson点集合
     * @return {GeoPoint}
     * @param xRatio x轴范围比例 缺省 0.6
     * @param yRatio y轴范围比例 缺省 0.6
     * @param count 点的数目
     * @param propertiesCb 属性回调函数
     */
    randomGeoJsonPointCollection(count: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object): GeoJsonGeomertry;
    /**
     * 生成一个随机geojson线集合
     * @return {GeoPoint}
     * @param xRatio x轴范围比例 缺省 0.6
     * @param yRatio y轴范围比例 缺省 0.6
     * @param maxLineCount 最多线的数目
     * @param maxPointCount 每条线最多的点的数目
     * @param propertiesCb 属性回调函数
     * @param minLineCount 最少线的数目（缺省为1)
     * @param minPointCount 每条线最少的点的数目（缺省为2)
     */
    randomGeoJsonLineCollection(maxLineCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minLineCount?: number, minPointCount?: number): GeoJsonGeomertry;
    /**
     * 生成一个随机geojson多边形集合
     * @return {GeoPoint}
     * @param xRatio x轴范围比例 缺省 0.6
     * @param yRatio y轴范围比例 缺省 0.6
     * @param maxPolygonCount 最多多边形的数目
     * @param maxPointCount 每条线最多的点的数目
     * @param propertiesCb 属性回调函数
     * @param minPolygonCount 最少多边形的数目(缺省为1)
     * @param minPointCount 每条线最少的点的数目(缺省为3)
     */
    randomGeoJsonPolygonCollection(maxPolygonCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minPolygonCount?: number, minPointCount?: number): GeoJsonGeomertry;
    /**
     * 返回数组
     *
     * @returns {Array} The coordinates represented as a array of the format `[minx, miny, maxx, maxy]'`.
     *
     */
    toArray(): number[];
    /**
     * 返回点数组，包括四个顶点
     *
     * @returns {Array} The coordinates represented as a array of the format `[[minx,maxy], [maxx,maxy], [maxx,miny], [minx,miny]]'`.
     *
     */
    toPointArray(): Array<[number, number]>;
    /**
     * 返回字符串.
     *
     * @returns {string} The coordinates represented as a string of the format `minx, miny, maxx, maxy'`.
     *
     */
    toString(fixed?: number): string;
    /**
     *  克隆
     *
     */
    clone(): GeoBounds;
    /**
     * 变成正方形，使宽高相等
     * @param isLatlng 是否是经纬度
     * @param isMinValue 是否取宽高的最小值或最大值，默认最大值
     * @return{GeoBounds}
     */
    square(isLatlng?: boolean, isMinValue?: boolean): GeoBounds;
    /**
     *  获取宽度
     *
     */
    width(): number;
    /**
     *  获取高度
     *
     */
    height(): number;
    /**
     *  按照比例扩大/缩小出一个新的 GeoBounds。
     * @param ratio 比例
     * @param origin 扩大时的基准点，默认为当前 bounds 的中心点
     */
    scale(ratio: number, origin?: GeoPoint | null): GeoBounds;
    /**
     *  按照XY比例扩大/缩小出一个新的 GeoBounds。
     * @param ratioX X比例
     * @param ratioY Y比例
     * @param origin 扩大时的基准点，默认为当前 bounds 的中心点
     */
    scaleXY(ratioX: number, ratioY: number, origin?: GeoPoint | null): GeoBounds;
    /**
     * 位移包围盒
     * @param dx
     * @param dy
     */
    translate(dx: number, dy: number): void;
    /**
     * 更新包围盒
     * @param vertices
     */
    update(vertices: GeoPoint[]): void;
    /**
     * 根据子包围盒更新包围盒
     * @param bounds
     */
    updateByBounds(bounds: GeoBounds[] | GeoBounds): void;
    /**
     * 两包围盒求交集
     * @param b
     */
    intersect(b: GeoBounds): GeoBounds | null;
    /**
     * 求多个包围盒的并集
     * @param bound
     */
    union(bound: GeoBounds): GeoBounds;
    /**
     * 判断与另一个包围盒是否相交
     * @param bound
     */
    isIntersect(bound: GeoBounds): boolean;
    /**
     * 求一个包围盒是否包含另一个包围盒
     * @param bound
     */
    isContains(bound: GeoBounds): boolean;
    /**
     * 查看点是否在包围盒中
     * @param point
     */
    contains(point: GeoPoint): boolean;
    /**
     * Returns the value in the interval that is nearest to `targetValue`.
     *
     * @ignore
     * @param interval        The interval to find the value within.
     * @param targetValue     The value to get nearest to.
     * @param includeInterior If false, the value will either be [[min]] or [[max]].
     *                        If true, the value may be any number between [[min]] and [[max]].
     */
    private closestInterval;
    /**
     * 查找边界框上最近的点并返回该点.
     * @param testPoint       点.
     * @param includeInterior 如果为true，则最近的点可以位于边界框内。如果为false，则最近的点只能位于边界框的外边缘上.
     */
    closestPoint(testPoint: GeoPoint, includeInterior?: boolean): GeoPoint;
}

/**
 * new一个GeoBounds实例
 * @param min
 * @param max
 */
export  function geoBounds(min?: GeoPoint, max?: GeoPoint): GeoBounds;

/**
 * GeoJSON
 *
 * All GeoJSON objects
 */
 type GeoJsonGeomertry = Feature | FeatureCollection | Geometry | GeometryCollection;

/**
 * GeoJSON Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 * The GeoJSON specification also allows [foreign members](https://tools.ietf.org/html/rfc7946#section-6.1)
 * Developers should use '&' type in TypeScript or extend the interface to add these foreign members.
 */
 interface GeoJSONObject {
    /**
     * Specifies the type of GeoJSON object.
     */
    type: string;
    /**
     * Bounding box of the coordinate range of the object's Geometries, Features, or Feature Collections.
     * https://tools.ietf.org/html/rfc7946#section-5
     */
    bbox?: BBox;
}

export  type GeoJSONSourceSpecification = {
    type: "geojson";
    data?: unknown;
    maxzoom?: number;
    attribution?: string;
    buffer?: number;
    filter?: unknown;
    tolerance?: number;
    cluster?: boolean;
    clusterRadius?: number;
    clusterMaxZoom?: number;
    clusterMinPoints?: number;
    clusterProperties?: unknown;
    lineMetrics?: boolean;
    generateId?: boolean;
    promoteId?: PromoteIdSpecificationEx;
};

/**
 * Geometry
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 */
 interface Geometry extends GeoJSONObject {
    coordinates: Position | Position[] | Position[][] | Position[][][];
}

/**
 * GeometryCollection
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.8
 *
 * A GeoJSON object with type 'GeometryCollection' is a Geometry object.
 * A GeometryCollection has a member with the name 'geometries'.
 * The value of 'geometries' is an array.  Each element of this array is a GeoJSON Geometry object.
 * It is possible for this array to be empty.
 */
 interface GeometryCollection extends GeometryObject {
    type: "GeometryCollection";
    geometries: Array<GeometryPoint | LineString | Polygon_2 | MultiPoint | MultiLineString | MultiPolygon>;
}

/**
 * Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 */
 interface GeometryObject extends GeoJSONObject {
    type: GeometryTypes;
}

/**
 * Point Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.2
 */
 interface GeometryPoint extends GeometryObject {
    type: "GeometryPoint";
    coordinates: Position;
}

/**
 * GeometryTypes
 *
 * https://tools.ietf.org/html/rfc7946#section-1.4
 * The valid values for the 'type' property of GeoJSON geometry objects.
 */
 type GeometryTypes = "GeometryPoint" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";

/**
 * `GeoPoint` 地理坐标.
 */
export  class GeoPoint {
    /**
     * 根据不同的类型创建地理坐标 {@link GeoPoint} .
     *
     * Example:
     * ```typescript
     * const p1 = GeoPoint.convert(new GeoPoint(x, y, z));
     * const p2 = GeoPoint.convert([x, y]);
     * const p3 = GeoPoint.convert([x, y, z]);
     * const p4 = GeoPoint.convert(lng: -73.9749, lat: 40.7736});
     * const p5 = GeoPoint.convert(lon: -73.9749, lat: 40.7736});
     * ```
     *
     * @param input - Either [[GeoPointLike]], {@link GeoPointLike}
     * or {@link GeoPointLike} object literal.
     */
    static convert(input: GeoPointLike): GeoPoint;
    /**
     * 根据字符串创建 `GeoPoint`.
     *
     * Example:
     * ```typescript
     * const b = GeoPoint.fromString("1,2");
     * ```
     */
    static fromString(input: string): GeoPoint;
    /** 坐标X. */
    x: number;
    /** 坐标y. */
    y: number;
    /** 坐标z(可选）. */
    z?: number;
    /**
     *  `GeoPoint` 构造函数
     *
     * @param x - x坐标.
     * @param y - y坐标.
     * @param z - z坐标(可选）.
     */
    constructor(x: number, y: number, z?: number);
    /**
     *  克隆一个坐标
     *
     */
    clone(): GeoPoint;
    private _add;
    /**
     * 返回数组
     *
     * @returns {Array<number>} The coordinates represeted as an array of x and y.
     * ```typescript
     * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
     * ll.toArray(); // = [-73.9749, 40.7736]
     * ```
     */
    toArray(): number[];
    /**
     * 返回字符串.
     * @param fixed
     * @returns {string} The coordinates represented as a string of the format `'x, y, z?'`.
     * ```typescript
     * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
     * ll.toString(); // = "GeoPoint(-73.9749, 40.7736)"
     * ```
     */
    toString(fixed?: number): string;
    /**
     * 后小数点几位取整
     * @param fixed
     * @return {GeoPoint}
     */
    round(fixed?: number): GeoPoint;
    roundStr(fixed?: number): string;
    /**
     * 两个点相加.
     *
     * @param p - 要相加的点.
     */
    add(p: GeoPoint): GeoPoint;
    private _sub;
    /**
     * 两个点相减.
     *
     * @param p - 要相减的点.
     */
    sub(p: GeoPoint): GeoPoint;
    lengthSq(): number;
    private _multByPoint;
    /**
     * 两个点相乘.
     *
     * @param p - 要相乘的点.
     */
    multByPoint(p: GeoPoint): GeoPoint;
    private _divByPoint;
    /**
     * 两个点相除.
     *
     * @param p - 要相除的点.
     */
    divByPoint(p: GeoPoint): GeoPoint;
    dot(p: GeoPoint): number;
    lerp(v: GeoPoint, alpha: number): this;
    private _mult;
    /**
     * 乘一个系数.
     *
     * @param k - 系数.
     */
    mult(k: number): GeoPoint;
    private _div;
    /**
     * 除一个系数.
     *
     * @param k - 系数.
     */
    div(k: number): GeoPoint;
    private _rotate;
    /**
     * 旋转.
     *
     * @param angle - 弧度.
     */
    rotate(angle: number): GeoPoint;
    private _rotateAround;
    /**
     * 绕一个点旋转.
     *
     * @param angle - 弧度.
     * @param p - 围绕的点.
     */
    roateAround(angle: number, p: GeoPoint): GeoPoint;
    private _matMult;
    /**
     * 乘一个矩阵.
     *
     * @param m - 矩阵值.
     */
    matMult(m: number[]): GeoPoint;
    private _unit;
    /**
     * 单位长度.
     *
     */
    unit(): GeoPoint;
    private _perp;
    /**
     * 投影 [x,y] = [-y, x].
     *
     */
    perp(): GeoPoint;
    private _round;
    /**
     * 四舍五入取整.
     *
     */
    roundInt(): GeoPoint;
    /**
     * 长度.
     *
     */
    mag(): number;
    /**
     * 判断是否相等
     * @param other 另外一个点
     * @param dotErr 允许误差的小数点后几位，默认8位
     * @return {boolean}
     */
    equals(other: GeoPoint, dotErr?: number): boolean;
    /**
     * 是否相等（判断z).
     *
     */
    equalsZ(other: GeoPoint): boolean;
    /**
     * 两点之间距离.
     *
     */
    distanceTo(p: GeoPoint): number;
    /**
     * 两点之间距离平方.
     *
     */
    distSqr(p: GeoPoint): number;
    /**
     * 角度.
     *
     */
    angle(): number;
    /**
     * 距一个点的角度
     *
     */
    angleTo(b: GeoPoint): number;
    /**
     * 距一个点的interiorAngle
     *
     */
    angleWith(b: GeoPoint): number;
    /**
     * 距一个点的interiorAngle
     *
     */
    angleWithSep(x: number, y: number): number;
    /**
     * 对一个点围绕一个基点进行缩放旋转平移操作.
     * @param basePt 围绕的基点坐标
     * @param destPt 要平移至的目的地坐标
     * @param scale 缩放比例，默认1.0
     * @param angle 旋转角度，逆时针，默认0
     * @return {GeoPoint}
     *
     */
    transform(basePt: GeoPoint, destPt: GeoPoint, scale?: number, angle?: number): this;
}

/**
 * new一个GeoPoint实例
 * @param input
 * @return {GeoPoint}
 */
export  function geoPoint(input: GeoPointLike): GeoPoint;

export  type GeoPointLike = [number, number] | [number, number, number] | GeoPoint | {
    x: number;
    y: number;
    z?: number;
} | {
    lng: number;
    lat: number;
} | {
    lon: number;
    lat: number;
};

/**
 * `GeoProjection` 地理坐标投影.
 *
 * Example:
 * ```typescript
 * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
 * const prj = new GeoProjection(mapExtent);
 * const pt = [30, 30];
 * const latlng = prj.toLngLat(pt);
 * const pt_geo = prj.fromLngLat(latlng);
 * const mkt = prj.toMercator(pt);
 * const pt_mkt = prj.fromMercator(mkt);
 * ```
 */
export  class GeoProjection extends Projection {
    /** 地图地理范围. */
    mapExtent: GeoBounds;
    private _ratio_x;
    private _ratio_y;
    /**
     *  `GeoBounds` 构造函数
     *
     * @extent extent - 地图地理范围.
     */
    constructor(extent: GeoBounds);
    /**
     *  设置地图范围
     *
     * @extent extent - 地图地理范围.
     */
    setExtent(extent: GeoBounds): void;
    /**
     * 坐标转墨卡托(epsg:3857)
     * @param input 坐标点
     * @return {[number, number]}
     */
    toMercator(input: GeoPointLike): [number, number];
    /**
     * 墨卡托(epsg:3857)转坐标
     * @param input 墨卡托坐标点
     * @return {[number, number]}
     */
    fromMercator(input: GeoPointLike): [number, number];
    /**
     * 地图地理坐标转经纬度
     * @param input 地理坐标点
     * @return {[number, number]}
     */
    toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 经纬度转地图地理坐标
     * @param input 经纬度坐标点
     * @return {GeoPoint}
     */
    fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 得到地图范围
     * @return {GeoBounds}
     */
    getMapExtent(): GeoBounds;
    /**
     * 把距离转化为米
     * @param dist
     */
    toMeter(dist: number): number;
    /**
     * 把米转化为距离
     * @param meter
     */
    fromMeter(meter: number): number;
}

/**
 *计算贝塞尔曲线的长度
 * @param bezierCurve 贝塞尔曲线
 * @param precision 需要的计算精度
 * @param recursiveCount 迭代次数
 */
export  function getBezierCurveLength(bezierCurve: BezierCurve, precision?: number, recursiveCount?: number): number;

/**
 *  得到圆或圆弧的离散化的多边形的geojson的形式
 * @param center 中心点
 * @param radius 半径
 * @param points 离散化的个数
 * @param startAngle 开始角度
 * @param endAngle 结束角度
 * @param includeCenterWhenArc 如果是圆弧时，最后一个点加上中心点
 * @return {{geometry: {coordinates: [number[][]], type: string}, type: string, properties: {}}}
 */
export  function getCircleFeature(center: GeoPointLike, radius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): GeoJsonGeomertry;

/**
 *  得到圆或圆弧的离散化的多边形的点
 * @param center 中心点
 * @param radius 半径
 * @param points 离散化的个数
 * @param startAngle 开始角度
 * @param endAngle 结束角度
 * @param includeCenterWhenArc 如果是圆弧时，最后一个点加上中心点
 */
export  function getCirclePolygonCoordinates(center: GeoPointLike, radius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): number[][];

export  function _getEdgeIntersection(a: GeoPoint, b: GeoPoint, code: number, bounds: GeoBounds): GeoPoint;

/**
 *  得到圆或圆弧的离散化的多边形的geojson的形式
 * @param center 中心点
 * @param majorAxisRadius: number,
 * @param minorAxisRadius: number,
 * @param points 离散化的个数
 * @param startAngle 开始角度
 * @param endAngle 结束角度
 * @param includeCenterWhenArc 如果是圆弧时，最后一个点加上中心点
 * @return {{geometry: {coordinates: [number[][]], type: string}, type: string, properties: {}}}
 */
export  function getEllipseFeature(center: GeoPointLike, majorAxisRadius: number, minorAxisRadius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): GeoJsonGeomertry;

/**
 *  得到椭圆或椭圆弧的离散化的多边形的点
 * @param center 中心点
 * @param points 离散化的个数
 * @param startAngle 开始角度
 * @param endAngle 结束角度
 * @param includeCenterWhenArc 如果是椭/圆弧时，最后一个点加上中心点
 * @param majorAxisRadius 长轴半径
 * @param minorAxisRadius 短轴半径
 * @return {any[]}
 */
export  function getEllipsePolygonCoordinates(center: GeoPointLike, majorAxisRadius: number, minorAxisRadius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): number[][];

/**
 * 根据外包矩形创建 `GeoBounds`.
 *
 * Example:
 * ```typescript
 * const b = vjmap.getEnvelopBounds('POLYGON((3466315.697899 6704304.297588, 3466315.697899 7784496.211226, 4546475.901198 7784496.211226, 4546475.901198 6704304.297588, 3466315.697899 6704304.297588))', prj);
 * ```
 */
export  function getEnvelopBounds(envelop: string, prj: any): GeoBounds;

/**
 * 根据坐标来获取epsg代号
 * @param coordinate 坐标，如果有带号的坐标x，输入x的前两位，否则可输入投影坐标[x,y]或经纬度[lng,lat]
 * @param crs 投影坐标类型 用来过滤结果， 不填默认全部
 * @param is3DegreeBelt 是否是三度带，用来过滤结果， 不填默认全部
 * @returns
 */
 function getEpsgCode(coordinate: number | [number, number], crs?: EpsgCrsTypes, is3DegreeBelt?: boolean): {
    crs: string;
    is3DegreeBelt: boolean;
    epsg: string;
    proj: string | undefined;
}[];

/**
 * 根据带号和坐标系来得到proj4的参数
 * @param crs 投影坐标类型
 * @param lon 如果为北京54,西安80，2000坐标，需要传入8位的经度坐标，或者带系前两位。如果是wgs84或3857，则不需要传入
 * @returns {null | {epsg: string, proj: string}}
 */
 function getEpsgParam(crs: EpsgCrsTypes, lon?: number): {
    epsg: string;
    proj: string;
} | null;

/**
 * 获取一个geojson的范围值
 * @param data 输入值
 * @return {GeoBounds} 获取的范围值
 */
export  function getGeoBounds<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(data: T | string): GeoBounds;

/**
 * Get first defined value.
 *
 * Specialized "replacement" for `a || b || c` used frequently to get value from various sources
 * (defaults, configs  constants).
 * In contrast to `||`, this function provides proper typing for usual use cases (constant as last
 * argument) and correct treatment of `null` and `undefined`.
 *
 * If last parameter is "defined" then return type is `T`, otherwise return type is `T | undefined`.
 *
 * Usage example:
 *
 *     interface Config {
 *         x?: number;
 *     }
 *     const someConfig: Config = {};
 *     const val: number | undefined = undefined;
 *     const DEFAULT = 5;
 *     const x = getOptionValue(val, someConfig.x, DEFAULT);
 *         // typeof x === 'number' because DEFAULT is defined
 *     const y = getOptionValue(val, someConfig.x);
 *         // typeof y === 'number | undefined' because someConfig.x is possibly undefined
 */
export  function getOptionValue<T>(a: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T | undefined, d: T): T;

export  function getOptionValue<T>(...values: Array<T | undefined>): T | undefined;

/**
 * 获取一个临时的图id(临时图形只会用临时查看，过期会自动删除)
 * @param expireTime 临时图形不浏览情况下过期自动删除时间，单位分钟。默认30
 * @param isVisible 是否可见，（可见的话，将可通过ListMaps获取，否则为隐藏图）。默认不可见
 * @return
 */
export  function getTempMapId(expireTime?: number, isVisible?: boolean): string;

/**
 * 具有深度优先搜索和拓扑排序的图数据结构。
 *
 * @example
 * var graph = Graph()
 * .addEdge("s", "t", 10)
 * .addEdge("s", "y", 5)
 * .addEdge("s", "y", 4)
 * .addEdge("t", "y", 2)
 * .addEdge("y", "t", 3)
 * .addEdge("t", "x", 1)
 * .addEdge("y", "x", 9)
 * .addEdge("y", "z", 2)
 * .addEdge("x", "z", 4)
 * .addEdge("z", "x", 6);
 * var res = graph.shortestPath("s", "z")
 */
export  function Graph(serialized?: Serialized): {
    addNode: (node: NodeId) => any;
    removeNode: (node: NodeId) => any;
    nodes: () => NodeId[];
    adjacent: (node: NodeId) => NodeId[];
    addEdge: (u: NodeId, v: NodeId, weight?: number | undefined) => any;
    removeEdge: (u: NodeId, v: NodeId) => any;
    hasEdge: (u: NodeId, v: NodeId) => boolean;
    setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any;
    getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight;
    indegree: (node: NodeId) => number;
    outdegree: (node: NodeId) => number;
    depthFirstSearch: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
    hasCycle: () => boolean;
    lowestCommonAncestors: (node1: NodeId, node2: NodeId) => string[];
    topologicalSort: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean) => string[];
    shortestPath: (source: NodeId, destination: NodeId) => string[] & {
        weight?: number | undefined;
    };
    serialize: () => Serialized;
    deserialize: (serialized: Serialized) => any;
};

/**
 * 发光的光环.
 */
export  class HaloRingMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _createMakerElement;
}

/**
 * 创建热力图图层.
 *
 **/
export  class Heatmap extends OverlayLayerBase {
    options: HeatmapOptions;
    constructor(options: HeatmapOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setHeatmapRadius(value: DataDrivenPropertyValueSpecification<number>): this;
    getHeatmapRadius(): DataDrivenPropertyValueSpecification<number>;
    setHeatmapWeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getHeatmapWeight(): DataDrivenPropertyValueSpecification<number>;
    setHeatmapIntensity(value: PropertyValueSpecificationEx<number>): this;
    getHeatmapIntensity(): PropertyValueSpecificationEx<number>;
    setHeatmapColor(value: ExpressionSpecificationEx): this;
    getHeatmapColor(): ExpressionSpecificationEx;
    setHeatmapOpacity(value: PropertyValueSpecificationEx<number>): this;
    getHeatmapOpacity(): PropertyValueSpecificationEx<number>;
}

export  type HeatmapLayerSpecification = {
    id: string;
    type: "heatmap";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "heatmap-radius"?: DataDrivenPropertyValueSpecification<number>;
        "heatmap-weight"?: DataDrivenPropertyValueSpecification<number>;
        "heatmap-intensity"?: PropertyValueSpecificationEx<number>;
        "heatmap-color"?: ExpressionSpecificationEx;
        "heatmap-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  type HeatmapLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    heatmapRadius?: DataDrivenPropertyValueSpecification<number>;
    heatmapWeight?: DataDrivenPropertyValueSpecification<number>;
    heatmapIntensity?: PropertyValueSpecificationEx<number>;
    heatmapColor?: ExpressionSpecificationEx;
    heatmapOpacity?: PropertyValueSpecificationEx<number>;
};

export  interface HeatmapOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    heatmapRadius?: DataDrivenPropertyValueSpecification<number>;
    heatmapWeight?: DataDrivenPropertyValueSpecification<number>;
    heatmapIntensity?: PropertyValueSpecificationEx<number>;
    heatmapColor?: ExpressionSpecificationEx;
    heatmapOpacity?: PropertyValueSpecificationEx<number>;
}

/**
 * 十六进制字符串转二进制字符串(可用于协同图形，图层开头显示设置的转换)
 * @param strHex 十进制的内容
 * @param isPadding 前面是否自动0，默认true
 * @param reverse 结果倒序，默认true
 */
export  function hexToBinStr(strHex: string, isPadding?: boolean, reverse?: boolean): string;

export  type HillshadeLayerSpecification = {
    id: string;
    type: "hillshade";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "hillshade-illumination-direction"?: PropertyValueSpecificationEx<number>;
        "hillshade-illumination-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "hillshade-exaggeration"?: PropertyValueSpecificationEx<number>;
        "hillshade-shadow-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "hillshade-highlight-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "hillshade-accent-color"?: PropertyValueSpecificationEx<ColorSpecification>;
    };
};

export  type HillshadeLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    hillshadeIlluminationDirection?: PropertyValueSpecificationEx<number>;
    hillshadeIlluminationAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    hillshadeExaggeration?: PropertyValueSpecificationEx<number>;
    hillshadeShadowColor?: PropertyValueSpecificationEx<ColorSpecification>;
    hillshadeHighlightColor?: PropertyValueSpecificationEx<ColorSpecification>;
    hillshadeAccentColor?: PropertyValueSpecificationEx<ColorSpecification>;
};

/**
 * html颜色转实体颜色
 * @param color html
 * @return {number}
 */
export  function htmlColorToEntColor(color: string): number;

export  const httpHelper: {
    configure: (opts: Partial<Config>) => void;
    event: {
        READY_STATE_CHANGE: string;
        LOAD_START: string;
        PROGRESS: string;
        ABORT: string;
        ERROR: string;
        LOAD: string;
        TIMEOUT: string;
        LOAD_END: string;
    };
    methods: Methods;
    rqeust: (args: Partial<Config>) => Promise<any>;
    get: (url: string, params?: Record<string, any> | undefined, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    put: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    post: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    patch: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    del: (url: string, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    options: (url: string, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
};

export  interface IAnimateFillLayerOptions extends Omit<PolygonOptions, "data"> {
    /** 动画图集. */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 速度，默认1. */
    speed?: number;
    /** 开始时自动动画，默认true. */
    startAutoAnimation?: boolean;
    /** 创建的图层位于哪个图层之前. */
    layerBefore?: string;
}

export  interface IAnimateLineLayerOptions extends Omit<PolylineOptions, "data"> {
    /** 动画图集. */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 速度，默认1. */
    speed?: number;
    /** 开始时自动动画，默认true. */
    startAutoAnimation?: boolean;
    /** 创建的图层位于哪个图层之前. */
    layerBefore?: string;
}

export  interface IAnimateSymbolLayerOptions extends Omit<SymbolOptions, "data"> {
    /** 动画图集. */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 速度，默认1. */
    speed?: number;
    /** 开始时自动动画，默认true. */
    startAutoAnimation?: boolean;
    /** 创建的图层位于哪个图层之前. */
    layerBefore?: string;
}

export  interface IAnimateVectorLayerOptions {
    /** 动画图集. */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 速度，默认1. */
    speed?: number;
    /** 开始时自动动画，默认true. */
    startAutoAnimation?: boolean;
}

export  interface IAnimateVectorLayerResult {
    /** 开始动画函数. */
    startAnimation: () => void;
    /** 结束动画函数. */
    stopAnimation: () => void;
    /** 移除. */
    remove: () => void;
    /** 设置速度. */
    setSpeed: (speed: number) => void;
    /** 更新动画图片集. */
    updateImages: (images: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>) => void;
}

/**
 * 组合新地图参数
 */
export  interface IComposeNewMap {
    /** 地图ID. */
    mapid: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 地图裁剪范围，范围如[x1,y1,x2,y2]， 为空的话，表示不裁剪 */
    clipbounds?: [number, number, number, number];
    /** 选择是包含还是相交（默认false表示包含，true相交） */
    selByCrossing?: boolean;
    /** 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正*/
    fourParameter?: [number, number, number, number];
    /** 是否用上面的四参数进行反算，默认false*/
    isInverseFourParamter?: boolean;
    /** 要显示的图层名称，为空的时候，表示全部图层 */
    layers?: string[];
    /** 生新成图的图层名称前缀，如果设置为null将不会有默认的图层前缀。如果没有前缀，不同的图有图层重名时，如果设置了随层属性有可能会导致绘制的不一样 */
    layerPrefix?: string;
    /** 生新成图的图层名称后缀 */
    layerSuffix?: string;
    /** 保存的文件名称，为空的时候，自根据参数自动生成 */
    savefilename?: string;
    /** 生成后清理图形数据以减少dwg文件大小 */
    purge?: boolean;
    /** 来源于其他图的实体时，如果块定义重复，则自动重命名 ，默认true */
    isRenameBlockNameIfExist?: boolean;
    /** 导出的CAD版本号。如果为*表示为当前CAD图的版本 */
    cadVersion?: string | "*" | "cad2000" | "cad2004" | "cad2007" | "cad2010" | "cad2013" | "cad2018";
}

/**
 * 条件查询实体参数
 */
export  interface IConditionQueryFeatures extends IQueryBaseFeatures {
    /** 条件. */
    condition: string;
    /** 范围. */
    bounds?: [number, number, number, number];
    /** 记录开始位置. */
    beginpos?: number;
    /** 是否返回几何数据,为了性能问题，realgeom为false时，如果返回条数大于1.只会返回每个实体的外包矩形，如果条数为1的话，会返回此实体的真实geojson；realgeom为true时每条都会返回实体的geojson */
    includegeom?: boolean;
    /** 是否返回真实实体几何geojson.与 includegeom参数，结合使用。参考includegeom的用法*/
    realgeom?: boolean;
    /** 是否为包含关系, true为包含关系,false为相交关系，默认false. (传入了bounds进行范围查询时有效)*/
    isContains?: boolean;
}

export  interface ICreateAnimateImagesOptions {
    /** 画片宽(2的n次幂，如2,4,8, 16, 32....).默认64 */
    canvasWidth?: number;
    /** 画片高(2的n次幂，如2,4,8, 16, 32....).默认32 */
    canvasHeight?: number;
    /** 绘制内容回调(此函数只需绘制第一帧，其作帧图片会根据移动方向和帧数自动计算出来). */
    draw?: (context: CanvasRenderingContext2D, width: number, height: number, opts: ICreateAnimateImagesOptions) => void;
    /** 每帧内容回调(此函数每帧都会调用，需要根据不同的帧数生成不同的图片，与上面的draw冲突，如果设置了drawFrame，则上面的draw函数无效). */
    drawFrame?: (context: CanvasRenderingContext2D, width: number, height: number, frameCount: number, curFrameIndex: number, opts: ICreateAnimateImagesOptions) => void;
    /** 要生成的动画图片帧的个数.默认2 */
    frameCount?: number;
    /** 方向是否反向. */
    directionReverse?: boolean;
    /** 是否y方向生成动画图片集. */
    yAxis?: boolean;
    /** 来源图片. */
    fromImage?: HTMLImageElement;
    /** 来源图片中精灵图所占宽. */
    spriteWidth?: number;
    /** 来源图片中精灵图所占高. */
    spriteHeight?: number;
    /** 生成的动画图片集中从第几个开始，默认0. */
    from?: number;
    /** 生成的动画图片集中到第几个结束，默认数组最后一个.. */
    to?: number;
    /** 其他数据. */
    [key: string]: any;
}

export  interface ICreateAnimateLayerResult {
    /** 数据源ID. */
    sourceId: string;
    /** 图层ID. */
    layerId: string;
    /** 开始动画函数. */
    startAnimation: () => void;
    /** 结束动画函数. */
    stopAnimation: () => void;
    /** 移除. */
    remove: () => void;
    /** 设置速度. */
    setSpeed: (speed: number) => void;
    /** 更新数据. */
    updateData: (input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any) => void;
    /** 更新动画图片集. */
    updateImages: (images: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>) => void;
    /** 创建动画图片集. */
    createAnimateImages: (options: ICreateAnimateImagesOptions) => Array<ImageData>;
}

export  interface ICreateAntPathAnimateLineLayerOptions extends IAnimateLineLayerOptions, ICreateAnimateImagesOptions {
    /** 填充背景颜色1. */
    fillColor1?: string | CanvasGradient | CanvasPattern;
    /** 填充背景颜色1. */
    fillColor2?: string | CanvasGradient | CanvasPattern;
}

export  interface ICreateArrowAnimateLineLayerOptions extends IAnimateLineLayerOptions, ICreateAnimateImagesOptions {
    /** 箭头填充背景颜色. */
    arrowFillColor?: string | CanvasGradient | CanvasPattern;
    /** 箭头颜色. */
    arrowStrokeColor?: string | CanvasGradient | CanvasPattern;
    /** 箭头线宽. */
    arrowStrokeWidth?: number;
    /** 箭头宽(默认为画布的一半). */
    arrowWidth?: number;
}

/**
 * 获取创建实体的几何数据
 */
export  interface ICreateEntitiesGeomData {
    /** 文件文档. */
    filedoc: string;
    /** 图形范围.如果不填的话，则使用全图范围 */
    mapBounds?: [number, number, number, number];
    /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
    renderAccuracy?: number;
    /** 返回的数据中排除属性数据( 默认true) */
    excludeAttribute?: boolean;
    /** 返回的数据是否启用zip压缩( 默认true) */
    useZip?: boolean;
}

export  interface ICreateFillAnimateLayerResult extends ICreateAnimateLayerResult {
    polygon: Polygon;
}

export  interface ICreateLineAnimateLayerResult extends ICreateAnimateLayerResult {
    polyline: Polyline;
}

export  interface ICreateSymbolAnimateLayerResult extends ICreateAnimateLayerResult {
    symbol: Symbol_2;
}

/**
 * Id
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * If a Feature has a commonly used identifier, that identifier SHOULD be included as a member of
 * the Feature object with the name 'id', and the value of this member is either a JSON string or number.
 */
 type Id = string | number;

/**
 * 2d折线实体类型接口
 */
export  interface IDb2dPolyline extends IDbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 高程. */
    elevation?: number;
    /** 2d折线类型*/
    polyType?: Poly2dType;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
}

/**
 * 角度标注[两条线]实体类型接口
 */
export  interface IDb2LineAngularDimension extends IDbDimension {
    /** 圆弧点位置. */
    arcPoint?: Array<[number, number, number?]>;
    /** 线1起点. */
    xLine1Start?: Array<[number, number, number?]>;
    /** 线1终点. */
    xLine1End?: Array<[number, number, number?]>;
    /** 线2起点. */
    xLine2Start?: Array<[number, number, number?]>;
    /** 线2终点. */
    xLine2End?: Array<[number, number, number?]>;
}

/**
 * 3d折线实体类型接口
 */
export  interface IDb3dPolyline extends IDbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 3d折线类型*/
    polyType?: Poly3dType;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
}

/**
 * 角度标注[三点]实体类型接口
 */
export  interface IDb3PointAngularDimension extends IDbDimension {
    /** 圆弧点位置. */
    arcPoint?: Array<[number, number, number?]>;
    /** 中点. */
    centerPoint?: Array<[number, number, number?]>;
    /** 点1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 点2. */
    xLine2Point?: Array<[number, number, number?]>;
}

/**
 * 对齐标注实体类型接口
 */
export  interface IDbAlignedDimension extends IDbDimension {
    /** 线1点. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线2点. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 设置定义此dimension实体尺寸线位置的WCS点. */
    dimLinePoint?: Array<[number, number, number?]>;
    /** 设置此实体的符号高度。. */
    jogSymbolHeight?: number;
}

/**
 * 圆弧实体类型接口
 */
export  interface IDbArc extends IDbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 半径. */
    radius?: number;
    /** 开始弧度. */
    startAngle?: number;
    /** 结束弧度. */
    endAngle?: number;
    /** 厚度. */
    thickness?: number;
    /** 法向量. */
    normal?: [number, number, number?];
}

/**
 * 圆弧标注实体类型接口
 */
export  interface IDbArcDimension extends IDbDimension {
    /** 线1点. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线2点. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 中心点. */
    centerPoint?: Array<[number, number, number?]>;
    /** 圆弧点. */
    arcPoint?: Array<[number, number, number?]>;
    /** 文本中使用的弧符号的类型。 0 弧符号在文本前面;   1 弧线符号在文字上方;   2  没有符号. */
    arcSymbolType?: number;
}

/**
 * 块定义接口
 */
export  interface IDbBlock {
    /** 块名称. */
    name?: string;
    /** 设置此块的参照的缩放特征. */
    scaling?: number;
    /** 设置此块的块插入单位 . */
    insertUnits?: number;
    /** 原点。 . */
    origin?: Array<[number, number, number?]>;
    /** 备注. */
    comments?: string;
    /** 是否可炸开. */
    explodable?: boolean;
    /** 由哪些实体创建而成. */
    entitys?: IDbEntity[];
}

/**
 * 块参照实体类型接口
 */
export  interface IDbBlockReference extends IDbEntity {
    /** 块名称. */
    blockname?: string;
    /** 参考外部图形，形式为 mapid/version,如 exam/v1. */
    ref?: string;
    /** 坐标. */
    position?: [number, number, number?];
    /** 法向量. */
    normal?: [number, number, number?];
    /** 旋转角度. */
    rotation?: number;
    /** 缩放因子. */
    scaleFactors?: number;
}

/**
 * 圆实体类型接口
 */
export  interface IDbCircle extends IDbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 半径. */
    radius?: number;
    /** 厚度. */
    thickness?: number;
    /** 法向量. */
    normal?: [number, number, number?];
}

/**
 * 曲线实体类型接口
 */
export  interface IDbCurve extends IDbEntity {
}

/**
 * 直径标注实体类型接口
 */
export  interface IDbDiametricDimension extends IDbDimension {
    /** 圆上1点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 圆上2点. */
    farChordPoint?: Array<[number, number, number?]>;
    /** 引线长度. */
    leaderLength?: number;
}

/**
 * 标注实体类型接口
 */
export  interface IDbDimension extends IDbEntity {
    /** 标注样式. */
    dimStyle?: string;
    /** 文字位置. */
    textPosition?: Array<[number, number, number?]>;
}

/**
 * 标注样式接口
 */
export  interface IDbDimStyle {
    /** 样式名称. */
    name?: string;
    /** 文字样式名称. */
    textStyle?: string;
    /** 尺寸线箭头块的显示 . */
    dimsah?: boolean;
    /** 符号和箭头1 .“” 实心闭合,“_DOT” 点,“_DOTSMALL” 小点,“_DOTBLANK” 空心点,“_ORIGIN” 指示原点,“_ORIGIN2” 指示原点 2,“_OPEN” 打开,“_OPEN90” 直角,“_OPEN30” 30 度角,“_CLOSED” 闭合,“_SMALL” 空心小点,“_NONE” 无,“_OBLIQUE” 倾斜,“_BOXFILLED” 填充框,“_BOXBLANK” 框,“_CLOSEDBLANK” 空心闭合,“_DATUMFILLED” 实心基准三角形,“_DATUMBLANK” 基准三角形,“_INTEGRAL” 完整标记,“_ARCHTICK” 建筑标记*/
    dimblk1?: string;
    /** 符号和箭头2 .同dimblk1 */
    dimblk2?: string;
}

/**
 * DB文档定义接口
 */
export  interface IDbDocument {
    /** 来源于哪个图，会在此图的上面进行修改或新增删除，格式如 形式为 mapid/version,如 exam/v1 . */
    from?: string;
    /** 实体集. */
    entitys?: IDbEntity[];
    /** 图层集. */
    layers?: IDbLayer[];
    /** 文字样式. */
    textStyles?: IDbTextStyle[];
    /** 标注样式. */
    dimStyles?: IDbDimStyle[];
    /** 线型. */
    linetypes?: IDbLinetype[];
    /** 块定义. */
    blocks?: IDbBlock[];
}

/**
 * 椭圆实体类型接口
 */
export  interface IDbEllipse extends IDbCurve {
    /** 中心坐标. */
    center?: [number, number, number?];
    /** 主轴方向. */
    minorAxis?: [number, number, number?];
    /** 开始弧度. */
    startAngle?: number;
    /** 结束弧度. */
    endAngle?: number;
    /** 短轴和长轴的比例. */
    radiusRatio?: number;
}

/**
 * 实体类型接口
 */
export  interface IDbEntity {
    /** 类型. */
    typename?: string;
    /** 颜色. */
    color?: number;
    /** 颜色索引. */
    colorIndex?: number;
    /** 图层. */
    layer?: string;
    /** 线型. */
    linetype?: string;
    /** 线型比例. */
    linetypeScale?: number;
    /** 线宽. */
    lineWidth?: number;
    /** 透明度. [0-255][0完全透明,255完全不透明]*/
    alpha?: number;
    /** 可见. */
    visibility?: boolean;
    /** 矩阵. */
    matrix?: IDbMatrixOp[];
    /** 扩展数据. */
    xdata?: string;
    /** 实体句柄，如传了实体句柄，是表示修改此实体. */
    objectid?: string;
    /** 是否删除此实体. */
    delete?: boolean;
}

/**
 * 填充实体类型接口
 */
export  interface IDbHatch extends IDbEntity {
    /** 高程. */
    elevation?: number;
    /** 填充图案, 缺省 SOLID */
    pattern?: string;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
}

/**
 * 图层接口
 */
export  interface IDbLayer {
    /** 图层名称. */
    name?: string;
    /** 图层颜色索引. */
    color?: number;
    /** 图层线型，缺省 CONTINUOUS . */
    linetype?: string;
}

/**
 * 线实体类型接口
 */
export  interface IDbLine extends IDbEntity {
    /** 起点. */
    start?: [number, number, number?];
    /** 终点. */
    end?: [number, number, number?];
    /** 厚度. */
    thickness?: number;
}

/**
 * 线型接口
 */
export  interface IDbLinetype {
    /** 线型名称. */
    name?: string;
    /** 评论. */
    comments?: string;
    /** 线型样式 . */
    style?: IDbLinetypeStyle[];
}

/**
 * 线型样式接口
 */
export  interface IDbLinetypeStyle {
    /** 方法. */
    method?: IDbLinetypeStyleMethod;
    /** 参数. */
    parameter?: string;
}

export  enum IDbLinetypeStyleMethod {
    /** [int count] . */
    numDashes = "numDashes",
    /** [double dPatLen] . */
    patternLength = "patternLength",
    /** [int dashIndex, double dashLength ]. */
    dashLengthAt = "dashLengthAt",
    /** [int dashIndex, string idTextStyle] . */
    shapeStyleAt = "shapeStyleAt",
    /** [int dashIndex, [int, int] shapeOffset] . */
    shapeOffsetAt = "shapeOffsetAt",
    /** [int dashIndex, string textString] . */
    textAt = "textAt",
    /** [ int dashIndex, double shapeScale] . */
    shapeScaleAt = "shapeScaleAt",
    /** [int dashIndex, int shapeNumber] . */
    shapeNumberAt = "shapeNumberAt",
    /** [int dashIndex, double shapeRotation] . */
    shapeRotationAt = "shapeRotationAt",
    /** [ bool bScaleToFit] . */
    isScaledToFit = "isScaledToFit"
}

/**
 * 矩阵操作接口
 */
export  interface IDbMatrixOp {
    /** 操作名称. */
    op?: IDbMatrixOpName;
    /** 平移的向量. */
    vector?: [number, number, number?];
    /** 缩放大小 . */
    scale?: number;
    /** 旋转的角度 . */
    angle?: number;
    /** 基点. */
    origin?: [number, number, number?];
}

export  enum IDbMatrixOpName {
    /** 平移 . */
    translation = "translation",
    /** 缩放 . */
    scale = "scale",
    /** rotate. */
    rotate = "rotate"
}

/**
 * 多行文本实体类型接口
 */
export  interface IDbMText extends IDbEntity {
    /** 宽. */
    width?: number;
    /** 高. */
    height?: number;
    /** 旋转角度. */
    rotation?: number;
    /** 文本高. */
    textHeight?: number;
    /** 文本内容. */
    contents?: string;
    /** 位置. */
    location?: [number, number, number?];
    /** 对齐方式. */
    attachment?: MTextAttachmentPoint;
    /** 文本样式. */
    textStyle?: string;
}

/**
 * 坐标标注实体类型接口
 */
export  interface IDbOrdinateDimension extends IDbDimension {
    /** 基点. */
    origin?: Array<[number, number, number?]>;
    /** 定义点. */
    definingPoint?: Array<[number, number, number?]>;
    /** 引线点. */
    leaderEndPoint?: Array<[number, number, number?]>;
    /** 是否用X轴. */
    useXAxis?: boolean;
}

/**
 * 实体基本属性
 */
/**
 * 坐标类型接口
 */
export  type IDbPoint = [number, number, number?];

/**
 * 折线实体类型接口
 */
export  interface IDbPolyline extends IDbCurve {
    /** 是否闭合. */
    closed?: boolean;
    /** 高程. */
    elevation?: number;
    /** 坐标. */
    points?: Array<[number, number, number?]>;
    /** 凸度. */
    bulge?: number[];
    /** 起点宽. */
    startWidth?: number[];
    /** 终点宽. */
    endWidth?: number[];
}

/**
 * 半径标注实体类型接口
 */
export  interface IDbRadialDimension extends IDbDimension {
    /** 中心点. */
    center?: Array<[number, number, number?]>;
    /** 圆上点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 引线长度. */
    leaderLength?: number;
}

/**
 * 半径折线标注实体类型接口
 */
export  interface IDbRadialDimensionLarge extends IDbDimension {
    /** 中心点. */
    center?: Array<[number, number, number?]>;
    /** 圆上点. */
    chordPoint?: Array<[number, number, number?]>;
    /** 设置由该Dimension实体确定尺寸的弧的WCS覆盖中心。. */
    overrideCenter?: Array<[number, number, number?]>;
    /** 设置此Dimension实体的折角点。. */
    jogPoint?: Array<[number, number, number?]>;
    /** 设置此Dimension实体的折角。. */
    jogAngle?: number;
}

/**
 * 栅格图片实体类型接口
 */
export  interface IDbRasterImage extends IDbEntity {
    /** 明亮度 [0.0 .. 100.0] */
    brightness?: number;
    /** 图片url地址. */
    sourceHttpUrl?: string;
    /** 源图片宽. */
    pixelWidth?: number;
    /** 源图片高. */
    pixelHeight?: number;
    /** 单位. */
    units?: RasterImageUnits;
    /** x轴每像素代表长度. */
    xPelsPerUnit?: number;
    /** y轴每像素代表长度. */
    yPelsPerUnit?: number;
    /** 宽. */
    width?: number;
    /** 高. */
    height?: number;
    /** 位置. */
    position?: [number, number, number?];
    /** 是否显示. */
    imageDisplayOptShow?: boolean;
    /** 是否裁剪. */
    imageDisplayOptClip?: boolean;
    /** 是否对齐. */
    imageDisplayOptShowUnAligned?: boolean;
    /** 是否透明. */
    imageDisplayOptTransparent?: boolean;
}

/**
 * 转角标注实体类型接口
 */
export  interface IDbRotatedDimension extends IDbDimension {
    /** 线上点1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 线上点2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** 设置定义此dimension实体尺寸线位置的WCS点。. */
    dimLinePoint?: Array<[number, number, number?]>;
}

/**
 * 型实体类型接口
 */
export  interface IDbShape extends IDbEntity {
    /** 旋转角度. */
    rotation?: number;
    /** 位置. */
    position?: [number, number, number?];
    /** 大小. */
    size?: number;
    /** 法向量. */
    normal?: [number, number, number?];
    /** 型名称. */
    name?: string;
}

/**
 * 样条曲线实体类型接口
 */
export  interface IDbSpline extends IDbCurve {
    /** the curve fitting tolerance for this Spline entity. */
    fitTol?: number;
    /** Increased the degree of this spline to the specified value. */
    degree?: number;
    /** 拟合点. */
    fitPoints?: Array<[number, number, number?]>;
    /** 控制点. */
    controlPoints?: Array<[number, number, number?]>;
}

/**
 * 表格实体类型接口
 */
export  interface IDbTable extends IDbBlockReference {
    /** 表样式名称. */
    tableStyleName?: string;
    /** 表格列数. */
    numColumns?: number;
    /** 表格行数. */
    numRows?: number;
    /** 列宽. */
    columnWidth?: number;
    /** 行高. */
    rowHeight?: number;
    /** 表格总共的宽度. */
    width?: number;
    /** 表格总共的高度. */
    height?: number;
    /** 是否禁用标题. */
    disableTitle?: boolean;
    /** 表格方向是否从上至上. */
    directionBottomToTop?: boolean;
    /** 文字高度(所有单元格). */
    textHeight?: number;
    /** 显示网格线.第二个参数(kHorzTop(1), kHorzInside(2), kHorzBottom(4), kVertLeft(8), kVertInside(16), kVertRight(32);  第三个参数 kTitleRow(1), kHeaderRow(2), kDataRow(4) */
    gridVisibility?: [boolean, number, number];
    /** 背景颜色(所有单元格). */
    backgroundColor?: number;
    /** 文字颜色(所有单元格). */
    contentColor?: number;
    /** 网格线颜色(所有单元格). */
    gridColor?: number;
    /** 单元格对齐方式(所有单元格). */
    alignment?: TableCellAlignment;
    /** 水平方向单元格边距. */
    horzCellMargin?: number;
    /** 竖直方向单元格边距. */
    vertCellMargin?: number;
    /** 需要合并的单元格 [[minRow, maxRow,minColumn, maxColumn], ...]  */
    mergeCells?: Array<[number, number, number, number]>;
    /** 数据. */
    data?: Array<Array<string | {
        /** 单元格文本内容. */
        text: string;
        /** 单元格对齐方式. */
        alignment: TableCellAlignment;
        /** 单元格背景色. */
        backgroundColor: number;
        /** 单元格网格线颜色. */
        gridColor: number;
        /** 单元格文本内容. */
        contentColor: number;
        /** 单元格文本高度. */
        textHeight: number;
        /** 是否显示单元格网格线. */
        gridVisibility: boolean;
    }>>;
}

/**
 * 单行文本实体类型接口
 */
export  interface IDbText extends IDbEntity {
    /** 高. */
    height?: number;
    /** 旋转角度. */
    rotation?: number;
    /** 文本内容， 同contents. */
    text?: string;
    /** 文本内容， 同text. */
    contents?: string;
    /** 宽度因子. */
    widthFactor?: number;
    /** 位置. */
    position?: [number, number, number?];
    /** 文本样式. */
    textStyle?: string;
    /** 水平模式. */
    horizontalMode?: DbTextHorzMode;
    /** 垂直模式. */
    verticalMode?: DbTextVertMode;
}

/**
 * 文字样式接口
 */
export  interface IDbTextStyle {
    /** 文字样式名称. */
    name?: string;
    /** 是否型文件. */
    isShapeFile?: boolean;
    /** 文本大小 . */
    textSize?: number;
    /** x轴缩放 . */
    xScale?: number;
    /** 设置最近使用此文本样式创建的文本的先前大小 . */
    priorSize?: number;
    /** 设置字母的倾斜角度。正角度顺时针（向右）倾斜字母。负值使字母逆时针倾斜（向左）。通过将值2*PI相加，将负值转换为其正当量。 默认情况下，初始值为0.0. */
    obliquingAngle?: number;
    /** 字体文件名 . */
    fileName?: string;
    /** 字体 . */
    typeFace?: string;
    /** 是否粗体 . */
    bold?: boolean;
    /** 是否斜体 . */
    italic?: boolean;
    /** 字符集标识符，缺省0 . */
    charset?: number;
    /** 字符间距和族，缺省34 . */
    pitchAndFamily?: number;
}

/**
 * 遮罩实体类型接口
 */
export  interface IDbWipeout extends IDbRasterImage {
    /** 坐标. */
    points?: Array<[number, number, number?]>;
}

/**
 * 清空地图缓存接口
 */
export  interface IDeleteCache {
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本, 如清空所有版本缓存，输入"*"号). */
    version?: string;
    /** 匹配的键值. */
    key?: string;
}

/**
 * 删除地图样式接口
 */
export  interface IDeleteStyle {
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本, 如删除所有版本，输入"*"号). */
    version?: string;
    /** 样式名称.如删除所有样式，输入"*"号； 删除所有系统产生的样式，输入 "a*"；内存打开的样式,输入"m*";几何打开的样式输入 "s*"*/
    styleid: string;
    /** 是否只清空数据, false 删除表和数据; true 只删除数据. */
    onlycleardata: boolean;
}

export  interface IDraw {
    /** 工具类. */
    Tool: new (options?: IDrawOptions) => IDrawTool;
    /** 缺省配置项. */
    defaultOptions: () => any;
    /** 模式. */
    modes: Record<string, any>;
    /** 绘制动作. */
    actionDraw: (map: any, modename: string, options?: Record<string, any>) => any;
    /** 绘制圆动作. */
    actionDrawCircle: (map: any, options?: Record<string, any>) => any;
    /** 绘制线动作. */
    actionDrawLineSting: (map: any, options?: Record<string, any>) => any;
    /** 绘制点动作. */
    actionDrawPoint: (map: any, options?: Record<string, any>) => any;
    /** 绘制多边形动作. */
    actionDrawPolygon: (map: any, options?: Record<string, any>) => any;
    /** 绘制矩形动作. */
    actionDrawRectangle: (map: any, options?: Record<string, any>) => any;
    /** 绘制斜矩形动作. */
    actionDrawSlantRectangle: (map: any, options?: Record<string, any>) => any;
    /** 选择实体. 如果只能选择一个实体，options选项请输入selectSingle为true*/
    actionSelect: (map: any, draw: any, options?: Record<string, any>) => any;
}

export  interface IDrawOptions {
    addControls?: any[];
    controls?: Record<string, boolean>;
    guides?: boolean;
    modes?: Record<string, any>;
    snap?: boolean;
    midpoints?: boolean;
    api: {
        getSnapFeatures: any;
        [key: string]: any;
    };
    snapOptions: {
        snapGridPx?: number;
        snapPx?: number;
        snapToMidPoints?: boolean;
        snapVertexPriorityDistance?: number;
    };
    styles?: any[];
    userProperties?: boolean;
    [key: string]: any;
}

export  interface IDrawTool {
    /** 此方法采用 GeoJSON Feature、FeatureCollection 或 Geometry 并将其添加到 Draw。它返回一个 id 数组，用于与添加的功能进行交互。如果某个功能没有自己的 id，则会自动生成一个 **/
    add: (geojson: any) => Array<string>;
    /**将绘图更改为另一种模式。返回用于链接的绘制实例 */
    changeMode: (mode: string, modeOptions?: any) => IDrawTool;
    /** 调用当前模式的combineFeatures操作。返回用于链接的绘制实例 */
    combineFeatures: () => IDrawTool;
    /** 删除具有指定 ID 的功能。返回用于链接的绘制实例*/
    delete: (featureIds: string[] | string) => IDrawTool;
    /** 删除所有功能。返回用于链接的绘制实例 */
    deleteAll: () => IDrawTool;
    /** 在当前模式下执行动作 */
    doAction: (actionName: string) => any;
    /** 强制刷新 */
    forceRefresh: () => any;
    /** 返回 Draw 中具有指定 id 的 GeoJSON 功能，或者undefined如果 id 不匹配任何功能 */
    get: (id: string) => any;
    /** 返回所有功能的 FeatureCollection */
    getAll: () => FeatureCollection;
    /** 返回当前在指定点呈现的功能的功能 ID 数组。*/
    getFeatureIdsAt: (point: {
        x: number;
        y: number;
    }) => Array<string>;
    /** 返回 Draw 的当前模式 */
    getMode: () => string;
    /** 返回当前选择的所有功能的 FeatureCollection */
    getSelected: () => FeatureCollection;
    /** 返回当前所选功能的功能 ID 数组 */
    getSelectedIds: () => Array<string>;
    /** 返回代表当前选择的所有顶点的 FeatureCollection 点 */
    getSelectedPoints: () => FeatureCollection;
    /** 内部变量模式值 */
    modes: Record<string, any>;
    /** 增加时回调接口 */
    onAdd: (map: any) => any;
    /** 移除时回调接口 */
    onRemove: () => any;
    /** 内部变量选项值 */
    options: Record<string, any>;
    redo: () => any;
    /** 将 Draw 的功能设置为指定的 FeatureCollection */
    set: (featureCollection: FeatureCollection) => Array<string>;
    /** 设置具有指定 id 的要素的属性值。返回用于链接的绘制实例 */
    setFeatureProperty: (featureId: string, property: string, value: any) => IDrawTool;
    /** 调用当前模式的删除trash操作。返回用于链接的绘制实例 */
    trash: () => IDrawTool;
    uncombineFeatures: () => IDrawTool;
    undo: () => any;
}

/**
 * 导出布局空间为dwg图
 */
export  interface IExportLayout {
    /** 地图ID. */
    mapid: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 布局索引，layoutIndex和layoutName只要输入一个就行，layoutIndex优先。如果都为空，则使用dwg当前的布局空间. */
    layoutIndex?: string;
    /** 布局名称. layoutIndex和layoutName只要输入一个就行，layoutIndex优先。如果都为空，则使用dwg当前的布局空间. */
    layoutName?: string;
}

/**
 * 表达式查询实体参数
 */
export  interface IExprQueryFeatures extends IQueryBaseFeatures {
    /** 表达式. */
    expr: string;
    /** 记录开始位置. */
    beginpos?: number;
}

export  type ImageSourceSpecification = {
    type: "image";
    url: string;
    coordinates: [[number, number], [number, number], [number, number], [number, number]];
};

/**
 * 比较地图不同
 */
export  interface IMapDiff {
    /** 地图一ID. */
    mapid1: string;
    /** 地图一版本(为空时采用当前打开的地图版本). */
    version1?: string;
    /** 地图一样式图层. */
    layer1?: string;
    /** 地图二ID. */
    mapid2: string;
    /** 地图二版本(为空时采用当前打开的地图版本). */
    version2?: string;
    /** 地图二样式图层. */
    layer2?: string;
    /** 不比较新增部分. */
    noCompareNew?: boolean;
    /** 不比较删除部分. */
    noCompareDelete?: boolean;
    /** 比较大小. */
    size?: number;
    /** 比较单元大小. */
    cellsize?: number;
    /** 不同的像素最小值. */
    diffMinPixel?: number;
    /** 不同的透明最小值. */
    diffMinAlpha?: number;
    /** 不同的颜色最小值. */
    diffMinColor?: number;
}

/**
 * 地图图层
 */
export  interface IMapLayer {
    /** 图层名称. */
    name: string;
    /** 颜色. */
    color: string;
    /** 图层索引. */
    index: number;
    /** 是否冻结. */
    isFrozen: boolean;
    /** 是否锁定. */
    isLocked: boolean;
    /** 图层是否关闭. */
    isOff: boolean;
    /** 线宽. */
    lineWeight: number;
    /** 线型. */
    linetype: number;
}

/**
 * 地图样式参数参数
 */
export  interface IMapStyleParam {
    /** 样式名称. */
    name?: string;
    /** 要开的图层索引列表，格式如[0,1,3]. */
    layeron?: string | number[];
    /** 要关的图层索引列表，格式如[2,4]. layeron与layeroff只要输入一个即可*/
    layeroff?: string | number[];
    /** 地图裁剪范围，范围如[x1,y1,x2,y2].如果只需入了数值的话，表示是缩放倍数 */
    clipbounds?: [number, number, number, number] | number;
    /** 颜色. */
    backcolor?: number;
    /** 线宽，格式如[1，1，1，1，0].表式第1，2，3，4级线宽开，第5级线宽关，大于第5级的，以最后设置的级别状态为主，所以也是关。如为空，则和原图线宽显示状态相同 */
    lineweight?: string | number[];
    /** 表达式. */
    expression?: string;
}

/**
 * 目标匹配
 */
export  interface IMatchObject {
    /** 地图ID. */
    mapid: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 图层样式名.为空时，将由选择的实体的图层来决定 */
    layer?: string;
    /** 目标匹配的地图范围，默认为全图的数据范围. */
    mapBounds?: string;
    /** 目标匹配的实体objectid数组，用||隔开. */
    objectIds?: string;
    /** 目标匹配的实体范围 */
    objectBounds: string;
    /** 目标匹配的地图打开的图层 */
    layeron?: string;
    /** 匹配时的图像尺寸，默认10000 */
    size?: number;
    /** 方法. 默认 matchPattern */
    method?: "matchTemplate" | "matchPattern";
    /** 允许返回的最大条数. 默认 200 */
    maxCount?: number;
    /** 分数，小于此分类将不显示 (0 -1)，默认 0.6 . */
    score?: number;
    /** 金字塔大小 范围(64-2048).默认256， 方法为matchPattern有效*/
    minReduceArea?: number;
    /** 允许重叠 (默认false). */
    canOverlap?: boolean;
    /** 重叠比例 范围(0-0.8)，默认 0.3. */
    maxOverlap?: number;
    /** 角度范围(-180, 180)有旋转的时候需要。方法为matchPattern有效. 默认180*/
    toleranceAngle?: number;
    /** 是否使用角度区间范围,默认false. 方法为matchPattern有效*/
    useToleranceRange?: boolean;
    /** 角度区间1开始角度. 方法为matchPattern有效*/
    tolerance1?: number;
    /** 角度区间1结束角度. 方法为matchPattern有效*/
    tolerance2?: number;
    /** 角度区间2开始角度. 方法为matchPattern有效*/
    tolerance3?: number;
    /** 角度区间2结束角度. 方法为matchPattern有效*/
    tolerance4?: number;
}

export  function inertia({ from, velocity, min, max, power, timeConstant, bounceStiffness, bounceDamping, restDelta, modifyTarget, driver, onUpdate, onComplete, onStop }: InertiaOptions): {
    stop: () => void;
};

export  interface InertiaOptions extends DecayOptions {
    bounceStiffness?: number;
    bounceDamping?: number;
    min?: number;
    max?: number;
    restSpeed?: number;
    restDelta?: number;
    driver?: Driver;
    onUpdate?: (v: number) => void;
    onComplete?: () => void;
    onStop?: () => void;
}

/**
 * Create a function that maps from a numerical input array to a generic output array.
 *
 * Accepts:
 *   - Numbers
 *   - Colors (hex, hsl, hsla, rgb, rgba)
 *   - Complex (combinations of one or more numbers or strings)
 *
 * ```jsx
 * const mixColor = interpolate([0, 1], ['#fff', '#000'])
 *
 * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
 * ```
 *
 * @public
 */
export  function interpolate<T>(input: number[], output: T[], { clamp: isClamp, ease, mixer }?: InterpolateOptions<T>): (v: number) => T;

/**
 * @param points 要插值的（多段）线的顶点(输入必须为经纬度).
 * @param number 沿线插入的点数；这包括端点，并且有效最小值为 2（如果给出较小的数字，则仍将返回端点）.
 * @param offsetDist 一个可选的垂直距离，用于从线段偏移每个点，否则它会位于.
 * @param minGap 在后续插值点之间保持可选的最小间隙；如果一组“number”点的后续点之间的投影间隙低于此值，则“number”将减小到合适的值.
 * @param includeSrcPoint 包括原有点
 * @param isLngLat 点坐标序列是否是经纬度坐标
 * @return {any[]}
 */
export  function interpolateLineRange(points: GeoPointLike[] | any, number: number, isLngLat?: boolean, offsetDist?: number, minGap?: number, includeSrcPoint?: boolean): any[];

 interface InterpolateOptions<T> {
    clamp?: boolean;
    ease?: MixEasing;
    mixer?: MixerFactory<T>;
}

/**
 * 通过比例(0-1)的值，得到坐标序列的点坐标的值
 * @param points
 * @param isLngLat
 * @param ratio
 * @return {any[]}
 */
export  function interpolatePointsByRatio(points: GeoPointLike[] | any, ratio: number, isLngLat?: boolean): any[];

/**
 * 地图打开参数
 */
export  interface IOpenMapBaseParam {
    /** 地图ID. */
    mapid: string;
    /** 地图打开方式(缺省: GeomRender) . */
    mapopenway?: MapOpenWay;
    /** 文件唯一ID. 地图ID第一次打开时，需传递fileid */
    fileid?: string;
    /** 文件文档. */
    filedoc?: string;
    /** 文件名称. */
    filename?: string;
    /** 上传时的文件名. */
    uploadname?: string;
    /** 秘钥(第一次上传打开图时有效，表示此图需要密码保护). */
    secretKey?: string;
    /** 访问权限的key，权限小于secretKey，不能对图进行删除等操作. */
    accessKey?: string;
    /** 要求输入密码回调. */
    cbInputPassword?: (param: {
        mapid: string;
        isPasswordError: boolean;
        tryPasswordCount: number;
        result: any;
    }) => Promise<string>;
    /** 地图来源参数. */
    mapfrom?: string;
    /** 地图依赖项. */
    mapdependencies?: string;
    /** 地图来源参数(这是子项的设置，与mapfrom不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapfrom一样的话，则为空 */
    subfrom?: string;
    /** 地图依赖项(这是子项的设置，与mapdependencies不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapdependencies一样的话，则为空  */
    subdependencies?: string;
    /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
    renderAccuracy?: number;
    /** 样式. */
    style?: IMapStyleParam;
    /** 不使用缺省的字体文件，将使用缺省的型文件来代替字体文件. */
    notUseDefaultTtfFont?: boolean;
    /** 不使用缺省的型文字文件，将使用缺省的字体来代替型文件. */
    notUseDefaultShxFont?: boolean;
    /** 不自动替换线型. */
    notReplaceLineType?: boolean;
    /** 字符替换规则. openMap返回的字段findFonts为系统查找的字体替换规则。如需修改默认的话，请传入替换的字体规则，如fontReplaceRule: {"tssdeng.shx_1": "_default_.ttc"}*/
    fontReplaceRule?: Record<string, string> | string;
    /** 地图初始化时显示小点时范围需自动处理比例大小，默认16 如不想自动处理，可以把值设置很大。**/
    mapInitViewErrMaxRatio?: number;
    /** 图像左上角坐标x 第一次打开图像类型时有效*/
    imageLeft?: number;
    /** 图像左上角坐标y 第一次打开图像类型时有效*/
    imageTop?: number;
    /** 图像分辨率 第一次打开图像类型时有效, 一个像素单位代表多少地理长度，计算公式为 真实坐标长度 / 图像像素宽 */
    imageResolution?: number;
    /** 判断是否打开或更新成功重试间隔（秒）。默认 5s 一次 */
    openFinishTryInterval?: number;
    /** 判断是否打开或更新成功重试最大次数。默认 120 次 */
    openFinishMaxTryCount?: number;
    /** 新建地图有fileDoc时有效 */
    cadVersion?: string;
    /** 使用post方式打开 (默认使用get)*/
    httpUsePost?: boolean;
}

/**
 * 地图打开参数
 */
export  interface IOpenMapParam extends IOpenMapBaseParam {
    /** 版本号(缺省: "" ). */
    version?: string;
    /** 图层名称，组合图层用英文逗号分开 */
    layer?: string;
    /** 布局索引 (从1开始)，默认为0，表示是模型空间 */
    layoutIndex?: number;
}

/**
 * 地图打开返回成功参数
 */
export  interface IOpenMapResponse {
    /** 地图ID. */
    mapid?: string;
    /** 版本号(缺省: "" ). */
    version?: string;
    /** 图层名称 */
    layer?: string;
    /** 地图打开方式(缺省: GeomRender) . */
    mapopenway?: MapOpenWay;
    /** DbID. */
    dbid?: string;
    /** 文件唯一ID. */
    fileid?: string;
    /** 文件名称. */
    filename?: string;
    /** 地图范围(如果通过clipBounds打开，则是clipBounds的范围). */
    bounds?: GeoBounds;
    /** 地图范围(地图的范围，如果没有通过clipBounds打开,则为空). */
    mapBounds?: GeoBounds;
    /** 数据库地图范围*/
    dbBounds?: GeoBounds;
    /** 图形中有数据的范围（此范围是非精确值，精确的数据范围需调用cmdGetDrawBounds去获取）*/
    drawBounds?: GeoBounds;
    /** 图层样式. */
    styles?: any;
    /** 图层列表. */
    layers?: any;
    /** 地图类型. 为空时表示是cad类型，image表示是图像 */
    maptype?: string;
    /** 状态. */
    status?: string;
    /** 暗黑模式(背景色为黑时). */
    darkMode?: boolean;
    /** 类型. */
    type?: string;
    /** ucs基点坐标. */
    ucsorg?: string;
    /** 上传的文件名. */
    uploadname?: string;
    /** 描述. */
    description?: string;
    /** 默认是否显示线宽. */
    lineWidthDisplay?: boolean;
    /** 所有布局. */
    layouts?: string[];
    /** 地图来源参数. */
    mapfrom?: string;
    /** 地图依赖项. */
    mapdependencies?: string;
    /** 地图来源参数(这是子项的设置，与mapfrom不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapfrom一样的话，则为空 */
    subfrom?: string;
    /** 地图依赖项(这是子项的设置，与mapdependencies不同的是，这个没有转化为基础图形，有可能还有依赖关系）.如与mapdependencies一样的话，则为空  */
    subdependencies?: string;
    /** 渲染精度，默认1，有时候图形特别大导致圆或圆弧精度不够时,不够光滑，可以先清空之前的缓存数据，再重新上传时，改变渲染精度来使圆或圆弧光滑些。注：提高精度会导致空间数据文件增大，渲染性能下降 */
    renderAccuracy?: number;
    /** 初始视图缩放倍数，bounds * initViewScale = dbBounds */
    initViewScale?: number;
    /** 初始视图. */
    view?: {
        /** 初始视图中心点. */
        center?: [number, number];
        /** 初始视图级别. */
        zoom?: number;
        /** 初始视图方位角. */
        bearing?: number;
    };
    /** 图像类型时最大级别 */
    maxzoom?: number;
    /** 图像类型时图像像素宽 */
    imageWidth?: number;
    /** 图像类型时图像像素高 */
    imageHeight?: number;
    /** 图像左上角坐标x */
    imageLeft?: number;
    /** 图像左上角坐标y */
    imageTop?: number;
    /** 图像分辨率  一个像素单位代表多少地理长度，计算公式为 真实坐标长度 / 图像像素宽 */
    imageResolution?: number;
}

/**
 * 点查询实体参数
 */
export  interface IPointQueryFeatures extends IQueryBaseFeatures {
    /** 查询的坐标X. */
    x: number;
    /** 查询的坐标Y. */
    y: number;
    /** 像素大小. */
    pixelsize?: number;
    /** 条件. */
    condition?: string;
    /** 返回最大的几何字节数. */
    maxGeomBytesSize?: number;
    /** 当前一个像素表示多少几何长度，如果输入了此值，则为此值为主，否则，根据输入的zoom值后台自动计算. */
    pixelToGeoLength?: number;
}

/**
 * 查询实体参数
 */
export  interface IQueryBaseFeatures {
    /** 当前级别. */
    zoom?: number;
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 图层名称（为空时采用当前打开的地图图层名称). */
    layer?: string;
    /** 返回最多的记录条数. */
    limit?: number;
    /** 是返回的字段列表，多个之是用逗号,分开,如. "name,objectid" */
    fields?: string;
    /** 是否为几何图形查询. */
    geom?: boolean;
    /** GeoJSON几何数据简化墨托卡距离，默认为零，不简化。例如允许10级别以上一个像素级别的误差，可用 map.pixelToGeoLength(1, 10) * vjmap.Projection.EQUATORIAL_SEMIPERIMETER * 2 / map.getGeoBounds(1.0).width() */
    simplifyTolerance?: boolean;
    /** 启动cache(内存打开的图形有效). */
    useCache?: boolean;
    /** 查询返回的坐标默认为墨卡托坐标，返回会程序会自动转化为cad坐标，如果要直接返回cad地图坐标，需要把toMapCoordinate设置为true. */
    toMapCoordinate?: boolean;
}

/**
 * 矩形查询实体参数
 */
export  interface IRectQueryFeatures extends IQueryBaseFeatures {
    /** 查询的坐标X1. (如果x1,y1,x2,y2同时不输的话，表示是查询整个图的范围 */
    x1?: number;
    /** 查询的坐标Y1. */
    y1?: number;
    /** 查询的坐标X2. */
    x2?: number;
    /** 查询的坐标Y2. */
    y2?: number;
    /** 条件. */
    condition?: string;
    /** 返回最大的几何字节数. */
    maxGeomBytesSize?: number;
}

export  interface IRequest {
    get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
    put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    del: (url: string, args?: Partial<Config>) => Promise<any>;
    options: (url: string, args?: Partial<Config>) => Promise<any>;
}

/**
 * 多边形是否闭合
 * @param points
 * @return {boolean}
 */
export  function isClosedPolygon(points: GeoPoint[]): boolean;

/**
 * 指示提供的点是按逆时针（真）还是顺时针（假）顺序排列
 * @param a
 * @param b
 * @param c
 * @return {boolean}
 */
export  function isCounterClockwise(a: GeoPoint, b: GeoPoint, c: GeoPoint): boolean;

/**
 * A {@link GeoPointLike} object, an array of two numbers representing longitude and latitude,
 * or an object with `lng` and `lat` or `lon` and `lat` properties.
 *
 * Example:
 * ```typescript
 * const center = { lat: 53.3, lng: 13.4 };
 * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
 * ```
 */
export  function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike;

/**
 * 获取图片切片缓存级别
 */
export  interface ISliceCacheZoom {
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 图层名称（为空时采用当前打开的地图图层名称) */
    layer?: string;
    /** 是否是矢量切片，如果否则为栅格瓦片切片 */
    ismvt: boolean;
}

/**
 * 对图层进行切片
 */
export  interface ISliceLayer {
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 图层名称（为空时采用当前打开的地图图层名称).如果为数组时，表示对多个图层进行切片 */
    layer: string | string[];
    /** 级别（切的第几级）, 如果为数组时，layer也必须是数组，一一对应 */
    zoom: number | number[];
    /** 是否是矢量切片，如果否则为栅格瓦片切片. 如果为数组时，layer也必须是数组，一一对应 */
    ismvt: boolean | boolean[];
    /** 是否取消对此图层的切片（正在切时有效）. */
    iscancel?: boolean;
    /** 是否取消所有的切片（正在切时有效）. */
    isAllCancel?: boolean;
    /** 批处理的条数（默认10000）. */
    batchNum?: number;
    /** 空闲一次批处理等待时间（默认1ms）. */
    idleBatchSleepMs?: number;
    /** 繁忙时一次批处理等待时间（默认10000ms）. */
    busyBatchSleepMs?: number;
}

export  const isPoint: (point: Object) => point is Point23D;

export  const isPoint3D: (point: Point23D) => point is Point3D;

/**
 * 判断点是否在多边形内。
 * @param pos 点
 * @param polygon 多边形坐标
 * @return {boolean}
 */
export  const isPointInPolygon: (pos: GeoPoint, polygon: GeoPoint[]) => boolean;

/**
 * 判断是否为零
 * @param value 值
 * @param precision 精度，缺省1e-6
 */
export  function isZero(value: number, precision?: number): boolean;

/**
 * 地图瓦片参数
 */
export  interface ITileUrlParam {
    /** 地图ID. */
    mapid?: string;
    /** 版本号. */
    version?: string;
    /** 图层名称. */
    layer?: string;
    /** 文件唯一ID. */
    fileid?: string;
}

/**
 * 更新地图参数
 */
export  interface IUpdateMapParam extends IOpenMapBaseParam {
    /** 是否删除老版本(缺省: false ). */
    deleteOldVersion?: boolean;
}

/**
 * 更新样式接口
 */
export  interface IUpdateStyle {
    /** 地图ID(为空时采用当前打开的mapid). */
    mapid?: string;
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string;
    /** 样式名称. */
    name?: string;
    /** 要开的图层索引列表，格式如[0,1,3]. */
    layeron?: string | number[];
    /** 要关的图层索引列表，格式如[2,4]. layeron与layeroff只要输入一个即可*/
    layeroff?: string | number[];
    /** 地图裁剪范围，范围如[x1,y1,x2,y2].如果只有数字的话，表示是缩放系数 */
    clipbounds?: [number, number, number, number] | number;
    /** 颜色. */
    backcolor?: number;
    /** 线宽，格式如[1，1，1，1，0].表式第1，2，3，4级线宽开，第5级线宽关，大于第5级的，以最后设置的级别状态为主，所以也是关。如为空，则和原图线宽显示状态相同 */
    lineweight?: string | number[];
    /** 表达式. */
    expression?: string;
}

/**
 * wms服务url地址接口
 */
export  interface IWmsTileUrl {
    /** 地图ID(为空时采用当前打开的mapid)， 为数组时表时同时请求多个. */
    mapid?: string | string[];
    /** 地图版本(为空时采用当前打开的地图版本). */
    version?: string | string[];
    /** 图层名称（为空时采用当前打开的地图图层名称). */
    layers?: string | string[];
    /** 范围，缺省{bbox-epsg-3857}. (如果要获取地图cad一个范围的wms数据无需任何坐标转换，将此范围填cad范围,srs,crs,mapbounds填为空).*/
    bbox?: string;
    /** 当前坐标系,缺省(EPSG:3857). */
    srs?: string;
    /** cad图的坐标系，为空的时候由元数据坐标系决定. 也可直接输入proj4字符串*/
    crs?: string | string[];
    /** 地理真实范围，如有值时,srs将不起作用 */
    mapbounds?: string;
    /** 宽. */
    width?: number;
    /** 高. */
    height?: number;
    /** 是否透明. */
    transparent?: boolean;
    /** 不透明时的背景颜色，默认为白色。格式必须为rgb(r,g,b)或rgba(r,g,b,a),a不透明应该是255. */
    backgroundColor?: string;
    /** 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正*/
    fourParameter?: string | string[];
    /** 是否用上面的四参数进行反算，默认false*/
    isInverseFourParamter?: boolean | boolean[];
    /** 是否是矢量瓦片. */
    mvt?: boolean;
    /** 是否考虑旋转，在不同坐标系中转换是需要考虑。默认自动考虑是否需要旋转. */
    useImageRotate?: boolean;
    /** 旋转时图像处理算法. 1或2,默认自动选择（旋转时有用）*/
    imageProcessAlg?: number;
    /** 当前互联网底图地图类型 WGS84(84坐标，如天地图，osm), GCJ02(火星坐标，如高德，腾讯地图)， BD09LL(百度经纬度坐标，如百度地图)， BD09MC(百度墨卡托米制坐标，如百度地图)*/
    webMapType?: "WGS84" | "GCJ02" | "BD09LL" | "BD09MC";
}

/**
 * 工作区（工作区主要用来对图纸进行分类管理。不同工作区的图纸存在的位置不同，查看不同工作区的图纸，需要切换到相应工作区才能查看）
 */
export  interface IWorkspace {
    /** 工作区名称(英文名称，不要有特殊字符，用于做为键值和路由). */
    name: string;
    /** 工作区别名(可以是中文). */
    alias?: string;
    /** 工作区目录，如果是相对于工作区路径的一个路径或绝对路径，如为空的话，则用工作区名称做为工作目录. */
    workDir?: string;
    /** 是否公开（不公开的话，无法通过获取工作区功能来获取到此工作区信息）. */
    isPublic?: boolean;
}

export  const kebabCase: (s: any) => any;

export  interface KeyframeOptions<V = number> {
    to: V | V[];
    from?: V;
    duration?: number;
    ease?: Easing | Easing[];
    offset?: number[];
}

export  function keyframes<V>({ from, to, ease, offset, duration }: KeyframeOptions): any;

export  type LayerCallback = (arg0: {}) => void;

export  type LayerRef = string | string[] | RegExp | ((arg0: LayerSpecification) => boolean);

export  type LayerRefFunc = (arg0: LayerRef, ...args: any[]) => void;

export  type LayerRefFunc0 = (arg0: LayerRef) => void;

export  type LayerRefFunc1<T1> = (arg0: LayerRef, arg1: T1) => void;

export  type LayerRefFunc2<T1, T2> = (arg0: LayerRef, arg1: T1, arg2: T2) => void;

export  type LayerRefFunc3<T1, T2, T3> = (arg0: LayerRef, arg1: T1, arg2: T2, arg3: T3) => void;

export  type LayerSpecification = FillLayerSpecification | LineLayerSpecification | SymbolLayerSpecification | CircleLayerSpecification | HeatmapLayerSpecification | FillExtrusionLayerSpecification | RasterLayerSpecification | HillshadeLayerSpecification | BackgroundLayerSpecification | SkyLayerSpecification;

export  type LightSpecification = {
    anchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    position?: PropertyValueSpecificationEx<[number, number, number]>;
    color?: PropertyValueSpecificationEx<ColorSpecification>;
    intensity?: PropertyValueSpecificationEx<number>;
};

export  const linear: Easing;

export  interface LineGeoJsonInput {
    points: GeoPointLike[];
    properties?: object;
}

export  type LineLayerSpecification = {
    id: string;
    type: "line";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "line-cap"?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
        "line-join"?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
        "line-miter-limit"?: PropertyValueSpecificationEx<number>;
        "line-round-limit"?: PropertyValueSpecificationEx<number>;
        "line-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "line-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "line-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "line-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "line-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "line-width"?: DataDrivenPropertyValueSpecification<number>;
        "line-gap-width"?: DataDrivenPropertyValueSpecification<number>;
        "line-offset"?: DataDrivenPropertyValueSpecification<number>;
        "line-blur"?: DataDrivenPropertyValueSpecification<number>;
        "line-dasharray"?: DataDrivenPropertyValueSpecification<Array<number>>;
        "line-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "line-gradient"?: ExpressionSpecificationEx;
    };
};

export  type LineLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    lineCap?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    lineJoin?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    lineMiterMimit?: PropertyValueSpecificationEx<number>;
    lineRoundLimit?: PropertyValueSpecificationEx<number>;
    lineSortKey?: DataDrivenPropertyValueSpecification<number>;
    visibility?: "visible" | "none";
    lineOpacity?: DataDrivenPropertyValueSpecification<number>;
    lineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    lineTranslate?: PropertyValueSpecificationEx<[number, number]>;
    lineTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    lineWidth?: DataDrivenPropertyValueSpecification<number>;
    lineGapWidth?: DataDrivenPropertyValueSpecification<number>;
    lineOffset?: DataDrivenPropertyValueSpecification<number>;
    lineBlur?: DataDrivenPropertyValueSpecification<number>;
    lineDasharray?: DataDrivenPropertyValueSpecification<Array<number>>;
    linePattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    lineGradient?: ExpressionSpecificationEx;
};

/**
 * 线被另外一条线分开多条线段，返回新的线段
 * @param line
 * @param splitLine
 * @param dotErr 允许误差的小数点后几位，默认6位
 * @return {any[] | GeoPoint[][]}
 */
export  function lineSplit(line: GeoPoint[], splitLine: GeoPoint[], dotErr?: number): GeoPoint[][];

/**
 * LineString Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.4
 */
 interface LineString extends GeometryObject {
    type: "LineString";
    coordinates: Position[];
}

/**
 * `LnglatProjection` 经纬度坐标投影.
 *
 * Example:
 * ```typescript
 * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
 * const prj = new LnglatProjection(mapExtent);
 * const pt = [30, 30];
 * const latlng = prj.toLngLat(pt);
 * const pt_geo = prj.fromLngLat(latlng);
 * const mkt = prj.toMercator(pt);
 * const pt_mkt = prj.fromMercator(mkt);
 * ```
 */
export  class LnglatProjection extends Projection {
    /** 地图地理范围. */
    mapExtent: GeoBounds;
    /**
     *  `GeoBounds` 构造函数
     *
     * @extent extent - 地图地理范围.
     */
    constructor();
    /**
     *  设置地图范围
     *
     * @extent extent - 地图地理范围.
     */
    setExtent(extent: GeoBounds): void;
    /**
     * 坐标转墨卡托(epsg:3857)
     * @param input 坐标点
     * @return {[number, number]}
     */
    toMercator(input: GeoPointLike): [number, number];
    /**
     * 墨卡托(epsg:3857)转坐标
     * @param input 墨卡托坐标点
     * @return {[number, number]}
     */
    fromMercator(input: GeoPointLike): [number, number];
    /**
     * 地图地理坐标转经纬度
     * @param input 地理坐标点
     * @return {[number, number]}
     */
    toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 经纬度转地图地理坐标
     * @param input 经纬度坐标点
     * @return {GeoPoint}
     */
    fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 得到地图范围
     * @return {GeoBounds}
     */
    getMapExtent(): GeoBounds;
    /**
     * 把距离转化为米
     * @param dist
     */
    toMeter(dist: number): number;
    /**
     * 把米转化为距离
     * @param meter
     */
    fromMeter(meter: number): number;
}

export  class MapGlUtils {
    constructor();
    static init(map: any, bindToMap: any): any;
    static newMap(params?: {}, options?: {}): Promise<Map>;
}

export  enum MapOpenWay {
    /** 内存模式. */
    Memory = "Memory",
    /** 存储为几何数据再渲染模式 */
    GeomRender = "GeomRender"
}

 class MarkerBase {
    protected options: AnimateMarkerLayerOption;
    protected markersElement: any;
    protected features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    };
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setFeatures(features: FeatureCollection): void;
    getMarkersElement(): any;
    getElement(index?: number): any;
    getLngLat(index?: number): any;
    createMarker(options?: createMarkerOptions, index?: number): Marker;
    setMarkersTextField(textField: string): void;
    setMarkersText(text: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    protected _getColorWithOpacity(color: string, opacity: string | number): string;
    protected _getTextContainer(feature: any, className: string): HTMLDivElement | null;
    set16ToRgb(str: string): string;
    getColorWithOpacity(color: string, opacity: string | number): string;
}

/**
 * 创建文本组件.
 */
export  class MarkerCluster extends Evented {
    private options;
    private markers;
    private markersOnScreen;
    private _map;
    private _hidden;
    private data;
    /**
     * 构造函数
     * @param options
     */
    constructor(options: MarkerClusterOptions);
    /**
     * 将 `MarkerCluster` 附加到 `Map` 对象。
     */
    addTo(map: Map): MarkerCluster;
    /**
     * 更新数据。
     */
    updateData(data: FeatureCollection | MarkerClusterData[]): void;
    /**
     * 获取数据。
     */
    getData(): MarkerClusterData[];
    /**
     * 更新markers。
     */
    updateMarkers(): void;
    /**
     * 从地图中删除。
     */
    remove(): void;
    /**
     * 显示
     */
    show(): void;
    /**
     * 隐藏
     */
    hide(): void;
    allowOverlap(bAllowOverlap: boolean): void;
    allowOverlapMaxZoom(zoom: number): void;
}

export  interface MarkerClusterData {
    point: GeoPointLike;
    properties?: Record<string, any>;
    [propName: string]: any;
}

export  interface MarkerClusterOptions {
    /** 数据内容.(传入坐标为CAD地理坐标) */
    data: FeatureCollection | MarkerClusterData[];
    createMarker: (curMarkerData: MarkerClusterData, clusterMarkersData: MarkerClusterData[]) => Marker | Text_2;
    updateMarker?: (curMarkerData: MarkerClusterData, clusterMarkersData: MarkerClusterData[], marker: Marker) => Marker | Text_2 | undefined;
    /** 是否允许重叠，默认false. */
    allowOverlap?: boolean;
    /** 离相机最近的在显示在前面，默认false. */
    cameraNearFront?: boolean;
    /** 允许重叠的最大缩放级别，小于或等于此级别才会处理重叠，超过此级时会全部显示当前所有的(如果不允许重叠时有效).默认4级*/
    allowOverlapMaxZoom?: number;
    /** marker div的像素宽，用于计算重叠时需要，默认40. 如果在data的properties设置了属性markerWidth，则以data设置的为准*/
    markerWidth?: number;
    /** marker div的像素高，用于计算重叠时需要，默认40. 如果在data的properties设置了属性markerHeight，则以data设置的为准 */
    markerHeight?: number;
}

export  namespace mat2 {
    export type valueType = mat2type;
    /**
     * Creates a new identity mat2
     *
     * @returns {mat2} a new 2x2 matrix
     */
    export function create(): Float32Array;
    /**
     * Creates a new mat2 initialized with values from an existing matrix
     *
     * @param {ReadonlyMat2} a matrix to clone
     * @returns {mat2} a new 2x2 matrix
     */
    export function clone(a: mat2type): Float32Array;
    /**
     * Copy the values from one mat2 to another
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function copy(out: mat2type, a: mat2type): mat2type;
    /**
     * Set a mat2 to the identity matrix
     *
     * @param {mat2} out the receiving matrix
     * @returns {mat2} out
     */
    export function identity(out: mat2type): mat2type;
    /**
     * Create a new mat2 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m10 Component in column 1, row 0 position (index 2)
     * @param {Number} m11 Component in column 1, row 1 position (index 3)
     * @returns {mat2} out A new 2x2 matrix
     */
    export function fromValues(m00: number, m01: number, m10: number, m11: number): mat2type;
    /**
     * Set the components of a mat2 to the given values
     *
     * @param {mat2} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m10 Component in column 1, row 0 position (index 2)
     * @param {Number} m11 Component in column 1, row 1 position (index 3)
     * @returns {mat2} out
     */
    export function set(out: mat2type, m00: number, m01: number, m10: number, m11: number): mat2type;
    /**
     * Transpose the values of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function transpose(out: mat2type, a: mat2type): mat2type;
    /**
     * Inverts a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function invert(out: mat2type, a: mat2type): mat2type | null;
    /**
     * Calculates the adjugate of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function adjoint(out: mat2type, a: mat2type): mat2type;
    /**
     * Calculates the determinant of a mat2
     *
     * @param {ReadonlyMat2} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat2type): number;
    /**
     * Multiplies two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function multiply(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Rotates a mat2 by the given angle
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    export function rotate(out: mat2type, a: mat2type, rad: number): mat2type;
    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to rotate
     * @param {ReadonlyVec2} v the vec2 to scale the matrix by
     * @returns {mat2} out
     **/
    export function scale(out: mat2type, a: mat2type, v: mat2type): mat2type;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.rotate(dest, dest, rad);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    export function fromRotation(out: mat2type, rad: number): mat2type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.scale(dest, dest, vec);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {ReadonlyVec2} v Scaling vector
     * @returns {mat2} out
     */
    export function fromScaling(out: mat2type, v: mat2type): mat2type;
    /**
     * Returns a string representation of a mat2
     *
     * @param {ReadonlyMat2} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat2type): string;
    /**
     * Returns Frobenius norm of a mat2
     *
     * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat2type): number;
    /**
     * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
     * @param {ReadonlyMat2} L the lower triangular matrix
     * @param {ReadonlyMat2} D the diagonal matrix
     * @param {ReadonlyMat2} U the upper triangular matrix
     * @param {ReadonlyMat2} a the input matrix to factorize
     */
    export function LDU(L: mat2type, D: mat2type, U: mat2type, a: mat2type): mat2type[];
    /**
     * Adds two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function add(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function subtract(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyMat2} a The first matrix.
     * @param {ReadonlyMat2} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat2type, b: mat2type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {ReadonlyMat2} a The first matrix.
     * @param {ReadonlyMat2} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat2type, b: mat2type): boolean;
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat2} out
     */
    export function multiplyScalar(out: mat2type, a: mat2type, b: number): mat2type;
    /**
     * Adds two mat2's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat2} out the receiving vector
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @param {Number} scale the amount to scale b's elements by before adding
     * @returns {mat2} out
     */
    export function multiplyScalarAndAdd(out: mat2type, a: mat2type, b: mat2type, scale: number): mat2type;
}

export  namespace mat2d {
    export type valueType = mat2dtype;
    /**
     * Creates a new identity mat2d
     *
     * @returns {mat2d} a new 2x3 matrix
     */
    export function create(): mat2dtype;
    /**
     * Creates a new mat2d initialized with values from an existing matrix
     *
     * @param {ReadonlyMat2d} a matrix to clone
     * @returns {mat2d} a new 2x3 matrix
     */
    export function clone(a: mat2dtype): mat2dtype;
    /**
     * Copy the values from one mat2d to another
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {mat2d} out
     */
    export function copy(out: mat2dtype, a: mat2dtype): mat2dtype;
    /**
     * Set a mat2d to the identity matrix
     *
     * @param {mat2d} out the receiving matrix
     * @returns {mat2d} out
     */
    export function identity(out: mat2dtype): mat2dtype;
    /**
     * Create a new mat2d with the given values
     *
     * @param {Number} a Component A (index 0)
     * @param {Number} b Component B (index 1)
     * @param {Number} c Component C (index 2)
     * @param {Number} d Component D (index 3)
     * @param {Number} tx Component TX (index 4)
     * @param {Number} ty Component TY (index 5)
     * @returns {mat2d} A new mat2d
     */
    export function fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): mat2dtype;
    /**
     * Set the components of a mat2d to the given values
     *
     * @param {mat2d} out the receiving matrix
     * @param {Number} a Component A (index 0)
     * @param {Number} b Component B (index 1)
     * @param {Number} c Component C (index 2)
     * @param {Number} d Component D (index 3)
     * @param {Number} tx Component TX (index 4)
     * @param {Number} ty Component TY (index 5)
     * @returns {mat2d} out
     */
    export function set(out: mat2dtype, a: number, b: number, c: number, d: number, tx: number, ty: number): mat2dtype;
    /**
     * Inverts a mat2d
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {mat2d} out
     */
    export function invert(out: mat2dtype, a: mat2dtype): mat2dtype | null;
    /**
     * Calculates the determinant of a mat2d
     *
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat2dtype): number;
    /**
     * Multiplies two mat2d's
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function multiply(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Rotates a mat2d by the given angle
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    export function rotate(out: mat2dtype, a: mat2dtype, rad: number): mat2dtype;
    /**
     * Scales the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to translate
     * @param {ReadonlyVec2} v the vec2 to scale the matrix by
     * @returns {mat2d} out
     **/
    export function scale(out: mat2dtype, a: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Translates the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to translate
     * @param {ReadonlyVec2} v the vec2 to translate the matrix by
     * @returns {mat2d} out
     **/
    export function translate(out: mat2dtype, a: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.rotate(dest, dest, rad);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    export function fromRotation(out: mat2dtype, rad: number): mat2dtype;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.scale(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {ReadonlyVec2} v Scaling vector
     * @returns {mat2d} out
     */
    export function fromScaling(out: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.translate(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {ReadonlyVec2} v Translation vector
     * @returns {mat2d} out
     */
    export function fromTranslation(out: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Returns a string representation of a mat2d
     *
     * @param {ReadonlyMat2d} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat2dtype): string;
    /**
     * Returns Frobenius norm of a mat2d
     *
     * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat2dtype): number;
    /**
     * Adds two mat2d's
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function add(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function subtract(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat2d} out
     */
    export function multiplyScalar(out: mat2dtype, a: mat2dtype, b: number): mat2dtype;
    /**
     * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat2d} out the receiving vector
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @param {Number} scale the amount to scale b's elements by before adding
     * @returns {mat2d} out
     */
    export function multiplyScalarAndAdd(out: mat2dtype, a: mat2dtype, b: mat2dtype, scale: number): mat2dtype;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyMat2d} a The first matrix.
     * @param {ReadonlyMat2d} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat2dtype, b: mat2dtype): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {ReadonlyMat2d} a The first matrix.
     * @param {ReadonlyMat2d} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat2dtype, b: mat2dtype): boolean;
}

export  type mat2dtype = [number, number, number, number, number, number] | Float32Array;

export  type mat2type = [number, number, number, number] | Float32Array;

export  namespace mat3 {
    export type valueType = mat3type;
    /**
     * Creates a new identity mat3
     *
     * @returns {mat3} a new 3x3 matrix
     */
    export function create(): mat3type;
    /**
     * Copies the upper-left 3x3 values into the given mat3.
     *
     * @param {mat3} out the receiving 3x3 matrix
     * @param {mat4} a   the source 4x4 matrix
     * @returns {mat3} out
     */
    export function fromMat4(out: mat3type, a: mat3type): mat3type;
    /**
     * Creates a new mat3 initialized with values from an existing matrix
     *
     * @param {mat3} a matrix to clone
     * @returns {mat3} a new 3x3 matrix
     */
    export function clone(a: mat3type): mat3type;
    /**
     * Copy the values from one mat3 to another
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function copy(out: mat3type, a: mat3type): mat3type;
    /**
     * Create a new mat3 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m10 Component in column 1, row 0 position (index 3)
     * @param {Number} m11 Component in column 1, row 1 position (index 4)
     * @param {Number} m12 Component in column 1, row 2 position (index 5)
     * @param {Number} m20 Component in column 2, row 0 position (index 6)
     * @param {Number} m21 Component in column 2, row 1 position (index 7)
     * @param {Number} m22 Component in column 2, row 2 position (index 8)
     * @returns {mat3} A new mat3
     */
    export function fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3type;
    /**
     * Set the components of a mat3 to the given values
     *
     * @param {mat3} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m10 Component in column 1, row 0 position (index 3)
     * @param {Number} m11 Component in column 1, row 1 position (index 4)
     * @param {Number} m12 Component in column 1, row 2 position (index 5)
     * @param {Number} m20 Component in column 2, row 0 position (index 6)
     * @param {Number} m21 Component in column 2, row 1 position (index 7)
     * @param {Number} m22 Component in column 2, row 2 position (index 8)
     * @returns {mat3} out
     */
    export function set(out: mat3type, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3type;
    /**
     * Set a mat3 to the identity matrix
     *
     * @param {mat3} out the receiving matrix
     * @returns {mat3} out
     */
    export function identity(out: mat3type): mat3type;
    /**
     * Transpose the values of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function transpose(out: mat3type, a: mat3type): mat3type;
    /**
     * Inverts a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function invert(out: mat3type, a: mat3type): mat3type | null;
    /**
     * Calculates the adjugate of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function adjoint(out: mat3type, a: mat3type): mat3type;
    /**
     * Calculates the determinant of a mat3
     *
     * @param {mat3} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat3type): number;
    /**
     * Multiplies two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function multiply(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Alias for {@link mat3.multiply}
     * @function
     */
    /**
     * Translate a mat3 by the given vector
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to translate
     * @param {vec2} v vector to translate by
     * @returns {mat3} out
     */
    export function translate(out: mat3type, a: mat3type, v: vec2type): mat3type;
    /**
     * Rotates a mat3 by the given angle
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    export function rotate(out: mat3type, a: mat3type, rad: number): mat3type;
    /**
     * Scales the mat3 by the dimensions in the given vec2
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {vec2} v the vec2 to scale the matrix by
     * @returns {mat3} out
     */
    export function scale(out: mat3type, a: mat3type, v: vec2type): mat3type;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.translate(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Translation vector
     * @returns {mat3} out
     */
    export function fromTranslation(out: mat3type, v: vec2type): mat3type;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.rotate(dest, dest, rad);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    export function fromRotation(out: mat3type, rad: number): mat3type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.scale(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Scaling vector
     * @returns {mat3} out
     */
    export function fromScaling(out: mat3type, v: vec2type): mat3type;
    /**
     * Copies the values from a mat2d into a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat2d} a the matrix to copy
     * @returns {mat3} out
     */
    export function fromMat2d(out: mat3type, a: mat2dtype): mat3type;
    /**
     * Calculates a 3x3 matrix from the given quaternion
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat3} out
     */
    export function fromQuat(out: mat3type, q: quattype): mat3type;
    /**
     * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {mat4} a Mat4 to derive the normal matrix from
     *
     * @returns {mat3} out
     */
    export function normalFromMat4(out: mat3type, a: mat4type): mat3type | null;
    /**
     * Returns a string representation of a mat3
     *
     * @param {mat3} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat3type): string;
    /**
     * Returns Frobenius norm of a mat3
     *
     * @param {mat3} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat3type): number;
    /**
     * Adds two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function add(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function subtract(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Alias for {@link mat3.subtract}
     * @function
     */
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat3} out
     */
    export function multiplyScalar(out: mat3type, a: mat3type, b: number): mat3type;
    /**
     * Adds two mat3's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat3} out the receiving vector
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @param {Number} s the amount to scale b's elements by before adding
     * @returns {mat3} out
     */
    export function multiplyScalarAndAdd(out: mat3type, a: mat3type, b: mat3type, s: number): mat3type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {mat3} a The first matrix.
     * @param {mat3} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat3type, b: mat3type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {mat3} a The first matrix.
     * @param {mat3} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat3type, b: mat3type): boolean;
}

export  type mat3type = [number, number, number, number, number, number, number, number, number] | Float32Array;

export  namespace mat4 {
    export type valueType = mat4type;
    /**
     * Creates a new identity mat4
     *
     * @returns {mat4} a new 4x4 matrix
     */
    export function create(): mat4type;
    /**
     * Creates a new mat4 initialized with values from an existing matrix
     *
     * @param {mat4} a matrix to clone
     * @returns {mat4} a new 4x4 matrix
     */
    export function clone(a: mat4type): mat4type;
    /**
     * Copy the values from one mat4 to another
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function copy(out: mat4type, a: mat4type): mat4type;
    /**
     * Create a new mat4 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m03 Component in column 0, row 3 position (index 3)
     * @param {Number} m10 Component in column 1, row 0 position (index 4)
     * @param {Number} m11 Component in column 1, row 1 position (index 5)
     * @param {Number} m12 Component in column 1, row 2 position (index 6)
     * @param {Number} m13 Component in column 1, row 3 position (index 7)
     * @param {Number} m20 Component in column 2, row 0 position (index 8)
     * @param {Number} m21 Component in column 2, row 1 position (index 9)
     * @param {Number} m22 Component in column 2, row 2 position (index 10)
     * @param {Number} m23 Component in column 2, row 3 position (index 11)
     * @param {Number} m30 Component in column 3, row 0 position (index 12)
     * @param {Number} m31 Component in column 3, row 1 position (index 13)
     * @param {Number} m32 Component in column 3, row 2 position (index 14)
     * @param {Number} m33 Component in column 3, row 3 position (index 15)
     * @returns {mat4} A new mat4
     */
    export function fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4type;
    /**
     * Set the components of a mat4 to the given values
     *
     * @param {mat4} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m03 Component in column 0, row 3 position (index 3)
     * @param {Number} m10 Component in column 1, row 0 position (index 4)
     * @param {Number} m11 Component in column 1, row 1 position (index 5)
     * @param {Number} m12 Component in column 1, row 2 position (index 6)
     * @param {Number} m13 Component in column 1, row 3 position (index 7)
     * @param {Number} m20 Component in column 2, row 0 position (index 8)
     * @param {Number} m21 Component in column 2, row 1 position (index 9)
     * @param {Number} m22 Component in column 2, row 2 position (index 10)
     * @param {Number} m23 Component in column 2, row 3 position (index 11)
     * @param {Number} m30 Component in column 3, row 0 position (index 12)
     * @param {Number} m31 Component in column 3, row 1 position (index 13)
     * @param {Number} m32 Component in column 3, row 2 position (index 14)
     * @param {Number} m33 Component in column 3, row 3 position (index 15)
     * @returns {mat4} out
     */
    export function set(out: mat4type, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4type;
    /**
     * Set a mat4 to the identity matrix
     *
     * @param {mat4} out the receiving matrix
     * @returns {mat4} out
     */
    export function identity(out: mat4type): mat4type;
    /**
     * Transpose the values of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function transpose(out: mat4type, a: mat4type): mat4type;
    /**
     * Inverts a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function invert(out: mat4type, a: mat4type): mat4type | null;
    /**
     * Calculates the adjugate of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function adjoint(out: mat4type, a: mat4type): mat4type;
    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat4type): number;
    /**
     * Multiplies two mat4s
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function multiply(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Alias for {@link mat4.multiply}
     * @function
     */
    /**
     * Translate a mat4 by the given vector
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to translate
     * @param {vec3} v vector to translate by
     * @returns {mat4} out
     */
    export function translate(out: mat4type, a: mat4type, v: vec3type): mat4type;
    /**
     * Scales the mat4 by the dimensions in the given vec3 not using vectorization
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to scale
     * @param {vec3} v the vec3 to scale the matrix by
     * @returns {mat4} out
     */
    export function scale(out: mat4type, a: mat4type, v: vec3type): mat4type;
    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    export function rotate(out: mat4type, a: mat4type, rad: number, axis: vec3type): mat4type | null;
    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateX(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateY(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateZ(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    export function fromTranslation(out: mat4type, v: vec3type): mat4type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.scale(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Scaling vector
     * @returns {mat4} out
     */
    export function fromScaling(out: mat4type, v: vec3type): mat4type;
    /**
     * Creates a matrix from a given angle around a given axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotate(dest, dest, rad, axis);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    export function fromRotation(out: mat4type, rad: number, axis: vec3type): mat4type | null;
    /**
     * Creates a matrix from the given angle around the X axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateX(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromXRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from the given angle around the Y axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateY(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromYRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from the given angle around the Z axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateZ(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromZRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    export function fromRotationTranslation(out: mat4type, q: quattype, v: vec3type): mat4type;
    /**
     * Returns the translation vector component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslation,
     *  the returned vector will be the same as the translation vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive translation component
     * @param  {mat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */
    export function getTranslation(out: vec3type, mat: mat4type): vec3type;
    /**
     * Returns the scaling factor component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslationScale
     *  with a normalized Quaternion paramter, the returned vector will be
     *  the same as the scaling vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive scaling factor component
     * @param  {mat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */
    export function getScaling(out: vec3type, mat: mat4type): vec3type;
    /**
     * Returns a quaternion representing the rotational component
     *  of a transformation matrix. If a matrix is built with
     *  fromRotationTranslation, the returned quaternion will be the
     *  same as the quaternion originally supplied.
     * @param {quat} out Quaternion to receive the rotation component
     * @param {mat4} mat Matrix to be decomposed (input)
     * @return {quat} out
     */
    export function getRotation(out: vec4type, mat: mat4type): quattype;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @returns {mat4} out
     */
    export function fromRotationTranslationScale(out: mat4type, q: quattype, v: vec3type, s: vec3type): mat4type;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     mat4.translate(dest, origin);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *     mat4.translate(dest, negativeOrigin);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @param {vec3} o The origin vector around which to scale and rotate
     * @returns {mat4} out
     */
    export function fromRotationTranslationScaleOrigin(out: mat4type, q: quattype, v: vec3type, s: vec3type, o: vec3type): mat4type;
    /**
     * Calculates a 4x4 matrix from the given quaternion
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat4} out
     */
    export function fromQuat(out: mat4type, q: quattype): mat4type;
    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {Number} left Left bound of the frustum
     * @param {Number} right Right bound of the frustum
     * @param {Number} bottom Bottom bound of the frustum
     * @param {Number} top Top bound of the frustum
     * @param {Number} near Near bound of the frustum
     * @param {Number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function frustum(out: mat4type, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4type;
    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function perspective(out: mat4type, fovy: number, aspect: number, near: number, far: number): mat4type;
    /**
     * Generates a perspective projection matrix with the given field of view.
     * This is primarily useful for generating projection matrices to be used
     * with the still experiemental WebVR API.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function perspectiveFromFieldOfView(out: mat4type, fov: {
        upDegrees: number;
        downDegrees: number;
        leftDegrees: number;
        rightDegrees: number;
    }, near: number, far: number): mat4type;
    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function ortho(out: mat4type, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4type;
    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing up
     * @returns {mat4} out
     */
    export function lookAt(out: mat4type, eye: vec3type, center: vec3type, up: vec3type): mat4type;
    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat4type): string;
    /**
     * Returns Frobenius norm of a mat4
     *
     * @param {mat4} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat4type): number;
    /**
     * Adds two mat4's
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function add(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function subtract(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Alias for {@link mat4.subtract}
     * @function
     */
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat4} out
     */
    export function multiplyScalar(out: mat4type, a: mat4type, b: number): mat4type;
    /**
     * Adds two mat4's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat4} out the receiving vector
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @param {Number} s the amount to scale b's elements by before adding
     * @returns {mat4} out
     */
    export function multiplyScalarAndAdd(out: mat4type, a: mat4type, b: mat4type, s: number): mat4type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {mat4} a The first matrix.
     * @param {mat4} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat4type, b: mat4type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {mat4} a The first matrix.
     * @param {mat4} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat4type, b: mat4type): boolean;
}

export  type mat4type = [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] | Float32Array;

export  namespace Math2D {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    export class Box {
        x: number;
        y: number;
        w: number;
        h: number;
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        constructor(x?: number, y?: number, w?: number, h?: number);
        /**
         * Set new values to all properties of the box.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        set(x: number, y: number, w: number, h: number): void;
        /**
         * Test box for inclusion of point.
         *
         * @param x - X coordinate of point.
         * @param y - Y coordinate of point.
         */
        contains(x: number, y: number): boolean;
        /**
         * Test box for inclusion of another box.
         *
         * @param other - Box 2 to test for inclusion.
         */
        containsBox(other: Box): boolean;
        /**
         * Test two boxes for intersection.
         *
         * @param other - Box 2 to test for intersection.
         */
        intersects(other: Box): boolean;
    }
    /**
     * Box to store UV coordinates.
     */
    export interface UvBox {
        s0: number;
        t0: number;
        s1: number;
        t1: number;
    }
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns Squared distance between the two points
     */
    export function distSquared(ax: number, ay: number, bx: number, by: number): number;
    /**
     * Compute distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns {number} between the two points
     * @param az
     * @param bz
     */
    export function dist(ax: number, ay: number, bx: number, by: number, az?: number, bz?: number): number;
    /**
     * 求线的距离
     * @param pts
     * @return {number}
     */
    export function lineDist(pts: GeoPointLike[]): number;
    /**
     * Computes the squared length of a line.
     *
     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    export function computeSquaredLineLength(line: number[]): number;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px - Test point X
     * @param py - Test point y
     * @param l0x - Line segment start X
     * @param l0y - Line segment start Y
     * @param l1x - Line segment end X
     * @param l1y - Line segment end Y
     * @returns Squared distance between point and line segment
     */
    export function distToSegmentSquared(px: number, py: number, l0x: number, l0y: number, l1x: number, l1y: number): number;
    /**
     * Finds the intersections of a line and a circle.
     *
     * @param xLine1 - abscissa of first line point.
     * @param yLine1 - ordinate of second line point.
     * @param xLine2 - abscissa of second line point.
     * @param yLine2 - ordinate of second line point.
     * @param radius - circle radius.
     * @param xCenter - abscissa of circle center.
     * @param yCenter - ordinate of circle center.
     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2
     * if it's secant) or undefined if there's no intersection.
     */
    export function intersectLineAndCircle(xLine1: number, yLine1: number, xLine2: number, yLine2: number, radius: number, xCenter?: number, yCenter?: number): {
        x1: number;
        y1: number;
        x2?: number;
        y2?: number;
    } | undefined;
    /**
     * Computes the intersection point between two lines.
     *
     * @remarks
     * This functions computes the
     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
     *    | line-line intersection} of two lines given two points on each line.
     *
     * @param x1 - x coordinate of the first point of the first line.
     * @param y1 - y coordinate of the first point of the first line.
     * @param x2 - x coordinate of the second point of the first line.
     * @param y2 - y coordinate of the second point of the first line.
     * @param x3 - x coordinate of the first point of the second line.
     * @param y3 - y coordinate of the first point of the second line.
     * @param x4 - x coordinate of the second point of the second line.
     * @param y4 - y coordinate of the second point of the second line.
     * @param result - The resulting point.
     */
    export function intersectLines(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, result?: Vec2Like): Vec2Like | undefined;
}

export  namespace MathUtils {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     *
     * @returns Clamped value.
     */
    export function clamp(value: number, min: number, max: number): number;
    /**
     * constrain n to the given range, excluding the minimum, via modular arithmetic
     *
     * @param n value
     * @param min the minimum value to be returned, (isMin is false, exclusive, is true inclusive)
     * @param max the maximum value to be returned, (isMin is false, inclusive, is true exclusive)
     * @returns {number} number
     * @param isMin
     */
    export function wrap(n: number, min: number, max: number, isMin?: boolean): number;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    export function smoothStep(edge0: number, edge1: number, x: number): number;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    export function smootherStep(edge0: number, edge1: number, x: number): number;
    /**
     * Maps a number from one range to another.
     *
     * @param val - The incoming value to be converted.
     * @param inMin - Lower bound of the value's current range.
     * @param inMax - Upper bound of the value's current range.
     * @param outMin - Lower bound of the value's target range.
     * @param outMax - Upper bound of the value's target range.
     */
    export function map(val: number, inMin: number, inMax: number, outMin: number, outMax: number): number;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    export function min2(a: number | undefined, b: number | undefined): number | undefined;
    /**
     * 线性插值
     * @param v1
     * @param v2
     * @param value
     * @return {number}
     */
    export function lerp(v1: number, v2: number, value: number): number;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    export function max2(a: number | undefined, b: number | undefined): number | undefined;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value - Value to check.
     * @param lowerBound - The lower bound to check the value against.
     * @param upperBound - The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    export function isClamped(value: number, lowerBound: number | undefined, upperBound: number | undefined): boolean;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue -
     * @param endValue -
     * @param time -
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    export function easeInOutCubic(startValue: number, endValue: number, time: number): number;
    /**
     * 判断两个数是否相等
     * @param dotErr 允许误差的小数点后几位，默认8位
     * @return {boolean}
     * @param num1
     * @param num2
     */
    export function equals(num1: number, num2: number, dotErr?: number): boolean;
}

/**
 * 求不同级级别下，每米表示多少像素
 * @param zoomLevel 级别从0表示
 * @param latitude 纬度
 * @return {number}
 */
export  function metersPerPixel(zoomLevel: number, latitude?: number): number;

export  const METHODS: Methods;

export  interface Methods {
    GET: "GET";
    POST: "POST";
    PUT: "PUT";
    DELETE: "DELETE";
    PATCH: "PATCH";
    OPTIONS: "OPTIONS";
    HEAD: "HEAD";
}

export  class MiniMapControl {
    private _ticking;
    private _lastMouseMoveEvent;
    private _parentMap;
    private _isDragging;
    private _isCursorOverFeature;
    private _previousPoint;
    private _currentPoint;
    private _trackingRectCoordinates;
    private options;
    private _container;
    private _miniMap;
    private _trackingRect;
    constructor(options: MiniMapControlOption);
    init(options: MiniMapControlOption): void;
    onAdd(parentMap: Map): HTMLElement;
    _onAdd(parentMap: Map): HTMLElement;
    _onSize(): void;
    _updateMapExtent(data: any): void;
    onRemove(): void;
    _onRemove(): void;
    getMap(): Map;
    getDefaultPosition(): string;
    _load(): void;
    _mouseDown(e: any): void;
    _mouseMove(e: any): void;
    _mouseUp(): void;
    _moveTrackingRect(offset: any): any;
    _setTrackingRectBounds(bounds: any): void;
    _convertBoundsToPoints(bounds: any): void;
    _update(e: any): void;
    _zoomAdjust(): void;
    _createContainer(parentMap: Map): HTMLDivElement;
    _preventDefault(e: any): void;
}

export  interface MiniMapControlOption {
    id?: string;
    width?: string;
    height?: string;
    style?: Style | string;
    center?: [number, number];
    zoom?: number;
    zoomAdjust?: null;
    lineColor?: string;
    lineWidth?: number;
    lineOpacity?: number;
    fillColor?: string;
    fillOpacity?: number;
    dragPan?: boolean;
    scrollZoom?: boolean;
    boxZoom?: boolean;
    dragRotate?: boolean;
    keyboard?: boolean;
    doubleClickZoom?: boolean;
    touchZoomRotate?: boolean;
    maxBounds?: LngLatBounds;
    containerStyle?: Partial<CSSStyleDeclaration>;
}

export  const mirrorEasing: EasingModifier;

 type Mix<T> = (v: number) => T;

export  const mix: (from: number, to: number, progress: number) => number;

export  const mixColor: (from: any | string, to: any | string) => (v: number) => any;

 type MixComplex = (p: number) => string;

export  const mixComplex: (origin: string, target: string) => MixComplex;

 type MixEasing = Easing | Easing[];

 type MixerFactory<T> = (from: T, to: T) => Mix<T>;

export  class MousePositionControl {
    private readonly digits;
    private readonly trackCenter;
    private readonly labelFormat;
    private coord;
    private readonly showLatLng;
    private readonly showZoom;
    private readonly showBearing;
    private readonly showPitch;
    private container;
    private panel;
    private map;
    private prj;
    private readonly style;
    constructor(options?: MousePositionControlOption);
    insertControl(): void;
    defaultLabelFormat(lng: number, lat: number, x: number, y: number): string;
    onMouseMove(evt?: any): void;
    onAdd(map: Map): HTMLElement;
    onRemove(): void;
    getDefaultPosition(): string;
}

export  interface MousePositionControlOption {
    digits?: number;
    trackCenter?: boolean;
    labelFormat?: (lng: number, lat: number, x: number, y: number, map?: Map) => string;
    projection?: Projection | undefined;
    style?: {
        border: string;
        backgroundColor: string;
    };
    showLatLng?: boolean;
    showZoom?: boolean;
    showBearing?: boolean;
    showPitch?: boolean;
}

export  enum MTextAttachmentPoint {
    kTopLeft = 1,
    kTopCenter = 2,
    kTopRight = 3,
    kMiddleLeft = 4,
    kMiddleCenter = 5,
    kMiddleRight = 6,
    kBottomLeft = 7,
    kBottomCenter = 8,
    kBottomRight = 9,
    kBaseLeft = 10,
    kBaseCenter = 11,
    kBaseRight = 12,
    kBaseAlign = 13,
    kBottomAlign = 14,
    kMiddleAlign = 15,
    kTopAlign = 16,
    kBaseFit = 17,
    kBottomFit = 18,
    kMiddleFit = 19,
    kTopFit = 20,
    kBaseMid = 21,
    kBottomMid = 22,
    kMiddleMid = 23,
    kTopMid = 24
}

/**
 * 多条线之间根据交点相互分开,返回相交后的所有线段，请确保每条线段不要自相交
 * @param lines
 * @param dotErr 允许误差的小数点后几位，默认6位
 */
export  function multiLineSplit(lines: GeoPoint[][], dotErr?: number): GeoPoint[][];

/**
 * MultiLineString Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.5
 */
 interface MultiLineString extends GeometryObject {
    type: "MultiLineString";
    coordinates: Position[][];
}

/**
 * MultiPoint Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.3
 */
 interface MultiPoint extends GeometryObject {
    type: "MultiPoint";
    coordinates: Position[];
}

/**
 * MultiPolygon Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.7
 */
 interface MultiPolygon extends GeometryObject {
    type: "MultiPolygon";
    coordinates: Position[][][];
}

 type NodeId = string;

export  type OffHandler = () => void;

export  function offsetPointLine(points: GeoPoint[], distance: number): any[];

export  function offsetPoints(pts: GeoPointLike[], options: {
    smoothFactor?: number;
    offset: number;
}): any[];

/**
 * 打开地图的深色背景样式，值为 {backcolor: 0}
 */
export  function openMapDarkStyle(): IMapStyleParam;

/**
 * 打开地图的浅色色背景样式，值为 {backcolor: 0xFFFFFF}
 */
export  function openMapLightStyle(): IMapStyleParam;

export  class OverlayLayerBase {
    sourceId?: string;
    layerId?: string;
    _map?: Map;
    constructor();
    addTo(map: Map, beforeId?: string): void;
    /**
     * 获取数据源ID
     * @return {string | undefined}
     */
    getSourceId(): string | undefined;
    /**
     * 获取图层ID
     * @return {string | undefined}
     */
    getLayerId(): string | undefined;
    /**
     * 获取数据源的数据
     * @return {GeoJsonGeomertry | undefined}
     */
    getData(): GeoJsonGeomertry | undefined;
    remove(): void;
    /** 每当鼠标悬停在这些图层上时，将地图的光标设置为“指针”。
     @returns A function to remove the handler.
     * @param layerOrLayers
     */
    hoverPointer(): void;
    /**
     每当将鼠标悬停在这些图层中的某个特征上时，更新连接源 [s] 中特征的特征状态。
     * @param enterCb
     * @param leaveCb
     */
    hoverFeatureState(enterCb?: (arg0: {}) => void, leaveCb?: (arg0: {}) => void): void;
    /** 将鼠标悬停在这些图层中的某个要素上时，会显示一个弹出窗口。
     @param htmlFunc Function that receives feature and popup, returns HTML.
     @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
     @example hoverPopup(f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { anchor: 'left' });
     */
    hoverPopup(htmlFunc: any, popupOptions?: PopupOptions): any;
    /** 每当单击这些图层中的要素时都会显示一个弹出窗口。
     @param htmlFunc Function that receives feature and popup, returns HTML.
     @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.

     @returns A function that removes the handler.
     @example clickPopup(f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { maxWidth: 500 });

     */
    clickPopup(htmlFunc: (arg0: {}) => void, popupOptions?: PopupOptions): any;
    /** 每当单击这些图层中的要素时都会触发回调。
     @param {function} cb Callback that receives event with .features property
     @returns A function that removes the handler.
     */
    clickLayer(cb: any): any;
    /** 当鼠标悬停在这些图层中的要素上时触发回调。
     @returns A function to remove the handler.
     */
    hoverLayer(cb: any): any;
    /**
     * 使给定的图层可见。
     * @param layer
     */
    show(): void;
    /**
     * 使给定的图层不可见。
     * @param layer
     */
    hide(): void;
    /** 根据参数使给定的图层隐藏或可见。
     @param {boolean} state True for visible, false for hidden.
     */
    toggle(state: boolean): boolean;
    /** 在一个或多个图层上设置绘制或布局属性。
     @example setProperty('fillOpacity', 0.5)
     */
    setProperty(prop: string | object, value?: any): void;
    /** 根据样式规范，获取给定图层 ID 的图层定义。
     */
    getLayerStyle(): LayerSpecification;
    /**
     * 设置图层样式
     * @param layer
     * @param style
     */
    setLayerStyle(style: any): void;
    /** 替换一个图层的过滤器。
     @param {Array} filter New filter to set.
     @example setFilter(['==','level','0']]);
     */
    setFilter(filter: FilterSpecification): void;
}

export  interface OverlayLayerBaseOptions {
    sourceId?: string;
    sourceLayer?: string;
    layerId?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: any;
    visibility?: "visible" | "none";
    isHoverPointer?: boolean;
    isHoverFeatureState?: boolean;
}

export  interface PhysicsSpringOptions {
    velocity?: number;
    stiffness?: number;
    damping?: number;
    mass?: number;
}

/**
 * Pick `props` from `object.
 *
 * Runtime version of `Pick<T,K>`.
 */
export  function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K>;

export  const pipe: (...transformers: Function[]) => Function;

/**
 * 不同级别下根据米数来求像素值
 * @param meters 米
 * @param zoomLevel 级别从0表示
 * @param latitude 纬度
 * @return {number}
 */
export  function pixelValue(meters: number, zoomLevel: number, latitude?: number): number;

export  interface PlaybackControls {
    stop: () => void;
}

/**
 * Playback options common to all animations.
 */
export  interface PlaybackOptions<V> {
    /**
     * Whether to autoplay the animation when animate is called. If
     * set to false, the animation must be started manually via the returned
     * play method.
     */
    autoplay?: boolean;
    driver?: Driver;
    elapsed?: number;
    from?: V;
    repeat?: number;
    repeatType?: "loop" | "reverse" | "mirror";
    repeatDelay?: number;
    type?: "spring" | "decay" | "keyframes";
    onUpdate?: (latest: V) => void;
    onPlay?: () => void;
    onComplete?: () => void;
    onRepeat?: () => void;
    onStop?: () => void;
}

 type Point23D = Point2D | Point3D;

 interface Point2D {
    x: number;
    y: number;
}

 type Point3D = Point2D & {
    z: number;
};

export  const pointFromVector: (origin: Point2D, angle: number, distance: number) => {
    x: number;
    y: number;
};

export  interface PointGeoJsonInput {
    point: GeoPointLike;
    properties?: object;
}

/**
 * 点到线段的距离
 * @param p
 * @param p1
 * @param p2
 * @return {number}
 */
export  function pointToSegmentDistance(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): number;

/**
 * 2d折线类型接口
 */
export  enum Poly2dType {
    k2dSimplePoly = 0,
    k2dFitCurvePoly = 1,
    k2dQuadSplinePoly = 2,
    k2dCubicSplinePoly = 3
}

/**
 * 3d折线类型接口
 */
export  enum Poly3dType {
    k3dSimplePoly = 0,
    k3dQuadSplinePoly = 1,
    k3dCubicSplinePoly = 2
}

/**
 * 创建多边形.
 *
 **/
export  class Polygon extends OverlayLayerBase {
    options: PolygonOptions;
    constructor(options: PolygonOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    /** 为一层或多层设置`fill-sort-key`布局属性。 */
    setFillSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    /** 为一个或多个图层设置`fill-antialias` 绘制属性。 */
    setFillAntialias(value: PropertyValueSpecificationEx<boolean>): this;
    /** 为一个或多个图层设置`fill-opacity` 绘画属性。 */
    setFillOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    /** 为一个或多个图层设置`fill-color` 绘画属性。 */
    setFillColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    /** 为一个或多个图层设置`fill-outline-color` 绘画属性。*/
    setFillOutlineColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    /** 为一个或多个图层设置`fill-translate` 绘制属性。 */
    setFillTranslate(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    /** 为一个或多个图层设置`fill-translate-anchor` 绘制属性。 */
    setFillTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    /** 为一个或多个图层设置`fill-pattern` 绘制属性。 */
    setFillPattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    /** 获取图层的`fill-sort-key` 布局属性. */
    getFillSortKey(): DataDrivenPropertyValueSpecification<number>;
    /** 获取图层的“填充抗锯齿”绘制属性。 */
    getFillAntialias(): PropertyValueSpecificationEx<boolean>;
    /** 获取图层的 `fill-opacity` 绘制属性。 */
    getFillOpacity(): DataDrivenPropertyValueSpecification<number>;
    /** 获取图层的 `fill-color` 绘制属性。 */
    getFillColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    /** 获取图层的 `fill-outline-color` 绘制属性。 */
    getFillOutlineColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    /** 获取图层的 `fill-translate` 绘制属性。 */
    getFillTranslate(): PropertyValueSpecificationEx<[number, number]>;
    /** 获取图层的 `fill-translate-anchor` 绘制属性。 */
    getFillTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    /** 获取图层的`fill-pattern` 绘制属性。 */
    getFillPattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
}

/**
 * Polygon Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 */
 interface Polygon_2 extends GeometryObject {
    type: "Polygon";
    coordinates: Position[][];
}

/**
 * 根据 [x,y] 坐标列表计算多边形的质心。
 * @return {GeoPoint}
 * @param vertices 顶点坐标
 */
export  function polygonCentroid(vertices: GeoPoint[]): GeoPoint;

/**
 * 根据格林公式判断多边形是否为顺时针
 *
 * @returns {boolean} false:逆时针
 * @param points
 */
export  function polygonIsClockwise(points: GeoPoint[]): boolean;

export  interface PolygonOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    fillSortKey?: DataDrivenPropertyValueSpecification<number>;
    fillAntialias?: PropertyValueSpecificationEx<boolean>;
    fillOpacity?: DataDrivenPropertyValueSpecification<number>;
    fillColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillOutlineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
}

/**
 * 创建多段线.
 *
 **/
export  class Polyline extends OverlayLayerBase {
    options: PolylineOptions;
    constructor(options: PolylineOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setLineCap(value: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">): this;
    getLineCap(): DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    setLineJoin(value: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">): this;
    getLineJoin(): DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    setLineMiterMimit(value: PropertyValueSpecificationEx<number>): this;
    getLineMiterMimit(): PropertyValueSpecificationEx<number>;
    setLineRoundLimit(value: PropertyValueSpecificationEx<number>): this;
    getLineRoundLimit(): PropertyValueSpecificationEx<number>;
    setLineSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineSortKey(): DataDrivenPropertyValueSpecification<number>;
    setLineOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineOpacity(): DataDrivenPropertyValueSpecification<number>;
    setLineColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getLineColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setLineTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getLineTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setLineTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getLineTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setLineWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineWidth(): DataDrivenPropertyValueSpecification<number>;
    setLineGapWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineGapWidth(): DataDrivenPropertyValueSpecification<number>;
    setLineOffset(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineOffset(): DataDrivenPropertyValueSpecification<number>;
    setLineBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineBlur(): DataDrivenPropertyValueSpecification<number>;
    setLineDasharray(value: DataDrivenPropertyValueSpecification<number[]>): this;
    getLineDasharray(): DataDrivenPropertyValueSpecification<number[]>;
    setLinePattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getLinePattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setLineGradient(value: ExpressionSpecificationEx): this;
    getLineGradient(): ExpressionSpecificationEx;
}

/**
 * 创建箭头多段线.
 *
 **/
export  class PolylineArrow {
    options: PolylineArrowOptions;
    id: string;
    animateFun: Function | null;
    animatedPointIdx: number;
    geojson: any;
    type: string;
    lineArrowImageName: string;
    borderGeoJson: any;
    lineGeojson: any;
    strokeImageName: string | undefined;
    private _layers;
    private _map;
    private readonly _timeout;
    private readonly _interval;
    private _mapStyleCursor;
    constructor(options: PolylineArrowOptions);
    init(): void;
    createGeojson(): void;
    _createLineGeojson(): void;
    _createBorderLine(): void;
    _creatDirLine(): void;
    getLength(): number;
    getBounds(): GeoBounds;
    getId(): string;
    remove(): void;
    _addStrokeImage(): void;
    setStrokeImage(strokeImage: string): void;
    addTo(map: Map, beforeId?: string): void;
    _addShowDirFun(): void;
    _addLayer(): void;
    setCursor(cursor?: string): void;
    _mouseenterCallbackFun(): void;
    _mouseleaveCallbackFun(): void;
    setPath(val: GeoPointLike[]): void;
    getPath(): any;
    /**
     * 开启动画
     * @param step 把线段分成多少段
     * @param fps 每一秒跑多少段
     * @param isLoop 是否循环
     * @param stopCallBack 结束回调
     * @param onFrameCallBack 每一帧的回调
     * @return {FrameAnimation}
     */
    animate(step?: number, fps?: number, isLoop?: boolean, stopCallBack?: (status: FrameAnimationStatus) => void, onFrameCallBack?: (status: FrameAnimationStatus, context: any) => void): FrameAnimation;
    on(type: any, listener: EventedListener): void;
    once(type: any, listener: EventedListener): void;
    off(type: any, listener: EventedListener): void;
    setOptions(options: PolylineArrowOptions): void;
    _updateLineStyle(options: any): void;
    getOptions(): PolylineArrowOptions;
    setColor(color: any): void;
    setOpacity(val: any): void;
    setWeight(val: any): void;
    setBorderColor(value: any): void;
    setBorderOpacity(val: any): void;
    setBorderWidth(weight: any): void;
    show(): void;
    hide(): void;
    addDir(): void;
    removeDir(): void;
    hideDir(): void;
    showDir(): void;
}

export  interface PolylineArrowOptions {
    minZoom?: number;
    maxZoom?: number;
    borderGapWidth?: number;
    lineGapWidth?: number;
    borderBlur?: number;
    lineBlur?: number;
    borderGradient?: string;
    lineGradient?: string;
    borderOffset?: number;
    lineOffset?: number;
    borderTranslateAnchor?: string;
    lineTranslateAnchor?: string;
    borderMiterLimit?: number;
    lineMiterLimit?: number;
    lineSortKey?: number;
    showDir?: boolean;
    lineCap?: string;
    lineColor?: string;
    lineWidth?: number;
    strokeDasharray?: number[];
    strokeImage?: string;
    lineJoin?: string;
    lineOpacity?: number;
    lineTranslate?: number[];
    showBorder?: boolean;
    borderWidth?: number;
    borderOpacity?: number;
    borderColor?: string;
    visible?: boolean;
    strokeStyle?: string;
    animated?: boolean;
    dirSize?: number;
    dirLayout?: object;
    dirIconColor?: string;
    dirSpacing?: number;
    beforeId?: string;
    cursor?: string;
    zIndex?: number;
    dirImageSrc?: string;
    dirImageWidth?: number;
    dirImageHeight?: number;
    dirImageColor?: string;
    map?: Map;
    path?: GeoPointLike[] | any;
}

/**
 * 把多段线往外扩展成多边形
 * @param pts
 * @param options
 */
export  function polylineMarginToPolygon(pts: GeoPointLike[], options: {
    smoothFactor?: number;
    offset: number;
    arcSegments?: number;
}): any;

export  interface PolylineOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    lineCap?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    lineJoin?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    lineMiterMimit?: PropertyValueSpecificationEx<number>;
    lineRoundLimit?: PropertyValueSpecificationEx<number>;
    lineSortKey?: DataDrivenPropertyValueSpecification<number>;
    lineOpacity?: DataDrivenPropertyValueSpecification<number>;
    lineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    lineTranslate?: PropertyValueSpecificationEx<[number, number]>;
    lineTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    lineWidth?: DataDrivenPropertyValueSpecification<number>;
    lineGapWidth?: DataDrivenPropertyValueSpecification<number>;
    lineOffset?: DataDrivenPropertyValueSpecification<number>;
    lineBlur?: DataDrivenPropertyValueSpecification<number>;
    lineDasharray?: DataDrivenPropertyValueSpecification<number[]>;
    linePattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    lineGradient?: ExpressionSpecificationEx;
}

/**
 * @description 将折线转换为贝塞尔曲线
 * @param {CurvePoint[]} polyline 组成折线的一组点
 * @param {boolean} close    闭合曲线
 * @param {number} offsetA   光滑程度A
 * @param {number} offsetB   光滑程度B
 * @return {BezierCurve} 一组贝塞尔曲线（无效输入将返回false）
 */
export  function polylineToBezierCurve(polyline: CurvePoint[], close?: boolean, offsetA?: number, offsetB?: number): BezierCurve;

/**
 * Position
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.1
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
 type Position = [number, number] | [number, number, number];

export  const progress: (from: number, to: number, value: number) => number;

/**
 * `GeoPoint` 地理坐标.
 */
export  abstract class Projection {
    /** The equatorial semi perimeter in meters. */
    static EQUATORIAL_SEMIPERIMETER: number;
    /** The equatorial semi perimeter in meters. */
    static EARTH_BOUNDS: [number, number, number, number];
    /**
     * 经纬度转墨卡托 .
     */
    static lngLat2Mercator(input: GeoPointLike): [number, number];
    /**
     * 墨卡托转经纬度 .
     */
    static mercator2LngLat(input: GeoPointLike): [number, number];
    /**
     * 坐标转墨卡托(epsg:3857)
     * @param input 坐标点
     * @return {[number, number]}
     */
    abstract toMercator(input: GeoPointLike): [number, number];
    /**
     * 墨卡托(epsg:3857)转坐标
     * @param input 墨卡托坐标点
     * @return {[number, number]}
     */
    abstract fromMercator(input: GeoPointLike): [number, number];
    /**
     * 地图地理坐标转经纬度
     * @param input 地理坐标点
     * @return {[number, number]}
     */
    abstract toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 经纬度转地图地理坐标
     * @param input 经纬度坐标点
     * @return {GeoPoint}
     */
    abstract fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 得到地图范围
     * @return {GeoBounds}
     */
    abstract getMapExtent(): GeoBounds;
    /**
     * 把距离转化为米
     * @param dist
     */
    abstract toMeter(dist: number): number;
    /**
     * 把米转化为距离
     * @param meter
     */
    abstract fromMeter(meter: number): number;
}

export  type PromoteIdSpecificationEx = Record<string, string> | string;

/**
 * Properties
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * A Feature object has a member with the name 'properties'.
 * The value of the properties member is an object (any JSON object or a JSON null value).
 */
 type Properties = {
    [name: string]: any;
} | null;

export  type PropertyValueSpecificationEx<T> = T | CameraFunctionSpecificationEx<T> | ExpressionSpecificationEx;

export  type PropName = string;

export  type PropValue = string | any[] | null | number | {};

export  namespace quat {
    export type valueType = quattype;
    /**
     * Creates a new identity quat
     *
     * @returns {quat} a new quaternion
     */
    export function create(): quattype;
    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.
     *
     * Both vectors are assumed to be unit length.
     *
     * @param {quat} out the receiving quaternion.
     * @param {vec3} a the initial vector
     * @param {vec3} b the destination vector
     * @returns {quat} out
     */
    export function rotationTo(out: quattype, a: vec3type, b: vec3type): quattype;
    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
     * perpendicular to all other specified axes.
     *
     * @param {vec3} view  the vector representing the viewing direction
     * @param {vec3} right the vector representing the local "right" direction
     * @param {vec3} up    the vector representing the local "up" direction
     * @returns {quat} out
     */
    export function setAxes(out: quattype, view: vec3type, right: vec3type, up: vec3type): quattype;
    /**
     * Creates a new quat initialized with values from an existing quaternion
     *
     * @param {quat} a quaternion to clone
     * @returns {quat} a new quaternion
     * @function
     */
    const clone: typeof vec4.clone;
    /**
     * Creates a new quat initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} a new quaternion
     * @function
     */
    const fromValues: typeof vec4.fromValues;
    /**
     * Copy the values from one quat to another
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the source quaternion
     * @returns {quat} out
     * @function
     */
    const copy: typeof vec4.copy;
    /**
     * Set the components of a quat to the given values
     *
     * @param {quat} out the receiving quaternion
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} out
     * @function
     */
    const set: typeof vec4.set;
    /**
     * Set a quat to the identity quaternion
     *
     * @param {quat} out the receiving quaternion
     * @returns {quat} out
     */
    export function identity(out: quattype): quattype;
    /**
     * Sets a quat from the given angle and rotation axis,
     * then returns it.
     *
     * @param {quat} out the receiving quaternion
     * @param {vec3} axis the axis around which to rotate
     * @param {Number} rad the angle in radians
     * @returns {quat} out
     */
    export function setAxisAngle(out: quattype, axis: vec3type, rad: number): quattype;
    /**
     * Gets the rotation axis and angle for a given
     *  quaternion. If a quaternion is created with
     *  setAxisAngle, this method will return the same
     *  values as providied in the original parameter list
     *  OR functionally equivalent values.
     * Example: The quaternion formed by axis [0, 0, 1] and
     *  angle -90 is the same as the quaternion formed by
     *  [0, 0, 1] and 270. This method favors the latter.
     * @param  {vec3} outAxis  Vector receiving the axis of rotation
     * @param  {quat} q     Quaternion to be decomposed
     * @return {Number}     Angle, in radians, of the rotation
     */
    export function getAxisAngle(outAxis: vec3type, q: quattype): number;
    /**
     * Adds two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     * @function
     */
    const add: typeof vec4.add;
    /**
     * Multiplies two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     */
    export function multiply(out: quattype, a: quattype, b: quattype): quattype;
    /**
     * Alias for {@link quat.multiply}
     * @function
     */
    /**
     * Scales a quat by a scalar number
     *
     * @param {quat} out the receiving vector
     * @param {quat} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {quat} out
     * @function
     */
    const scale: typeof vec4.scale;
    /**
     * Rotates a quaternion by the given angle about the X axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateX(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Rotates a quaternion by the given angle about the Y axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateY(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Rotates a quaternion by the given angle about the Z axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateZ(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Calculates the W component of a quat from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate W component of
     * @returns {quat} out
     */
    export function calculateW(out: quattype, a: quattype): quattype;
    /**
     * Calculates the dot product of two quat's
     *
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {Number} dot product of a and b
     * @function
     */
    const dot: typeof vec4.dot;
    /**
     * Performs a linear interpolation between two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     * @function
     */
    const lerp: typeof vec4.lerp;
    /**
     * Performs a spherical linear interpolation between two quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     */
    export function slerp(out: quattype, a: quattype, b: quattype, t: number): quattype;
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {quat} c the third operand
     * @param {quat} d the fourth operand
     * @param {Number} t interpolation amount
     * @returns {quat} out
     */
    export function sqlerp(out: quattype, a: quattype, b: quattype, c: quattype, d: quattype, t: number): quattype;
    /**
     * Calculates the inverse of a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate inverse of
     * @returns {quat} out
     */
    export function invert(out: quattype, a: quattype): quattype;
    /**
     * Calculates the conjugate of a quat
     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate conjugate of
     * @returns {quat} out
     */
    export function conjugate(out: quattype, a: quattype): quattype;
    /**
     * Calculates the length of a quat
     *
     * @param {quat} a vector to calculate length of
     * @returns {Number} length of a
     * @function
     */
    const length: typeof vec4.length;
    /**
     * Alias for {@link quat.length}
     * @function
     */
    /**
     * Calculates the squared length of a quat
     *
     * @param {quat} a vector to calculate squared length of
     * @returns {Number} squared length of a
     * @function
     */
    const squaredLength: typeof vec4.squaredLength;
    /**
     * Alias for {@link quat.squaredLength}
     * @function
     */
    /**
     * Normalize a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quaternion to normalize
     * @returns {quat} out
     * @function
     */
    const normalize: typeof vec4.normalize;
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     *
     * NOTE: The resultant quaternion is not normalized, so you should be sure
     * to renormalize the quaternion yourself where necessary.
     *
     * @param {quat} out the receiving quaternion
     * @param {mat3} m rotation matrix
     * @returns {quat} out
     * @function
     */
    export function fromMat3(out: quattype, m: mat3type): quattype;
    /**
     * Returns a string representation of a quatenion
     *
     * @param {quat} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: quattype): string;
    /**
     * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
     *
     * @param {quat} a The first quaternion.
     * @param {quat} b The second quaternion.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    const exactEquals: typeof vec4.exactEquals;
    /**
     * Returns whether or not the quaternions have approximately the same elements in the same position.
     *
     * @param {quat} a The first vector.
     * @param {quat} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    const equals: typeof vec4.equals;
}

export  type quattype = [number, number, number, number] | Float32Array;

export  const radiansToDegrees: (radians: number) => number;

/**
 * 弧度转角度
 * @param a
 */
export  function radToDeg(a: number): number;

/**
 * 生成一个区间的随机总数
 * @param n
 * @param m
 * @return {number}
 */
export  function randInt(n: number, m: number): number;

/**
 * 生成随机颜色
 * @return {string}
 */
export  function randomColor(): string;

/**
 * 生成随机ID
 * @param length
 * @return {string}
 */
export  function RandomID(length?: number): string;

export  type RasterDEMSourceSpecification = {
    type: "raster-dem";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    minzoom?: number;
    maxzoom?: number;
    tileSize?: number;
    attribution?: string;
    encoding?: "terrarium";
    volatile?: boolean;
};

export  enum RasterImageUnits {
    /** No measurement units are used. */
    kNone = 0,
    /** Millimeters are used. */
    kMillimeter = 1,
    /** Centimeters are used. */
    kCentimeter = 2,
    /** Meters are used. */
    kMeter = 3,
    /** Kilometers are used. */
    kKilometer = 4,
    /** Inches are used. */
    kInch = 5,
    /** Foots are used. */
    kFoot = 6,
    /** Yards are used. */
    kYard = 7,
    /** Miles are used. */
    kMile = 8,
    /** Microinches are used. */
    kMicroinches = 9,
    /** Mils (thousandths of an inch) are used. */
    kMils = 10,
    /** Angstroms (10^-10 of a meter or ten-billionths of a meter) are used. */
    kAngstroms = 11,
    /** Nanometers are used. */
    kNanometers = 12,
    /** Microns are used. */
    kMicrons = 13,
    /** Decimeters are used. */
    kDecimeters = 14,
    /** Dekameters (10 meters) are used. */
    kDekameters = 15,
    /** Hectometers (10^2 meters) are used. */
    kHectometers = 16,
    /** Gigameters (10^9 meters) are used. */
    kGigameters = 17,
    /** Astronominal units (149597870700 meters) are used. */
    kAstronomical = 18,
    /** Light years (9460730472580800 meters) are used. */
    kLightYears = 19,
    /** Parsecs (approx 3.261563777 light years) are used. */
    kParsecs = 20
}

export  type RasterLayerSpecification = {
    id: string;
    type: "raster";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "raster-opacity"?: PropertyValueSpecificationEx<number>;
        "raster-hue-rotate"?: PropertyValueSpecificationEx<number>;
        "raster-brightness-min"?: PropertyValueSpecificationEx<number>;
        "raster-brightness-max"?: PropertyValueSpecificationEx<number>;
        "raster-saturation"?: PropertyValueSpecificationEx<number>;
        "raster-contrast"?: PropertyValueSpecificationEx<number>;
        "raster-resampling"?: PropertyValueSpecificationEx<"linear" | "nearest">;
        "raster-fade-duration"?: PropertyValueSpecificationEx<number>;
    };
};

export  type RasterLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    rasterOpacity?: PropertyValueSpecificationEx<number>;
    rasterHueRotate?: PropertyValueSpecificationEx<number>;
    rasterBrightnessMin?: PropertyValueSpecificationEx<number>;
    rasterBrightnessMax?: PropertyValueSpecificationEx<number>;
    rasterSaturation?: PropertyValueSpecificationEx<number>;
    rasterContrast?: PropertyValueSpecificationEx<number>;
    rasterResampling?: PropertyValueSpecificationEx<"linear" | "nearest">;
    rasterFadeDuration?: PropertyValueSpecificationEx<number>;
};

export  type RasterSourceSpecification = {
    type: "raster";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    minzoom?: number;
    maxzoom?: number;
    tileSize?: number;
    scheme?: "xyz" | "tms";
    attribution?: string;
    volatile?: boolean;
};

export  abstract class ReglBaseLayer extends Evented implements CustomLayerInterface {
    id: string;
    type: 'custom';
    map: Map;
    regl: any;
    renderAnimation?: boolean;
    protected abstract getReglInitialization(gl: WebGLRenderingContext): any;
    protected abstract init(map: Map, gl: WebGLRenderingContext): void;
    protected abstract frame(gl: WebGLRenderingContext, matrix: Array<number>, context?: any): void;
    protected abstract remove(map: Map, gl: WebGLRenderingContext): void;
    triggerRepaint(): void;
    onAdd(map: Map, gl: WebGLRenderingContext): void;
    onRemove(map: Map, gl: WebGLRenderingContext): void;
    /**
     * NOTE: map won't call it every frame.
     *
     * @param gl
     * @param matrix
     */
    render(gl: WebGLRenderingContext, matrix: Array<number>): void;
    prerender(gl: WebGLRenderingContext, matrix: Array<number>): void;
}

export  type ResolvedImageSpecification = string;

 interface Response_2 {
    status: number;
    response: Record<string, unknown>;
    data?: string | Record<string, unknown>;
    xhr: XMLHttpRequest;
}
export { Response_2 as Response }

export  const reverseEasing: EasingModifier;

/**
 * 旋转的光环.
 */
export  class RotatingApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _createMakerElement;
    private _getDotsStyleObj;
}

/**
 * 旋转的文本框.
 */
export  class RotatingTextBorderMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number): void;
    setMarkersHeight(height: number): void;
    setMarkersTextField(textField: string, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    _setMarkerContainerProperty(properties: any, index?: number): void;
}

/**
 * L7图层，可参考https://l7.antv.vision/.
 * 返回一个场景对象
 * @param L7 L7命名空间
 * @param map
 * @param option
 * @return {(L7: any, map: Map, option?: object) => any}
 **/
export  function Scene(L7: any, map: Map, option?: object): {
    getServiceContainer(): any;
    getSize(): [number, number];
    getMinZoom(): number;
    getMaxZoom(): number;
    getType(): string;
    getMapContainer(): HTMLElement | null;
    getMapCanvasContainer(): HTMLElement;
    getMapService(): any;
    exportPng(type?: 'png' | 'jpg'): string;
    exportMap(type?: 'png' | 'jpg'): string;
    registerRenderService(render: any): void;
    setBgColor(color: string): void;
    addLayer(layer: any): void;
    getLayers(): any[];
    getLayer(id: string): any | undefined;
    getLayerByName(name: string): any | undefined;
    removeLayer(layer: any, parentLayer?: any): void;
    removeAllLayer(): void;
    render(): void;
    setEnableRender(flag: boolean): void;
    /**
     * 为 layer/point/text 支持 iconfont 模式支持
     * @param fontUnicode
     * @param name
     */
    addIconFont(name: string, fontUnicode: string): void;
    addIconFonts(options: string[][]): void;
    /**
     * 用户自定义添加第三方字体
     * @param fontFamily
     * @param fontPath
     */
    addFontFace(fontFamily: string, fontPath: string): void;
    addImage(id: string, img: any): void;
    hasImage(id: string): boolean;
    removeImage(id: string): void;
    addIconFontGlyphs(fontFamily: string, glyphs: any[]): void;
    addControl(ctr: any): void;
    removeControl(ctr: any): void;
    getControlByName(name: string): any | undefined;
    addMarker(marker: any): void;
    addMarkerLayer(layer: any): void;
    removeMarkerLayer(layer: any): void;
    removeAllMakers(): void;
    addPopup(popup: any): void;
    on(type: string, handle: (...args: any[]) => void): void;
    once(type: string, handle: (...args: any[]) => void): void;
    off(type: string, handle: (...args: any[]) => void): void;
    getZoom(): number;
    getCenter(options?: any): any;
    setCenter(center: [number, number], options?: any): void;
    getPitch(): number;
    setPitch(pitch: number): void;
    getRotation(): number;
    getBounds(): any;
    setRotation(rotation: number): void;
    zoomIn(): void;
    zoomOut(): void;
    panTo(p: any): void;
    panBy(x: number, y: number): void;
    getContainer(): HTMLElement | null;
    setZoom(zoom: number): void;
    fitBounds(bound: any, options?: unknown): void;
    setZoomAndCenter(zoom: number, center: any): void;
    setMapStyle(style: any): void;
    setMapStatus(options: Partial<any>): void;
    pixelToLngLat(pixel: any): any;
    lngLatToPixel(lnglat: any): any;
    containerToLngLat(pixel: any): any;
    lngLatToContainer(lnglat: any): any;
    destroy(): void;
    registerPostProcessingPass(constructor: new (...args: any[]) => any, name: string): void;
    enableShaderPick(): void;
    diasbleShaderPick(): void;
    getPointSizeRange(): Float32Array;
};

export  interface ScriptDefaultOptions {
    src: string;
    strategy?: string;
    injectLocation?: string;
    async?: boolean;
}

/**
 * 线段相交
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param x3
 * @param y3
 * @param x4
 * @param y4
 * @return {{result: string, status: boolean} | {result: string, status: boolean} | {x: number, y: number, status: boolean, ratio: number} | {result: string, status: boolean}}
 */
export  function segmentIntersect(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): {
    result: string;
    status: boolean;
    x?: undefined;
    y?: undefined;
    ratio?: undefined;
} | {
    status: boolean;
    x: number;
    y: number;
    ratio: number;
    result?: undefined;
};

 interface Serialized {
    nodes: Array<{
        id: NodeId;
    }>;
    links: Array<{
        source: NodeId;
        target: NodeId;
        weight: EdgeWeight;
    }>;
}

/**
 * `Service` 服务类.
 *
 */
export  class Service {
    /**
     * 服务器地址
     * @type {string}
     */
    serverUrl: string;
    /**
     * 访问凭证
     * @type {string}
     */
    accessToken: string;
    private readonly _reqImpl;
    private _cur_map_param;
    private _svr_url_map;
    private readonly _svr_url_service;
    private _secretKeys?;
    private _accessKeys?;
    private _workspaceName?;
    /**
     * 构造函数
     * @param url 服务地址
     * @param token 访问凭证
     * @param req 请求的方法实现（默认内部实现)
     */
    constructor(url: string, token?: string, req?: IRequest);
    private _url;
    /**
     * 克隆一个新的服务实例对象
     * @param isCloneWorkspace 是否克隆当前工作区 (默认是)
     * @return Service
     */
    clone(isCloneWorkspace?: boolean): Service;
    /**
     * 得到服务地址
     * @param u 要拼接的地址
     * @return string
     */
    serviceUrl(u: string): string;
    /**
     * 切换至工作区
     * @param workspaceName 工作区名称
     * @return
     */
    switchWorkspace(workspaceName: string): void;
    /**
     * 获取当前的工作区名称
     * @return
     */
    getCurWorkspaceName(): string;
    /**
     * 获取所有工作区(如果不是root权限的token获取非公开的工作区名称将返回空)
     * @return
     */
    getWorkspaces(): Promise<any>;
    /**
     * 创建工作区(默认需要root权限)
     * @param workspace 工作区设置
     * @return
     */
    workspaceCreate(workspace: IWorkspace): Promise<any>;
    /**
     * 修改工作区(默认需要root权限)
     * @param workspace 工作区
     * @return
     */
    workspaceModify(workspace: IWorkspace): Promise<any>;
    /**
     * 删除工作区（会同时删除工作区下面的所有目录文件）(默认需要root权限)
     * @param name 要删除的工作区名称
     * @return
     */
    workspaceDelete(name: string): Promise<any>;
    /**
     * 密码转换为秘钥
     * @param pwd 密码
     */
    pwdToSecretKey(pwd: string): string;
    /**
     * 增加秘钥key
     * @param key key值
     */
    addSecretKey(key: string): Set<string>;
    /**
     * 移除秘钥key, 如果key为undefined时，则移除所有的
     * @param key key值
     */
    removeSecretKey(key: string): Set<string> | undefined;
    /**
     * 增加访问key
     * @param key key值
     */
    addAccessKey(key: string): Set<string>;
    /**
     * 移除访问key, 如果key为undefined时，则移除所有的
     * @param key key值
     */
    removeAccessKey(key: string): void;
    private _to_layer_string;
    private _addTokenHeader;
    private _get;
    private _post;
    private _del;
    /**
     * 把图层名称数组转成图层索引数组
     * @param layernames 图层名称数组
     * @param layers 图层列表
     * @return {number[]}
     */
    toLayerIndex(layernames: string[], layers: any[]): number[];
    private _waitOpenMap;
    /**
     * 设置打开地图参数
     */
    setCurrentMapParam(param: IOpenMapResponse): IOpenMapResponse | null;
    /**
     * 当前地图参数
     */
    currentMapParam(): IOpenMapResponse | null;
    /**
     * 打开图
     * @param param
     * @param isWaitFinish 是否等待打开完成
     * @return {Promise<any>}
     */
    openMap(param: IOpenMapParam, isWaitFinish?: boolean): Promise<any>;
    /**
     * 更新地图
     * @param param
     * @param isWaitFinish 是否等待打开完成
     */
    updateMap(param: IUpdateMapParam, isWaitFinish?: boolean): Promise<any>;
    /**
     * 字体地址
     * @param param
     */
    glyphsUrl(): string;
    /**
     * 服务根地址
     */
    baseUrl(): string;
    /**
     * 精灵图片名称
     * @param name 精灵名称
     */
    spriteUrl(name: string): string;
    /**
     * 设置精灵图片名称
     * @param name 精灵名称
     */
    setSprite(name: string): string;
    /**
     * 空白瓦片地址
     */
    blankTileUrl(): string;
    /**
     * 二维码图片地址
     * @param content 生成二维码的内容
     * @param size 生成二维码的大小，默认256
     */
    qrcodeUrl(content: string, size?: number): string;
    /**
     * 栅格瓦片地址
     * @param param
     */
    rasterTileUrl(param?: ITileUrlParam): string;
    /**
     * 矢量瓦片地址
     * @param param
     */
    vectorTileUrl(param?: ITileUrlParam): string;
    /**
     * 检查文件是否上传过
     * @param filemd5 文件md5值
     */
    checkFileHasUpload(filemd5: string): Promise<any>;
    /**
     * 返回上传文件的url地址
     * @return {string}
     */
    uploadUrl(): string;
    /**
     * 获取字符串的Md5值
     * @param str
     * @return {string}
     */
    strMd5(str: string): string;
    /**
     * 得到style的版本号
     */
    styleVersion(): number;
    /**
     * 获取文件的Md5值
     * @param file
     * @return {Promise<any>}
     */
    fileMd5(file: File): Promise<any>;
    /**
     * 上传地图
     * @param file
     * @return {Promise<any>}
     */
    uploadMap(file: File): Promise<any>;
    /**
     * 执行命令
     * @return {string}
     */
    execCommand(cmdname: string, param?: Record<string, any>, mapid?: string, version?: string, useGet?: boolean): Promise<any>;
    /**
     * 获取地图元数据
     * @param mapid 地图ID ，为空, 则为当前打开的图形
     * @param version 版本号，为空 则为当前打开的版本;
     */
    metadata(mapid?: string, version?: string): Promise<any>;
    /**
     * 修改地图元数据
     * @param meta 要修改的元数据项
     * @param mapid 地图ID ，为空, 则为当前打开的图形
     * @param version 版本号，为空 则为当前打开的版本;
     */
    updateMetadata(meta: Record<string, number | boolean | string | undefined | null>, mapid?: string, version?: string): Promise<any>;
    /**
     * 获取所有地图信息
     * @param mapid 地图ID，为空，则获取所有的；如果传入的是地图ID数组，则获取指定的地图ID数组的信息。如果不想一次性获取，可通过传入分页对象获取，如{curPage: 1, pageCount: 10}
     * @param version 版本号，为空，则获取最新的; * 则获取所有的版本
     */
    listMaps(mapid?: string | string[] | {
        curPage: number;
        pageCount: number;
        mapIds?: string[];
    }, version?: string): Promise<any>;
    /**
     * 等待地图打开完成
     * @param mapid 地图ID
     * @param version 地图版本号
     * @param tryTime 每次尝试时间间隔(秒)
     * @param maxTryTimes 最大尝试次数
     * @return {Promise<void>}
     */
    waitMapOpenFinish(mapid: string, version: string, tryTime?: number, maxTryTimes?: number): Promise<any>;
    /**
     * 处理查询结果
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     */
    processQueryResult(param: any, cb?: (point: [number, number]) => [number, number] | null | undefined): any;
    /**
     * 处理查询结果
     * @private
     */
    private _processQueryResult;
    /**
     * 点查询实体
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     */
    pointQueryFeature(param: IPointQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 矩形查询实体
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     */
    rectQueryFeature(param: IRectQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 表达式查询实体
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     */
    exprQueryFeature(param: IExprQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 条件查询实体
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     */
    conditionQueryFeature(param: IConditionQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 得到地图图层集合，调用前请确保地图已打开，否则会抛异常
     */
    getMapLayers(): IMapLayer[];
    /**
     * 切换图层
     * @param visibleLayers 让可见的图层列表数组
     * @return {Promise<void>}
     */
    cmdSwitchLayers(visibleLayers: string[]): Promise<any>;
    /**
     * 更新样式
     * @param param 样式参数
     * @return {Promise<any>}
     *
     *
     * Example:
     * ```typescript
     * const res = svc.cmdUpdateStyle({
     *     name: "style1",
     *     layeron: [0,1,2,4,5,6,7,8,9],
     *     layeroff: "",
     *     clipbounds: "",
     *     backcolor: 0,
     *     lineweight:[1,1,0]
     *     expression: "gOutColorRed := gInColorGreen;gOutColorGreen := gInColorBlue;gOutColorBlue := gInColorRed;gOutColorAlpha := gInColorAlpha;"
     * });
     * ```
     */
    cmdUpdateStyle(param: IUpdateStyle): Promise<any>;
    /**
     * 对图层进行切片缓存
     * @param param
     * @return {Promise<any>}
     */
    cmdSliceLayer(param: ISliceLayer): Promise<any>;
    /**
     * 获取样式图层名
     * @param style 样式参数
     * @param mapid 地图ID
     * @param version 版本号，为空，则获取最新的;
     * @param isGeomLayer 几何渲染图层优先(默认true)
     * @return {Promise<any>}
     */
    createStyle(style: IMapStyleParam, mapid?: string, version?: string, isGeomLayer?: boolean): Promise<any>;
    /**
     * 获取已缓存的切片级别
     * @param param 参数
     * @return {Promise<any>}
     */
    getSliceCacheZoom(param: ISliceCacheZoom): Promise<any>;
    /**
     * 获取图形中有数据的范围区域
     * @param mapid 地图id
     * @param version 版本号
     * @return {Promise<any>}
     */
    cmdGetDrawBounds(mapid?: string, version?: string): Promise<GeoBounds | null>;
    /**
     * 获取样式图层名
     * @param mapid 地图ID
     * @param version 版本号，为空，则获取最新的;
     * @param isGeomLayer 几何渲染图层优先(默认true)
     * @param name 有名称时，根据名称来查找;
     * @return {Promise<any>}
     */
    getStyleLayerName(mapid: string, version?: string, isGeomLayer?: boolean, name?: string): Promise<any>;
    /**
     * 获取图的缩略图
     * @param mapid
     * @param version
     * @param width
     * @param height
     * @param darkTheme 是否是深色主题，是的话，图片将反色（黑色变白色）
     */
    thumbnailUrl(mapid?: string, version?: string, width?: number, height?: number, darkTheme?: boolean): string;
    wmsTileUrl(param: IWmsTileUrl): string;
    /**
     * 删除地图
     * @return {Promise<any>}
     * @param mapid 地图ID
     * @param version 版本号，如删除所有版本，输入"*"号
     * @param retainVersionMaxCount 删除所有版本时，保留的最新的版本总数。如总共有10个版本，retainVersionMaxCount为3时，会保存最新的3个版本，其余的都会删除
     */
    cmdDeleteMap(mapid: string, version: string, retainVersionMaxCount?: number): Promise<any>;
    /**
     * 获取地图的AccessKey，获取之前请确保已成功打开了地图
     * @param mapid 地图ID
     * @param key secretKey秘钥和超级管理员superKey
     * @return {Promise<any>}
     */
    cmdGetAccessKey(mapid: string, key: string): Promise<any>;
    /**
     * 重置地图的AccessKey，获取之前请确保已成功打开了地图
     * @param mapid 地图ID
     * @param key secretKey秘钥和超级管理员superKey
     * @return {Promise<any>}
     */
    cmdResetAccessKey(mapid: string, key: string): Promise<any>;
    /**
     * 重置地图的密码，如果之前有密码，则是修改密码。如果之前没有密码，则是把此地图设置了密码保护。如果设置密码为空，则取消对此地图的密码保护。
     * @param mapid 地图ID
     * @param key 旧的secretKey秘钥和超级管理员superKey
     * @param newKey 新的secretKey秘钥
     * @return {Promise<any>}
     */
    cmdSetMapPassword(mapid: string, key: string, newKey: string): Promise<any>;
    /**
     * 地图ID重命名
     * @return {Promise<any>}
     * @param oldMapID 旧地图ID
     * @param newMapID 新地图ID
     */
    cmdRenameMap(oldMapID: string, newMapID: string): Promise<any>;
    /**
     * 清空地图的几何和瓦片缓存数据
     * @return {Promise<any>}
     * @param mapid 地图ID
     * @param version 版本号
     */
    cmdClearMapCache(mapid: string, version: string): Promise<any>;
    /**
     * 清空地图的瓦片缓存数据
     * @return {Promise<any>}
     * @param mapid 地图ID
     * @param version 版本号
     */
    cmdClearTileCache(mapid: string, version: string): Promise<any>;
    /**
     * 删除地图样式
     * @return {Promise<any>}
     * @param param 样式接口
     */
    cmdDeleteStyle(param: IDeleteStyle): Promise<any>;
    /**
     * 删除地图缓存
     * @return {Promise<any>}
     * @param param 缓存接口
     */
    cmdDeleteCache(param: IDeleteCache): Promise<any>;
    /**
     * 获取当前运行状态
     * @return {Promise<any>}
     * @param bDetail 是否需要细节 (默认false)
     */
    cmdRunStatus(bDetail?: boolean): Promise<any>;
    /**
     * 获取支持的格式类型
     * @return {Promise<any>}
     */
    cmdGetSupportFormat(): Promise<any>;
    /**
     * 获取服务后台常量设置
     * @return {Promise<any>}
     */
    getConstData(): Promise<any>;
    /**
     * 空白栅格style
     * @param minzoom 最小级别，缺省0
     * @param maxzoom 最大级别，缺省24
     * @param prefix 前缀，缺省rasterBlank
     */
    rasterBlankStyle(minzoom?: number, maxzoom?: number, prefix?: string): Style;
    /**
     * 获取栅格图层ID
     * @param prefix
     * @return {string}
     */
    rasterLayerId(prefix?: string): string;
    /**
     * 获取栅格源ID
     * @param prefix
     * @return {string}
     */
    rasterSourceId(prefix?: string): string;
    /**
     * 栅格style
     * @param tileUrl 栅格瓦片地址
     * @param minzoom 最小级别，缺省0
     * @param maxzoom 最大级别，缺省24
     * @param prefix 前缀，缺省raster
     */
    rasterStyle(tileUrl?: string, minzoom?: number, maxzoom?: number, prefix?: string): Style;
    /**
     * 矢量style
     * @param tileUrl 矢量瓦片地址 或者为一个Object，为Object时，设置项为参数的每个项值，做为一个参数传入
     * @param minzoom 最小级别，缺省0
     * @param maxzoom 最大级别，缺省24
     * @param prefix 前缀，缺省vector
     * @param hoverColor 高亮时颜色，缺省rgba(0,0,255,255)
     * @param hoverOpacity 高亮时透明度,缺省0.5
     * @param hoverLineWidth 高亮时线宽,缺省3
     * @param customColorCaseExpr 自定义颜色表达式，必须为数组[条件1，值，条件2，值,...]，如[['==', ['feature-state', 'status'], 'alarm'], '#ff0000', ['==', ['feature-state', 'status'], 'normal'], '#00ff00'],缺省默认
     * @param customOpacityCaseExpr 自定义透明度表达式，必须为数组,缺省默认
     * @param customLineWidthCaseExpr 自定义线宽表达式，必须为数组,缺省默认
     * @param disableHover 禁止hover
     */
    vectorStyle(tileUrl?: string | Record<string, any>, minzoom?: number, maxzoom?: number, prefix?: string, hoverColor?: string, hoverOpacity?: number, hoverLineWidth?: number, customColorCaseExpr?: any[], customOpacityCaseExpr?: any[], customLineWidthCaseExpr?: any[], disableHover?: boolean): Style;
    /**
     * 得到所有矢量字体名称
     * @return {Promise<any>}
     */
    getFontsCapacity(): Promise<{}>;
    /**
     * 清空服务器缓存数据
     * @return {Promise<any>}
     * @param prefix key前缀
     */
    clearCache(prefix?: string): Promise<{}>;
    /**
     * 获取服务器地图服务地址
     * @param tileProvider
     * @return {string}
     */
    webMapUrl(tileProvider: {
        tileCrs?: "gcj02" | "wgs84";
        tileSize?: number;
        tileRetina?: number;
        tileMaxZoom?: number;
        tileUrl: string | string[];
        tileShards?: string;
        tileToken?: string | string[];
        tileFlipY?: boolean;
        mapbounds?: string;
        fourParameterBefore?: string;
        fourParameterAfter?: string;
        srs?: string;
    }): string;
    /**
     * 组合成新地图
     * @param param 组合参数
     * @return {Promise<any>}
     */
    composeNewMap(param: IComposeNewMap | IComposeNewMap[]): Promise<any>;
    /**
     * 比较地图不同
     * @param param 组合参数
     * @return {Promise<any>}
     */
    cmdMapDiff(param: IMapDiff): Promise<any>;
    /**
     * 导出布局空间为dwg图
     * @param param 参数
     * @return {Promise<any>}
     */
    cmdExportLayout(param: IExportLayout): Promise<any>;
    /**
     * 目标匹配
     * @param param 参数
     * @return {Promise<any>}
     */
    cmdMatchObject(param: IMatchObject): Promise<any>;
    /**
     * 获取创建实体的几何数据
     * @param param 参数
     * @param cb 结果中每个点的处理回调。如果返回空的话，则用默认处理方法
     * @return {Promise<any>}
     */
    cmdCreateEntitiesGeomData(param: ICreateEntitiesGeomData, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 坐标转换
     * @return {Promise<any>}
     * @param srs 源坐标系名称，如 EPSG:4326
     * @param crs 目标坐标系名称，如 EPSG:3857
     * @param points 要转换的坐标
     * @param fourParameter 四参数(x偏移,y偏移,缩放，旋转弧度)，可选，对坐标最后进行修正
     * @param isInverseFourParamter 是否是上面四参数坐标的反算
     */
    cmdTransform(srs: string, crs: string, points: GeoPoint | GeoPoint[], fourParameter?: string | string[], isInverseFourParamter?: boolean): Promise<any>;
    /**
     * 投影prj文件WKT字符转proj4字符串
     * @return {Promise<any>}
     * @param srs 投影prj文件WKT字符
     * @param from 字符串来源，为空为话为WKT
     */
    cmdPrjWktToPrj4(wkt: string, from?: undefined | "" | "wmsauto" | "xml" | "urn" | "crsurl" | "url" | "micoordsys" | "pci"): Promise<any>;
    /**
     * 保存用户自定义数据
     * @param key 键名(必须唯一，否则会覆盖之前的数据，同类型的key前缀尽量一样)，如果是数组的话，可以批量
     * @param value 键值
     * @param prop 属性值
     * @param ttl 有效时间，单位秒，默认长期有效
     */
    saveCustomData(key: string | {
        key: string;
        value: any;
        prop?: any;
        ttl?: number;
    }[], value?: any, prop?: any, ttl?: number): Promise<any>;
    /**
     * 获取用户自定义数据
     * @param key 键名，如果是数组的话，可以查询.
     * @param options 选项 retDataType为空时查询数据及属性,"value"只查询数据，"prop"只查询属性。contentType返回类型,为空时为json，为"image"时为图片.
     */
    getCustomData(key: string | string[], options?: {
        retDataType?: "" | "value" | "prop";
        contentType?: "" | "image";
    }): Promise<any>;
    /**
     * 通过前缀获取用户自定义数据的键值
     * @param prefix 键名前缀
     */
    getCustomDataKeysByPrefix(prefix: string): Promise<any>;
    /**
     * 删除用户自定义数据
     * @param key 键名，如果是数组的话，可以查询
     * @param isPrefix 是否删除所有前缀为key的所有键值，默认false
     */
    deleteCustomData(key: string | string[], isPrefix?: boolean): Promise<any>;
}

/**
 * 简化点坐标
 * @param points
 * @param tolerance
 * @return {GeoPoint[]}
 */
export  function simplify(points: GeoPoint[], tolerance?: number): GeoPoint[];

/**
 * 创建天空图层.
 *
 **/
export  class SkyLayer extends OverlayLayerBase {
    options: SkyLayerOptions;
    constructor(options: SkyLayerOptions);
    addTo(map: Map, beforeId?: string): void;
    setSkyType(value: PropertyValueSpecificationEx<"gradient" | "atmosphere">): this;
    getSkyType(): PropertyValueSpecificationEx<"gradient" | "atmosphere">;
    setSkyAtmosphereSun(value: PropertyValueSpecificationEx<[number, number]>): this;
    getSkyAtmosphereSun(): PropertyValueSpecificationEx<[number, number]>;
    setSkyAtmosphereSunIntensity(value: number): this;
    getSkyAtmosphereSunIntensity(): number;
    setSkyGradientCenter(value: PropertyValueSpecificationEx<[number, number]>): this;
    getSkyGradientCenter(): PropertyValueSpecificationEx<[number, number]>;
    setSkyGradientRadius(value: PropertyValueSpecificationEx<number>): this;
    getSkyGradientRadius(): PropertyValueSpecificationEx<number>;
    setSkyGradient(value: ExpressionSpecificationEx): this;
    getSkyGradient(): ExpressionSpecificationEx;
    setSkyAtmosphereHaloColor(value: ColorSpecification): this;
    getSkyAtmosphereHaloColor(): ColorSpecification;
    setSkyAtmosphereColor(value: ColorSpecification): this;
    getSkyAtmosphereColor(): ColorSpecification;
    setSkyOpacity(value: PropertyValueSpecificationEx<number>): this;
    getSkyOpacity(): PropertyValueSpecificationEx<number>;
}

export  interface SkyLayerOptions extends OverlayLayerBaseOptions {
    skyType?: PropertyValueSpecificationEx<"gradient" | "atmosphere">;
    skyAtmosphereSun?: PropertyValueSpecificationEx<[number, number]>;
    skyAtmosphereSunIntensity?: number;
    skyGradientCenter?: PropertyValueSpecificationEx<[number, number]>;
    skyGradientRadius?: PropertyValueSpecificationEx<number>;
    skyGradient?: ExpressionSpecificationEx;
    skyAtmosphereHaloColor?: ColorSpecification;
    skyAtmosphereColor?: ColorSpecification;
    skyOpacity?: PropertyValueSpecificationEx<number>;
}

export  type SkyLayerSpecification = {
    id: string;
    type: "sky";
    metadata?: unknown;
    minzoom?: number;
    maxzoom?: number;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "sky-type"?: PropertyValueSpecificationEx<"gradient" | "atmosphere">;
        "sky-atmosphere-sun"?: PropertyValueSpecificationEx<[number, number]>;
        "sky-atmosphere-sun-intensity"?: number;
        "sky-gradient-center"?: PropertyValueSpecificationEx<[number, number]>;
        "sky-gradient-radius"?: PropertyValueSpecificationEx<number>;
        "sky-gradient"?: ExpressionSpecificationEx;
        "sky-atmosphere-halo-color"?: ColorSpecification;
        "sky-atmosphere-color"?: ColorSpecification;
        "sky-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  const smooth: (strength?: number) => (v: number) => number;

export  const smoothFrame: (prevValue: number, nextValue: number, duration: number, smoothing?: number) => number;

export  const snap: (points: number | number[]) => (v: number) => number | undefined;

export  type SourceBoundUtils = MapGlUtils;

export  type SourceFunctionSpecification<T> = {
    type: "exponential";
    stops: Array<[number, T]>;
    property: string;
    default?: T;
} | {
    type: "interval";
    stops: Array<[number, T]>;
    property: string;
    default?: T;
} | {
    type: "categorical";
    stops: Array<[string | number | boolean, T]>;
    property: string;
    default?: T;
} | {
    type: "identity";
    property: string;
    default?: T;
};

export  type SourceOrData = SourceSpecification | string | GeoJsonGeomertry;

export  type SourceRef = LayerRef;

export  type SourceRefFunc0 = (arg0: SourceRef) => void;

export  type SourceRefFunc1<T1> = (arg0: SourceRef, arg1: T1) => void;

export  type SourceRefFunc2<T1, T2> = (arg0: SourceRef, arg1: T1, arg2: T2) => void;

export  type SourceRefFunc3<T1, T2, T3> = (arg0: SourceRef, arg1: T1, arg2: T2, arg3: T3) => void;

export  type SourceSpecification = VectorSourceSpecification | RasterSourceSpecification | RasterDEMSourceSpecification | GeoJSONSourceSpecification | VideoSourceSpecification | ImageSourceSpecification;

/**
 * This is based on the spring implementation of Wobble https://github.com/skevy/wobble
 */
export  function spring({ from, to, restSpeed, restDelta, ...options }: SpringOptions): any;

export  namespace spring {
    var needsInterpolation: (a: any, b: any) => boolean;
}

export  interface SpringOptions extends PhysicsSpringOptions {
    from?: number;
    to?: number;
    duration?: number;
    bounce?: number;
    restSpeed?: number;
    restDelta?: number;
}

export  const steps: (steps: number, direction?: Direction) => Easing;

export  type StyleSpecification = {
    version: 8;
    name?: string;
    metadata?: unknown;
    center?: Array<number>;
    zoom?: number;
    bearing?: number;
    pitch?: number;
    light?: LightSpecification;
    terrain?: TerrainSpecificationEx;
    fog?: FogSpecification;
    sources: Record<string, SourceSpecification>;
    sprite?: string;
    glyphs?: string;
    transition?: TransitionSpecification;
    layers: Array<LayerSpecification>;
};

export  interface SvgElementOptions {
    /**  元素字符串内容，地理坐标用{{x,y}}来表示，长度用{{r}}来代表 */
    html: string;
    /** 事件，在回调函数里，响应要处理的事件，每次更新图形会重新执行 */
    event?: (svgParentElement: SVGSVGElement) => {};
    /** 元素地理范围，如果不填，会根据传入的坐标自动计算，但对于一些复杂的图形，需传入， */
    bounds?: GeoBounds | [number, number, number, number];
    /**  是否不显示 */
    hidden?: boolean;
    /**  最小缩放级别 */
    minZoom?: number;
    /**  最大缩放级别 */
    maxZoom?: boolean;
    /**  id */
    id?: string | number;
}

/**
 * 在一个地理范围内创建一个随缩放而缩放的svg的覆盖物，(注：svg覆盖物性能低，不建议大量使用，同时在级别特别大时会导致失真，在倾斜角很大时会导致不可见)
 **/
export  class SvgOverlay {
    options: SvgOverlayOptions;
    divOverlay: DivOverlay;
    elements: SvgElementOptions[];
    private _map;
    private bounds;
    private svgParentElement;
    constructor(options?: SvgOverlayOptions);
    addTo(map: Map, insertId?: string | HTMLElement): void;
    remove(): void;
    /**
     * 增加svg元素
     * @param element 要增加的元素
     * @param noUpdate 不立即更新
     */
    addElement(element: SvgElementOptions | string, noUpdate?: boolean): void;
    /**
     * 增加svg元素
     * @param elements 多个元素内容
     * @param noUpdate 不立即更新
     */
    addElements(elements: SvgElementOptions[], noUpdate?: boolean): void;
    /**
     * 获取svg获取
     */
    getSvgContainer(): SVGSVGElement;
    /**
     * 获取所有的元素
     */
    getElements(): SvgElementOptions[];
    /**
     * 移动一个元素
     */
    removeElements(id: string[] | string): SvgElementOptions[];
    /**
     * 更新一个元素
     */
    updateElements(elements: SvgElementOptions[] | SvgElementOptions): SvgElementOptions[];
    /**
     * 更新
     */
    private update;
    /**
     * 圆心半径属性字符串
     */
    static attr_cx_cy_r(cx: number, cy: number, r: number): string;
    /**
     * 椭圆心半径属性字符串
     */
    static attr_cx_cy_rx_ry(cx: number, cy: number, rx: number, ry: number): string;
    /**
     * 直线坐标属性字符串
     */
    static attr_x1_y1_x2_y2(x1: number, y1: number, x2: number, y2: number): string;
    /**
     * 坐标宽高属性字符串
     */
    static attr_x_y_w_h(x: number, y: number, w: number, h: number): string;
    /**
     * 坐标属性字符串
     */
    static attr_x_y(x: number, y: number): string;
    /**
     * 字体属性字符串
     */
    static attr_fontsize(fontsize: number): string;
    /**
     * 和长度有关属性字符串
     */
    static attr_length(len: number): string;
    /**
     * 和点坐标有关属性字符串
     */
    static attr_point(point: GeoPoint, joinComma?: boolean): string;
    /**
     * 坐标序列属性字符串
     */
    static attr_points(points: GeoPoint[]): string;
    /**
     * 路径序列属性字符串
     */
    static attr_path(points: GeoPoint[]): string;
}

export  interface SvgOverlayOptions {
    /** 显示最大级别 */
    minZoom?: number;
    /** 显示最小级别 */
    maxZoom?: number;
    /** 显示最大倾斜角 */
    maxPitch?: number;
    /** 自动更新div大小，（如果需要svg放大，需要设置为true) */
    updateDivSize?: boolean;
    /** 放大div时，最大的div大小，超过了就像素放大了 */
    maxDivSize?: number;
    /** 当移动结束时不自动更新范围 */
    noUpdateBoundsWhenMoveend?: boolean;
    /** 类名 */
    divClassName?: string;
    /** svg初始化时最大像素宽,默认1000 */
    svgMaxWidth?: number;
    /** svg初始化时最大像素高,默认1000 */
    svgMaxHeight?: number;
    /** svg初始化时Offset像素距离,默认100 */
    svgOffset?: number;
}

/**
 * 创建符号图层.
 *
 **/
 class Symbol_2 extends OverlayLayerBase {
    options: SymbolOptions;
    constructor(options: SymbolOptions);
    addTo(map: Map, beforeId?: string): void;
    /** 替换 GeoJSON 图层的当前数据。
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setSymbolPlacement(value: PropertyValueSpecificationEx<"point" | "line" | "line-center">): this;
    getSymbolPlacement(): PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    setSymbolSpacing(value: PropertyValueSpecificationEx<number>): this;
    getSymbolSpacing(): PropertyValueSpecificationEx<number>;
    setSymbolAvoidEdges(value: PropertyValueSpecificationEx<boolean>): this;
    getSymbolAvoidEdges(): PropertyValueSpecificationEx<boolean>;
    setSymbolSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getSymbolSortKey(): DataDrivenPropertyValueSpecification<number>;
    setSymbolZOrder(value: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">): this;
    getSymbolZOrder(): PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    setIconAllowOverlap(value: PropertyValueSpecificationEx<boolean>): this;
    getIconAllowOverlap(): PropertyValueSpecificationEx<boolean>;
    setIconIgnorePlacement(value: PropertyValueSpecificationEx<boolean>): this;
    getIconIgnorePlacement(): PropertyValueSpecificationEx<boolean>;
    setIconOptional(value: PropertyValueSpecificationEx<boolean>): this;
    getIconOptional(): PropertyValueSpecificationEx<boolean>;
    setIconRotationAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getIconRotationAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setIconSize(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconSize(): DataDrivenPropertyValueSpecification<number>;
    setIconTextFit(value: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">): this;
    getIconTextFit(): PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    setIconTextFitPadding(value: PropertyValueSpecificationEx<[number, number, number, number]>): this;
    getIconTextFitPadding(): PropertyValueSpecificationEx<[number, number, number, number]>;
    setIconImage(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getIconImage(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setIconRotate(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconRotate(): DataDrivenPropertyValueSpecification<number>;
    setIconPadding(value: PropertyValueSpecificationEx<number>): this;
    getIconPadding(): PropertyValueSpecificationEx<number>;
    setIconKeepUpright(value: PropertyValueSpecificationEx<boolean>): this;
    getIconKeepUpright(): PropertyValueSpecificationEx<boolean>;
    setIconOffset(value: DataDrivenPropertyValueSpecification<[number, number]>): this;
    getIconOffset(): DataDrivenPropertyValueSpecification<[number, number]>;
    setIconAnchor(value: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">): this;
    getIconAnchor(): DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    setIconPitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getIconPitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextPitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getTextPitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextRotationAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getTextRotationAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextField(value: DataDrivenPropertyValueSpecification<FormattedSpecification>): this;
    getTextField(): DataDrivenPropertyValueSpecification<FormattedSpecification>;
    setTextFont(value: DataDrivenPropertyValueSpecification<string[]>): this;
    getTextFont(): DataDrivenPropertyValueSpecification<string[]>;
    setTextSize(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextSize(): DataDrivenPropertyValueSpecification<number>;
    setTextMaxWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextMaxWidth(): DataDrivenPropertyValueSpecification<number>;
    setTextLineHeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextLineHeight(): DataDrivenPropertyValueSpecification<number>;
    setTextLetterSpacing(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextLetterSpacing(): DataDrivenPropertyValueSpecification<number>;
    setTextJustify(value: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">): this;
    getTextJustify(): DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    setTextRadialOffset(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextRadialOffset(): DataDrivenPropertyValueSpecification<number>;
    setTextVariableAnchor(value: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>): this;
    getTextVariableAnchor(): PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    setTextAnchor(value: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">): this;
    getTextAnchor(): DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    setTextMaxAngle(value: PropertyValueSpecificationEx<number>): this;
    getTextMaxAngle(): PropertyValueSpecificationEx<number>;
    setTextWritingMode(value: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>): this;
    getTextWritingMode(): PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    setTextRotate(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextRotate(): DataDrivenPropertyValueSpecification<number>;
    setTextPadding(value: PropertyValueSpecificationEx<number>): this;
    getTextPadding(): PropertyValueSpecificationEx<number>;
    setTextKeepUpright(value: PropertyValueSpecificationEx<boolean>): this;
    getTextKeepUpright(): PropertyValueSpecificationEx<boolean>;
    setTextTransform(value: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">): this;
    getTextTransform(): DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    setTextOffset(value: DataDrivenPropertyValueSpecification<[number, number]>): this;
    getTextOffset(): DataDrivenPropertyValueSpecification<[number, number]>;
    setTextAllowOverlap(value: PropertyValueSpecificationEx<boolean>): this;
    getTextAllowOverlap(): PropertyValueSpecificationEx<boolean>;
    setTextIgnorePlacement(value: PropertyValueSpecificationEx<boolean>): this;
    getTextIgnorePlacement(): PropertyValueSpecificationEx<boolean>;
    setTextOptional(value: PropertyValueSpecificationEx<boolean>): this;
    getTextOptional(): PropertyValueSpecificationEx<boolean>;
    setIconOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconOpacity(): DataDrivenPropertyValueSpecification<number>;
    setIconColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getIconColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setIconHaloColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getIconHaloColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setIconHaloWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconHaloWidth(): DataDrivenPropertyValueSpecification<number>;
    setIconHaloBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconHaloBlur(): DataDrivenPropertyValueSpecification<number>;
    setIconTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getIconTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setIconTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getIconTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setTextOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextOpacity(): DataDrivenPropertyValueSpecification<number>;
    setTextColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getTextColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setTextHaloColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getTextHaloColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setTextHaloWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextHaloWidth(): DataDrivenPropertyValueSpecification<number>;
    setTextHaloBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextHaloBlur(): DataDrivenPropertyValueSpecification<number>;
    setTextTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getTextTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setTextTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getTextTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
}
export { Symbol_2 as Symbol }

export  type SymbolLayerSpecification = {
    id: string;
    type: "symbol";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "symbol-placement"?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
        "symbol-spacing"?: PropertyValueSpecificationEx<number>;
        "symbol-avoid-edges"?: PropertyValueSpecificationEx<boolean>;
        "symbol-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        "symbol-z-order"?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
        "icon-allow-overlap"?: PropertyValueSpecificationEx<boolean>;
        "icon-ignore-placement"?: PropertyValueSpecificationEx<boolean>;
        "icon-optional"?: PropertyValueSpecificationEx<boolean>;
        "icon-rotation-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "icon-size"?: DataDrivenPropertyValueSpecification<number>;
        "icon-text-fit"?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
        "icon-text-fit-padding"?: PropertyValueSpecificationEx<[number, number, number, number]>;
        "icon-image"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "icon-rotate"?: DataDrivenPropertyValueSpecification<number>;
        "icon-padding"?: PropertyValueSpecificationEx<number>;
        "icon-keep-upright"?: PropertyValueSpecificationEx<boolean>;
        "icon-offset"?: DataDrivenPropertyValueSpecification<[number, number]>;
        "icon-anchor"?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
        "icon-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-rotation-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-field"?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
        "text-font"?: DataDrivenPropertyValueSpecification<Array<string>>;
        "text-size"?: DataDrivenPropertyValueSpecification<number>;
        "text-max-width"?: DataDrivenPropertyValueSpecification<number>;
        "text-line-height"?: DataDrivenPropertyValueSpecification<number>;
        "text-letter-spacing"?: DataDrivenPropertyValueSpecification<number>;
        "text-justify"?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
        "text-radial-offset"?: DataDrivenPropertyValueSpecification<number>;
        "text-variable-anchor"?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
        "text-anchor"?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
        "text-max-angle"?: PropertyValueSpecificationEx<number>;
        "text-writing-mode"?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
        "text-rotate"?: DataDrivenPropertyValueSpecification<number>;
        "text-padding"?: PropertyValueSpecificationEx<number>;
        "text-keep-upright"?: PropertyValueSpecificationEx<boolean>;
        "text-transform"?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
        "text-offset"?: DataDrivenPropertyValueSpecification<[number, number]>;
        "text-allow-overlap"?: PropertyValueSpecificationEx<boolean>;
        "text-ignore-placement"?: PropertyValueSpecificationEx<boolean>;
        "text-optional"?: PropertyValueSpecificationEx<boolean>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "icon-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "icon-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "icon-halo-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "icon-halo-width"?: DataDrivenPropertyValueSpecification<number>;
        "icon-halo-blur"?: DataDrivenPropertyValueSpecification<number>;
        "icon-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "icon-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "text-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "text-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "text-halo-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "text-halo-width"?: DataDrivenPropertyValueSpecification<number>;
        "text-halo-blur"?: DataDrivenPropertyValueSpecification<number>;
        "text-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "text-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
    };
};

export  type SymbolLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    symbolPlacement?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    symbolSpacing?: PropertyValueSpecificationEx<number>;
    symbolAvoidEdges?: PropertyValueSpecificationEx<boolean>;
    symbolSortKey?: DataDrivenPropertyValueSpecification<number>;
    symbolZOrder?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    iconAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    iconIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    iconOptional?: PropertyValueSpecificationEx<boolean>;
    iconRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    iconSize?: DataDrivenPropertyValueSpecification<number>;
    iconTextFit?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    iconTextFitPadding?: PropertyValueSpecificationEx<[number, number, number, number]>;
    iconImage?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    iconRotate?: DataDrivenPropertyValueSpecification<number>;
    iconPadding?: PropertyValueSpecificationEx<number>;
    iconKeepUpright?: PropertyValueSpecificationEx<boolean>;
    iconOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    iconAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    iconPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textField?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
    textFont?: DataDrivenPropertyValueSpecification<Array<string>>;
    textSize?: DataDrivenPropertyValueSpecification<number>;
    textMaxWidth?: DataDrivenPropertyValueSpecification<number>;
    textLineHeight?: DataDrivenPropertyValueSpecification<number>;
    textLetterSpacing?: DataDrivenPropertyValueSpecification<number>;
    textJustify?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    textRadialOffset?: DataDrivenPropertyValueSpecification<number>;
    textVariableAnchor?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    textAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    textMaxAngle?: PropertyValueSpecificationEx<number>;
    textWritingMode?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    textRotate?: DataDrivenPropertyValueSpecification<number>;
    textPadding?: PropertyValueSpecificationEx<number>;
    textKeepUpright?: PropertyValueSpecificationEx<boolean>;
    textTransform?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    textOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    textAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    textIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    textOptional?: PropertyValueSpecificationEx<boolean>;
    visibility?: "visible" | "none";
    iconOpacity?: DataDrivenPropertyValueSpecification<number>;
    iconColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    iconHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    iconTranslate?: PropertyValueSpecificationEx<[number, number]>;
    iconTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    textOpacity?: DataDrivenPropertyValueSpecification<number>;
    textColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    textHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    textTranslate?: PropertyValueSpecificationEx<[number, number]>;
    textTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
};

export  interface SymbolOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    symbolPlacement?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    symbolSpacing?: PropertyValueSpecificationEx<number>;
    symbolAvoidEdges?: PropertyValueSpecificationEx<boolean>;
    symbolSortKey?: DataDrivenPropertyValueSpecification<number>;
    symbolZOrder?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    iconAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    iconIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    iconOptional?: PropertyValueSpecificationEx<boolean>;
    iconRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    iconSize?: DataDrivenPropertyValueSpecification<number>;
    iconTextFit?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    iconTextFitPadding?: PropertyValueSpecificationEx<[number, number, number, number]>;
    iconImage?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    iconRotate?: DataDrivenPropertyValueSpecification<number>;
    iconPadding?: PropertyValueSpecificationEx<number>;
    iconKeepUpright?: PropertyValueSpecificationEx<boolean>;
    iconOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    iconAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    iconPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textField?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
    textFont?: DataDrivenPropertyValueSpecification<string[]>;
    textSize?: DataDrivenPropertyValueSpecification<number>;
    textMaxWidth?: DataDrivenPropertyValueSpecification<number>;
    textLineHeight?: DataDrivenPropertyValueSpecification<number>;
    textLetterSpacing?: DataDrivenPropertyValueSpecification<number>;
    textJustify?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    textRadialOffset?: DataDrivenPropertyValueSpecification<number>;
    textVariableAnchor?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    textAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    textMaxAngle?: PropertyValueSpecificationEx<number>;
    textWritingMode?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    textRotate?: DataDrivenPropertyValueSpecification<number>;
    textPadding?: PropertyValueSpecificationEx<number>;
    textKeepUpright?: PropertyValueSpecificationEx<boolean>;
    textTransform?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    textOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    textAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    textIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    textOptional?: PropertyValueSpecificationEx<boolean>;
    iconOpacity?: DataDrivenPropertyValueSpecification<number>;
    iconColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    iconHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    iconTranslate?: PropertyValueSpecificationEx<[number, number]>;
    iconTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    textOpacity?: DataDrivenPropertyValueSpecification<number>;
    textColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    textHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    textTranslate?: PropertyValueSpecificationEx<[number, number]>;
    textTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
}

/**
 * 同步两张地图的移动。
 *
 */
export  function syncMaps(...args: Map[]): () => void;

/**
 * 表格单元格对齐方式
 */
export  enum TableCellAlignment {
    kTopLeft = 1,
    kTopCenter = 2,
    kTopRight = 3,
    kMiddleLeft = 4,
    kMiddleCenter = 5,
    kMiddleRight = 6,
    kBottomLeft = 7,
    kBottomCenter = 8,
    kBottomRight = 9
}

export  type TerrainSpecificationEx = {
    source: string;
    exaggeration?: PropertyValueSpecificationEx<number>;
};

/**
 * 创建文本组件.
 *
 * @param {Object} [options]
 * @param {object}  [options.text] 文字内容
 * @param {object}  [options.style] 文字样式
 * @param {HTMLElement} [options.element] 用作文本的 DOM 元素。
 * @param {string} [options.anchor='center'] 一个字符串，指示应该放置在最靠近坐标的标记部分。选项有“center”、“top”、“bottom”、“left”、“right”、“top-left”、“top-right”、“top-right” “左下”和“右下”.
 * @param {PointLike} [options.offset] 作为要应用的对象相对于元素中心的偏移量（以像素为单位）。负数表示向左和向上.
 * @param {string} [options.color='#3FB1CE'] 如果未提供`options.element`.
 * @param {number} [options.scale=1] 如果未提供`options.element`，则用于默认文本的比例。.
 * @param {boolean} [options.draggable=false] 一个布尔值，指示是否可以将文本拖动到地图上的新位置.
 * @param {number} [options.clickTolerance=0] 用户在单击文本期间可以移动鼠标指针以将其视为有效单击（与文本拖动相反）的最大像素数。默认是继承地图的`clickTolerance`.
 * @param {number} [options.rotation=0] 文本相对于其各自的“rotationAlignment”设置的旋转角度（以度为单位）。正值将顺时针旋转文本.
 * @param {string} [options.pitchAlignment='auto'] `map` 将 `Text` 与地图平面对齐。 `viewport` 将 `Text` 与视口平面对齐。 `auto` 自动匹配 `rotationAlignment` 的值.
 * @param {string} [options.rotationAlignment='auto'] `map` 对齐 `Text` 相对于地图的旋转，在地图旋转时保持方位。 `viewport` 对齐 `Text` 相对于视口的旋转，与地图旋转无关。 `auto` 等价于 `viewport`.
 * @example
 * // Create a new Text.
 * const text = new vjmap.Text({text: "abc“})
 *     .setLngLat([30.5, 50.5])
 *     .addTo(map);
 * @example
 * // Set text options.
 * const text = new vjmap.Text({
 *     text: "abc“,
 *     draggable: true
 * }).setLngLat([30.5, 50.5])
 *     .addTo(map);
 */
 class Text_2 extends Evented {
    private readonly _marker;
    _textContainerDom: HTMLElement;
    _style: object;
    /**
     * 构造函数
     * @param options
     */
    constructor(options?: TextOptions);
    /**
     * 将 `Text` 附加到 `Map` 对象。
     *
     * @param {Map}  map to add the text to.
     * @returns {Text} Returns itself to allow for method chaining.
     * @example
     * const text = new vjmap.Text({text: "abc"})
     *     .setLngLat([30.5, 50.5])
     *     .addTo(map); // add the text to the map
     */
    addTo(map: Map): Text_2;
    /**
     * 从地图中删除文本。
     *
     * @example
     * const text = new vjmap.Text().addTo(map);
     * text.remove();
     * @returns {Text} Returns itself to allow for method chaining.
     */
    remove(): Text_2;
    /**
     * 得到经纬度
     * @return {any}
     */
    getLngLat(): LngLatLike;
    /**
     * 设置经纬度
     * @param lnglat
     * @return {this}
     */
    setLngLat(lnglat: LngLatLike): Text_2;
    /**
     * 返回 `Text` 的 HTML 元素。
     *
     * @returns {HTMLElement} Returns the text element.
     * @example
     * const element = text.getElement();
     */
    getElement(): HTMLElement;
    /**
     * 返回 `Text` 的 Marker 对象。
     */
    getMarker(): Marker;
    /**
     * Binds a `Popup` to the `Text`
     * @param popup
     * @return {this}
     */
    setPopup(popup?: Popup): Text_2;
    /**
     * 返回绑定到 `Text` 的 `Popup` 实例。
     *
     * @returns {Popup} Returns the popup.
     */
    getPopup(): Popup;
    /**
     * 根据 `Popup` 的当前状态打开或关闭绑定到 `Text` 的 `Popup` 实例.
     *
     * @returns {Text} Returns itself to allow for method chaining.
     */
    togglePopup(): Text_2;
    /**
     * 获取文本的偏移量.
     *
     * @returns {Point} The text's screen coordinates in pixels.
     */
    getOffset(): number;
    /**
     * 设置文本的偏移量.
     *
     * @param {PointLike} offset 以像素为单位的偏移量，作为 PointLike 对象相对于元素的中心应用。负数表示向左和向上。
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setOffset(offset: PointLike): Text_2;
    /**
     * 设置文本的 `draggable` 属性和功能.
     *
     * @param {boolean} [shouldBeDraggable=false] Turns drag functionality on/off.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setDraggable(shouldBeDraggable: boolean): Text_2;
    /**
     * 如果可以拖动文本，则返回 true。
     *
     * @returns {boolean} True if the text is draggable.
     */
    isDraggable(): boolean;
    /**
     * Sets the `rotation` property of the text.
     *
     * @param {number} [rotation=0] 文本相对于其各自设置的旋转角度（顺时针，以度为单位）.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setRotation(rotation: number): Text_2;
    /**
     * 返回文本的当前旋转角度（以度为单位）.
     *
     * @returns {number} The current rotation angle of the text.
     */
    getRotation(): number;
    /**
     * 设置文本的 `rotationAlignment` 属性.
     *
     * @param {string} [alignment='auto'] 设置文本的 `rotationAlignment` 属性.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setRotationAlignment(alignment: string): this;
    /**
     * 返回文本的当前 `rotationAlignment` 属性.
     *
     * @returns {string} The current rotational alignment of the text.
     */
    getRotationAlignment(): string;
    /**
     * 设置文本的 `pitchAlignment` 属性.
     *
     * @param {string} [alignment] 设置文本的 `pitchAlignment` 属性。如果alignment是'auto'，它会自动匹配'rotationAlignment'.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setPitchAlignment(alignment: string): Text_2;
    /**
     * 返回文本的当前 `pitchAlignment` 属性.
     *
     * @returns {string} The current pitch alignment of the text in degrees.
     */
    getPitchAlignment(): string;
    /**
     * 设置动画
     * @param animationType
     * MAP_ANIMATION_NONE 无动画
     * MAP_ANIMATION_BOUNCE 弹跳
     * MAP_ANIMATION_DROP 坠落
     */
    setAnimation(animationType: string): void;
    /**
     * 显示
     */
    show(): void;
    /**
     * 隐藏
     */
    hide(): void;
    /**
     * 设置光标
     * @param cur 光标名称
     */
    setCursor(cur: string): void;
    /**
     * 设置文本内容
     * @param txt
     */
    setText(txt: string): Text_2;
    /**
     * 得到文本内容
     */
    getText(): string;
    /**
     * 设置文本样式
     * @param style
     */
    setStyle(style?: object): Text_2;
    /**
     * 得到文本样式
     */
    getStyle(): object;
}
export { Text_2 as Text }

export  interface TextOptions extends MarkerOptions {
    /** 文本内容. */
    text?: string;
    /** 文本样式. */
    style?: object;
}

export  interface ThreeJsContext {
    repaint(): void;
    createSkyLayer(): void;
    createTerrainLayer(): void;
    sphere(options: any): any;
    line(options: any): any;
    label(options: any): any;
    tooltip(options: any): any;
    tube(options: any): any;
    extrusion(options: any): any;
    Object3D(options: any): any;
    projectToWorld(coords: any): any;
    unprojectFromWorld(v3: any): any;
    projectedUnitsPerMeter(lat: any): any;
    getFeatureCenter(feature: any, obj: any, level: number): any;
    getObjectHeightOnFloor(coords: any, obj: any, level: number): any;
    queryRenderedFeatures(point: any): any;
    findParent3DObject(mesh: any): any;
    setLayoutProperty(layerId: string, name: string, value: any): any;
    setLayerZoomRange(layerId: string, minZoomLayer: number, maxZoomLayer: number): any;
    setLayerHeigthProperty(layerId: string, level: number): any;
    setObjectsScale(): any;
    setStyle(styleId: string, options: any): any;
    toggleLayer(layerId: string, visible?: boolean): any;
    toggle(layerId: string, visible?: boolean): any;
    update(): any;
    add(obj: any, layerId?: string, sourceId?: string): any;
    removeByName(name: string): any;
    remove(obj: any): any;
    clear(layerId?: string, dispose?: boolean): any;
    removeLayer(layerId: string): any;
    getSunPosition(date: any, coords: any): any;
    getSunTimes(date: any, coords: any): any;
    setBuildingShadows(options: any): any;
    setSunlight(newDate: any, coords: any): any;
    getSunSky(date: any, sunPos: any): any;
    updateSunSky(sunPos: any): any;
    updateSunGround(sunPos: any): any;
    updateLightHelper(): any;
    dispose(): any;
    defaultLights(): any;
    realSunlight(helper?: boolean): any;
    setDefaultView(options: any, defOptions: any): any;
    memory(): any;
    programs(): any;
    /**
     * 地图几何坐标转threejs世界坐标.
     **/
    mapToWorld(coords: any): any;
    /**
     * threejs世界坐标地转图几何坐标.
     **/
    mapToWorldLength(coords: any): any;
    /**
     * 地图几何长度转threejs世界坐标长度.
     **/
    mapToWorldLength(len: number): number;
    /**
     * threejs世界坐标长度转地图几何长度.
     **/
    worldToMapLength(len: number): number;
    /**
     * threejs世界坐标总长度.
     **/
    getWorldSize(): number;
    /**
     * 加载材质，要使用base64图片，返回 `THREE.Texture` 对象.
     **/
    loadTexture(img: string, defaultImg?: string): any;
    /**
     * 创建一个四棱锥
     **/
    coneMesh(co: GeoPoint, opts?: {
        size?: number;
        height?: number;
        color?: string | number;
        animation?: boolean;
        animationUpDown?: boolean;
        obj3dOpts?: object;
    }): any;
    /**
     * 创建一个立体光墙
     **/
    wall(pts: GeoPoint[], opts?: {
        height?: number;
        flyline?: boolean;
        repeatX?: number;
        repeatY?: number;
        offsetX?: number;
        offsetY?: number;
        color1?: string | number;
        texture1?: string;
        color2?: string | number;
        texture2?: string;
        opacity?: number;
        obj3dOpts?: object;
    }): any;
    /**
     * 创建一个波动光圈
     **/
    wave(co: GeoPoint, opts?: {
        size?: number;
        color?: string | number;
        texture?: string;
        speed?: number;
    }): any;
    /**
     * 创建一个径向渐变球
     **/
    radialGradient(co: GeoPoint, opts?: {
        size?: number;
        color?: string | number | any;
        speed?: number;
    }): any;
    /**
     * 创建一个扫描雷达
     **/
    radar(co: GeoPoint, opts?: {
        size?: number;
        color1?: string | number;
        texture1: string;
        color2?: string | number;
        texture2: string;
        speed?: number;
    }): any;
    /**
     * 创建一个波动光圈
     **/
    waveWall(co: GeoPoint, opts?: {
        size?: number;
        height?: number;
        color?: string | number;
        texture?: string;
        speed?: number;
        opacity?: number;
    }): any;
    /**
     *  创建一条飞行线
     **/
    flyline(opts: {
        source: GeoPoint;
        target: GeoPoint;
        height?: number;
        size?: number;
        color: string | number;
        color2?: string | number;
        count?: number;
        range?: number;
        opacity?: number;
        speed?: number;
    }): any;
}

export  interface ThreeJsContextOptions {
    defaultLights?: boolean;
    realSunlight?: boolean;
    realSunlightHelper?: boolean;
    passiveRendering?: boolean;
    preserveDrawingBuffer?: boolean;
    enableSelectingFeatures?: boolean;
    enableSelectingObjects?: boolean;
    enableDraggingObjects?: boolean;
    enableRotatingObjects?: boolean;
    enableTooltips?: boolean;
    multiLayer?: boolean;
    orthographic?: boolean;
    fov?: number;
    sky?: boolean;
    terrain?: boolean;
}

/**
 * threejs图层.
 *
 **/
export  class ThreeLayer extends Evented implements CustomLayerInterface {
    id: string;
    type: "custom";
    renderingMode?: "2d" | "3d" | undefined;
    context: ThreeJsContext;
    constructor(options: ThreeLayerOptions);
    onAdd(map: any, gl: any): void;
    onRemove(): void;
    render(gl: any, matrix: any): void;
}

export  interface ThreeLayerOptions {
    id?: string;
    context: ThreeJsContext;
    onAdd?: (map: any, gl: any) => void;
    onRemove?: () => void;
    render?: (gl: any, matrix: any) => void;
}

export  const toDecimal: (num: number, precision?: number) => number;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
export  function toRadian(a: number): number;

export  const transform: {
    CRSTypes: typeof CRSTypes;
    convert: typeof convert;
    EpsgCrsTypes: typeof EpsgCrsTypes;
    getEpsgParam: typeof getEpsgParam;
    getEpsgCode: typeof getEpsgCode;
};

export  type TransitionSpecification = {
    duration?: number;
    delay?: number;
};

/**
 * An update function. It accepts a timestamp used to advance the animation.
 */
 type Update = (timestamp: number) => void;

export  const upperCamelCase: (s: any) => any;

/**
 * utf8转unicode
 * @param strUtf8 utf8的内容
 */
export  function utf8ToUnicode(strUtf8: string): string;

export  namespace vec2 {
    export type valueType = vec2type;
    /**
     * Creates a new, empty vec2
     *
     * @returns {vec2} a new 2D vector
     */
    export function create(): vec2type;
    /**
     * Creates a new vec2 initialized with values from an existing vector
     *
     * @param {ReadonlyVec2} a vector to clone
     * @returns {vec2} a new 2D vector
     */
    export function clone(a: vec2type): vec2type;
    /**
     * Creates a new vec2 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} a new 2D vector
     */
    export function fromValues(x: number, y: number): vec2type;
    /**
     * Copy the values from one vec2 to another
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the source vector
     * @returns {vec2} out
     */
    export function copy(out: vec2type, a: vec2type): vec2type;
    /**
     * Set the components of a vec2 to the given values
     *
     * @param {vec2} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} out
     */
    export function set(out: vec2type, x: number, y: number): vec2type;
    /**
     * Adds two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function add(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function subtract(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Multiplies two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function multiply(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Divides two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function divide(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Math.ceil the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to ceil
     * @returns {vec2} out
     */
    export function ceil(out: vec2type, a: vec2type): vec2type;
    /**
     * Math.floor the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to floor
     * @returns {vec2} out
     */
    export function floor(out: vec2type, a: vec2type): vec2type;
    /**
     * Returns the minimum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function min(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Returns the maximum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function max(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Math.round the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to round
     * @returns {vec2} out
     */
    export function round(out: vec2type, a: vec2type): vec2type;
    /**
     * Scales a vec2 by a scalar number
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec2} out
     */
    export function scale(out: vec2type, a: vec2type, b: number): vec2type;
    /**
     * Adds two vec2's after scaling the second operand by a scalar value
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @param {Number} scale the amount to scale b by before adding
     * @returns {vec2} out
     */
    export function scaleAndAdd(out: vec2type, a: vec2type, b: vec2type, scale: number): vec2type;
    /**
     * Calculates the euclidian distance between two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec2type, b: vec2type): number;
    /**
     * Calculates the squared euclidian distance between two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec2type, b: vec2type): number;
    /**
     * Calculates the length of a vec2
     *
     * @param {ReadonlyVec2} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec2type): number;
    /**
     * Calculates the squared length of a vec2
     *
     * @param {ReadonlyVec2} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec2type): number;
    /**
     * Negates the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to negate
     * @returns {vec2} out
     */
    export function negate(out: vec2type, a: vec2type): vec2type;
    /**
     * Returns the inverse of the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to invert
     * @returns {vec2} out
     */
    export function inverse(out: vec2type, a: vec2type): vec2type;
    /**
     * Normalize a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to normalize
     * @returns {vec2} out
     */
    export function normalize(out: vec2type, a: vec2type): vec2type;
    /**
     * Calculates the dot product of two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec2type, b: vec2type): number;
    /**
     * Computes the cross product of two vec2's
     * Note that the cross product must by definition produce a 3D vector
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec3} out
     */
    export function cross(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Performs a linear interpolation between two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {vec2} out
     */
    export function lerp(out: vec2type, a: vec2type, b: vec2type, t: number): vec2type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec2} out the receiving vector
     * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
     * @returns {vec2} out
     */
    export function random(out: vec2type, scale: number): vec2type;
    /**
     * Transforms the vec2 with a mat2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat2} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat2(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat2d
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat2d} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat2d(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat3
     * 3rd vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat3} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat3(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat4
     * 3rd vector component is implicitly '0'
     * 4th vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat4} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat4(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Rotate a 2D vector
     * @param {vec2} out The receiving vec2
     * @param {ReadonlyVec2} a The vec2 point to rotate
     * @param {ReadonlyVec2} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @returns {vec2} out
     */
    export function rotate(out: vec2type, a: vec2type, b: vec2type, rad: number): vec2type;
    /**
     * Get the angle between two 2D vectors
     * @param {ReadonlyVec2} a The first operand
     * @param {ReadonlyVec2} b The second operand
     * @returns {Number} The angle in radians
     */
    export function angle(a: vec2type, b: vec2type): number;
    /**
     * Set the components of a vec2 to zero
     *
     * @param {vec2} out the receiving vector
     * @returns {vec2} out
     */
    export function zero(out: vec2type): vec2type;
    /**
     * Returns a string representation of a vector
     *
     * @param {ReadonlyVec2} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec2type): string;
    /**
     * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyVec2} a The first vector.
     * @param {ReadonlyVec2} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec2type, b: vec2type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {ReadonlyVec2} a The first vector.
     * @param {ReadonlyVec2} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec2type, b: vec2type): boolean;
    /**
     * Perform some operation over an array of vec2s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    const forEach: (a: any, stride: any, offset: any, count: any, fn: any, arg: any) => any;
}

 interface Vec2Like {
    x: number;
    y: number;
}

export  type vec2type = [number, number] | Float32Array;

export  namespace vec3 {
    export type valueType = vec3type;
    /**
     * Creates a new, empty vec3
     *
     * @returns {vec3} a new 3D vector
     */
    export function create(): vec3type;
    /**
     * Creates a new vec3 initialized with values from an existing vector
     *
     * @param {vec3} a vector to clone
     * @returns {vec3} a new 3D vector
     */
    export function clone(a: vec3type): vec3type;
    /**
     * Creates a new vec3 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} a new 3D vector
     */
    export function fromValues(x: number, y: number, z: number): vec3type;
    /**
     * Copy the values from one vec3 to another
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the source vector
     * @returns {vec3} out
     */
    export function copy(out: vec3type, a: vec3type): vec3type;
    /**
     * Set the components of a vec3 to the given values
     *
     * @param {vec3} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} out
     */
    export function set(out: vec3type, x: number, y: number, z: number): vec3type;
    /**
     * Adds two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function add(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function subtract(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.subtract}
     * @function
     */
    /**
     * Multiplies two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function multiply(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.multiply}
     * @function
     */
    /**
     * Divides two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function divide(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.divide}
     * @function
     */
    /**
     * Math.ceil the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to ceil
     * @returns {vec3} out
     */
    export function ceil(out: vec3type, a: vec3type): vec3type;
    /**
     * Math.floor the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to floor
     * @returns {vec3} out
     */
    export function floor(out: vec3type, a: vec3type): vec3type;
    /**
     * Returns the minimum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function min(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Returns the maximum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function max(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Math.round the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to round
     * @returns {vec3} out
     */
    export function round(out: vec3type, a: vec3type): vec3type;
    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */
    export function scale(out: vec3type, a: vec3type, b: number): vec3type;
    /**
     * Adds two vec3's after scaling the second operand by a scalar value
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} s the amount to scale b by before adding
     * @returns {vec3} out
     */
    export function scaleAndAdd(out: vec3type, a: vec3type, b: vec3type, s: number): vec3type;
    /**
     * Calculates the euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec3type, b: vec3type): number;
    /**
     * Alias for {@link vec3.distance}
     * @function
     */
    /**
     * Calculates the squared euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec3type, b: vec3type): number;
    /**
     * Alias for {@link vec3.squaredDistance}
     * @function
     */
    /**
     * Calculates the length of a vec3
     *
     * @param {vec3} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec3type): number;
    /**
     * Alias for {@link vec3.length}
     * @function
     */
    /**
     * Calculates the squared length of a vec3
     *
     * @param {vec3} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec3type): number;
    /**
     * Alias for {@link vec3.squaredLength}
     * @function
     */
    /**
     * Negates the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to negate
     * @returns {vec3} out
     */
    export function negate(out: vec3type, a: vec3type): vec3type;
    /**
     * Returns the inverse of the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to invert
     * @returns {vec3} out
     */
    export function inverse(out: vec3type, a: vec3type): vec3type;
    /**
     * Normalize a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to normalize
     * @returns {vec3} out
     */
    export function normalize(out: vec3type, a: vec3type): vec3type;
    /**
     * Calculates the dot product of two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec3type, b: vec3type): number;
    /**
     * Computes the cross product of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function cross(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Performs a linear interpolation between two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function lerp(out: vec3type, a: vec3type, b: vec3type, t: number): vec3type;
    /**
     * Performs a hermite interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function hermite(out: vec3type, a: vec3type, b: vec3type, c: vec3type, d: vec3type, t: number): vec3type;
    /**
     * Performs a bezier interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function bezier(out: vec3type, a: vec3type, b: vec3type, c: vec3type, d: vec3type, t: number): vec3type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec3} out the receiving vector
     * @param {Number} [s] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec3} out
     */
    export function random(out: vec3type, s?: number): vec3type;
    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    export function transformMat4(out: vec3type, a: vec3type, m: mat4type): vec3type;
    /**
     * Transforms the vec3 with a mat3.
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m the 3x3 matrix to transform with
     * @returns {vec3} out
     */
    export function transformMat3(out: vec3type, a: vec3type, m: mat4type): vec3type;
    /**
     * Transforms the vec3 with a quat
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec3} out
     */
    export function transformQuat(out: vec3type, a: vec3type, q: quattype): vec3type;
    /**
     * Rotate a 3D vector around the x-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateX(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Rotate a 3D vector around the y-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateY(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Rotate a 3D vector around the z-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateZ(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Perform some operation over an array of vec3s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    export function forEach(a: vec3type, stride: number, offset: number, count: number, fn: (out: vec3type, vec: vec3type, arg: any) => void, arg?: any): any;
    /**
     * Get the angle between two 3D vectors
     * @param {vec3} a The first operand
     * @param {vec3} b The second operand
     * @returns {Number} The angle in radians
     */
    export function angle(a: vec3type, b: vec3type): number;
    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec3type): string;
    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     *
     * @param {vec3} a The first vector.
     * @param {vec3} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec3type, b: vec3type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {vec3} a The first vector.
     * @param {vec3} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec3type, b: vec3type): boolean;
}

export  type vec3type = [number, number, number] | Float32Array;

export  namespace vec4 {
    export type valueType = vec4type;
    /**
     * Creates a new, empty vec4
     *
     * @returns {vec4} a new 4D vector
     */
    export function create(): vec4type;
    /**
     * Creates a new vec4 initialized with values from an existing vector
     *
     * @param {vec4} a vector to clone
     * @returns {vec4} a new 4D vector
     */
    export function clone(a: vec4type): vec4type;
    /**
     * Creates a new vec4 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} a new 4D vector
     */
    export function fromValues(x: number, y: number, z: number, w: number): vec4type;
    /**
     * Copy the values from one vec4 to another
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the source vector
     * @returns {vec4} out
     */
    export function copy(out: vec4type, a: vec4type): vec4type;
    /**
     * Set the components of a vec4 to the given values
     *
     * @param {vec4} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} out
     */
    export function set(out: vec4type, x: number, y: number, z: number, w: number): vec4type;
    /**
     * Adds two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function add(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function subtract(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.subtract}
     * @function
     */
    /**
     * Multiplies two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function multiply(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.multiply}
     * @function
     */
    /**
     * Divides two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function divide(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.divide}
     * @function
     */
    /**
     * Math.ceil the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to ceil
     * @returns {vec4} out
     */
    export function ceil(out: vec4type, a: vec4type): vec4type;
    /**
     * Math.floor the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to floor
     * @returns {vec4} out
     */
    export function floor(out: vec4type, a: vec4type): vec4type;
    /**
     * Returns the minimum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function min(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Returns the maximum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function max(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Math.round the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to round
     * @returns {vec4} out
     */
    export function round(out: vec4type, a: vec4type): vec4type;
    /**
     * Scales a vec4 by a scalar number
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec4} out
     */
    export function scale(out: vec4type, a: vec4type, b: number): vec4type;
    /**
     * Adds two vec4's after scaling the second operand by a scalar value
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} s the amount to scale b by before adding
     * @returns {vec4} out
     */
    export function scaleAndAdd(out: vec4type, a: vec4type, b: vec4type, s: number): vec4type;
    /**
     * Calculates the euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec4type, b: vec4type): number;
    /**
     * Alias for {@link vec4.distance}
     * @function
     */
    /**
     * Calculates the squared euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec4type, b: vec4type): number;
    /**
     * Alias for {@link vec4.squaredDistance}
     * @function
     */
    /**
     * Calculates the length of a vec4
     *
     * @param {vec4} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec4type): number;
    /**
     * Alias for {@link vec4.length}
     * @function
     */
    /**
     * Calculates the squared length of a vec4
     *
     * @param {vec4} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec4type): number;
    /**
     * Alias for {@link vec4.squaredLength}
     * @function
     */
    /**
     * Negates the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to negate
     * @returns {vec4} out
     */
    export function negate(out: vec4type, a: vec4type): vec4type;
    /**
     * Returns the inverse of the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to invert
     * @returns {vec4} out
     */
    export function inverse(out: vec4type, a: vec4type): vec4type;
    /**
     * Normalize a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to normalize
     * @returns {vec4} out
     */
    export function normalize(out: vec4type, a: vec4type): vec4type;
    /**
     * Calculates the dot product of two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec4type, b: vec4type): number;
    /**
     * Performs a linear interpolation between two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec4} out
     */
    export function lerp(out: vec4type, a: vec4type, b: vec4type, t: number): vec4type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec4} out the receiving vector
     * @param {Number} [s] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec4} out
     */
    export function random(out: vec4type, s?: number): vec4type;
    /**
     * Transforms the vec4 with a mat4.
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec4} out
     */
    export function transformMat4(out: vec4type, a: vec4type, m: mat4type): vec4type;
    /**
     * Transforms the vec4 with a quat
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec4} out
     */
    export function transformQuat(out: vec4type, a: vec4type, q: quattype): vec4type;
    /**
     * Perform some operation over an array of vec4s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    export function forEach(a: vec4type, stride: number, offset: number, count: number, fn: (out: vec4type, vec: vec4type, arg: any) => void, arg?: any): any;
    /**
     * Returns a string representation of a vector
     *
     * @param {vec4} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec4type): string;
    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     *
     * @param {vec4} a The first vector.
     * @param {vec4} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec4type, b: vec4type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {vec4} a The first vector.
     * @param {vec4} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec4type, b: vec4type): boolean;
}

export  type vec4type = [number, number, number, number] | Float32Array;

/**
 * 生成矢量等值面
 * @param {json} featureCollection：，已有点数据，geojson格式 (如果不填，为undefined时，表示获取的是算法本身对象）
 * @param {string} weight：必填，插值所依赖的属性中字段名称
 * @param {array} breaks：必填，等值面分级区间
 * @param params
 params:{
         model:'exponential','gaussian','spherical'，三选一，默认exponential
         sigma2: 0, // sigma2是σ²，对应高斯过程的方差参数，也就是这组数据z的距离，方差参数σ²的似然性反映了高斯过程中的误差，并应手动设置。一般设置为 0 ，其他数值设了可能会出空白图
         alpha: 100, // Alpha α对应方差函数的先验值，此参数可能控制钻孔扩散范围,越小范围越大,少量点效果明显，但点多了且分布均匀以后改变该数字即基本无效果了，默认设置为100
         canvas: HTMLCanvasElement, // 如果要渲染到画布上填这个
         xlim: number, // canvas有效
         ylim: number, // canvas有效
         colors:string[] // canvas有效 等值面分级区间
         width: number // 生成等值线宽度参数。像素长度。默认200。宽度值越大，绘制越精确，但也会导致速度变慢，内存占用越多
  }
 */
export  function vectorContour(featureCollection: FeatureCollection, weight: string, breaks: number[], params?: {
    model?: 'exponential' | 'gaussian' | 'spherical';
    sigma2?: number;
    alpha?: number;
    canvas?: HTMLCanvasElement;
    xlim?: number;
    ylim?: number;
    colors?: string[];
    extent?: [number, number, number, number];
    width?: number;
}): {
    grid?: {
        grid: number[];
        n: number;
        m: number;
        xlim: number;
        ylim: number;
        zlim: number;
        x_resolution: number;
        y_resolution: number;
    };
    contour?: FeatureCollection;
    variogram?: any;
    alg?: any;
};

export  type VectorSourceSpecification = {
    type: "vector";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    scheme?: "xyz" | "tms";
    minzoom?: number;
    maxzoom?: number;
    attribution?: string;
    promoteId?: PromoteIdSpecificationEx;
    volatile?: boolean;
};

export  function velocityPerFrame(xps: number, frameDuration: number): number;

export  function velocityPerSecond(velocity: number, frameDuration: number): number;

export  type VideoSourceSpecification = {
    type: "video";
    urls: Array<string>;
    coordinates: [[number, number], [number, number], [number, number], [number, number]];
};

export  function WorkerExpose(target: any): void;

/**
 * 和一个Worker相关联
 * @param worker
 * @return {any}
 * @constructor
 */
export  function WorkerLink(worker: Worker): any;

/**
 * 将独立函数/类移动到工作线程的一种非常简单的方法。 或者，将 worker 中的对象或函数暴露给主线程。 所有调用都是异步的。与 async/await 配合使用效果很好
 *
 * Example:
 * ```typescript
 * function busyAdd(a, b) {
 *  let st = Date.now();
 *  while (true) {
 *    if ((Date.now() - st) > 2000) break;
 *  }
 *  return a + b;
 * }
 *
 * (async () => {
 *  let workerAdd = vjmap.WorkerProxy(busyAdd);
 *  console.log(await workerAdd(10, 20)); //30
 *  // the busyAdd is executed in a worker so
 *  // the UI does not get blocked
 * })();
 *
 * class Adder {
 * constructor() {
 *   this.count = 0;
 * }
 * add(a, b) {
 *  this.count++;
 *   return a + b;
 * }
 *}

 * (async () => {
 * let WAdder = vjmap.WorkerProxy(Adder);
 * let a = await new WAdder(); // instance created/running in worker
 * console.log(await a.count); // 0
 * console.log(await a.add(10, 20)); // 30
 * console.log(await a.count); // 1
 *})();
 *
 * // or:
 * // worker.js
 *
 *importScripts('https://cdn.jsdelivr.net/npm/moment@2.20.1/moment.min.js', '../dist/workly.js');
 *function friendlyTime(value) {
 *return moment(value).calendar(null, {
 *   sameDay: function (now) {
 *    if (now - this < 1000 * 60) {
 *       return "[Just now]";
 *    } else if (now - this < 1000 * 60 * 60) {
 *       return "[" + Math.round((now - this) / (1000 * 60)) + " mins ago]";
 *    } else {
 *      return '[Today at] LT'
 *    }
 *  }
 * });
 *}
 *vjmap.WorkerExpose(friendlyTime);
 *main.js
 *
 *(async () => {
 * let w = vjmap.WorkerProxy("./worker.js");
 *let now = Date.now();
 * console.log(now);
 * console.log(await w(now));
 *console.log(await w(now - (24 * 60 * 60 * 1000)));
 *console.log(await w(now - (4 * 24 * 60 * 60 * 1000)));
 *})();
 *
 *  function randAdd(a, b) {
 *      return randInt(a, b)  + 1000; // randInt这个函数是上下文传递进来的
 *  }
 *
 * let randAddFunc = vjmap.WorkerProxy(randAdd, {
 *    randInt: vjmap.randInt // 把主进程库的函数做为上下文传进去
 * });
 * console.log(await randAddFunc(100, 300));
 * ```
 * @param obj
 * @param funcContext 函数上下文，如果传入的obj是函数的话，需要把obj中函数里调用的函数名称和函数方法传进来
 * @return {any}
 * @constructor
 */
export  function WorkerProxy(obj: Function | string, funcContext?: Record<string, Function | string>): Function;

export  const wrap: (min: number, max: number, v: number) => number;


    export function supported(options?: { failIfMajorPerformanceCaveat?: boolean | undefined }): boolean;

    /**
     * Clears browser storage used by this library. Using this method flushes the Map tile cache that is managed by this library.
     * Tiles may still be cached by the browser in some cases.
     */
    export function clearStorage(callback?: (err?: Error) => void): void;

    export function setRTLTextPlugin(pluginURL: string, callback: (error: Error) => void, deferred?: boolean): void;
    export function getRTLTextPluginStatus(): PluginStatus;

    /**
     * Initializes resources like WebWorkers that can be shared across maps to lower load
     * times in some situations. `vjmap.workerUrl` and `vjmap.workerCount`, if being
     * used, must be set before `prewarm()` is called to have an effect.
     *
     * By default, the lifecycle of these resources is managed automatically, and they are
     * lazily initialized when a Map is first created. By invoking `prewarm()`, these
     * resources will be created ahead of time, and will not be cleared when the last Map
     * is removed from the page. This allows them to be re-used by new Map instances that
     * are created later. They can be manually cleared by calling
     * `vjmap.clearPrewarmedResources()`. This is only necessary if your web page remains
     * active but stops using maps altogether.
     *
     * This is primarily useful when using GL-JS maps in a single page app, wherein a user
     * would navigate between various views that can cause Map instances to constantly be
     * created and destroyed.
     */
    export function prewarm(): void;

    /**
     * Clears up resources that have previously been created by `vjmap.prewarm()`.
     * Note that this is typically not necessary. You should only call this function
     * if you expect the user of your app to not return to a Map view at any point
     * in your application.
     */
    export function clearPrewarmedResources(): void;

  export  type PluginStatus = 'unavailable' | 'loading' | 'loaded' | 'error';

  export  type LngLatLike = [number, number] | LngLat | { lng: number; lat: number } | { lon: number; lat: number };

  export  type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number] | LngLatLike;
  export  type PointLike = Point | [number, number];
  export  type Offset = number | PointLike | { [_: string]: PointLike };

  export  type ExpressionName =
        // Types
        | 'array'
        | 'boolean'
        | 'collator'
        | 'format'
        | 'literal'
        | 'number'
        | 'number-format'
        | 'object'
        | 'string'
        | 'image'
        | 'to-boolean'
        | 'to-color'
        | 'to-number'
        | 'to-string'
        | 'typeof'
        // Feature data
        | 'feature-state'
        | 'geometry-type'
        | 'id'
        | 'line-progress'
        | 'properties'
        // Lookup
        | 'at'
        | 'get'
        | 'has'
        | 'in'
        | 'index-of'
        | 'length'
        | 'slice'
        // Decision
        | '!'
        | '!='
        | '<'
        | '<='
        | '=='
        | '>'
        | '>='
        | 'all'
        | 'any'
        | 'case'
        | 'match'
        | 'coalesce'
        | 'within'
        // Ramps, scales, curves
        | 'interpolate'
        | 'interpolate-hcl'
        | 'interpolate-lab'
        | 'step'
        // Variable binding
        | 'let'
        | 'var'
        // String
        | 'concat'
        | 'downcase'
        | 'is-supported-script'
        | 'resolved-locale'
        | 'upcase'
        // Color
        | 'rgb'
        | 'rgba'
        | 'to-rgba'
        // Math
        | '-'
        | '*'
        | '/'
        | '%'
        | '^'
        | '+'
        | 'abs'
        | 'acos'
        | 'asin'
        | 'atan'
        | 'ceil'
        | 'cos'
        | 'e'
        | 'floor'
        | 'ln'
        | 'ln2'
        | 'log10'
        | 'log2'
        | 'max'
        | 'min'
        | 'pi'
        | 'round'
        | 'sin'
        | 'sqrt'
        | 'tan'
        // Zoom, Heatmap
        | 'zoom'
        | 'heatmap-density';

  export  type Expression = [ExpressionName, ...any[]];

  export  type Anchor =
        | 'center'
        | 'left'
        | 'right'
        | 'top'
        | 'bottom'
        | 'top-left'
        | 'top-right'
        | 'bottom-left'
        | 'bottom-right';

  export  type DragPanOptions = {
        linearity?: number;
        easing?: (t: number) => number;
        deceleration?: number;
        maxSpeed?: number;
    };

  export  type InteractiveOptions = { around?: 'center' };

    /**
     * Map
     */
    export class Map extends Evented {
        constructor(options?: MapOptions);

        /**
         * 设置地图右键上下文菜单，运行时将触发 上下文菜单将要打开`contextMenuPreOpen`, 上下文菜单已打开`contextMenuOpened`, 上下文菜单打开无内容`contextMenuNoContent`事件, 如果isInteracting()为true时，将不会弹出菜单，并会触发上下文取消contextMenuCancel事件
         * @param menu 获取菜单的函数
         * @param key 多次调用setMenu时，同样的key会覆盖之前的事件函数；有多个key时，调用次序为key的字母次序倒序；多次调用时，直到函数返回一个非null的ContextMenu为止
         */
        setMenu(menu?: (event: any) => ContextMenu | null, key?: string): void;


        /**
         * 更改地图栅格瓦片地址
         * @param map 地图对象
         * @param tiles 瓦片地址
         *  @param source 栅格源名称 缺省 raster-source
         */
        changeSourceTiles(tiles: string[] | string, source?: string): void;

        /**
         * 关联服务对象和投影对象
         * @param svc 服务对象
         * @param projection 投影对象
         * @param options 其他关联对象
         */
        attach(svc: Service, projection: Projection, options?: object): void;

        /**
         * 得到服务对象接口
         */
        getService(): Service;

        /**
         * 得到关联的选项
         */
        getAttachOptions(): object;

        /**
         * 设置投影接口
         * @param projection
         */
        setMapProjection(projection: Projection): void;

        /**
         * 得到投影接口
         */
        getMapProjection(): Projection;


        /**
         * 地图地理坐标转经纬度
         * @param input 地理坐标点
         * @return {[number, number]}
         */
        toLngLat<
            T extends
                | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
        >(
            input: T
        ): any;

        /**
         * 经纬度转地图地理坐标
         * @param input 经纬度坐标点
         * @return {GeoPoint}
         */
        fromLngLat<
            T extends
                | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
        >(
            input: T
        ): any;


        /**
         *
         * @param tileUrl  切换至矢量瓦片地址
         * @param rasterPrefix 栅格图层前缀，缺省raster
         * @param minzoom 最小级别，缺省0
         * @param maxzoom 最大级别，缺省24
         * @param vecotrPrefix 矢量图层前缀，缺省vector
         * @param hoverColor 高亮时颜色，缺省rgba(0,0,255,255)
         * @param hoverOpacity 高亮时透明度,缺省0.5
         * @param hoverLineWidth 高亮时线宽,缺省3
         */
        switchRasterToVectorStyle(
            tileUrl: string,
            rasterPrefix?: string,
            minzoom?: number,
            maxzoom?: number,
            vecotrPrefix?: string,
            hoverColor?: string,
            hoverOpacity?: number,
            hoverLineWidth?: number
        ): void;

        /**
         *
         * @param tileUrl 切换至栅格瓦片地址
         * @param vecotrPrefix 矢量图层前缀，缺省vector
         * @param minzoom 最小级别，缺省0
         * @param maxzoom 最大级别，缺省24
         * @param rasterPrefix 前缀，缺省raster
         */
        switchVectorToRasterStyle(
            tileUrl: string,
            vecotrPrefix?: string,
            minzoom?: number,
            maxzoom?: number,
            rasterPrefix?: string
        ): void;

        /**
         * 使矢量图层悬浮高亮
         * @param cb 回调
         * @param prefix 矢量图层名称前缀
         */
        enableVectorLayerHoverHighlight(
            cb?: (eventName: string, hoverFeature: any, hoverLayer: string, event: any) => void,
            prefix?: string
        ): void;

        /**
         * 不使矢量图层悬浮高亮
         * @param prefix 矢量图层名称前缀
         */
        disableVectorLayerHoverHighlight(prefix?: string): boolean;

        /**
         * 使图层点击高亮
         * @param svc 服务接口实例
         * @param cb 回调
         * @param HighlightColor  高亮时的颜色，（颜色为#0000时，则不会绘制）
         * @param prefix 高亮图层名称前缀，缺省(highlight)
         * @param filterCb 结果过滤回调
         * @param enterQueryCb 进入查询前回调，可用来修改查询的参数，如坐标等
         */
        enableLayerClickHighlight(
            svc: Service,
            cb?: (res: any, event: any) => void,
            HighlightColor?: string,
            prefix?: string,
            filterCb?: (curResult: any, zoom?: number, x?: number, y?: number) => any,
            enterQueryCb?: (lngLat: LngLatLike) => IPointQueryFeatures
        ): void;

        /**
         * 不使图层点击高亮
         * @param prefix 高亮图层名称前缀，缺省(highlight)
         */
        disableLayerClickHighlight(prefix?: string): boolean;

        /**
         * 是否是矢量图层
         */
        hasVectorLayer(): boolean;



        /**
         * 切换图层
         * @param svc 服务接口实例
         * @param visibleLayers 让可见的图层列表数组
         * @return {Promise<void>}
         */
        switchLayers(svc: Service, visibleLayers: string[]): Promise<any>;

        /**
         * 更新样式
         * @param svc 服务接口实例
         * @param param 样式参数
         * @param noInheritFromCurStyle 不从当前样式继承,默认false,继承
         * @return {Promise<any>}
         *
         */
         updateStyle(svc: Service, param: IUpdateStyle, noInheritFromCurStyle?: boolean): Promise<any>;

        /**
         * 更新地图范围，重新生成投影对象
         * @param extent
         */
        updateMapExtent(extent: string | [number, number, number, number] | GeoBounds): Projection;

        /**
         * 缩放至地图范围
         * @param bounds  bounds 地图范围或地图全图比例(缺省0.4)
         * @param options
         * - **`Object`?** 除了以下字段之外，Options 还支持[AnimationOptions][195]和[CameraOptions][194]中的所有属性。
         * - `options.padding` **( `number`| [PaddingOptions][196] )？**添加到给定边界的填充量（以像素为单位）。
         * - `options.linear` **`boolean`**如果`true`，则地图使用 `Map#easeTo 进行转换`。如果`false`，则地图使用`Map#flyTo 进行转换`。有关可用选项的信息，请参阅这些函数和[AnimationOptions][195]。（可选，默认`false`）
         * - `options.easing` **功能？**动画过渡的缓动函数。请参阅`动画选项`。
         * - `options.offset` **[PointLike][166]**相对于地图中心的给定边界的中心，以像素为单位。（可选，默认`[0,0]`）
         * - `options.maxZoom` **`number`?** 当地图视图转换到指定边界时允许的最大缩放级别。
         * - `options.fitFillClip` **`boolean`?** 默认为窗口包含地图，如果要使地图占满窗口超出的部分裁剪，请设置为true。
         * @param eventData
         * - `eventData` **`Object`?** 要添加到此方法触发的事件的事件对象的附加属性。
         * @return {this}
         */
        fitMapBounds(bounds?: number | GeoBounds, options?: Record<string, any>, eventData?: any): Map;

        /**
         * 得到地图的地理范围
         * @param ratio  缺省0.4
         */
        getGeoBounds(ratio?: number): GeoBounds;

        /**
         * 得到地图的地理范围, 方法同getGeoBounds,相当于getGeoBounds(1.0)
         */
        getMapExtent(): GeoBounds;


        /**
         * 得到地图的容器的像素大小，返回[宽，高]
         */
        getCanvasSize(): [number, number];

        /**
         * 得到地图的所有marker
         */
        getMarkers(): Marker[];

        /**
         * 得到地图的所有DivOverlay
         */
        getDivOverlays(): DivOverlay[];

        /**
         * 得到地图的所有SvgOverlay
         */
        getSvgOverlays(): SvgOverlay[];

        /**
         * 清除所有marker包括Text,divOverlays，会触发`removeMarkers`事件, noIncludeDivOverlay移除不包括divOverlays
         */
        removeMarkers(noIncludeDivOverlay?: boolean): any;

        /**
         * 清除所有popups，会触发`removePopups`事件
         */
        removePopups(): any;

        /**
         * 经纬度坐标转像素坐标，不会返回无效值
         * @param lnglat
         * @param altitude 高度值(m)
         */
        projectEx(lnglat: LngLatLike, altitude?: number): Point;

        /**
         * 创建Threejs上下文，请确保已加载其插件
         * @param Options
         */
        createThreeJsContext(Options: ThreeJsContextOptions): ThreeJsContext;

        /**
         * 像素长度转高度值
         * @param len 像素长度
         * @param zoom 缩放级别
         */
        pixelToHeight(len: number, zoom: number): number

        /**
         * 地理长度转高度值
         * @param len 像素长度
         */
        geoLengthToHeight(len: number): number

        /**
         * 像素长度转地理长度
         * @param len 像素长度
         * @param zoom 缩放级别
         */
        pixelToGeoLength(len: number, zoom: number): number

        /**
         * 地理长度转像素长度
         * @param len 地理长度
         * @param zoom 缩放级别
         */
        geoToPixelLength(len: number, zoom: number): number

        /**
         * 地理长度转墨卡托长度
         * @param len 地理长度
         * @return number 墨卡托长度
         */
         geoToMercatorLength(len: number): number;


        /**
         * 墨卡托长度转地理长度
         * @param len 墨卡托长度
         * @param number 地理长度
         */
         mercatorToGeoLength(len: number): number;

        /**
         * 设置自定义键值
         * @param key 键
         * @param value 值
         */
        setCustomKeyValue(key: string, value: any): void

        /**
         * 得到自定义键值
         * @param key 键
         */
        getCustomKeyValue(key: string): any


        /**
         * 设置地图打开是否有错误
         * @param value 值
         */
        setError(value: any): void

        /**
         * 得到地图打开是否有错误
         */
        getError(): any

        /**
         * 切换地图，请确保之前打开过地图,开始前触发`mapopenstart`事件，打开后触发`mapopenfinish`事件
         * @param param 打开选项
         * @param isKeepOldLayers 是否保留之前的图层数据，默认false
         * @param isVectorStyle 是否为矢量样式
         * @param isSetCenter 是否默认设置为地图中心点
         * @param isFitBounds 默认是否缩放
         * @param source 数据源id，如果修改了默认的栅格或瓦片source，需要传此参数
         */
        switchMap(param: IOpenMapParam, isKeepOldLayers?:boolean, isVectorStyle?:boolean, isSetCenter?: boolean, isFitBounds?: boolean, source?: string): Promise<any>;

        /**
         * 根据外包矩形创建 `GeoBounds`.
         *
         * Example:
         * ```typescript
         * const b = map.getEnvelopBounds('POLYGON((3466315.697899 6704304.297588, 3466315.697899 7784496.211226, 4546475.901198 7784496.211226, 4546475.901198 6704304.297588, 3466315.697899 6704304.297588))');
         * ```
         */
        getEnvelopBounds(envelop: string): GeoBounds;


        /**
         * 获取实体的外包矩形范围
         * @param input 实体坐标，可以是点序列或GeoJson数据
         * @param isLngLat 坐标是否为经纬度坐标，如果为true，内部将转为CAD地理坐标.默认false
         * @return CAD坐标矩形范围
         */
        getFeatureBounds<
            T extends
                    | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
            >(
            input: T,
            isLngLat?: boolean
        ): GeoBounds;

        /**
         * 是否正在交互
         */
         isInteracting(): boolean;

        /**
         * 设置是否正在交互
         */
         setIsInteracting(interacting: boolean): boolean;

        /**
         * 得到数据源ID的数据
         */
        getSourceData(sourceId: string): any;


        /**
         * 获取相机的位置
         * @param isMKT  是否返回墨卡托坐标，true（默认）墨卡托, false经纬度
         */
        getCameraPosition(isMKT?: boolean): LngLatLike


        /**
         * 得到绘制图层，不存在的话，将自动创建一个新的
         */
        getDrawLayer(options?: IDrawOptions): IDrawTool;

        /**
         * 创建一个新的绘制图层，每调用一次将自动创建一个
         */
        createDrawLayer(options?: IDrawOptions): IDrawTool;

        /**
         * 删除绘制图层,为空的话，将删除默认的由getDrawLayer创建的绘制图层
         */
        removeDrawLayer(layer?: IDrawTool): void;

        /**
         * 实体颜色转html颜色
         * @param color 实体颜色
         * @return {string}
         */
        entColorToHtmlColor(color: number): string

        /**
         * html颜色转实体颜色
         * @param color html 格式如 "#rrggbb"
         * @return {number}
         */
        htmlColorToEntColor(color: string): number

        /**
         * 加载image数据，可以是svg或base64图片
         * @param id id
         * @param data 数据
         * @param width 图片宽
         * @param height 图片高
         * @param options 选项
         * @return
         */
        addImageData(id: string, data: string, width: number, height: number, options?: Record<string, any>): Promise<any>


        /**
         * 根据数据库文档对象创建数据库几何数据，返回创建完的geojson
         * @param doc 数据库文档对象
         * @param isAutoUpdateMapExtent 是否根据返回的数据更新当前地图的范围
         * @param isDarkMode 是否深色背景，如不填，则用当前地图的
         * @param options cmdCreateEntitiesGeomData的选项
         * @param includeAttrSet 返回数据属性中需包含的属性项
         * @return {number}
         */
        createDbGeomData(doc: DbDocument, isAutoUpdateMapExtent?: boolean, isDarkMode?: boolean, options?: ICreateEntitiesGeomData, includeAttrSet?: string[]): Promise<any>

        

        /** 每当鼠标悬停在这些图层上时，将地图的光标设置为“指针”。
         @returns A function to remove the handler.
         * @param layerOrLayers
         */
        hoverPointer(layerOrLayers: LayerRef): void;

        /**
         每当将鼠标悬停在这些图层中的某个特征上时，更新连接源 [s] 中特征的特征状态。
         @param layer Layer(s) to add handler to.
         @param {string|Array} [source] Source whose features will be updated. If not provided, use the source defined for the layer.
         @param {string} [sourceLayer] Source layer (if using vector source)
         * @param enterCb
         * @param leaveCb
         */
        hoverFeatureState(
            layer: LayerRef,
            source?: string,
            sourceLayer?: string,
            enterCb?: (arg0: {}) => void,
            leaveCb?: (arg0: {}) => void
        ): void;

        /** 将鼠标悬停在这些图层中的某个要素上时，会显示一个弹出窗口。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param htmlFunc Function that receives feature and popup, returns HTML.
         @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
         @example hoverPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { anchor: 'left' });
         */
        hoverPopup(
            layers: LayerRef,
            htmlFunc: LayerCallback,
            popupOptions?: PopupOptions
        ): OffHandler;

        /** 每当单击这些图层中的要素时都会显示一个弹出窗口。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param htmlFunc Function that receives feature and popup, returns HTML.
         @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.

         @returns A function that removes the handler.
         @example clickPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { maxWidth: 500 });

         */
        clickPopup(
            layers: LayerRef,
            htmlFunc: (arg0: {}) => void,
            popupOptions?: PopupOptions
        ): OffHandler;

        /** 每当单击这些图层中的要素时都会触发回调。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param {function} cb Callback that receives event with .features property
         @returns A function that removes the handler.
         */
        clickLayer(layers: LayerRef, cb: LayerCallback): OffHandler;

        /**
         在给定的一系列图层中的第一个中检测单击，并触发回调。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param cb Callback, receives `{ event, layer, feature, features }`.
         @param noMatchCb Callback when a click happens that misses all these layers. Receives `{ event }`.
         @returns A function to remove the handler.
         */
        clickOneLayer(
            layerRef: LayerRef,
            cb: LayerCallback,
            noMatchCb: LayerCallback | null | undefined
        ): OffHandler;

        /** 当鼠标悬停在这些图层中的要素上时触发回调。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @returns A function to remove the handler.
         */
        hoverLayer(layers: LayerRef, cb: LayerCallback): OffHandler;

        /**
         * 增加一个图层，位于某图层之前
         * @param layerDef
         * @param beforeLayerId
         */
        mapAddLayerBefore(layerDef: LayerSpecification, beforeLayerId?: string): void;

        /** 添加一个图层，给定 id、来源、类型和属性。
         * @param id
         * @param source
         * @param type
         * @param props
         * @param before
         */
        addLayerEx(
            id: string,
            source: string,
            type: string,
            props: {},
            before: string | null | undefined
        ): SourceBoundUtils;

        /** 在某个图层之前添加一个图层，给定 id、来源、类型和属性。
         * @param id
         * @param source
         * @param type
         * @param props
         * @param before
         */
        addLayerBefore(
            id: string,
            source: SourceOrData,
            type: string,
            props: {},
            before?: string
        ): SourceBoundUtils | null | undefined;

        /**
         * 移除一个或多个图层
         * @param id
         */
        removeLayerEx(id: string | string[]): this;

        /**
         * 创建一个 GeoJSON 层。
         * @param id
         * @param geojson
         * @param props
         */
        addGeoJSONSource(
            id: string,
            geojson?: GeoJsonGeomertry,
            props?: GeoJSONSourceSpecification
        ): SourceBoundUtils;

        /**
         * 增加数据源
         * @param id
         * @param sourceDef
         */
        addSourceEx(id: string, sourceDef: SourceSpecification): SourceBoundUtils;

        /**
         * 获取一个数据源中的所有图层
         * @param source
         */
        layersBySource(source: string): string[];

        /**
         * 增加矢量数据源
         * @param sourceId
         * @param props
         * @param extraProps
         * @param data
         */
        addVectorSource(
            sourceId: string,
            props: object | string,
            extraProps: {},
            data?: string
        ): SourceBoundUtils;

        /**
         * 将 pascalCase 或 kebab-case 中的一组属性转换为具有布局和绘制属性的图层对象。
         * @param props
         */
        properties(props?: {}): {} | null | undefined;

        /**
         * layerStyle([id,] [source,] [type,] props)
         * @param args
         */
        layerStyle(...args: unknown[]): any;

        /**
         * 使给定的图层可见。
         * @param layer
         */
        show(layer: LayerRef): void;

        /**
         * 使给定的图层不可见。
         * @param layer
         */
        hide(layer: LayerRef): void;

        /** 根据参数使给定的图层隐藏或可见。
         @param {string|Array<string>|RegExp|function} Layer to toggle.
         @param {boolean} state True for visible, false for hidden.
         */
        toggle(Layer: LayerRef, state: boolean): boolean;

        /**
         * 使取决于给定源的所有图层可见。
         * @param source
         */
        showSource(source: string): void;

        /**
         * 使取决于给定源的所有图层不可见。
         * @param source
         */
        hideSource(source: string): void;

        /** 根据参数，使连接到给定源的给定层隐藏或可见.
         @param {string} sourceId Source[s] whose layers will be toggled.
         @param {boolean} state True for visible, false for hidden.*/
        toggleSource(sourceId: string, state: boolean): void;

        /**
         * 移除一个或多个源，首先移除所有依赖于它们的层。如果源不存在，则不会提示错误
         * @param source
         */
        removeSourceEx(source: string | string[]): void;

        /**
         * 地图加载时触发的回调，或者如果地图已经加载则立即触发
         * @param cb 回调函数,地图加载时触发的回调 或  boolean,设置为true,表示等待loaded为true才返回
         */
        onLoad(cb?: ((arg0: void) => void) | boolean): void | Promise<void>;

        /** 从 URL 添加用作符号图层的图像，url可以是一个图片svg字符串内容或者图片的base64。如果是svg或base64，请在第三个参数选项中设置图片width, height的值。
         @example loadImageEx('marker', '/assets/marker-pin@2x.png', { pixelRatio: 2}) 或 loadImageEx('marker2', '<svg>...<svg>', { width: 20, height:20}) 或 loadImageEx('marker3', 'data:image/png;base64,xxxx', { width: 20, height:20})
         */
        loadImageEx(id: string, url: string, options?: Record<string, any>): any;

        /**
         * 锁定方向
         */
        lockOrientation(): void;

        /**
         * 获取正在使用的字体名称数组，由遍历样式决定。不会在所有可能的情况下检测字体。
         */
        fontsInUse(): string[];

        /** 添加一个类型为“line”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addLineLayer(id: string, source: string, props: LineLayerStyleProp, before?: string): void;

        /** 添加一个类型为“fill”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addFillLayer(id: string, source: string, props: FillLayerStyleProp, before?: string): void;

        /** 添加一个类型为“circle”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addCircleLayer(
            id: string,
            source: string,
            props: CircleLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个类型为“符号”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addSymbolLayer(
            id: string,
            source: string,
            props: SymbolLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个类型为`video`的层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addVideoLayer(id: string, source: string, props: object, before?: string): void;

        /**添加一个类型为 `raster` 的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addRasterLayer(
            id: string,
            source: string,
            props: RasterLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个类型为“FillExtrusion”的层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addFillExtrusionLayer(
            id: string,
            source: string,
            props: FillExtrusionLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个类型为“Heatmap”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addHeatmapLayer(
            id: string,
            source: string,
            props: HeatmapLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个类型为“hillshade”的图层。
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addHillshadeLayer(
            id: string,
            source: string,
            props: HillshadeLayerStyleProp,
            before?: string
        ): void;

        /** 添加一个 `raster` 源
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addRasterSource(sourceId: string, props: RasterSourceSpecification): SourceBoundUtils;

        /** 添加一个 `raster-dem` 源
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addRasterDemSource(sourceId: string, props: RasterDEMSourceSpecification): SourceBoundUtils;

        /** 添加一个 `image` 源
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addImageSource(sourceId: string, props: ImageSourceSpecification): SourceBoundUtils;

        /** 添加“Video”源
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addVideoSource(sourceId: string, props: VideoSourceSpecification): SourceBoundUtils;

        /**
         * 设置图层属性
         * @param layerId
         * @param source
         * @param type
         * @param props
         * @param before
         */
        setLayer(
            layerId: string,
            source: string,
            type: string,
            props: SourceSpecification,
            before?: string
        ): SourceBoundUtils;

        /** 在一个或多个图层上设置绘制或布局属性。
         @example setProperty(['buildings-fill', 'parks-fill'], 'fillOpacity', 0.5)
         */
        setProperty(layer: LayerRef, prop: string | object, value?: PropValue): void;

        /** 根据样式规范，获取给定图层 ID 的图层定义。
         * @param layerId
         */
        getLayerStyle(layerId: string): LayerSpecification;

        /**
         * 设置图层样式
         * @param layer
         * @param style
         */
        setLayerStyle(
            layer:
                | LayerRef
                | {
                      id: string;
                  },
            style: {}
        ): void;

        /** 替换 GeoJSON 图层的当前数据。
         @param sourceId Id of the source being updated.
         @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
         */
        setData(sourceId: string, data?: GeoJsonGeomertry): void;

        /** 替换一个图层层或多图层的过滤器。
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param {Array} filter New filter to set.
         @example map.setFilterEx(['buildings-fill', 'buildings-outline', 'buildings-label'], ['==','level','0']]);
         */
        setFilterEx(layer: LayerRef, filter: FilterSpecification): void;

        /**
         * 设置图层至数据源
         * @param layerId
         * @param source
         * @param sourceLayer
         */
        setLayerSource(layerId: string, source: string, sourceLayer: string): void;

        /** 在样式的根上设置一个属性，例如 `light` 或 `transition`.
         * @param propName
         * @param val
         */
        setRootProperty(propName: string, val: PropValue): void;

        /** 设置过渡属性。
         @example setTransition({ duration: 500, delay: 100 })
         */
        setTransition(val: TransitionSpecification): void;

        /** 为一个或多个图层设置`fill-antialias` 绘制属性。 */
        setFillAntialias(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-opacity` 绘画属性。 */
        setFillOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-color` 绘画属性。 */
        setFillColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-outline-color` 绘画属性。*/
        setFillOutlineColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-translate` 绘制属性。 */
        setFillTranslate(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-translate-anchor` 绘制属性。 */
        setFillTranslateAnchor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`fill-pattern` 绘制属性。 */
        setFillPattern(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-opacity` 绘画属性。 */
        setFillExtrusionOpacity(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-color` 绘制属性。 */
        setFillExtrusionColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-translate` 绘制属性。 */
        setFillExtrusionTranslate(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-translate-anchor` 绘制属性。 */
        setFillExtrusionTranslateAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-pattern` 绘制属性。 */
        setFillExtrusionPattern(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-height` 绘制属性。 */
        setFillExtrusionHeight(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-base` 绘制属性。 */
        setFillExtrusionBase(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-extrusion-vertical-gradient`绘画属性。 */
        setFillExtrusionVerticalGradient(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`line-opacity` 绘制属性。 */
        setLineOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-color` 绘制属性。 */
        setLineColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-translate` 绘制属性。 */
        setLineTranslate(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-translate-anchor` 绘制属性。 */
        setLineTranslateAnchor(layer: LayerRef, value: any): void;

        /** 设置一个或多个图层的“线宽”绘制属性。 */
        setLineWidth(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`line-gap-width` 绘制属性。 */
        setLineGapWidth(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`line-offset` 绘制属性。 */
        setLineOffset(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-blur` 绘制属性。 */
        setLineBlur(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-dasharray` 绘制属性。 */
        setLineDasharray(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`line-pattern` 绘制属性。 */
        setLinePattern(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-gradient` 绘制属性。 */
        setLineGradient(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`circle-radius` 绘制属性。 */
        setCircleRadius(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`circle-color` 绘制属性。 */
        setCircleColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`circle-blur`绘画属性。 */
        setCircleBlur(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`circle-opacity` 绘制属性。 */
        setCircleOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `circle-translate` 绘制属性。 */
        setCircleTranslate(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `circle-translate-anchor` 绘制属性。 */
        setCircleTranslateAnchor(layer: LayerRef, value: any): void;

        /** 设置一个或多个图层的“circle-pitch-scale”绘制属性。 */
        setCirclePitchScale(layer: LayerRef, value: any): void;

        /** 为一层或多层设置“circle-pitch-alignment”绘制属性。 */
        setCirclePitchAlignment(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`circle-stroke-width` 绘制属性。 */
        setCircleStrokeWidth(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`circle-stroke-color` 绘画属性。 */
        setCircleStrokeColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`circle-stroke-opacity` 绘画属性。 */
        setCircleStrokeOpacity(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`heatmap-radius` 绘制属性。 */
        setHeatmapRadius(layer: LayerRef, value: any): void;

        /** 为一层或多层设置“热图权重”绘制属性。 */
        setHeatmapWeight(layer: LayerRef, value: any): void;

        /** 为一层或多层设置“热图强度”绘制属性。 */
        setHeatmapIntensity(layer: LayerRef, value: any): void;

        /** 为一层或多层设置“热图颜色”绘制属性。 */
        setHeatmapColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`heatmap-opacity` 绘制属性。 */
        setHeatmapOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`icon-opacity` 绘制属性。 */
        setIconOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`icon-color` 绘制属性。 */
        setIconColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-halo-color` 绘制属性。 */
        setIconHaloColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-halo-width` 绘制属性。 */
        setIconHaloWidth(layer: LayerRef, value: any): void;

        /** 为一层或多层设置 `icon-halo-blur` 绘制属性。 */
        setIconHaloBlur(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-translate` 绘制属性。 */
        setIconTranslate(layer: LayerRef, value: any): void;

        /** 为一层或多层设置 `icon-translate-anchor` 绘制属性。 */
        setIconTranslateAnchor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-opacity` 绘制属性。 */
        setTextOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-color` 绘制属性。 */
        setTextColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-halo-color` 绘制属性。 */
        setTextHaloColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-halo-width` 绘制属性。 */
        setTextHaloWidth(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-halo-blur` 绘制属性。 */
        setTextHaloBlur(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-translate` 绘制属性。 */
        setTextTranslate(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-translate-anchor` 绘制属性。 */
        setTextTranslateAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-opacity` 绘制属性。 */
        setRasterOpacity(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-hue-rotate` 绘制属性。 */
        setRasterHueRotate(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-monochrome` 绘制属性。 */
        setRasterMonochrome(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-inverse` 绘制属性。 */
        setRasterInverse(layer: LayerRef, value: any): void;

        /** 为一层或多层设置 `raster-brightness-min` 绘制属性。 */
        setRasterBrightnessMin(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-brightness-max` 绘制属性。 */
        setRasterBrightnessMax(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-saturation` 绘制属性。 */
        setRasterSaturation(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-contrast` 绘制属性。 */
        setRasterContrast(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`raster-resampling` 绘制属性。 */
        setRasterResampling(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`raster-fade-duration` 绘制属性。 */
        setRasterFadeDuration(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`hillshade-illumination-direction` 绘制属性。 */
        setHillshadeIlluminationDirection(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`hillshade-illumination-anchor` 绘制属性。 */
        setHillshadeIlluminationAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`hillshade-exaggeration` 绘制属性。 */
        setHillshadeExaggeration(layer: LayerRef, value: any): void;

        /** 为一层或多层设置 `hillshade-shadow-color` 绘制属性。 */
        setHillshadeShadowColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`hillshade-highlight-color` 绘制属性。 */
        setHillshadeHighlightColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`hillshade-accent-color` 绘制属性。 */
        setHillshadeAccentColor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`background-color` 绘制属性。 */
        setBackgroundColor(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`background-pattern` 绘制属性。 */
        setBackgroundPattern(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`background-opacity` 绘制属性。 */
        setBackgroundOpacity(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置“可见性”布局属性。 */
        setVisibility(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`fill-sort-key`布局属性。 */
        setFillSortKey(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `circle-sort-key` 布局属性。 */
        setCircleSortKey(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `line-cap` 布局属性。 */
        setLineCap(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置“line-join”布局属性。 */
        setLineJoin(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置“line-miter-limit”布局属性。 */
        setLineMiterLimit(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`line-round-limit`布局属性。 */
        setLineRoundLimit(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`line-sort-key`布局属性。 */
        setLineSortKey(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `symbol-placement` 布局属性。 */
        setSymbolPlacement(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `symbol-spacing` 布局属性。 */
        setSymbolSpacing(layer: LayerRef, value: any): void;

        /** 为一层或多层设置 `symbol-avoid-edges` 布局属性。 */
        setSymbolAvoidEdges(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `symbol-sort-key` 布局属性。 */
        setSymbolSortKey(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `symbol-z-order` 布局属性。 */
        setSymbolZOrder(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-allow-overlap`布局属性。 */
        setIconAllowOverlap(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`icon-ignore-placement` 布局属性。 */
        setIconIgnorePlacement(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`icon-optional` 布局属性。 */
        setIconOptional(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`icon-rotation-alignment` 布局属性。 */
        setIconRotationAlignment(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-size`布局属性。 */
        setIconSize(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-text-fit`布局属性。 */
        setIconTextFit(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-text-fit-padding`布局属性。 */
        setIconTextFitPadding(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-image`布局属性。 */
        setIconImage(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-rotate`布局属性。 */
        setIconRotate(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-padding`布局属性。 */
        setIconPadding(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-keep-upright`布局属性。 */
        setIconKeepUpright(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-offset`布局属性。 */
        setIconOffset(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-anchor`布局属性。 */
        setIconAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`icon-pitch-alignment`布局属性。 */
        setIconPitchAlignment(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-pitch-alignment` 布局属性。 */
        setTextPitchAlignment(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-rotation-alignment` 布局属性。 */
        setTextRotationAlignment(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-field` 布局属性。 */
        setTextField(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-font` 布局属性。 */
        setTextFont(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-size` 布局属性。 */
        setTextSize(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-max-width`布局属性。 */
        setTextMaxWidth(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-line-height`布局属性。 */
        setTextLineHeight(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-letter-spacing`布局属性。 */
        setTextLetterSpacing(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-justify` 布局属性。 */
        setTextJustify(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-radial-offset`布局属性。 */
        setTextRadialOffset(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-variable-anchor`布局属性。 */
        setTextVariableAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-anchor`布局属性。 */
        setTextAnchor(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-max-angle`布局属性。 */
        setTextMaxAngle(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-writing-mode` 布局属性。 */
        setTextWritingMode(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-rotate` 布局属性。 */
        setTextRotate(layer: LayerRef, value: any): void;

        /** 为一层或多层设置`text-padding`布局属性。 */
        setTextPadding(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-keep-upright` 布局属性。 */
        setTextKeepUpright(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-transform` 布局属性。 */
        setTextTransform(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置 `text-offset` 布局属性。 */
        setTextOffset(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-allow-overlap` 布局属性。 */
        setTextAllowOverlap(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-ignore-placement` 布局属性。 */
        setTextIgnorePlacement(layer: LayerRef, value: any): void;

        /** 为一个或多个图层设置`text-optional` 布局属性。 */
        setTextOptional(layer: LayerRef, value: any): void;

        /** 获取图层的“填充抗锯齿”绘制属性。 */
        getFillAntialias(layer: LayerRef): any;

        /** 获取图层的 `fill-opacity` 绘制属性。 */
        getFillOpacity(layer: LayerRef): any;

        /** 获取图层的 `fill-color` 绘制属性。 */
        getFillColor(layer: LayerRef): any;

        /** 获取图层的 `fill-outline-color` 绘制属性。 */
        getFillOutlineColor(layer: LayerRef): any;

        /** 获取图层的 `fill-translate` 绘制属性。 */
        getFillTranslate(layer: LayerRef): any;

        /** 获取图层的 `fill-translate-anchor` 绘制属性。 */
        getFillTranslateAnchor(layer: LayerRef): any;

        /** 获取图层的`fill-pattern` 绘制属性。 */
        getFillPattern(layer: LayerRef): any;

        /** 获取图层的 `fill-extrusion-opacity` 绘画属性。 */
        getFillExtrusionOpacity(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-color` 绘画属性。 */
        getFillExtrusionColor(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-translate` 绘制属性。 */
        getFillExtrusionTranslate(layer: LayerRef): any;

        /** 获取图层的 `fill-extrusion-translate-anchor` 绘制属性。 */
        getFillExtrusionTranslateAnchor(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-pattern` 绘制属性。 */
        getFillExtrusionPattern(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-height` 绘制属性。*/
        getFillExtrusionHeight(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-base` 绘画属性。 */
        getFillExtrusionBase(layer: LayerRef): any;

        /** 获取图层的`fill-extrusion-vertical-gradient` 绘制属性。*/
        getFillExtrusionVerticalGradient(layer: LayerRef): any;

        /** 获取图层的 `line-opacity` 绘制属性。 */
        getLineOpacity(layer: LayerRef): any;

        /** 获取图层的 `line-color` 绘制属性。 */
        getLineColor(layer: LayerRef): any;

        /** 获取图层的 `line-translate` 绘制属性。 */
        getLineTranslate(layer: LayerRef): any;

        /** 获取图层的 `line-translate-anchor` 绘制属性。 */
        getLineTranslateAnchor(layer: LayerRef): any;

        /** 获取图层的“线宽”绘制属性。 */
        getLineWidth(layer: LayerRef): any;

        /** 获取图层的 `line-gap-width` 绘制属性。 */
        getLineGapWidth(layer: LayerRef): any;

        /** 获取图层的 `line-offset` 绘制属性。 */
        getLineOffset(layer: LayerRef): any;

        /** 获取图层的 `line-blur` 绘制属性。 */
        getLineBlur(layer: LayerRef): any;

        /** 获取图层的 `line-dasharray` 绘制属性。 */
        getLineDasharray(layer: LayerRef): any;

        /** 获取图层的 `line-pattern` 绘制属性。 */
        getLinePattern(layer: LayerRef): any;

        /** 获取图层的 `line-gradient` 绘制属性。 */
        getLineGradient(layer: LayerRef): any;

        /** 获取图层的 `circle-radius` 绘制属性。 */
        getCircleRadius(layer: LayerRef): any;

        /** 获取图层的 `circle-color` 绘制属性。 */
        getCircleColor(layer: LayerRef): any;

        /** 获取图层的 `circle-blur` 绘制属性。*/
        getCircleBlur(layer: LayerRef): any;

        /** 获取图层的 `circle-opacity` 绘制属性。 */
        getCircleOpacity(layer: LayerRef): any;

        /** 获取图层的 `circle-translate` 绘制属性。 */
        getCircleTranslate(layer: LayerRef): any;

        /** 获取图层的 `circle-translate-anchor` 绘制属性。 */
        getCircleTranslateAnchor(layer: LayerRef): any;

        /** 获取图层的 `circle-pitch-scale` 绘制属性。 */
        getCirclePitchScale(layer: LayerRef): any;

        /** 获取图层的 `circle-pitch-alignment` 绘制属性。 */
        getCirclePitchAlignment(layer: LayerRef): any;

        /** 获取图层的 `circle-stroke-width` 绘制属性。 */
        getCircleStrokeWidth(layer: LayerRef): any;

        /** 获取图层的 `circle-stroke-color` 绘画属性。 */
        getCircleStrokeColor(layer: LayerRef): any;

        /** Gets the `circle-stroke-opacity`  绘图属性. */
        getCircleStrokeOpacity(layer: LayerRef): any;

        /** Gets the `heatmap-radius`  绘图属性. */
        getHeatmapRadius(layer: LayerRef): any;

        /** Gets the `heatmap-weight`  绘图属性. */
        getHeatmapWeight(layer: LayerRef): any;

        /** Gets the `heatmap-intensity`  绘图属性. */
        getHeatmapIntensity(layer: LayerRef): any;

        /** Gets the `heatmap-color`  绘图属性. */
        getHeatmapColor(layer: LayerRef): any;

        /** Gets the `heatmap-opacity`  绘图属性. */
        getHeatmapOpacity(layer: LayerRef): any;

        /** Gets the `icon-opacity`  绘图属性. */
        getIconOpacity(layer: LayerRef): any;

        /** Gets the `icon-color`  绘图属性. */
        getIconColor(layer: LayerRef): any;

        /** Gets the `icon-halo-color`  绘图属性. */
        getIconHaloColor(layer: LayerRef): any;

        /** Gets the `icon-halo-width`  绘图属性. */
        getIconHaloWidth(layer: LayerRef): any;

        /** Gets the `icon-halo-blur`  绘图属性. */
        getIconHaloBlur(layer: LayerRef): any;

        /** Gets the `icon-translate`  绘图属性. */
        getIconTranslate(layer: LayerRef): any;

        /** Gets the `icon-translate-anchor`  绘图属性. */
        getIconTranslateAnchor(layer: LayerRef): any;

        /** Gets the `text-opacity`  绘图属性. */
        getTextOpacity(layer: LayerRef): any;

        /** Gets the `text-color`  绘图属性. */
        getTextColor(layer: LayerRef): any;

        /** Gets the `text-halo-color`  绘图属性. */
        getTextHaloColor(layer: LayerRef): any;

        /** Gets the `text-halo-width`  绘图属性. */
        getTextHaloWidth(layer: LayerRef): any;

        /** Gets the `text-halo-blur`  绘图属性. */
        getTextHaloBlur(layer: LayerRef): any;

        /** Gets the `text-translate`  绘图属性. */
        getTextTranslate(layer: LayerRef): any;

        /** Gets the `text-translate-anchor`  绘图属性. */
        getTextTranslateAnchor(layer: LayerRef): any;

        /** Gets the `raster-opacity`  绘图属性. */
        getRasterOpacity(layer: LayerRef): any;

        /** Gets the `raster-hue-rotate`  绘图属性. */
        getRasterHueRotate(layer: LayerRef): any;

        /** 获取图层的`raster-brightness-min`  绘图属性. */
        getRasterBrightnessMin(layer: LayerRef): any;

        /** 获取图层的`raster-brightness-max`  绘图属性. */
        getRasterBrightnessMax(layer: LayerRef): any;

        /** 获取图层的`raster-saturation`  绘图属性. */
        getRasterSaturation(layer: LayerRef): any;

        /** 获取图层的`raster-contrast`  绘图属性. */
        getRasterContrast(layer: LayerRef): any;

        /** 获取图层的`raster-resampling`  绘图属性. */
        getRasterResampling(layer: LayerRef): any;

        /** 获取图层的`raster-fade-duration`  绘图属性. */
        getRasterFadeDuration(layer: LayerRef): any;

        /** 获取图层的`hillshade-illumination-direction`  绘图属性. */
        getHillshadeIlluminationDirection(layer: LayerRef): any;

        /** 获取图层的`hillshade-illumination-anchor`  绘图属性. */
        getHillshadeIlluminationAnchor(layer: LayerRef): any;

        /** 获取图层的`hillshade-exaggeration`  绘图属性. */
        getHillshadeExaggeration(layer: LayerRef): any;

        /** 获取图层的`hillshade-shadow-color`  绘图属性. */
        getHillshadeShadowColor(layer: LayerRef): any;

        /** 获取图层的`hillshade-highlight-color`  绘图属性. */
        getHillshadeHighlightColor(layer: LayerRef): any;

        /** 获取图层的`hillshade-accent-color`  绘图属性. */
        getHillshadeAccentColor(layer: LayerRef): any;

        /** 获取图层的`background-color`  绘图属性. */
        getBackgroundColor(layer: LayerRef): any;

        /** 获取图层的`background-pattern`  绘图属性. */
        getBackgroundPattern(layer: LayerRef): any;

        /** 获取图层的`background-opacity`  绘图属性. */
        getBackgroundOpacity(layer: LayerRef): any;

        /** 获取图层的`visibility` 布局属性. */
        getVisibility(layer: LayerRef): any;

        /** 获取图层的`fill-sort-key` 布局属性. */
        getFillSortKey(layer: LayerRef): any;

        /** 获取图层的`circle-sort-key` 布局属性. */
        getCircleSortKey(layer: LayerRef): any;

        /** 获取图层的`line-cap` 布局属性. */
        getLineCap(layer: LayerRef): any;

        /** 获取图层的`line-join` 布局属性. */
        getLineJoin(layer: LayerRef): any;

        /** 获取图层的`line-miter-limit` 布局属性. */
        getLineMiterLimit(layer: LayerRef): any;

        /** 获取图层的`line-round-limit` 布局属性. */
        getLineRoundLimit(layer: LayerRef): any;

        /** 获取图层的`line-sort-key` 布局属性. */
        getLineSortKey(layer: LayerRef): any;

        /** 获取图层的`symbol-placement` 布局属性. */
        getSymbolPlacement(layer: LayerRef): any;

        /** 获取图层的 `symbol-spacing` 布局属性。 */
        getSymbolSpacing(layer: LayerRef): any;

        /** 获取图层的 `symbol-avoid-edges` 布局属性。 */
        getSymbolAvoidEdges(layer: LayerRef): any;

        /** 获取图层的 `symbol-sort-key` 布局属性。 */
        getSymbolSortKey(layer: LayerRef): any;

        /** 获取图层的 `symbol-z-order` 布局属性。 */
        getSymbolZOrder(layer: LayerRef): any;

        /** 获取图层的`icon-allow-overlap` 布局属性。 */
        getIconAllowOverlap(layer: LayerRef): any;

        /** 获取图层的`icon-ignore-placement` 布局属性。 */
        getIconIgnorePlacement(layer: LayerRef): any;

        /** 获取图层的`icon-optional` 布局属性。 */
        getIconOptional(layer: LayerRef): any;

        /** 获取图层的`icon-rotation-alignment` 布局属性。 */
        getIconRotationAlignment(layer: LayerRef): any;

        /** 获取图层的`icon-size` 布局属性。 */
        getIconSize(layer: LayerRef): any;

        /** 获取图层的`icon-text-fit` 布局属性。 */
        getIconTextFit(layer: LayerRef): any;

        /** 获取图层的`icon-text-fit-padding`布局属性。 */
        getIconTextFitPadding(layer: LayerRef): any;

        /** 获取图层的`icon-image` 布局属性。 */
        getIconImage(layer: LayerRef): any;

        /** 获取图层的`icon-rotate` 布局属性。 */
        getIconRotate(layer: LayerRef): any;

        /** 获取图层的`icon-padding`布局属性。 */
        getIconPadding(layer: LayerRef): any;

        /** 获取图层的 `icon-keep-upright` 布局属性。 */
        getIconKeepUpright(layer: LayerRef): any;

        /** 获取图层的`icon-offset`布局属性。 */
        getIconOffset(layer: LayerRef): any;

        /** 获取图层的`icon-anchor` 布局属性。 */
        getIconAnchor(layer: LayerRef): any;

        /** 获取图层的`icon-pitch-alignment` 布局属性。*/
        getIconPitchAlignment(layer: LayerRef): any;

        /** 获取图层的 `text-pitch-alignment` 布局属性。 */
        getTextPitchAlignment(layer: LayerRef): any;

        /**获取图层的 `text-rotation-alignment` 布局属性。 */
        getTextRotationAlignment(layer: LayerRef): any;

        /** 获取图层的“文本字段”布局属性。 */
        getTextField(layer: LayerRef): any;

        /** 获取图层的 `text-font` 布局属性。 */
        getTextFont(layer: LayerRef): any;

        /** 获取图层的 `text-size` 布局属性。 */
        getTextSize(layer: LayerRef): any;

        /** 获取图层的 `text-max-width` 布局属性。*/
        getTextMaxWidth(layer: LayerRef): any;

        /** 获取图层的 `text-line-height` 布局属性。*/
        getTextLineHeight(layer: LayerRef): any;

        /** 获取图层的 `text-letter-spacing` 布局属性。 */
        getTextLetterSpacing(layer: LayerRef): any;

        /** 获取图层的 `text-justify` 布局属性。 */
        getTextJustify(layer: LayerRef): any;

        /** 获取图层的 `text-radial-offset` 布局属性。 */
        getTextRadialOffset(layer: LayerRef): any;

        /** 获取图层的 `text-variable-anchor` 布局属性。 */
        getTextVariableAnchor(layer: LayerRef): any;

        /** 获取图层的 `text-anchor` 布局属性。*/
        getTextAnchor(layer: LayerRef): any;

        /** 获取图层的 `text-max-angle` 布局属性。 */
        getTextMaxAngle(layer: LayerRef): any;

        /** 获取图层的 `text-writing-mode` 布局属性。 */
        getTextWritingMode(layer: LayerRef): any;

        /** 获取图层的 `text-rotate` 布局属性。 */
        getTextRotate(layer: LayerRef): any;

        /** 获取图层的 `text-padding` 布局属性。 */
        getTextPadding(layer: LayerRef): any;

        /** 获取图层的 `text-keep-upright` 布局属性。 */
        getTextKeepUpright(layer: LayerRef): any;

        /** 获取图层的 `text-transform` 布局属性。 */
        getTextTransform(layer: LayerRef): any;

        /** 获取图层的 `text-offset` 布局属性。 */
        getTextOffset(layer: LayerRef): any;

        /** 获取图层的 `text-allow-overlap` 布局属性。 */
        getTextAllowOverlap(layer: LayerRef): any;

        /** 获取图层的 `text-ignore-placement` 布局属性。 */
        getTextIgnorePlacement(layer: LayerRef): any;

        /** 获取图层的 `text-optional` 布局属性。 */
        getTextOptional(layer: LayerRef): any;

        

        addControl(
            control: Control | IControl,
            position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left',
        ): this;

        removeControl(control: Control | IControl): this;

        /**
         * Checks if a control exists on the map.
         *
         * @param {IControl} control The {@link IControl} to check.
         * @returns {boolean} True if map contains control.
         * @example
         */
        hasControl(control: IControl): boolean;

        resize(eventData?: EventData): this;

        getBounds(): LngLatBounds;

        getMaxBounds(): LngLatBounds | null;

        setMaxBounds(lnglatbounds?: LngLatBoundsLike): this;

        setMinZoom(minZoom?: number | null): this;

        getMinZoom(): number;

        setMaxZoom(maxZoom?: number | null): this;

        getMaxZoom(): number;

        setMinPitch(minPitch?: number | null): this;

        getMinPitch(): number;

        setMaxPitch(maxPitch?: number | null): this;

        getMaxPitch(): number;

        getRenderWorldCopies(): boolean;

        setRenderWorldCopies(renderWorldCopies?: boolean): this;

        project(lnglat: LngLatLike): vjmap.Point;

        unproject(point: PointLike): vjmap.LngLat;

        isMoving(): boolean;

        isZooming(): boolean;

        isRotating(): boolean;

        /**
         * Returns an array of GeoJSON Feature objects representing visible features that satisfy the query parameters.
         *
         * The properties value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only string and numeric property values are supported (i.e. null, Array, and Object values are not supported).
         *
         * Each feature includes top-level layer, source, and sourceLayer properties. The layer property is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
         *
         * Only features that are currently rendered are included. Some features will not be included, like:
         *
         * - Features from layers whose visibility property is "none".
         * - Features from layers whose zoom range excludes the current zoom level.
         * - Symbol features that have been hidden due to text or icon collision.
         *
         * Features from all other layers are included, including features that may have no visible contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to 0.
         *
         * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low zoom levels) are returned only once (though subject to the following caveat).
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param pointOrBox The geometry of the query region: either a single point or southwest and northeast points describing a bounding box. Omitting this parameter (i.e. calling Map#queryRenderedFeatures with zero arguments, or with only a  options argument) is equivalent to passing a bounding box encompassing the entire map viewport.
         * @param options
         */
        queryRenderedFeatures(
            pointOrBox?: PointLike | [PointLike, PointLike],
            options?: { layers?: string[] | undefined; filter?: any[] | undefined } & FilterOptions,
        ): MapGeoJSONFeature[];

        /**
         * Returns an array of GeoJSON Feature objects representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
         *
         * In contrast to Map#queryRenderedFeatures, this function returns all features matching the query parameters, whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently visible viewport.
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param sourceID The ID of the vector tile or GeoJSON source to query.
         * @param parameters
         */
        querySourceFeatures(
            sourceID: string,
            parameters?: {
                sourceLayer?: string | undefined;
                filter?: any[] | undefined;
            } & FilterOptions,
        ): MapGeoJSONFeature[];

        setStyle(
            style: vjmap.Style | string,
            options?: { diff?: boolean | undefined; localIdeographFontFamily?: string | undefined },
        ): this;

        getStyle(): vjmap.Style;

        isStyleLoaded(): boolean;

        addSource(id: string, source: AnySourceData): this;

        isSourceLoaded(id: string): boolean;

        areTilesLoaded(): boolean;

        removeSource(id: string): this;

        getSource(id: string): AnySourceImpl;

        addImage(
            name: string,
            image:
                | HTMLImageElement
                | ArrayBufferView
                | { width: number; height: number; data: Uint8Array | Uint8ClampedArray }
                | ImageData
                | ImageBitmap,
            options?: { pixelRatio?: number | undefined; sdf?: boolean | undefined },
        ): void;

        updateImage(
            name: string,
            image:
                | HTMLImageElement
                | ArrayBufferView
                | { width: number; height: number; data: Uint8Array | Uint8ClampedArray }
                | ImageData
                | ImageBitmap,
        ): void;

        hasImage(name: string): boolean;

        removeImage(name: string): void;

        loadImage(url: string, callback: (error?: Error, result?: HTMLImageElement | ImageBitmap) => void): void;

        listImages(): string[];

        addLayer(layer: vjmap.AnyLayer, before?: string): this;

        moveLayer(id: string, beforeId?: string): this;

        removeLayer(id: string): this;

        getLayer(id: string): vjmap.AnyLayer;

        setFilter(layer: string, filter?: any[] | boolean | null, options?: FilterOptions | null): this;

        setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this;

        getFilter(layer: string): any[];

        setPaintProperty(layer: string, name: string, value: any, klass?: string): this;

        getPaintProperty(layer: string, name: string): any;

        setLayoutProperty(layer: string, name: string, value: any): this;

        getLayoutProperty(layer: string, name: string): any;

        setLight(options: vjmap.Light, lightOptions?: any): this;

        getLight(): vjmap.Light;

        /**
         * Sets the terrain property of the style.
         *
         * @param terrain Terrain properties to set. Must conform to the [Map Style Specification](https://www.Map.com/Map-gl-style-spec/#terrain).
         * If `null` or `undefined` is provided, function removes terrain.
         * @returns {Map} `this`
         * @example
         * map.addSource('Map-dem', {
         *     'type': 'raster-dem',
         *     'url': 'Map://Map.Map-terrain-dem-v1',
         *     'tileSize': 512,
         *     'maxzoom': 14
         * });
         * // add the DEM source as a terrain layer with exaggerated height
         * map.setTerrain({ 'source': 'Map-dem', 'exaggeration': 1.5 });
         */
        setTerrain(terrain?: TerrainSpecification | null): this;

        getTerrain(): TerrainSpecification | null;

        showTerrainWireframe: boolean;

        /**
         *
         * @param lngLat The coordinate to query
         * @param options Optional {ElevationQueryOptions}
         * @returns The elevation in meters at mean sea level or null
         */
        queryTerrainElevation(lngLat: LngLatLike, options?: ElevationQueryOptions): number | null;

        setFeatureState(
            feature: FeatureIdentifier | vjmap.MapGeoJSONFeature,
            state: { [key: string]: any },
        ): void;

        getFeatureState(feature: FeatureIdentifier | vjmap.MapGeoJSONFeature): { [key: string]: any };

        removeFeatureState(target: FeatureIdentifier | vjmap.MapGeoJSONFeature, key?: string): void;

        getContainer(): HTMLElement;

        getCanvasContainer(): HTMLElement;

        getCanvas(): HTMLCanvasElement;

        loaded(): boolean;

        remove(): void;

        triggerRepaint(): void;

        showTileBoundaries: boolean;

        showCollisionBoxes: boolean;

        /**
         * Gets and sets a Boolean indicating whether the map will visualize
         * the padding offsets.
         *
         * @name showPadding
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        showPadding: boolean;

        repaint: boolean;

        getCenter(): vjmap.LngLat;

        setCenter(center: LngLatLike, eventData?: vjmap.EventData): this;

        panBy(offset: PointLike, options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        panTo(lnglat: LngLatLike, options?: vjmap.AnimationOptions, eventdata?: vjmap.EventData): this;

        getZoom(): number;

        setZoom(zoom: number, eventData?: vjmap.EventData): this;

        zoomTo(zoom: number, options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        zoomIn(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        zoomOut(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        getBearing(): number;

        setBearing(bearing: number, eventData?: vjmap.EventData): this;

        /**
         * Returns the current padding applied around the map viewport.
         *
         * @memberof Map#
         * @returns The current padding around the map viewport.
         */
        getPadding(): PaddingOptions;

        /**
         * Sets the padding in pixels around the viewport.
         *
         * Equivalent to `jumpTo({padding: padding})`.
         *
         * @memberof Map#
         * @param padding The desired padding. Format: { left: number, right: number, top: number, bottom: number }
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * // Sets a left padding of 300px, and a top padding of 50px
         * map.setPadding({ left: 300, top: 50 });
         */
        setPadding(padding: PaddingOptions, eventData?: EventData): this;

        rotateTo(bearing: number, options?: vjmap.AnimationOptions, eventData?: EventData): this;

        resetNorth(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        resetNorthPitch(options?: vjmap.AnimationOptions | null, eventData?: vjmap.EventData | null): this;

        snapToNorth(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        getPitch(): number;

        setPitch(pitch: number, eventData?: EventData): this;

        cameraForBounds(bounds: LngLatBoundsLike, options?: CameraForBoundsOptions): CameraForBoundsResult | undefined;

        fitBounds(bounds: LngLatBoundsLike, options?: vjmap.FitBoundsOptions, eventData?: vjmap.EventData): this;

        fitScreenCoordinates(
            p0: PointLike,
            p1: PointLike,
            bearing: number,
            options?: AnimationOptions & CameraOptions,
            eventData?: EventData,
        ): this;

        jumpTo(options: vjmap.CameraOptions, eventData?: vjmap.EventData): this;

        /**
         * Returns position and orientation of the camera entity.
         *
         * @memberof Map#
         * @returns {FreeCameraOptions} The camera state
         */
        getFreeCameraOptions(): FreeCameraOptions;

        /**
         * FreeCameraOptions provides more direct access to the underlying camera entity.
         * For backwards compatibility the state set using this API must be representable with
         * `CameraOptions` as well. Parameters are clamped into a valid range or discarded as invalid
         * if the conversion to the pitch and bearing presentation is ambiguous. For example orientation
         * can be invalid if it leads to the camera being upside down, the quaternion has zero length,
         * or the pitch is over the maximum pitch limit.
         *
         * @memberof Map#
         * @param {FreeCameraOptions} options FreeCameraOptions object
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires pitchstart
         * @fires rotate
         * @fires move
         * @fires zoom
         * @fires pitch
         * @fires moveend
         * @fires zoomend
         * @fires pitchend
         * @returns {Map} `this`
         */
        setFreeCameraOptions(options: FreeCameraOptions, eventData?: Object): this;

        easeTo(options: vjmap.EaseToOptions, eventData?: vjmap.EventData): this;

        flyTo(options: vjmap.FlyToOptions, eventData?: vjmap.EventData): this;

        isEasing(): boolean;

        stop(): this;

        on<T extends keyof MapLayerEventType>(
            type: T,
            layer: string | ReadonlyArray<string>,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        on<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        on(type: string, listener: (ev: any) => void): this;

        once<T extends keyof MapLayerEventType>(
            type: T,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        once<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        once(type: string, listener: (ev: any) => void): this;
        once<T extends keyof MapEventType>(type: T): Promise<MapEventType[T]>;

        off<T extends keyof MapLayerEventType>(
            type: T,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        off<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        off(type: string, listener: (ev: any) => void): this;

        scrollZoom: ScrollZoomHandler;

        boxZoom: BoxZoomHandler;

        dragRotate: DragRotateHandler;

        dragPan: DragPanHandler;

        keyboard: KeyboardHandler;

        doubleClickZoom: DoubleClickZoomHandler;

        touchZoomRotate: TouchZoomRotateHandler;

        touchPitch: TouchPitchHandler;

        getFog(): Fog | null;
        setFog(fog: Fog): this;
    }

    export interface MapOptions {
        /**
         * If true, the gl context will be created with MSA antialiasing, which can be useful for antialiasing custom layers.
         * This is false by default as a performance optimization.
         */
        antialias?: boolean | undefined;

        /** If true, an attribution control will be added to the map. */
        attributionControl?: boolean | undefined;

        bearing?: number | undefined;

        /** Snap to north threshold in degrees. */
        bearingSnap?: number | undefined;

        /** The initial bounds of the map. If bounds is specified, it overrides center and zoom constructor options. */
        bounds?: LngLatBoundsLike | undefined;

        /** If true, enable the "box zoom" interaction (see BoxZoomHandler) */
        boxZoom?: boolean | undefined;

        /** initial map center */
        center?: LngLatLike | undefined;

        /**
         * The max number of pixels a user can shift the mouse pointer during a click for it to be
         * considered a valid click (as opposed to a mouse drag).
         *
         * @default 3
         */
        clickTolerance?: number | undefined;

        /**
         * If `true`, Resource Timing API information will be collected for requests made by GeoJSON
         * and Vector Tile web workers (this information is normally inaccessible from the main
         * Javascript thread). Information will be returned in a `resourceTiming` property of
         * relevant `data` events.
         *
         * @default false
         */
        collectResourceTiming?: boolean | undefined;

        /**
         * If `true`, symbols from multiple sources can collide with each other during collision
         * detection. If `false`, collision detection is run separately for the symbols in each source.
         *
         * @default true
         */
        crossSourceCollisions?: boolean | undefined;

        /** ID of the container element */
        container: string | HTMLElement;

        /**
         * If `true` , scroll zoom will require pressing the ctrl or ⌘ key while scrolling to zoom map,
         * and touch pan will require using two fingers while panning to move the map.
         * Touch pitch will require three fingers to activate if enabled.
         */
        cooperativeGestures?: boolean;

        /** String or strings to show in an AttributionControl.
         * Only applicable if options.attributionControl is `true`. */
        customAttribution?: string | string[] | undefined;

        /**
         * If `true`, the "drag to pan" interaction is enabled.
         * An `Object` value is passed as options to {@link DragPanHandler#enable}.
         */
        dragPan?: boolean | DragPanOptions | undefined;

        /** If true, enable the "drag to rotate" interaction (see DragRotateHandler). */
        dragRotate?: boolean | undefined;

        /** If true, enable the "double click to zoom" interaction (see DoubleClickZoomHandler). */
        doubleClickZoom?: boolean | undefined;

        /** If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.
         * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.
         * An additional string may optionally be provided to indicate a parameter-styled hash,
         * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo
         * is a custom parameter and bar is an arbitrary hash distinct from the map hash.
         * */
        hash?: boolean | string | undefined;

        /**
         * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.
         * This setting affects all symbol layers. This setting does not affect the duration of runtime
         * styling transitions or raster tile cross-fading.
         *
         * @default 300
         */
        fadeDuration?: number | undefined;

        /** If true, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected. */
        failIfMajorPerformanceCaveat?: boolean | undefined;

        /** A fitBounds options object to use only when setting the bounds option. */
        fitBoundsOptions?: FitBoundsOptions | undefined;

        /** If false, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input */
        interactive?: boolean | undefined;

        /** If true, enable keyboard shortcuts (see KeyboardHandler). */
        keyboard?: boolean | undefined;

        /** A patch to apply to the default localization table for UI strings, e.g. control tooltips.
         * The `locale` object maps namespaced UI string IDs to translated strings in the target language;
         * see `src/ui/default_locale.js` for an example with all supported string IDs.
         * The object may specify all UI strings (thereby adding support for a new translation) or
         * only a subset of strings (thereby patching the default translation table).
         */
        locale?: { [key: string]: string } | undefined;

        /**
         * Overrides the generation of all glyphs and font settings except font-weight keywords
         * Also overrides localIdeographFontFamily
         * @default null
         */
        localFontFamily?: string | undefined;

        /**
         * If specified, defines a CSS font-family for locally overriding generation of glyphs in the
         * 'CJK Unified Ideographs' and 'Hangul Syllables' ranges. In these ranges, font settings from
         * the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
         * The purpose of this option is to avoid bandwidth-intensive glyph server requests.
         *
         * @default null
         */
        localIdeographFontFamily?: string | undefined;

        /**
         * A string representing the position of the Map wordmark on the map.
         *
         * @default "bottom-left"
         */
        logoPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | undefined;

        /** If set, the map is constrained to the given bounds. */
        maxBounds?: LngLatBoundsLike | undefined;

        /** Maximum pitch of the map. */
        maxPitch?: number | undefined;

        /** Maximum zoom of the map. */
        maxZoom?: number | undefined;

        /** Minimum pitch of the map. */
        minPitch?: number | undefined;

        /** Minimum zoom of the map. */
        minZoom?: number | undefined;

        /**
         * If true, map will prioritize rendering for performance by reordering layers
         * If false, layers will always be drawn in the specified order
         *
         * @default true
         */
        optimizeForTerrain?: boolean | undefined;

        /** If true, The maps canvas can be exported to a PNG using map.getCanvas().toDataURL();. This is false by default as a performance optimization. */
        preserveDrawingBuffer?: boolean | undefined;

        /**
         * The initial pitch (tilt) of the map, measured in degrees away from the plane of the
         * screen (0-60).
         *
         * @default 0
         */
        pitch?: number | undefined;

        /**
         * A style's projection property sets which projection a map is rendered in.
         *
         * @default 'mercator'
         */
         projection?: {
            name: 'albers' | 'equalEarth' | 'equirectangular' | 'lambertConformalConic' | 'mercator' | 'naturalEarth' | 'winkelTripel' | 'globe',
            center?: [number, number],
            parallels?: [number, number]
        };

        /**
         * If `false`, the map's pitch (tilt) control with "drag to rotate" interaction will be disabled.
         *
         * @default true
         */
        pitchWithRotate?: boolean | undefined;

        /**
         * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP
         * `cacheControl`/`expires` headers.
         *
         * @default true
         */
        refreshExpiredTiles?: boolean | undefined;

        /**
         * If `true`, multiple copies of the world will be rendered, when zoomed out.
         *
         * @default true
         */
        renderWorldCopies?: boolean | undefined;

        /**
         * If `true`, the "scroll to zoom" interaction is enabled.
         * An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.
         */
        scrollZoom?: boolean | InteractiveOptions | undefined;

        /** stylesheet location */
        style?: vjmap.Style | string | undefined;

        /** If  true, the map will automatically resize when the browser window resizes */
        trackResize?: boolean | undefined;

        /**
         * A callback run before the Map makes a request for an external URL. The callback can be
         * used to modify the url, set headers, or set the credentials property for cross-origin requests.
         *
         * @default null
         */
        transformRequest?: TransformRequestFunction | undefined;

        /**
         * If `true`, the "pinch to rotate and zoom" interaction is enabled.
         * An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.
         */
        touchZoomRotate?: boolean | InteractiveOptions | undefined;

        /**
         * If `true`, the "drag to pitch" interaction is enabled.
         * An `Object` value is passed as options to {@link TouchPitchHandler#enable}.
         */
        touchPitch?: boolean | InteractiveOptions | undefined;

        /** Initial zoom level */
        zoom?: number | undefined;

        /**
         * The maximum number of tiles stored in the tile cache for a given source. If omitted, the
         * cache will be dynamically sized based on the current viewport.
         *
         * @default null
         */
        maxTileCacheSize?: number | undefined;

        /**
         * If specified, map will use this token instead of the one defined in vjmap.accessToken.
         *
         * @default null
         */
        accessToken?: string | undefined;

        /**
         * Allows for the usage of the map in automated tests without an accessToken with custom self-hosted test fixtures.
         *
         * @default null
         */
        testMode?: boolean | undefined;
    }

  export  type quat = number[];
  export  type vec3 = number[];

    /**
     * Various options for accessing physical properties of the underlying camera entity.
     * A direct access to these properties allows more flexible and precise controlling of the camera
     * while also being fully compatible and interchangeable with CameraOptions. All fields are optional.
     * See {@Link Camera#setFreeCameraOptions} and {@Link Camera#getFreeCameraOptions}
     *
     * @param {MercatorCoordinate} position Position of the camera in slightly modified web mercator coordinates
            - The size of 1 unit is the width of the projected world instead of the "mercator meter".
            Coordinate [0, 0, 0] is the north-west corner and [1, 1, 0] is the south-east corner.
            - Z coordinate is conformal and must respect minimum and maximum zoom values.
            - Zoom is automatically computed from the altitude (z)
    * @param {quat} orientation Orientation of the camera represented as a unit quaternion [x, y, z, w]
            in a left-handed coordinate space. Direction of the rotation is clockwise around the respective axis.
            The default pose of the camera is such that the forward vector is looking up the -Z axis and
            the up vector is aligned with north orientation of the map:
            forward: [0, 0, -1]
            up:      [0, -1, 0]
            right    [1, 0, 0]
            Orientation can be set freely but certain constraints still apply
            - Orientation must be representable with only pitch and bearing.
            - Pitch has an upper limit
    */
    export class FreeCameraOptions {
        constructor(position?: MercatorCoordinate, orientation?: quat);

        position: MercatorCoordinate | undefined;

        /**
         * Helper function for setting orientation of the camera by defining a focus point
         * on the map.
         *
         * @param {LngLatLike} location Location of the focus point on the map
         * @param {vec3} up Up vector of the camera is required in certain scenarios where bearing can't be deduced
         *      from the viewing direction.
         */
        lookAtPoint(location: LngLatLike, up?: vec3): void;

        /**
         * Helper function for setting the orientation of the camera as a pitch and a bearing.
         *
         * @param {number} pitch Pitch angle in degrees
         * @param {number} bearing Bearing angle in degrees
         */
        setPitchBearing(pitch: number, bearing: number): void;
    }

    export type ResourceType =
        | 'Unknown'
        | 'Style'
        | 'Source'
        | 'Tile'
        | 'Glyphs'
        | 'SpriteImage'
        | 'SpriteJSON'
        | 'Image';

    export interface RequestParameters {
        /**
         * The URL to be requested.
         */
        url: string;

        /**
         * Use `'include'` to send cookies with cross-origin requests.
         */
        credentials?: 'same-origin' | 'include' | undefined;

        /**
         * The headers to be sent with the request.
         */
        headers?: { [header: string]: any } | undefined;

        method?: 'GET' | 'POST' | 'PUT' | undefined;

        collectResourceTiming?: boolean | undefined;
    }

    export type TransformRequestFunction = (url: string, resourceType: ResourceType) => RequestParameters;

    export interface PaddingOptions {
        top: number;
        bottom: number;
        left: number;
        right: number;
    }

    export interface FeatureIdentifier {
        id?: string | number | undefined;
        source: string;
        sourceLayer?: string | undefined;
    }

    /**
     * BoxZoomHandler
     */
    export class BoxZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * ScrollZoomHandler
     */
    export class ScrollZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(options?: InteractiveOptions): void;

        disable(): void;

        setZoomRate(zoomRate: number): void;

        setWheelZoomRate(wheelZoomRate: number): void;
    }

    /**
     * DragPenHandler
     */
    export class DragPanHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(options?: DragPanOptions): void;

        disable(): void;
    }

    /**
     * DragRotateHandler
     */
    export class DragRotateHandler {
        constructor(
            map: vjmap.Map,
            options?: { bearingSnap?: number | undefined; pitchWithRotate?: boolean | undefined },
        );

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * KeyboardHandler
     */
    export class KeyboardHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;

        /**
         * Returns true if the handler is enabled and has detected the start of a
         * zoom/rotate gesture.
         *
         * @returns {boolean} `true` if the handler is enabled and has detected the
         * start of a zoom/rotate gesture.
         */
        isActive(): boolean;

        /**
         * Disables the "keyboard pan/rotate" interaction, leaving the
         * "keyboard zoom" interaction enabled.
         *
         * @example
         *   map.keyboard.disableRotation();
         */
        disableRotation(): void;

        /**
         * Enables the "keyboard pan/rotate" interaction.
         *
         * @example
         *   map.keyboard.enable();
         *   map.keyboard.enableRotation();
         */
        enableRotation(): void;
    }

    /**
     * DoubleClickZoomHandler
     */
    export class DoubleClickZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * TouchZoomRotateHandler
     */
    export class TouchZoomRotateHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(options?: InteractiveOptions): void;

        disable(): void;

        disableRotation(): void;

        enableRotation(): void;
    }

    export class TouchPitchHandler {
        constructor(map: vjmap.Map);

        enable(options?: InteractiveOptions): void;

        isActive(): boolean;

        isEnabled(): boolean;

        disable(): void;
    }

    export interface IControl {
        onAdd(map: Map): HTMLElement;

        onRemove(map: Map): void;

        getDefaultPosition?: (() => string) | undefined;
    }

    /**
     * Control
     */
    export class Control extends Evented implements IControl {
        onAdd(map: Map): HTMLElement;
        onRemove(map: Map): void;
        getDefaultPosition?: (() => string) | undefined;
    }

    /**
     * Navigation
     */
    export class NavigationControl extends Control {
        constructor(options?: {
            showCompass?: boolean | undefined;
            showZoom?: boolean | undefined;
            visualizePitch?: boolean | undefined;
        });
    }

    export class PositionOptions {
        enableHighAccuracy?: boolean | undefined;
        timeout?: number | undefined;
        maximumAge?: number | undefined;
    }

    /**
     * Geolocate
     */
    export class GeolocateControl extends Control {
        constructor(options?: {
            positionOptions?: PositionOptions | undefined;
            fitBoundsOptions?: FitBoundsOptions | undefined;
            trackUserLocation?: boolean | undefined;
            showAccuracyCircle?: boolean | undefined;
            showUserLocation?: boolean | undefined;
            showUserHeading?: boolean | undefined;
        });
        trigger(): boolean;
    }

    /**
     * Attribution
     */
    export class AttributionControl extends Control {
        constructor(options?: { compact?: boolean | undefined; customAttribution?: string | string[] | undefined });
    }

    /**
     * Scale
     */
    export class ScaleControl extends Control {
        constructor(options?: { maxWidth?: number | undefined; unit?: string | undefined });

        setUnit(unit: 'imperial' | 'metric' | 'nautical'): void;
    }

    /**
     * FullscreenControl
     */
    export class FullscreenControl extends Control {
        constructor(options?: FullscreenControlOptions | null);
    }

    export interface FullscreenControlOptions {
        /**
         * A compatible DOM element which should be made full screen.
         * By default, the map container element will be made full screen.
         */
        container?: HTMLElement | null | undefined;
    }

    /**
     * Popup
     */
    export class Popup extends Evented {

        /**
         * 设置高度
         * @param height 高度值
         */
        setHeight(height: number): Popup;


        /**
         * 得到高度值
         */
        getHeight(): number | undefined;


        
        constructor(options?: vjmap.PopupOptions);

        addTo(map: vjmap.Map): this;

        isOpen(): boolean;

        remove(): this;

        getLngLat(): vjmap.LngLat;

        /**
         * Sets the geographical location of the popup's anchor, and moves the popup to it. Replaces trackPointer() behavior.
         *
         * @param lnglat The geographical location to set as the popup's anchor.
         */
        setLngLat(lnglat: LngLatLike): this;

        /**
         * Tracks the popup anchor to the cursor position, on screens with a pointer device (will be hidden on touchscreens). Replaces the setLngLat behavior.
         * For most use cases, `closeOnClick` and `closeButton` should also be set to `false` here.
         */
        trackPointer(): this;

        /** Returns the `Popup`'s HTML element. */
        getElement(): HTMLElement;

        setText(text: string): this;

        setHTML(html: string): this;

        setDOMContent(htmlNode: Node): this;

        getMaxWidth(): string;

        setMaxWidth(maxWidth: string): this;

        /**
         * Adds a CSS class to the popup container element.
         *
         * @param {string} className Non-empty string with CSS class name to add to popup container
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.addClassName('some-class')
         */
        addClassName(className: string): void;

        /**
         * Removes a CSS class from the popup container element.
         *
         * @param {string} className Non-empty string with CSS class name to remove from popup container
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.removeClassName('some-class')
         */
        removeClassName(className: string): void;

        /**
         * Sets the popup's offset.
         *
         * @param offset Sets the popup's offset.
         * @returns {Popup} `this`
         */
        setOffset(offset?: Offset | null): this;

        /**
         * Add or remove the given CSS class on the popup container, depending on whether the container currently has that class.
         *
         * @param {string} className Non-empty string with CSS class name to add/remove
         *
         * @returns {boolean} if the class was removed return false, if class was added, then return true
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.toggleClassName('toggleClass')
         */
        toggleClassName(className: string): void;
    }

    export interface PopupOptions {
        closeButton?: boolean | undefined;

        closeOnClick?: boolean | undefined;

        /**
         * @param {boolean} [options.closeOnMove=false] If `true`, the popup will closed when the map moves.
         */
        closeOnMove?: boolean | undefined;

        /**
         * @param {boolean} [options.focusAfterOpen=true] If `true`, the popup will try to focus the
         *   first focusable element inside the popup.
         */
        focusAfterOpen?: boolean | null | undefined;

        anchor?: Anchor | undefined;

        offset?: Offset | null | undefined;

        className?: string | undefined;

        maxWidth?: string | undefined;
    }

    export interface Style {
        layers: AnyLayer[];
        sources: Sources;

        bearing?: number | undefined;
        center?: number[] | undefined;
        fog?: Fog | undefined;
        glyphs?: string | undefined;
        metadata?: any;
        name?: string | undefined;
        pitch?: number | undefined;
        light?: Light | undefined;
        sprite?: string | undefined;
        terrain?: TerrainSpecification | undefined;
        transition?: Transition | undefined;
        version: number;
        zoom?: number | undefined;
    }

    export interface Transition {
        delay?: number | undefined;
        duration?: number | undefined;
    }

    export interface Light {
        anchor?: 'map' | 'viewport' | undefined;
        position?: number[] | undefined;
        'position-transition'?: Transition | undefined;
        color?: string | undefined;
        'color-transition'?: Transition | undefined;
        intensity?: number | undefined;
        'intensity-transition'?: Transition | undefined;
    }

    export interface Fog {
        color?: string | Expression | undefined;
        'horizon-blend'?: number | Expression | undefined;
        range?: number[] | Expression | undefined;
    }

    export interface Sources {
        [sourceName: string]: AnySourceData;
    }

    export type PromoteIdSpecification = { [key: string]: string } | string;

    export type AnySourceData =
        | GeoJSONSourceRaw
        | VideoSourceRaw
        | ImageSourceRaw
        | CanvasSourceRaw
        | VectorSource
        | RasterSource
        | RasterDemSource
        | CustomSourceInterface<HTMLImageElement | ImageData | ImageBitmap>;

    interface VectorSourceImpl extends VectorSource {
        /**
         * Sets the source `tiles` property and re-renders the map.
         *
         * @param {string[]} tiles An array of one or more tile source URLs, as in the TileJSON spec.
         * @returns {VectorTileSource} this
         */
        setTiles(tiles: ReadonlyArray<string>): VectorSourceImpl;

        /**
         * Sets the source `url` property and re-renders the map.
         *
         * @param {string} url A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `Map://<Tileset ID>`.
         * @returns {VectorTileSource} this
         */
        setUrl(url: string): VectorSourceImpl;
    }

    export type AnySourceImpl =
        | GeoJSONSource
        | VideoSource
        | ImageSource
        | CanvasSource
        | VectorSourceImpl
        | RasterSource
        | RasterDemSource
        | CustomSource<HTMLImageElement | ImageData | ImageBitmap>;

    export interface Source {
        type: 'vector' | 'raster' | 'raster-dem' | 'geojson' | 'image' | 'video' | 'canvas' | 'custom';
    }

    /**
     * GeoJSONSource
     */

    export interface GeoJSONSourceRaw extends Source, GeoJSONSourceOptions {
        type: 'geojson';
    }

    export class GeoJSONSource implements GeoJSONSourceRaw {
        type: 'geojson';

        constructor(options?: vjmap.GeoJSONSourceOptions);

        setData(data: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | String): this;

        getClusterExpansionZoom(clusterId: number, callback: (error: any, zoom: number) => void): this;

        getClusterChildren(
            clusterId: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;

        getClusterLeaves(
            cluserId: number,
            limit: number,
            offset: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;
    }

    export interface GeoJSONSourceOptions {
        data?: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | string | undefined;

        maxzoom?: number | undefined;

        attribution?: string | undefined;

        buffer?: number | undefined;

        tolerance?: number | undefined;

        cluster?: number | boolean | undefined;

        clusterRadius?: number | undefined;

        clusterMaxZoom?: number | undefined;

        /**
         * Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`.
         */
        clusterMinPoints?: number | undefined;

        clusterProperties?: object | undefined;

        lineMetrics?: boolean | undefined;

        generateId?: boolean | undefined;

        promoteId?: PromoteIdSpecification | undefined;

        filter?: any;
    }

    /**
     * VideoSource
     */
    export interface VideoSourceRaw extends Source, VideoSourceOptions {
        type: 'video';
    }

    export class VideoSource implements VideoSourceRaw {
        type: 'video';

        constructor(options?: vjmap.VideoSourceOptions);

        getVideo(): HTMLVideoElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface VideoSourceOptions {
        urls?: string[] | undefined;

        coordinates?: number[][] | undefined;
    }

    /**
     * ImageSource
     */
    export interface ImageSourceRaw extends Source, ImageSourceOptions {
        type: 'image';
    }

    export class ImageSource implements ImageSourceRaw {
        type: 'image';

        constructor(options?: vjmap.ImageSourceOptions);

        updateImage(options: ImageSourceOptions): this;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface ImageSourceOptions {
        url?: string | undefined;

        coordinates?: number[][] | undefined;
    }

    /**
     * CanvasSource
     */
    export interface CanvasSourceRaw extends Source, CanvasSourceOptions {
        type: 'canvas';
    }

    export class CanvasSource implements CanvasSourceRaw {
        type: 'canvas';

        coordinates: number[][];

        canvas: string | HTMLCanvasElement;

        play(): void;

        pause(): void;

        getCanvas(): HTMLCanvasElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface CanvasSourceOptions {
        coordinates: number[][];

        animate?: boolean | undefined;

        canvas: string | HTMLCanvasElement;
    }

    export type CameraFunctionSpecification<T> =
        | { type: 'exponential'; stops: Array<[number, T]> }
        | { type: 'interval'; stops: Array<[number, T]> };

    export type ExpressionSpecification = Array<unknown>;

    export type PropertyValueSpecification<T> = T | CameraFunctionSpecification<T> | ExpressionSpecification;

    export interface TerrainSpecification {
        source: string;
        exaggeration?: PropertyValueSpecification<number> | undefined;
    }

    /**
     * @see https://github.com/Map/tilejson-spec/tree/master/3.0.0#33-vector_layers
     */
  export  type SourceVectorLayer = {
        id: string;
        fields?: Record<string, string>;
        description?: string;
        minzoom?: number;
        maxzoom?: number;

        // Non standard extensions that are valid in a Map context.
        source?: string;
        source_name?: string;
    };

    interface VectorSource extends Source {
        type: 'vector';
        format?: 'pbf';

        url?: string | undefined;
        id?: string;
        name?: string;

        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        scheme?: 'xyz' | 'tms' | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        attribution?: string | undefined;
        promoteId?: PromoteIdSpecification | undefined;

        vector_layers?: SourceVectorLayer[];
    }

    interface RasterSource extends Source {
        name?: string;
        type: 'raster';
        id?: string;
        format?: 'webp' | string;

        url?: string | undefined;
        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        tileSize?: number | undefined;
        scheme?: 'xyz' | 'tms' | undefined;
        attribution?: string | undefined;
    }

    interface RasterDemSource extends Source {
        name?: string;
        type: 'raster-dem';
        id?: string;

        url?: string | undefined;
        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        tileSize?: number | undefined;
        attribution?: string | undefined;
        encoding?: 'terrarium' | 'Map' | undefined;
    }

    interface CustomSourceInterface<T> {
        id: string;
        type: 'custom';
        dataType: 'raster';
        minzoom?: number;
        maxzoom?: number;
        scheme?: string;
        tileSize?: number;
        attribution?: string;
        bounds?: [number, number, number, number];
        hasTile?: (tileID: { z: number, x: number, y: number }) => boolean;
        loadTile: (tileID: { z: number, x: number, y: number }, options: { signal: AbortSignal }) => Promise<T>;
        prepareTile?: (tileID: { z: number, x: number, y: number }) => T | undefined;
        unloadTile?: (tileID: { z: number, x: number, y: number }) => void;
        onAdd?: (map: Map) => void;
        onRemove?: (map: Map) => void;
    }

    interface CustomSource<T> extends Source {
        id: string;
        type: 'custom';
        scheme: string;
        minzoom: number;
        maxzoom: number;
        tileSize: number;
        attribution: string;

        _implementation: CustomSourceInterface<T>;
    }

    /**
     * LngLat
     */
    export class LngLat {
        lng: number;
        lat: number;

        constructor(lng: number, lat: number);

        /** Return a new LngLat object whose longitude is wrapped to the range (-180, 180). */
        wrap(): vjmap.LngLat;

        /** Return a LngLat as an array */
        toArray(): number[];

        /** Return a LngLat as a string */
        toString(): string;

        /** Returns the approximate distance between a pair of coordinates in meters
         * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159) */
        distanceTo(lngLat: LngLat): number;

        toBounds(radius: number): LngLatBounds;

        static convert(input: LngLatLike): vjmap.LngLat;
    }

    /**
     * LngLatBounds
     */
    export class LngLatBounds {
        sw: LngLatLike;
        ne: LngLatLike;

        constructor(boundsLike?: [LngLatLike, LngLatLike] | [number, number, number, number]);
        constructor(sw: LngLatLike, ne: LngLatLike);

        setNorthEast(ne: LngLatLike): this;

        setSouthWest(sw: LngLatLike): this;

        /** Check if the point is within the bounding box. */
        contains(lnglat: LngLatLike): boolean;

        /** Extend the bounds to include a given LngLat or LngLatBounds. */
        extend(obj: LngLatLike | LngLatBoundsLike): this;

        /** Get the point equidistant from this box's corners */
        getCenter(): vjmap.LngLat;

        /** Get southwest corner */
        getSouthWest(): vjmap.LngLat;

        /** Get northeast corner */
        getNorthEast(): vjmap.LngLat;

        /** Get northwest corner */
        getNorthWest(): vjmap.LngLat;

        /** Get southeast corner */
        getSouthEast(): vjmap.LngLat;

        /** Get west edge longitude */
        getWest(): number;

        /** Get south edge latitude */
        getSouth(): number;

        /** Get east edge longitude */
        getEast(): number;

        /** Get north edge latitude */
        getNorth(): number;

        /** Returns a LngLatBounds as an array */
        toArray(): number[][];

        /** Return a LngLatBounds as a string */
        toString(): string;

        /** Returns a boolean */
        isEmpty(): boolean;

        /** Convert an array to a LngLatBounds object, or return an existing LngLatBounds object unchanged. */
        static convert(input: LngLatBoundsLike): vjmap.LngLatBounds;
    }

    /**
     * Point
     */
    // Todo: Pull out class to seperate definition for Module "point-geometry"
    export class Point {
        x: number;
        y: number;

        constructor(x: number, y: number);

        clone(): Point;

        add(p: Point): Point;

        sub(p: Point): Point;

        mult(k: number): Point;

        div(k: number): Point;

        rotate(a: number): Point;

        matMult(m: number): Point;

        unit(): Point;

        perp(): Point;

        round(): Point;

        mag(): number;

        equals(p: Point): boolean;

        dist(p: Point): number;

        distSqr(p: Point): number;

        angle(): number;

        angleTo(p: Point): number;

        angleWidth(p: Point): number;

        angleWithSep(x: number, y: number): number;

        static convert(a: PointLike): Point;
    }

    /**
     * MercatorCoordinate
     */
    export class MercatorCoordinate {
        /** The x component of the position. */
        x: number;

        /** The y component of the position. */
        y: number;

        /**
         * The z component of the position.
         *
         * @default 0
         */
        z?: number | undefined;

        constructor(x: number, y: number, z?: number);

        /** Returns the altitude in meters of the coordinate. */
        toAltitude(): number;

        /** Returns the LngLat for the coordinate. */
        toLngLat(): LngLat;

        /**
         * Returns the distance of 1 meter in MercatorCoordinate units at this latitude.
         *
         * For coordinates in real world units using meters, this naturally provides the
         * scale to transform into MercatorCoordinates.
         */
        meterInMercatorCoordinateUnits(): number;

        /** Project a LngLat to a MercatorCoordinate. */
        static fromLngLat(lngLatLike: LngLatLike, altitude?: number): MercatorCoordinate;
    }

    /**
     * Marker
     */
    export class Marker extends Evented {

        /**
         * 设置动画
         * @param animationType
         * MAP_ANIMATION_NONE 无动画
         * MAP_ANIMATION_BOUNCE 弹跳
         * MAP_ANIMATION_DROP 坠落
         */
        setAnimation(animationType: string): void;

        /**
         * 设置颜色
         * @param color 颜色
         */
        setColor(color: string): void;

        /**
         * 显示
         */
        show(): void;

        /**
         * 隐藏
         */
        hide(): void;

        /**
         * 获取是否隐藏了，当设置了hide或缩放级别或视图范围外不可见时，返回true，否则返回false
         */
        isHidden(): boolean;

        /**
         * 设置光标
         * @param cur 光标名称
         */
        setCursor(cur: string): void;

        /**
         * 设置高度
         * @param height 高度值
         */
        setHeight(height: number): Marker;

        /**
         * 设置显示的最小缩放级别
         * @param zoom 缩放级别
         */
        setMinZoom(zoom: number): Marker;

        /**
         * 设置显示的最大缩放级别
         * @param zoom 缩放级别
         */
        setMaxZoom(zoom: number): Marker;

        /**
         * 设置当marker不在当前地图视图范围内时，将自动移除。进入视图范围内时，将自动增加上，当自动移除或增加时，将触发`autoAdd`和`autoRemove`事件
         * @param autoRemove true不在当前地图视图范围内时，将自动移除，false不会自动移除
         * @param padding 范围向外扩的像素范围，默认500px，向视图范围往外扩些像素，在平移的时候，能看到marker，体验效果好些。
         */
        setRemoveWhenNoInMapView(autoRemove: boolean, padding?: number): Marker;

        /**
         * 设置能缩放的最大级别。如果小于这个级别，div将根据缩小级别自动缩小比例。默认不会自动缩放，当自动移除或增加时，将触发`autoAdd`和`autoRemove`事件
         * @param zoom 缩放级别
         */
        setScaleMaxZoom(zoom: number): Marker;

        /**
         * 得到高度值
         */
        getHeight(): number | undefined;

        /**
         * 得到显示的最小缩放级别
         */
        getMinZoom(): number | undefined;

        /**
         * 得到显示的最大缩放级别
         */
        getMaxZoom(): number | undefined;

        /**
         * 得到能缩放的最大级别。如果小于这个级别，div将根据缩小级别自动缩小比例。默认不会自动缩放
         */
        getScaleMaxZoom(zoom: number): number | undefined;

        /**
         * 得到当marker不在当前地图视图范围内时，将自动移除。进入视图范围内时，将自动增加上
         */
        getRemoveWhenNoInMapView(): boolean;

        /**
         * 设置是否显示隐藏
         * @param visible 是否显示
         * @param isDisplay true的话，表示用style的display去控制隐藏显示，dom还在文档中。false的话，会从文档动态清空增加
         */
        setVisible(visible?: boolean, isDisplay?: boolean): Marker;

        
        constructor(options?: vjmap.MarkerOptions);

        constructor(element?: HTMLElement, options?: vjmap.MarkerOptions);

        addTo(map: Map): this;

        remove(): this;

        getLngLat(): LngLat;

        setLngLat(lngLat: LngLatLike): this;

        getElement(): HTMLElement;

        setPopup(popup?: Popup): this;

        getPopup(): Popup;

        togglePopup(): this;

        getOffset(): PointLike;

        setOffset(offset: PointLike): this;

        setDraggable(shouldBeDraggable: boolean): this;

        isDraggable(): boolean;

        getRotation(): number;

        setRotation(rotation: number): this;

        getRotationAlignment(): Alignment;

        setRotationAlignment(alignment: Alignment): this;

        getPitchAlignment(): Alignment;

        setPitchAlignment(alignment: Alignment): this;
    }

  export  type Alignment = 'map' | 'viewport' | 'auto';

    export interface MarkerOptions {
        /** DOM element to use as a marker. The default is a light blue, droplet-shaped SVG marker */
        element?: HTMLElement | undefined;

        /** The offset in pixels as a PointLike object to apply relative to the element's center. Negatives indicate left and up. */
        offset?: PointLike | undefined;

        /** A string indicating the part of the Marker that should be positioned closest to the coordinate set via Marker.setLngLat.
         * Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`.
         * The default value os `'center'`
         */
        anchor?: Anchor | undefined;

        /** The color to use for the default marker if options.element is not provided. The default is light blue (#3FB1CE). */
        color?: string | undefined;

        /** A boolean indicating whether or not a marker is able to be dragged to a new position on the map. The default value is false */
        draggable?: boolean | undefined;

        /**
         * The max number of pixels a user can shift the mouse pointer during a click on the marker for it to be considered a valid click
         * (as opposed to a marker drag). The default (0) is to inherit map's clickTolerance.
         */
        clickTolerance?: number | null | undefined;

        /** The rotation angle of the marker in degrees, relative to its `rotationAlignment` setting. A positive value will rotate the marker clockwise.
         * The default value is 0.
         */
        rotation?: number | undefined;

        /** `map` aligns the `Marker`'s rotation relative to the map, maintaining a bearing as the map rotates.
         * `viewport` aligns the `Marker`'s rotation relative to the viewport, agnostic to map rotations.
         * `auto` is equivalent to `viewport`.
         * The default value is `auto`
         */
        rotationAlignment?: Alignment | undefined;

        /** `map` aligns the `Marker` to the plane of the map.
         * `viewport` aligns the `Marker` to the plane of the viewport.
         * `auto` automatically matches the value of `rotationAlignment`.
         * The default value is `auto`.
         */
        pitchAlignment?: Alignment | undefined;

        /** The scale to use for the default marker if options.element is not provided.
         * The default scale (1) corresponds to a height of `41px` and a width of `27px`.
         */
        scale?: number | undefined;
    }

  export  type EventedListener = (object?: Object) => any;
    /**
     * Evented
     */
    export class Evented {
        on(type: string, listener: EventedListener): this;

        off(type?: string | any, listener?: EventedListener): this;

        once(type: string, listener: EventedListener): this;

        
        fire(type: string, properties?: { [key: string]: any }): this;
    }

    /**
     * StyleOptions
     */
    export interface StyleOptions {
        transition?: boolean | undefined;
    }

    export type MapGeoJSONFeature = GeoJSON.Feature<GeoJSON.Geometry> & {
        layer: Layer;
        source: string;
        sourceLayer: string;
        state: { [key: string]: any };
    };

    export type EventData = { [key: string]: any };

    export class MapEvent<TOrig = undefined> {
        type: string;
        target: Map;
        originalEvent: TOrig;
    }

    export class MapMouseEvent extends MapEvent<MouseEvent> {
        type:
            | 'mousedown'
            | 'mouseup'
            | 'click'
            | 'dblclick'
            | 'mousemove'
            | 'mouseover'
            | 'mouseenter'
            | 'mouseleave'
            | 'mouseout'
            | 'contextmenu';

        point: Point;
        lngLat: LngLat;

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerMouseEvent = MapMouseEvent & { features?: MapGeoJSONFeature[] | undefined };

    export class MapTouchEvent extends MapEvent<TouchEvent> {
        type: 'touchstart' | 'touchend' | 'touchcancel';

        point: Point;
        lngLat: LngLat;
        points: Point[];
        lngLats: LngLat[];

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerTouchEvent = MapTouchEvent & { features?: MapGeoJSONFeature[] | undefined };

    export class MapWheelEvent extends MapEvent<WheelEvent> {
        type: 'wheel';

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export interface MapZoomEvent extends MapEvent<MouseEvent> {
        type: 'boxzoomstart' | 'boxzoomend' | 'boxzoomcancel';

        boxZoomBounds: LngLatBounds;
    }

    export type MapDataEvent = MapSourceDataEvent | MapStyleDataEvent;

    export interface MapStyleDataEvent extends MapEvent {
        dataType: 'style';
    }

    export interface MapSourceDataEvent extends MapEvent {
        dataType: 'source';
        isSourceLoaded: boolean;
        source: Source;
        sourceId: string;
        sourceDataType: 'metadata' | 'content';
        tile: any;
        coord: Coordinate;
    }

    export interface Coordinate {
        canonical: CanonicalCoordinate;
        wrap: number;
        key: number;
    }

    export interface CanonicalCoordinate {
        x: number;
        y: number;
        z: number;
        key: number;
        equals(coord: CanonicalCoordinate): boolean;
    }

    export interface MapContextEvent extends MapEvent<WebGLContextEvent> {
        type: 'webglcontextlost' | 'webglcontextrestored';
    }

    export class ErrorEvent extends MapEvent {
        type: 'error';
        error: Error;
    }

    /**
     * FilterOptions
     */
    export interface FilterOptions {
        /**
         * Whether to check if the filter conforms to the Map GL Style Specification.
         * Disabling validation is a performance optimization that should only be used
         * if you have previously validated the values you will be passing to this function.
         */
        validate?: boolean | null | undefined;
    }

    /**
     * AnimationOptions
     */
    export interface AnimationOptions {
        /** Number in milliseconds */
        duration?: number | undefined;
        /**
         * A function taking a time in the range 0..1 and returning a number where 0 is the initial
         * state and 1 is the final state.
         */
        easing?: ((time: number) => number) | undefined;
        /** point, origin of movement relative to map center */
        offset?: PointLike | undefined;
        /** When set to false, no animation happens */
        animate?: boolean | undefined;

        /** If `true`, then the animation is considered essential and will not be affected by `prefers-reduced-motion`.
         * Otherwise, the transition will happen instantly if the user has enabled the `reduced motion` accesibility feature in their operating system.
         */
        essential?: boolean | undefined;
    }

    /**
     * CameraOptions
     */
    export interface CameraOptions {
        /** Map center */
        center?: LngLatLike | undefined;
        /** Map zoom level */
        zoom?: number | undefined;
        /** Map rotation bearing in degrees counter-clockwise from north */
        bearing?: number | undefined;
        /** Map angle in degrees at which the camera is looking at the ground */
        pitch?: number | undefined;
        /** If zooming, the zoom center (defaults to map center) */
        around?: LngLatLike | undefined;
        /** Dimensions in pixels applied on each side of the viewport for shifting the vanishing point. */
        padding?: number | PaddingOptions | undefined;
    }

    export interface CameraForBoundsOptions extends CameraOptions {
        offset?: PointLike | undefined;
        maxZoom?: number | undefined;
    }

    // The Map docs say that if the result is defined, it will have zoom, center and bearing set.
    // In practice center is always a {lat, lng} object.
    export type CameraForBoundsResult = Required<Pick<CameraOptions, 'zoom' | 'bearing'>> & {
        /** Map center */
        center: { lng: number; lat: number };
    };

    /**
     * FlyToOptions
     */
    export interface FlyToOptions extends AnimationOptions, CameraOptions {
        curve?: number | undefined;
        minZoom?: number | undefined;
        speed?: number | undefined;
        screenSpeed?: number | undefined;
        maxDuration?: number | undefined;
    }

    /**
     * EaseToOptions
     */
    export interface EaseToOptions extends AnimationOptions, CameraOptions {
        delayEndEvents?: number | undefined;
    }

    export interface FitBoundsOptions extends vjmap.FlyToOptions {
        linear?: boolean | undefined;
        offset?: PointLike | undefined;
        maxZoom?: number | undefined;
        maxDuration?: number | undefined;
    }

    /**
     * MapEvent
     */
    export type MapEventType = {
        error: ErrorEvent;

        load: MapEvent;
        idle: MapEvent;
        remove: MapEvent;
        render: MapEvent;
        resize: MapEvent;

        webglcontextlost: MapContextEvent;
        webglcontextrestored: MapContextEvent;

        dataloading: MapDataEvent;
        data: MapDataEvent;
        tiledataloading: MapDataEvent;
        sourcedataloading: MapSourceDataEvent;
        styledataloading: MapStyleDataEvent;
        sourcedata: MapSourceDataEvent;
        styledata: MapStyleDataEvent;

        boxzoomcancel: MapZoomEvent;
        boxzoomstart: MapZoomEvent;
        boxzoomend: MapZoomEvent;

        touchcancel: MapTouchEvent;
        touchmove: MapTouchEvent;
        touchend: MapTouchEvent;
        touchstart: MapTouchEvent;

        click: MapMouseEvent;
        contextmenu: MapMouseEvent;
        dblclick: MapMouseEvent;
        mousemove: MapMouseEvent;
        mouseup: MapMouseEvent;
        mousedown: MapMouseEvent;
        mouseout: MapMouseEvent;
        mouseover: MapMouseEvent;

        movestart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        move: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        moveend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        zoomstart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoom: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoomend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        rotatestart: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotate: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotateend: MapEvent<MouseEvent | TouchEvent | undefined>;

        dragstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        drag: MapEvent<MouseEvent | TouchEvent | undefined>;
        dragend: MapEvent<MouseEvent | TouchEvent | undefined>;

        pitchstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitch: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitchend: MapEvent<MouseEvent | TouchEvent | undefined>;

        wheel: MapWheelEvent;
    };

    export type MapLayerEventType = {
        click: MapLayerMouseEvent;
        dblclick: MapLayerMouseEvent;
        mousedown: MapLayerMouseEvent;
        mouseup: MapLayerMouseEvent;
        mousemove: MapLayerMouseEvent;
        mouseenter: MapLayerMouseEvent;
        mouseleave: MapLayerMouseEvent;
        mouseover: MapLayerMouseEvent;
        mouseout: MapLayerMouseEvent;
        contextmenu: MapLayerMouseEvent;

        touchstart: MapLayerTouchEvent;
        touchend: MapLayerTouchEvent;
        touchcancel: MapLayerTouchEvent;
    };

    export type AnyLayout =
        | BackgroundLayout
        | FillLayout
        | FillExtrusionLayout
        | LineLayout
        | SymbolLayout
        | RasterLayout
        | CircleLayout
        | HeatmapLayout
        | HillshadeLayout
        | SkyLayout;

    export type AnyPaint =
        | BackgroundPaint
        | FillPaint
        | FillExtrusionPaint
        | LinePaint
        | SymbolPaint
        | RasterPaint
        | CirclePaint
        | HeatmapPaint
        | HillshadePaint
        | SkyPaint;

    interface Layer {
        id: string;
        type: string;

        metadata?: any;
        ref?: string | undefined;

        source?: string | AnySourceData | undefined;

        'source-layer'?: string | undefined;

        minzoom?: number | undefined;
        maxzoom?: number | undefined;

        interactive?: boolean | undefined;

        filter?: any[] | undefined;
        layout?: AnyLayout | undefined;
        paint?: AnyPaint | undefined;
    }

    interface BackgroundLayer extends Layer {
        type: 'background';
        layout?: BackgroundLayout | undefined;
        paint?: BackgroundPaint | undefined;
    }

    interface CircleLayer extends Layer {
        type: 'circle';
        layout?: CircleLayout | undefined;
        paint?: CirclePaint | undefined;
    }

    interface FillExtrusionLayer extends Layer {
        type: 'fill-extrusion';
        layout?: FillExtrusionLayout | undefined;
        paint?: FillExtrusionPaint | undefined;
    }

    interface FillLayer extends Layer {
        type: 'fill';
        layout?: FillLayout | undefined;
        paint?: FillPaint | undefined;
    }

    interface HeatmapLayer extends Layer {
        type: 'heatmap';
        layout?: HeatmapLayout | undefined;
        paint?: HeatmapPaint | undefined;
    }

    interface HillshadeLayer extends Layer {
        type: 'hillshade';
        layout?: HillshadeLayout | undefined;
        paint?: HillshadePaint | undefined;
    }

    interface LineLayer extends Layer {
        type: 'line';
        layout?: LineLayout | undefined;
        paint?: LinePaint | undefined;
    }

    interface RasterLayer extends Layer {
        type: 'raster';
        layout?: RasterLayout | undefined;
        paint?: RasterPaint | undefined;
    }

    interface SymbolLayer extends Layer {
        type: 'symbol';
        layout?: SymbolLayout | undefined;
        paint?: SymbolPaint | undefined;
    }

    interface SkyLayer extends Layer {
        type: 'sky';
        layout?: SkyLayout | undefined;
        paint?: SkyPaint | undefined;
    }

    export type AnyLayer =
        | BackgroundLayer
        | CircleLayer
        | FillExtrusionLayer
        | FillLayer
        | HeatmapLayer
        | HillshadeLayer
        | LineLayer
        | RasterLayer
        | SymbolLayer
        | CustomLayerInterface
        | SkyLayer;

    
    export interface CustomLayerInterface {
        /** A unique layer id. */
        id: string;

        /* The layer's type. Must be "custom". */
        type: 'custom';

        /* Either "2d" or "3d". Defaults to  "2d". */
        renderingMode?: '2d' | '3d' | undefined;

        /**
         * Optional method called when the layer has been removed from the Map with Map#removeLayer.
         * This gives the layer a chance to clean up gl resources and event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onRemove?(map: vjmap.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called when the layer has been added to the Map with Map#addLayer.
         * This gives the layer a chance to initialize gl resources and register event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onAdd?(map: vjmap.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called during a render frame to allow a layer to prepare resources
         * or render into a texture.
         *
         * The layer cannot make any assumptions about the current GL state and must bind a framebuffer
         * before rendering.
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        prerender?(gl: WebGLRenderingContext, matrix: number[]): void;

        /**
         * Called during a render frame allowing the layer to draw into the GL context.
         *
         * The layer can assume blending and depth state is set to allow the layer to properly blend
         * and clip other layers. The layer cannot make any other assumptions about the current GL state.
         *
         * If the layer needs to render to a texture, it should implement the prerender method to do this
         * and only use the render method for drawing directly into the main framebuffer.
         *
         * The blend function is set to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA). This expects
         * colors to be provided in premultiplied alpha form where the r, g and b values are already
         * multiplied by the a value. If you are unable to provide colors in premultiplied form you may
         * want to change the blend function to
         * gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA).
         *
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        render(gl: WebGLRenderingContext, matrix: number[]): void;
    }

    export interface StyleFunction {
        stops?: any[][] | undefined;
        property?: string | undefined;
        base?: number | undefined;
        type?: 'identity' | 'exponential' | 'interval' | 'categorical' | undefined;
        default?: any;
        colorSpace?: 'rgb' | 'lab' | 'hcl' | undefined;
    }

  export  type Visibility = 'visible' | 'none';

    export interface Layout {
        visibility?: Visibility | undefined;
    }

    export interface BackgroundLayout extends Layout {}

    export interface BackgroundPaint {
        'background-color'?: string | Expression | undefined;
        'background-color-transition'?: Transition | undefined;
        'background-pattern'?: string | undefined;
        'background-pattern-transition'?: Transition | undefined;
        'background-opacity'?: number | Expression | undefined;
        'background-opacity-transition'?: Transition | undefined;
    }

    export interface FillLayout extends Layout {
        'fill-sort-key'?: number | Expression | undefined;
    }

    export interface FillPaint {
        'fill-antialias'?: boolean | Expression | undefined;
        'fill-opacity'?: number | StyleFunction | Expression | undefined;
        'fill-opacity-transition'?: Transition | undefined;
        'fill-color'?: string | StyleFunction | Expression | undefined;
        'fill-color-transition'?: Transition | undefined;
        'fill-outline-color'?: string | StyleFunction | Expression | undefined;
        'fill-outline-color-transition'?: Transition | undefined;
        'fill-translate'?: number[] | undefined;
        'fill-translate-transition'?: Transition | undefined;
        'fill-translate-anchor'?: 'map' | 'viewport' | undefined;
        'fill-pattern'?: string | Expression | undefined;
        'fill-pattern-transition'?: Transition | undefined;
    }

    export interface FillExtrusionLayout extends Layout {}

    export interface FillExtrusionPaint {
        'fill-extrusion-opacity'?: number | Expression | undefined;
        'fill-extrusion-opacity-transition'?: Transition | undefined;
        'fill-extrusion-color'?: string | StyleFunction | Expression | undefined;
        'fill-extrusion-color-transition'?: Transition | undefined;
        'fill-extrusion-translate'?: number[] | Expression | undefined;
        'fill-extrusion-translate-transition'?: Transition | undefined;
        'fill-extrusion-translate-anchor'?: 'map' | 'viewport' | undefined;
        'fill-extrusion-pattern'?: string | Expression | undefined;
        'fill-extrusion-pattern-transition'?: Transition | undefined;
        'fill-extrusion-height'?: number | StyleFunction | Expression | undefined;
        'fill-extrusion-height-transition'?: Transition | undefined;
        'fill-extrusion-base'?: number | StyleFunction | Expression | undefined;
        'fill-extrusion-base-transition'?: Transition | undefined;
        'fill-extrusion-vertical-gradient'?: boolean | undefined;
    }

    export interface LineLayout extends Layout {
        'line-cap'?: 'butt' | 'round' | 'square' | Expression | undefined;
        'line-join'?: 'bevel' | 'round' | 'miter' | Expression | undefined;
        'line-miter-limit'?: number | Expression | undefined;
        'line-round-limit'?: number | Expression | undefined;
        'line-sort-key'?: number | Expression | undefined;
    }

    export interface LinePaint {
        'line-opacity'?: number | StyleFunction | Expression | undefined;
        'line-opacity-transition'?: Transition | undefined;
        'line-color'?: string | StyleFunction | Expression | undefined;
        'line-color-transition'?: Transition | undefined;
        'line-translate'?: number[] | Expression | undefined;
        'line-translate-transition'?: Transition | undefined;
        'line-translate-anchor'?: 'map' | 'viewport' | undefined;
        'line-width'?: number | StyleFunction | Expression | undefined;
        'line-width-transition'?: Transition | undefined;
        'line-gap-width'?: number | StyleFunction | Expression | undefined;
        'line-gap-width-transition'?: Transition | undefined;
        'line-offset'?: number | StyleFunction | Expression | undefined;
        'line-offset-transition'?: Transition | undefined;
        'line-blur'?: number | StyleFunction | Expression | undefined;
        'line-blur-transition'?: Transition | undefined;
        'line-dasharray'?: number[] | Expression | undefined;
        'line-dasharray-transition'?: Transition | undefined;
        'line-pattern'?: string | Expression | undefined;
        'line-pattern-transition'?: Transition | undefined;
        'line-gradient'?: Expression | undefined;
    }

    export interface SymbolLayout extends Layout {
        'symbol-placement'?: 'point' | 'line' | 'line-center' | undefined;
        'symbol-spacing'?: number | Expression | undefined;
        'symbol-avoid-edges'?: boolean | undefined;
        'symbol-z-order'?: 'viewport-y' | 'source' | undefined;
        'icon-allow-overlap'?: boolean | StyleFunction | Expression | undefined;
        'icon-ignore-placement'?: boolean | Expression | undefined;
        'icon-optional'?: boolean | undefined;
        'icon-rotation-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'icon-size'?: number | StyleFunction | Expression | undefined;
        'icon-text-fit'?: 'none' | 'both' | 'width' | 'height' | undefined;
        'icon-text-fit-padding'?: number[] | Expression | undefined;
        'icon-image'?: string | StyleFunction | Expression | undefined;
        'icon-rotate'?: number | StyleFunction | Expression | undefined;
        'icon-padding'?: number | Expression | undefined;
        'icon-keep-upright'?: boolean | undefined;
        'icon-offset'?: number[] | StyleFunction | Expression | undefined;
        'icon-anchor'?: Anchor | StyleFunction | Expression | undefined;
        'icon-pitch-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-pitch-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-rotation-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-field'?: string | StyleFunction | Expression | undefined;
        'text-font'?: string[] | Expression | undefined;
        'text-size'?: number | StyleFunction | Expression | undefined;
        'text-max-width'?: number | StyleFunction | Expression | undefined;
        'text-line-height'?: number | Expression | undefined;
        'text-letter-spacing'?: number | Expression | undefined;
        'text-justify'?: 'auto' | 'left' | 'center' | 'right' | Expression | undefined;
        'text-anchor'?: Anchor | StyleFunction | Expression | undefined;
        'text-max-angle'?: number | Expression | undefined;
        'text-rotate'?: number | StyleFunction | Expression | undefined;
        'text-padding'?: number | Expression | undefined;
        'text-keep-upright'?: boolean | undefined;
        'text-transform'?: 'none' | 'uppercase' | 'lowercase' | StyleFunction | Expression | undefined;
        'text-offset'?: number[] | Expression | undefined;
        'text-allow-overlap'?: boolean | undefined;
        'text-ignore-placement'?: boolean | undefined;
        'text-optional'?: boolean | undefined;
        'text-radial-offset'?: number | Expression | undefined;
        'text-variable-anchor'?: Anchor[] | undefined;
        'text-writing-mode'?: ('horizontal' | 'vertical')[] | undefined;
        'symbol-sort-key'?: number | Expression | undefined;
    }

    export interface SymbolPaint {
        'icon-opacity'?: number | StyleFunction | Expression | undefined;
        'icon-opacity-transition'?: Transition | undefined;
        'icon-color'?: string | StyleFunction | Expression | undefined;
        'icon-color-transition'?: Transition | undefined;
        'icon-halo-color'?: string | StyleFunction | Expression | undefined;
        'icon-halo-color-transition'?: Transition | undefined;
        'icon-halo-width'?: number | StyleFunction | Expression | undefined;
        'icon-halo-width-transition'?: Transition | undefined;
        'icon-halo-blur'?: number | StyleFunction | Expression | undefined;
        'icon-halo-blur-transition'?: Transition | undefined;
        'icon-translate'?: number[] | Expression | undefined;
        'icon-translate-transition'?: Transition | undefined;
        'icon-translate-anchor'?: 'map' | 'viewport' | undefined;
        'text-opacity'?: number | StyleFunction | Expression | undefined;
        'text-opacity-transition'?: Transition | undefined;
        'text-color'?: string | StyleFunction | Expression | undefined;
        'text-color-transition'?: Transition | undefined;
        'text-halo-color'?: string | StyleFunction | Expression | undefined;
        'text-halo-color-transition'?: Transition | undefined;
        'text-halo-width'?: number | StyleFunction | Expression | undefined;
        'text-halo-width-transition'?: Transition | undefined;
        'text-halo-blur'?: number | StyleFunction | Expression | undefined;
        'text-halo-blur-transition'?: Transition | undefined;
        'text-translate'?: number[] | Expression | undefined;
        'text-translate-transition'?: Transition | undefined;
        'text-translate-anchor'?: 'map' | 'viewport' | undefined;
    }

    export interface RasterLayout extends Layout {}

    export interface RasterPaint {
        'raster-opacity'?: number | Expression | undefined;
        'raster-opacity-transition'?: Transition | undefined;
        'raster-hue-rotate'?: number | Expression | undefined;
        'raster-hue-rotate-transition'?: Transition | undefined;
        'raster-brightness-min'?: number | Expression | undefined;
        'raster-brightness-min-transition'?: Transition | undefined;
        'raster-brightness-max'?: number | Expression | undefined;
        'raster-brightness-max-transition'?: Transition | undefined;
        'raster-saturation'?: number | Expression | undefined;
        'raster-saturation-transition'?: Transition | undefined;
        'raster-contrast'?: number | Expression | undefined;
        'raster-contrast-transition'?: Transition | undefined;
        'raster-fade-duration'?: number | Expression | undefined;
        'raster-resampling'?: 'linear' | 'nearest' | undefined;
    }

    export interface CircleLayout extends Layout {
        'circle-sort-key'?: number | Expression | undefined;
    }

    export interface CirclePaint {
        'circle-radius'?: number | StyleFunction | Expression | undefined;
        'circle-radius-transition'?: Transition | undefined;
        'circle-color'?: string | StyleFunction | Expression | undefined;
        'circle-color-transition'?: Transition | undefined;
        'circle-blur'?: number | StyleFunction | Expression | undefined;
        'circle-blur-transition'?: Transition | undefined;
        'circle-opacity'?: number | StyleFunction | Expression | undefined;
        'circle-opacity-transition'?: Transition | undefined;
        'circle-translate'?: number[] | Expression | undefined;
        'circle-translate-transition'?: Transition | undefined;
        'circle-translate-anchor'?: 'map' | 'viewport' | undefined;
        'circle-pitch-scale'?: 'map' | 'viewport' | undefined;
        'circle-pitch-alignment'?: 'map' | 'viewport' | undefined;
        'circle-stroke-width'?: number | StyleFunction | Expression | undefined;
        'circle-stroke-width-transition'?: Transition | undefined;
        'circle-stroke-color'?: string | StyleFunction | Expression | undefined;
        'circle-stroke-color-transition'?: Transition | undefined;
        'circle-stroke-opacity'?: number | StyleFunction | Expression | undefined;
        'circle-stroke-opacity-transition'?: Transition | undefined;
    }

    export interface HeatmapLayout extends Layout {}

    export interface HeatmapPaint {
        'heatmap-radius'?: number | StyleFunction | Expression | undefined;
        'heatmap-radius-transition'?: Transition | undefined;
        'heatmap-weight'?: number | StyleFunction | Expression | undefined;
        'heatmap-intensity'?: number | StyleFunction | Expression | undefined;
        'heatmap-intensity-transition'?: Transition | undefined;
        'heatmap-color'?: string | StyleFunction | Expression | undefined;
        'heatmap-opacity'?: number | StyleFunction | Expression | undefined;
        'heatmap-opacity-transition'?: Transition | undefined;
    }

    export interface HillshadeLayout extends Layout {}

    export interface HillshadePaint {
        'hillshade-illumination-direction'?: number | Expression | undefined;
        'hillshade-illumination-anchor'?: 'map' | 'viewport' | undefined;
        'hillshade-exaggeration'?: number | Expression | undefined;
        'hillshade-exaggeration-transition'?: Transition | undefined;
        'hillshade-shadow-color'?: string | Expression | undefined;
        'hillshade-shadow-color-transition'?: Transition | undefined;
        'hillshade-highlight-color'?: string | Expression | undefined;
        'hillshade-highlight-color-transition'?: Transition | undefined;
        'hillshade-accent-color'?: string | Expression | undefined;
        'hillshade-accent-color-transition'?: Transition | undefined;
    }

    export interface SkyLayout extends Layout {}

    export interface SkyPaint {
        'sky-atmosphere-color'?: string | Expression | undefined;
        'sky-atmosphere-halo-color'?: string | Expression | undefined;
        'sky-atmosphere-sun'?: number[] | Expression | undefined;
        'sky-atmosphere-sun-intensity'?: number | Expression | undefined;
        'sky-gradient'?: string | Expression | undefined;
        'sky-gradient-center'?: number[] | Expression | undefined;
        'sky-gradient-radius'?: number | Expression | undefined;
        'sky-opacity'?: number | Expression | undefined;
        'sky-type'?: 'gradient' | 'atmosphere' | undefined;
    }

    export type ElevationQueryOptions = {
        exaggerated: boolean;
    };

}
