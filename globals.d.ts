

    
    export as namespace vjmap3d;

    declare namespace vjmap3d {
    import { AnimationAction } from 'three';
import { AnimationActionLoopStyles } from 'three';
import { AnimationBlendMode } from 'three';
import { AnimationClip } from 'three';
import { AnimationMixer } from 'three';
import { AxesHelper } from 'three';
import { Blending } from 'three';
import { Box2 } from 'three';
import { Box3 } from 'three';
import { BoxGeometry } from 'three';
import { BufferAttribute } from 'three';
import { BufferGeometry } from 'three';
import { Camera } from 'three';
import { CanvasTexture } from 'three';
import { CatmullRomCurve3 } from 'three';
import { Clock } from 'three';
import { Color } from 'three';
import { ColorRepresentation } from 'three';
import { ColorSpace } from 'three';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS2DParameters } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DParameters } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CSS3DSprite } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { CubeTexture } from 'three';
import { DataTexture } from 'three';
import { DDSLoader } from 'three/examples/jsm/loaders/DDSLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { Euler } from 'three';
import { EulerOrder } from 'three/src/math/Euler';
import { EventDispatcher as EventDispatcher_2 } from 'three';
import { ExtrudeGeometryOptions } from 'three';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
import { FileLoader } from 'three';
import type { Float32BufferAttribute } from 'three';
import { Fog } from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GridHelper } from 'three';
import { Group as Group_2 } from 'three';
import { ImageLoader } from 'three';
import { InstancedBufferGeometry } from 'three';
import { InstancedInterleavedBuffer } from 'three';
import { InstancedMesh } from 'three';
import { InterleavedBufferAttribute } from 'three';
import { InterpolationModes } from 'three';
import { Intersection } from 'three';
import { IUniform } from 'three';
import { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';
import { Layers } from 'three';
import { Light } from 'three';
import { Line3 } from 'three';
import { Line as Line_2 } from 'three';
import { LineBasicMaterial } from 'three';
import { LineBasicMaterialParameters } from 'three';
import { LineDashedMaterialParameters } from 'three';
import { LineMaterialParameters as LineMaterialParameters_2 } from 'three/examples/jsm/lines/LineMaterial.js';
import { LineSegments } from 'three';
import { LineSegments2 as LineSegments2_2 } from 'three/examples/jsm/lines/LineSegments2.js';
import { Loader } from 'three';
import { LoadingManager } from 'three';
import { Lut } from 'three/examples/jsm/math/Lut.js';
import { MagnificationTextureFilter } from 'three';
import { Material } from 'three';
import { MaterialParameters } from 'three';
import { Matrix3 } from 'three';
import { Matrix4 } from 'three';
import { Matrix4Tuple } from 'three';
import { Mesh } from 'three';
import { MeshBasicMaterial } from 'three';
import { MeshBasicMaterialParameters } from 'three';
import { MeshLambertMaterialParameters } from 'three';
import { MeshPhongMaterial } from 'three';
import { MeshPhysicalMaterial } from 'three';
import { MeshStandardMaterial } from 'three';
import { MeshStandardMaterialParameters } from 'three';
import { MinificationTextureFilter } from 'three';
import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
import { NormalBufferAttributes } from 'three';
import { Object3D } from 'three';
import { Object3DEventMap } from 'three';
import { ObjectLoader } from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
import { OrthographicCamera } from 'three';
import { ParametricGeometry } from 'three/examples/jsm/geometries/ParametricGeometry.js';
import { PerspectiveCamera } from 'three';
import { Plane } from 'three';
import { PlaneGeometry } from 'three';
import { Points } from 'three';
import { PointsMaterial } from 'three';
import { PointsMaterialParameters } from 'three';
import { Quaternion } from 'three';
import { RawShaderMaterial } from 'three';
import { Ray } from 'three';
import { Raycaster } from 'three';
import { RaycasterParameters } from 'three';
import { Renderer } from 'three';
import { RenderTargetOptions } from 'three';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { Scene } from 'three';
import { ShaderMaterial } from 'three';
import { ShaderMaterialParameters } from 'three';
import { Shape as Shape_2 } from 'three';
import { Side } from 'three';
import { Sphere } from 'three';
import { Spherical } from 'three';
import { Sprite } from 'three';
import { SpriteMaterial } from 'three';
import { SpriteMaterialParameters } from 'three';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import { Texture } from 'three';
import { TextureDataType } from 'three';
import { TextureImageData } from 'three/src/textures/types';
import { Triangle } from 'three';
import { TrianglesDrawModes } from 'three';
import type { Uint16BufferAttribute } from 'three';
import { Uniform as Uniform_2 } from 'three';
import { UniformsLib } from 'three';
import { Usage } from 'three';
import { Vector2 } from 'three';
import { Vector3 } from 'three';
import { Vector3Tuple } from 'three';
import { Vector4 } from 'three';
import { WebGLMultipleRenderTargets } from 'three';
import { WebGLRenderer } from 'three';
import { WebGLRendererParameters } from 'three';
import { WebGLRenderTarget } from 'three';

import {
    Uniform,
    DepthPackingStrategies,
    DepthModes,
	Data3DTexture
} from "three";

import { Timer as Timer3 } from "three/examples/jsm/misc/Timer.js";
	/**
	 * A color channel enumeration.
	 *
	 * @type {Object}
	 * @property {Number} RED - Red.
	 * @property {Number} GREEN - Green.
	 * @property {Number} BLUE - Blue.
	 * @property {Number} ALPHA - Alpha.
	 */
	export enum ColorChannel {
		RED,
		GREEN,
		BLUE,
		ALPHA,
	}

	/**
	 * The Disposable contract.
	 *
	 * Implemented by objects that can free internal resources.
	 *
	 * @interface
	 */
	export interface Disposable {

		/**
		 * Frees internal resources.
		 */
		dispose(): void;

	}

	/**
	 * The initializable contract.
	 *
	 * Implemented by objects that can be initialized.
	 *
	 * @interface
	 */
	export interface Initializable {

		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - A renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A Gauss kernel.
	 *
	 */
	export class GaussKernel {

		/**
		 * Constructs a new Gauss kernel.
		 *
		 * @param kernelSize - The kernel size. Should be an odd number in the range [3, 1020].
		 * @param [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.
		 */
		constructor(kernelSize: number, edgeBias: number);

	}
	/**
	 * An adaptive luminance shader material.
	 */
	export class AdaptiveLuminanceMaterial extends ShaderMaterial {

		/**
		 * Constructs a new adaptive luminance material.
		 */
		constructor();
		/**
		 * The primary luminance buffer that contains the downsampled average luminance.
		 *
		 * @type {Texture}
		 */
		set luminanceBuffer0(arg: Texture);
		/**
		 * Sets the primary luminance buffer that contains the downsampled average luminance.
		 *
		 * @deprecated Use luminanceBuffer0 instead.
		 * @param {Texture} value - The buffer.
		 */
		setLuminanceBuffer0(value: Texture): void;
		/**
		 * The secondary luminance buffer.
		 *
		 * @type {Texture}
		 */
		set luminanceBuffer1(arg: Texture);
		/**
		 * Sets the secondary luminance buffer.
		 *
		 * @deprecated Use luminanceBuffer1 instead.
		 * @param {Texture} value - The buffer.
		 */
		setLuminanceBuffer1(value: Texture): void;
		/**
		 * The 1x1 mipmap level.
		 *
		 * This level is used to identify the smallest mipmap of the primary luminance buffer.
		 *
		 * @type {Number}
		 */
		set mipLevel1x1(arg: number);
		/**
		 * Sets the 1x1 mipmap level.
		 *
		 * @deprecated Use mipLevel1x1 instead.
		 * @param {Number} value - The level.
		 */
		setMipLevel1x1(value: number): void;
		/**
		 * The delta time.
		 *
		 * @type {Number}
		 */
		set deltaTime(arg: number);
		/**
		 * Sets the delta time.
		 *
		 * @deprecated Use deltaTime instead.
		 * @param {Number} value - The delta time.
		 */
		setDeltaTime(value: number): void;
		set minLuminance(arg: number);
		/**
		 * The lowest possible luminance value.
		 *
		 * @type {Number}
		 */
		get minLuminance(): number;
		/**
		 * Returns the lowest possible luminance value.
		 *
		 * @deprecated Use minLuminance instead.
		 * @return {Number} The minimum luminance.
		 */
		getMinLuminance(): number;
		/**
		 * Sets the minimum luminance.
		 *
		 * @deprecated Use minLuminance instead.
		 * @param {Number} value - The minimum luminance.
		 */
		setMinLuminance(value: number): void;
		set adaptationRate(arg: number);
		/**
		 * The luminance adaptation rate.
		 *
		 * @type {Number}
		 */
		get adaptationRate(): number;
		/**
		 * Returns the luminance adaptation rate.
		 *
		 * @deprecated Use adaptationRate instead.
		 * @return {Number} The adaptation rate.
		 */
		getAdaptationRate(): number;
		/**
		 * Sets the luminance adaptation rate.
		 *
		 * @deprecated Use adaptationRate instead.
		 * @param {Number} value - The adaptation rate.
		 */
		setAdaptationRate(value: number): void;

	}

	/**
	 * A bokeh disc blur material.
	 *
	 * This material should be applied twice in a row, with `fill` mode enabled for the second pass. Enabling the
	 * `foreground` option causes the shader to combine the near and far CoC values around foreground objects.
	 *
	 * @implements {Resizable}
	 */
	export class BokehMaterial extends ShaderMaterial implements Resizable {

		/**
		 * Constructs a new bokeh material.
		 *
		 * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.
		 * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.
		 */
		constructor(fill?: boolean, foreground?: boolean);
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The buffer.
		 */
		setInputBuffer(value: Texture): void;
		/**
		 * The circle of confusion buffer.
		 *
		 * @type {Texture}
		 */
		set cocBuffer(arg: Texture);
		/**
		 * Sets the circle of confusion buffer.
		 *
		 * @deprecated Use cocBuffer instead.
		 * @param {Texture} value - The buffer.
		 */
		setCoCBuffer(value: Texture): void;
		set scale(arg: number);
		/**
		 * The blur scale.
		 *
		 * @type {Number}
		 */
		get scale(): number;
		/**
		 * Returns the blur scale.
		 *
		 * @deprecated Use scale instead.
		 * @return {Number} The scale.
		 */
		getScale(value: number): number;
		/**
		 * Sets the blur scale.
		 *
		 * @deprecated Use scale instead.
		 * @param {Number} value - The scale.
		 */
		setScale(value: number): void;
		/**
		 * Sets the texel size.
		 *
		 * @deprecated Use setSize() instead.
		 * @param {Number} x - The texel width.
		 * @param {Number} y - The texel height.
		 */
		setTexelSize(x: number, y: number): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * A Circle of Confusion shader material.
	 */
	export class CircleOfConfusionMaterial extends ShaderMaterial {

		/**
		 * Constructs a new CoC material.
		 *
		 * @param {Camera} camera - A camera.
		 */
		constructor(camera: Camera);
		/**
		 * The depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		set focusDistance(arg: number);
		/**
		 * The focus distance. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get focusDistance(): number;
		/**
		 * Returns the focus distance.
		 *
		 * @deprecated Use focusDistance instead.
		 * @return {Number} The focus distance.
		 */
		getFocusDistance(value: number): number;
		/**
		 * Sets the focus distance.
		 *
		 * @deprecated Use focusDistance instead.
		 * @param {Number} value - The focus distance.
		 */
		setFocusDistance(value: number): void;
		set focalLength(arg: number);
		/**
		 * The focal length.
		 *
		 * @deprecated Renamed to focusRange.
		 * @type {Number}
		 */
		get focalLength(): number;
		/**
		 * Returns the focal length.
		 *
		 * @deprecated Use focusRange instead.
		 * @return {Number} The focal length.
		 */
		getFocalLength(value: number): number;
		/**
		 * Sets the focal length.
		 *
		 * @deprecated Use focusRange instead.
		 * @param {Number} value - The focal length.
		 */
		setFocalLength(value: number): void;
		/**
		 * Adopts the settings of the given camera.
		 *
		 * @param {Camera} camera - A camera.
		 */
		adoptCameraSettings(camera: Camera): void;

		/**
		 * The focus distance in world units.
		 *
		 * @type {Number}
		 */
		get worldFocusDistance(): number;
		set worldFocusDistance(value: number);

		/**
		 * The focus range. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get focusRange(): number;
		set focusRange(value: number);

		/**
		 * The focus range in world units.
		 *
		 * @type {Number}
		 */
		get worldFocusRange(): number;
		set worldFocusRange(value: number);

	}

	/**
	 * A blur kernel size enumeration.
	 *
	 * @type {Object}
	 * @property {Number} VERY_SMALL - A very small kernel that matches a 7x7 Gaussian blur kernel.
	 * @property {Number} SMALL - A small kernel that matches a 15x15 Gaussian blur kernel.
	 * @property {Number} MEDIUM - A medium sized kernel that matches a 23x23 Gaussian blur kernel.
	 * @property {Number} LARGE - A large kernel that matches a 35x35 Gaussian blur kernel.
	 * @property {Number} VERY_LARGE - A very large kernel that matches a 63x63 Gaussian blur kernel.
	 * @property {Number} HUGE - A huge kernel that matches a 127x127 Gaussian blur kernel.
	 */
	export enum KernelSize {
		VERY_SMALL,
		SMALL,
		MEDIUM,
		LARGE,
		VERY_LARGE,
		HUGE,
	}

	/**
	 * A simple copy shader material.
	 */
	export class CopyMaterial extends ShaderMaterial {

		/**
		 * Constructs a new copy material.
		 */
		constructor();
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Number} value - The buffer.
		 */
		setInputBuffer(value: number): void;
		/**
		 * Returns the opacity.
		 *
		 * @deprecated Use opacity instead.
		 * @return {Number} The opacity.
		 */
		getOpacity(): number;
		/**
		 * Sets the opacity.
		 *
		 * @deprecated Use opacity instead.
		 * @param {Number} value - The opacity.
		 */
		setOpacity(value: number): void;

	}

	/**
	 * A depth comparison shader material.
	 */
	export class DepthComparisonMaterial extends ShaderMaterial {

		/**
		 * Constructs a new depth comparison material.
		 *
		 * @param {Texture} [depthTexture=null] - A depth texture.
		 * @param {PerspectiveCamera} [camera] - A camera.
		 */
		constructor(depthTexture?: Texture, camera?: PerspectiveCamera);
		/**
		 * The depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Adopts the settings of the given camera.
		 *
		 * @param {Camera} camera - A camera.
		 */
		adoptCameraSettings(camera: Camera): void;

	}

	/**
	 * An enumeration of depth copy modes.
	 *
	 * @type {Object}
	 * @property {Number} FULL - Copies the full depth texture every frame.
	 * @property {Number} SINGLE - Copies a single texel from the depth texture on demand.
	 */
	export enum DepthCopyMode {
		FULL,
		SINGLE,
	}

	/**
	 * A depth copy shader material.
	 */
	export class DepthCopyMaterial extends ShaderMaterial {

		/**
		 * Constructs a new depth copy material.
		 */
		constructor();
		/**
		 * The input depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The input depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set inputDepthPacking(arg: DepthPackingStrategies);
		set outputDepthPacking(arg: DepthPackingStrategies);
		/**
		 * The output depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		get outputDepthPacking(): DepthPackingStrategies;
		/**
		 * Sets the input depth buffer.
		 *
		 * @deprecated Use depthBuffer and inputDepthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Returns the current input depth packing strategy.
		 *
		 * @deprecated
		 * @return {DepthPackingStrategies} The input depth packing strategy.
		 */
		getInputDepthPacking(): DepthPackingStrategies;
		/**
		 * Sets the input depth packing strategy.
		 *
		 * @deprecated Use inputDepthPacking instead.
		 * @param {DepthPackingStrategies} value - The new input depth packing strategy.
		 */
		setInputDepthPacking(value: DepthPackingStrategies): void;
		/**
		 * Returns the current output depth packing strategy.
		 *
		 * @deprecated Use outputDepthPacking instead.
		 * @return {DepthPackingStrategies} The output depth packing strategy.
		 */
		getOutputDepthPacking(): DepthPackingStrategies;
		/**
		 * Sets the output depth packing strategy.
		 *
		 * @deprecated Use outputDepthPacking instead.
		 * @param {DepthPackingStrategies} value - The new output depth packing strategy.
		 */
		setOutputDepthPacking(value: DepthPackingStrategies): void;
		/**
		 * The screen space position used for single-texel copy operations.
		 *
		 * @type {Vector2}
		 */
		get texelPosition(): Vector2;
		/**
		 * Returns the screen space position used for single-texel copy operations.
		 *
		 * @deprecated Use texelPosition instead.
		 * @return {Vector2} The position.
		 */
		getTexelPosition(): Vector2;
		/**
		 * Sets the screen space position used for single-texel copy operations.
		 *
		 * @deprecated
		 * @param {Vector2} value - The position.
		 */
		setTexelPosition(value: Vector2): void;
		set mode(arg: DepthCopyMode);
		/**
		 * The depth copy mode.
		 *
		 * @type {DepthCopyMode}
		 */
		get mode(): DepthCopyMode;
		/**
		 * Returns the depth copy mode.
		 *
		 * @deprecated Use mode instead.
		 * @return {DepthCopyMode} The depth copy mode.
		 */
		getMode(): DepthCopyMode;
		/**
		 * Sets the depth copy mode.
		 *
		 * @deprecated Use mode instead.
		 * @param {DepthCopyMode} value - The new mode.
		 */
		setMode(value: DepthCopyMode): void;

	}

	/**
	 * A depth downsampling shader material.
	 *
	 *
	 * @implements {Resizable}
	 */
	export class DepthDownsamplingMaterial
		extends ShaderMaterial
		implements Resizable {

		/**
		 * Constructs a new depth downsampling material.
		 */
		constructor();
		/**
		 * The depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * The normal buffer.
		 *
		 * @type {Texture}
		 */
		set normalBuffer(arg: Texture);
		/**
		 * Sets the normal buffer.
		 *
		 * @deprecated Use normalBuffer instead.
		 * @param {Texture} value - The normal buffer.
		 */
		setNormalBuffer(value: Texture): void;
		/**
		 * Sets the texel size.
		 *
		 * @deprecated Use setSize() instead.
		 * @param {Number} x - The texel width.
		 * @param {Number} y - The texel height.
		 */
		setTexelSize(x: number, y: number): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * An enumeration of depth test strategies.
	 *
	 * @type {Object}
	 * @property {Number} DEFAULT - Perform depth test only.
	 * @property {Number} KEEP_MAX_DEPTH - Always keep max depth.
	 * @property {Number} DISCARD_MAX_DEPTH - Always discard max depth.
	 */
	export enum DepthTestStrategy {
		DEFAULT,
		KEEP_MAX_DEPTH,
		DISCARD_MAX_DEPTH,
	}

	/**
	 * A depth mask shader material.
	 *
	 * This material masks a color buffer by comparing two depth textures.
	 */
	export class DepthMaskMaterial extends ShaderMaterial {

		/**
		 * Constructs a new depth mask material.
		 */
		constructor();
		set depthMode(arg: DepthModes);
		/**
		 * The depth mode.
		 *
		 * @type {DepthModes}
		 */
		get depthMode(): DepthModes;
		/**
		 * The primary depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer0(arg: Texture);
		/**
		 * The primary depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking0(arg: DepthPackingStrategies);
		/**
		 * Sets the base depth buffer.
		 *
		 * @deprecated Use depthBuffer0 and depthPacking0 instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer0(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * The secondary depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer1(arg: Texture);
		/**
		 * The secondary depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking1(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer that will be compared with the base depth buffer.
		 *
		 * @deprecated Use depthBuffer1 and depthPacking1 instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer1(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		set maxDepthStrategy(arg: DepthTestStrategy);
		/**
		 * The strategy for handling maximum depth.
		 *
		 * @type {DepthTestStrategy}
		 */
		get maxDepthStrategy(): DepthTestStrategy;
		set keepFar(arg: boolean);
		/**
		 * Indicates whether maximum depth values should be preserved.
		 *
		 * @type {Boolean}
		 * @deprecated Use maxDepthStrategy instead.
		 */
		get keepFar(): boolean;
		/**
		 * Returns the strategy for dealing with maximum depth values.
		 *
		 * @deprecated Use maxDepthStrategy instead.
		 * @return {DepthTestStrategy} The strategy.
		 */
		getMaxDepthStrategy(): DepthTestStrategy;
		/**
		 * Sets the strategy for dealing with maximum depth values.
		 *
		 * @deprecated Use maxDepthStrategy instead.
		 * @param {DepthTestStrategy} value - The strategy.
		 */
		setMaxDepthStrategy(value: DepthTestStrategy): void;
		set epsilon(arg: number);
		/**
		 * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-5`.
		 *
		 * @type {Number}
		 */
		get epsilon(): number;
		/**
		 * Returns the current error threshold for depth comparisons. Default is `1e-5`.
		 *
		 * @deprecated Use epsilon instead.
		 * @return {Number} The error threshold.
		 */
		getEpsilon(): number;
		/**
		 * Sets the depth comparison error threshold.
		 *
		 * @deprecated Use epsilon instead.
		 * @param {Number} value - The new error threshold.
		 */
		setEpsilon(value: number): void;
		/**
		 * Returns the current depth mode.
		 *
		 * @deprecated Use depthMode instead.
		 * @return {DepthModes} The depth mode. Default is `LessDepth`.
		 */
		getDepthMode(): DepthModes;
		/**
		 * Sets the depth mode.
		 *
		 * @deprecated Use depthMode instead.
		 * @param {DepthModes} mode - The depth mode.
		 */
		setDepthMode(mode: DepthModes): void;

	}

	/**
	 * An enumeration of edge detection modes.
	 *
	 * @type {Object}
	 * @property {Number} DEPTH - Depth-based edge detection.
	 * @property {Number} LUMA - Luminance-based edge detection.
	 * @property {Number} COLOR - Chroma-based edge detection.
	 */
	export enum EdgeDetectionMode {
		DEPTH,
		LUMA,
		COLOR,
	}

	/**
	 * An enumeration of predication modes.
	 *
	 * @type {Object}
	 * @property {Number} DISABLED - No predicated thresholding.
	 * @property {Number} DEPTH - Depth-based predicated thresholding.
	 * @property {Number} CUSTOM - Predicated thresholding using a custom buffer.
	 */
	export enum PredicationMode {
		DISABLED,
		DEPTH,
		CUSTOM,
	}
	/**
	 * An edge detection material.
	 *
	 * Mainly used for Subpixel Morphological Anti-Aliasing.
	 *
	 * @implements {Resizable}
	 */
	export class EdgeDetectionMaterial
		extends ShaderMaterial
		implements Resizable {

		/**
		 * Constructs a new edge detection material.
		 *
		 * TODO Remove parameters.
		 * @param {Vector2} [texelSize] - The screen texel size.
		 * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
		 */
		constructor(texelSize?: Vector2, mode?: EdgeDetectionMode);
		set edgeDetectionMode(arg: EdgeDetectionMode);
		/**
		 * The edge detection mode.
		 *
		 * @type {EdgeDetectionMode}
		 */
		get edgeDetectionMode(): EdgeDetectionMode;
		/**
		 * The depth buffer.
		 *
		 * @type {Texture}
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Returns the edge detection mode.
		 *
		 * @deprecated Use edgeDetectionMode instead.
		 * @return {EdgeDetectionMode} The mode.
		 */
		getEdgeDetectionMode(): EdgeDetectionMode;
		/**
		 * Sets the edge detection mode.
		 *
		 * @deprecated Use edgeDetectionMode instead.
		 * @param {EdgeDetectionMode} value - The edge detection mode.
		 */
		setEdgeDetectionMode(value: EdgeDetectionMode): void;
		set localContrastAdaptationFactor(arg: number);
		/**
		 * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
		 *
		 * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
		 *
		 * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
		 * direction, the perceptual contrast in the other neighbors will be hidden.
		 *
		 * @type {Number}
		 */
		get localContrastAdaptationFactor(): number;
		/**
		 * Returns the local contrast adaptation factor.
		 *
		 * @deprecated Use localContrastAdaptationFactor instead.
		 * @return {Number} The factor.
		 */
		getLocalContrastAdaptationFactor(): number;
		/**
		 * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
		 *
		 * @deprecated Use localContrastAdaptationFactor instead.
		 * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
		 */
		setLocalContrastAdaptationFactor(value: number): void;
		set edgeDetectionThreshold(arg: number);
		/**
		 * The edge detection threshold. Range: [0.0, 0.5].
		 *
		 * A lower value results in more edges being detected at the expense of performance.
		 *
		 * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
		 * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
		 *
		 * If depth-based edge detection is used, the threshold will depend on the scene depth.
		 *
		 * @type {Number}
		 */
		get edgeDetectionThreshold(): number;
		/**
		 * Returns the edge detection threshold.
		 *
		 * @deprecated Use edgeDetectionThreshold instead.
		 * @return {Number} The threshold.
		 */
		getEdgeDetectionThreshold(): number;
		/**
		 * Sets the edge detection threshold.
		 *
		 * @deprecated Use edgeDetectionThreshold instead.
		 * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
		 */
		setEdgeDetectionThreshold(value: number): void;
		set predicationMode(arg: PredicationMode);
		/**
		 * The predication mode.
		 *
		 * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
		 * buffer such as a light accumulation or depth buffer.
		 *
		 * @type {PredicationMode}
		 */
		get predicationMode(): PredicationMode;
		/**
		 * Returns the predication mode.
		 *
		 * @deprecated Use predicationMode instead.
		 * @return {PredicationMode} The mode.
		 */
		getPredicationMode(): PredicationMode;
		/**
		 * Sets the predication mode.
		 *
		 * @deprecated Use predicationMode instead.
		 * @param {PredicationMode} value - The predication mode.
		 */
		setPredicationMode(value: PredicationMode): void;
		/**
		 * The predication buffer.
		 *
		 * @type {Texture}
		 */
		set predicationBuffer(arg: Texture);
		/**
		 * Sets a custom predication buffer.
		 *
		 * @deprecated Use predicationBuffer instead.
		 * @param {Texture} value - The predication buffer.
		 */
		setPredicationBuffer(value: Texture): void;
		set predicationThreshold(arg: number);
		/**
		 * The predication threshold.
		 *
		 * @type {Number}
		 */
		get predicationThreshold(): number;
		/**
		 * Returns the predication threshold.
		 *
		 * @deprecated Use predicationThreshold instead.
		 * @return {Number} The threshold.
		 */
		getPredicationThreshold(): number;
		/**
		 * Sets the predication threshold.
		 *
		 * @deprecated Use predicationThreshold instead.
		 * @param {Number} value - The threshold.
		 */
		setPredicationThreshold(value: number): void;
		set predicationScale(arg: number);
		/**
		 * The predication scale. Range: [1.0, 5.0].
		 *
		 * Determines how much the edge detection threshold should be scaled when using predication.
		 *
		 * @type {Number}
		 */
		get predicationScale(): number;
		/**
		 * Returns the predication scale.
		 *
		 * @deprecated Use predicationScale instead.
		 * @return {Number} The scale.
		 */
		getPredicationScale(): number;
		/**
		 * Sets the predication scale.
		 *
		 * @deprecated Use predicationScale instead.
		 * @param {Number} value - The scale. Range: [1.0, 5.0].
		 */
		setPredicationScale(value: number): void;
		set predicationStrength(arg: number);
		/**
		 * The predication strength. Range: [0.0, 1.0].
		 *
		 * Determines how much the edge detection threshold should be decreased locally when using predication.
		 *
		 * @type {Number}
		 */
		get predicationStrength(): number;
		/**
		 * Returns the predication strength.
		 *
		 * @deprecated Use predicationStrength instead.
		 * @return {Number} The strength.
		 */
		getPredicationStrength(): number;
		/**
		 * Sets the predication strength.
		 *
		 * @deprecated Use predicationStrength instead.
		 * @param {Number} value - The strength. Range: [0.0, 1.0].
		 */
		setPredicationStrength(value: number): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	export type ColorEdgesMaterial = EdgeDetectionMaterial;

	/**
	 * An effect material for compound shaders. Supports dithering.
	 *
	 * @implements {Resizable}
	 */
	export class EffectMaterial extends ShaderMaterial implements Resizable {

		/**
		 * An enumeration of shader code section placeholders used by the {@link EffectPass}.
		 *
		 * @type {Object}
		 * @property {String} FRAGMENT_HEAD - A placeholder for function and variable declarations inside the fragment shader.
		 * @property {String} FRAGMENT_MAIN_UV - A placeholder for UV transformations inside the fragment shader.
		 * @property {String} FRAGMENT_MAIN_IMAGE - A placeholder for color calculations inside the fragment shader.
		 * @property {String} VERTEX_HEAD - A placeholder for function and variable declarations inside the vertex shader.
		 * @property {String} VERTEX_MAIN_SUPPORT - A placeholder for supporting calculations inside the vertex shader.
		 */
		static get Section(): {
			FRAGMENT_HEAD: string;
			FRAGMENT_MAIN_UV: string;
			FRAGMENT_MAIN_IMAGE: string;
			VERTEX_HEAD: string;
			VERTEX_MAIN_SUPPORT: string;
		};

		/**
		 * Constructs a new effect material.
		 *
		 * @param {Map<String, String>} [shaderParts] - A collection of shader snippets. See {@link Section}.
		 * @param {Map<String, String>} [defines] - A collection of preprocessor macro definitions.
		 * @param {Map<String, Uniform>} [uniforms] - A collection of uniforms.
		 * @param {Camera} [camera] - A camera.
		 * @param {Boolean} [dithering=false] - Whether dithering should be enabled.
		 */
		constructor(
			shaderParts?: Map<string, string>,
			defines?: Map<string, string>,
			uniforms?: Map<string, Uniform>,
			camera?: Camera,
			dithering?: boolean
		);

		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		set depthBuffer(arg: Texture);
		/**
		 * The depth buffer.
		 *
		 * @type {Texture}
		 */
		get depthBuffer(): Texture;
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * The depth packing strategy.
		 *
		 * @type {DepthPackingStrategies}
		 */
		get depthPacking(): DepthPackingStrategies;
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Sets the shader parts.
		 *
		 * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link Section}.
		 * @return {EffectMaterial} This material.
		 */
		setShaderParts(shaderParts: Map<string, string>): EffectMaterial;
		/**
		 * Sets the shader macros.
		 *
		 * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
		 * @return {EffectMaterial} This material.
		 */
		setDefines(defines: Map<string, string>): EffectMaterial;
		/**
		 * Sets the shader uniforms.
		 *
		 * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
		 * @return {EffectMaterial} This material.
		 */
		setUniforms(uniforms: Map<string, Uniform>): EffectMaterial;
		/**
		 * Sets the required shader extensions.
		 *
		 * @param {Set<WebGLExtension>} extensions - A collection of extensions.
		 * @return {EffectMaterial} This material.
		 */
		setExtensions(extensions: Set<WebGLExtension>): EffectMaterial;
		set encodeOutput(arg: boolean);
		/**
		 * Indicates whether output encoding is enabled.
		 *
		 * @type {Boolean}
		 */
		get encodeOutput(): boolean;
		/**
		 * Indicates whether output encoding is enabled.
		 *
		 * @deprecated Use encodeOutput instead.
		 * @return {Boolean} Whether output encoding is enabled.
		 */
		isOutputEncodingEnabled(): boolean;
		/**
		 * Enables or disables output encoding.
		 *
		 * @deprecated Use encodeOutput instead.
		 * @param {Boolean} value - Whether output encoding should be enabled.
		 */
		setOutputEncodingEnabled(value: boolean): void;
		set time(arg: number);
		/**
		 * The time in seconds.
		 *
		 * @type {Number}
		 */
		get time(): number;
		/**
		 * Sets the delta time.
		 *
		 * @deprecated Use time instead.
		 * @param {Number} value - The delta time in seconds.
		 */
		setDeltaTime(value: number): void;
		/**
		 * Adopts the settings of the given camera.
		 *
		 * @param {Camera} camera - A camera.
		 */
		adoptCameraSettings(camera: Camera): void;
		/**
		 * Sets the resolution.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * An enumeration of shader code placeholders used by the {@link EffectPass}.
	 * @property FRAGMENT_HEAD - A placeholder for function and variable declarations inside the fragment shader.
	 * @property FRAGMENT_MAIN_UV - A placeholder for UV transformations inside the fragment shader.
	 * @property FRAGMENT_MAIN_IMAGE - A placeholder for color calculations inside the fragment shader.
	 * @property VERTEX_HEAD - A placeholder for function and variable declarations inside the vertex shader.
	 * @property VERTEX_MAIN_SUPPORT - A placeholder for supporting calculations inside the vertex shader.
	 * @deprecated Use EffectMaterial.Section instead.
	 */
	export const Section: {
		FRAGMENT_HEAD: string;
		FRAGMENT_MAIN_UV: string;
		FRAGMENT_MAIN_IMAGE: string;
		VERTEX_HEAD: string;
		VERTEX_MAIN_SUPPORT: string;
	};

	/**
	 * A crepuscular rays shader material.
	 *
	 * @todo Remove dithering code from fragment shader.
	 */
	export class GodRaysMaterial extends ShaderMaterial {

		/**
		 * Constructs a new god rays material.
		 *
		 * TODO Remove lightPosition param.
		 * @param {Vector2} lightPosition - Deprecated.
		 */
		constructor(lightPosition: Vector2);
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		/**
		 * The screen space position of the light source.
		 *
		 * @type {Vector2}
		 */
		get lightPosition(): Vector2;
		/**
		 * Returns the screen space position of the light source.
		 *
		 * @deprecated Use lightPosition instead.
		 * @return {Vector2} The position.
		 */
		getLightPosition(): Vector2;
		/**
		 * Sets the screen space position of the light source.
		 *
		 * @deprecated Use lightPosition instead.
		 * @param {Vector2} value - The position.
		 */
		setLightPosition(value: Vector2): void;
		set density(arg: number);
		/**
		 * The density.
		 *
		 * @type {Number}
		 */
		get density(): number;
		/**
		 * Returns the density.
		 *
		 * @deprecated Use density instead.
		 * @return {Number} The density.
		 */
		getDensity(): number;
		/**
		 * Sets the density.
		 *
		 * @deprecated Use density instead.
		 * @param {Number} value - The density.
		 */
		setDensity(value: number): void;
		set decay(arg: number);
		/**
		 * The decay.
		 *
		 * @type {Number}
		 */
		get decay(): number;
		/**
		 * Returns the decay.
		 *
		 * @deprecated Use decay instead.
		 * @return {Number} The decay.
		 */
		getDecay(): number;
		/**
		 * Sets the decay.
		 *
		 * @deprecated Use decay instead.
		 * @param {Number} value - The decay.
		 */
		setDecay(value: number): void;
		set weight(arg: number);
		/**
		 * The weight.
		 *
		 * @type {Number}
		 */
		get weight(): number;
		/**
		 * Returns the weight.
		 *
		 * @deprecated Use weight instead.
		 * @return {Number} The weight.
		 */
		getWeight(): number;
		/**
		 * Sets the weight.
		 *
		 * @deprecated Use weight instead.
		 * @param {Number} value - The weight.
		 */
		setWeight(value: number): void;
		set exposure(arg: number);
		/**
		 * The exposure.
		 *
		 * @type {Number}
		 */
		get exposure(): number;
		/**
		 * Returns the exposure.
		 *
		 * @deprecated Use exposure instead.
		 * @return {Number} The exposure.
		 */
		getExposure(): number;
		/**
		 * Sets the exposure.
		 *
		 * @deprecated Use exposure instead.
		 * @param {Number} value - The exposure.
		 */
		setExposure(value: number): void;
		set maxIntensity(arg: number);
		/**
		 * The maximum light intensity.
		 *
		 * @type {Number}
		 */
		get maxIntensity(): number;
		/**
		 * Returns the maximum light intensity.
		 *
		 * @deprecated Use maxIntensity instead.
		 * @return {Number} The maximum light intensity.
		 */
		getMaxIntensity(): number;
		/**
		 * Sets the maximum light intensity.
		 *
		 * @deprecated Use maxIntensity instead.
		 * @param {Number} value - The maximum light intensity.
		 */
		setMaxIntensity(value: number): void;
		set samples(arg: number);
		/**
		 * The amount of samples per pixel.
		 *
		 * @type {Number}
		 */
		get samples(): number;
		/**
		 * Returns the amount of samples per pixel.
		 *
		 * @deprecated Use samples instead.
		 * @return {Number} The sample count.
		 */
		getSamples(): number;
		/**
		 * Sets the amount of samples per pixel.
		 *
		 * @deprecated Use samples instead.
		 * @param {Number} value - The sample count.
		 */
		setSamples(value: number): void;

	}

	/**
	 * A box blur material.
	 *
	 * @implements {Resizable}
	 */

	export class BoxBlurMaterial extends ShaderMaterial {}

	/**
	 * A box blur pass.
	 */

	export class BoxBlurPass extends Pass {

		/**
		 * Constructs a new box blur pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.kernelSize=5] - The kernel size.
		 * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.
		 * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 */

		constructor(
			{
				kernelSize,
				iterations,
				bilateral,
				resolutionScale,
				resolutionX,
				resolutionY
			}?: {
				kernelSize?: number;
				iterations?: number;
				bilateral?: boolean;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
			}
		);

	}

	/**
	 * An optimized Gaussian convolution shader material.
	 * @implements {Resizable}
	 */

	export class GaussianBlurMaterial extends ShaderMaterial {

		/**
		 * Constructs a new convolution material.
		 *
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.kernelSize=35] - The kernel size.
		 */
		constructor(
			{
				kernelSize
			}?: {
				kernelSize?: number;
			}
		);

	}

	/**
	 * A Gaussian blur pass.
	 */

	export class GaussianBlurPass extends Pass {

		/**
		 * Constructs a new Gaussian blur pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].
		 * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 */

		constructor(
			{
				kernelSize,
				iterations,
				resolutionScale,
				resolutionX,
				resolutionY
			}?: {
				kernelSize?: number;
				iterations?: number;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
			}
		);

	}

	/**
	 * An optimised convolution shader material.
	 *
	 * @todo Remove dithering code from fragment shader.
	 * @implements {Resizable}
	 */
	export class KawaseBlurMaterial extends ShaderMaterial implements Resizable {

		/**
		 * Constructs a new convolution material.
		 *
		 * TODO Remove texelSize param.
		 * @param {Vector2} [texelSize] - Deprecated.
		 */
		constructor(texelSize?: Vector2);
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		set scale(arg: number);
		/**
		 * The blur scale.
		 *
		 * @type {Number}
		 */
		get scale(): number;
		/**
		 * Returns the blur scale.
		 *
		 * @deprecated Use scale instead.
		 * @return {Number} The scale.
		 */
		getScale(): number;
		/**
		 * Sets the blur scale.
		 *
		 * @deprecated Use scale instead.
		 * @param {Number} value - The scale.
		 */
		setScale(value: number): void;
		/**
		 * Returns the kernel.
		 *
		 * @return {Float32Array} The kernel.
		 * @deprecated Implementation detail, removed with no replacement.
		 */
		getKernel(): Float32Array;
		set kernel(arg: number);
		/**
		 * The current kernel.
		 *
		 * @type {Number}
		 */
		get kernel(): number;
		/**
		 * Sets the current kernel.
		 *
		 * @deprecated Use kernel instead.
		 * @param {Number} value - The kernel.
		 */
		setKernel(value: number): void;
		/**
		 * Sets the texel size.
		 *
		 * @deprecated Use setSize() instead.
		 * @param {Number} x - The texel width.
		 * @param {Number} y - The texel height.
		 */
		setTexelSize(x: number, y: number): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	export type ConvolutionMaterial2 = KawaseBlurMaterial;

	/**
	 * A luminance shader material.
	 *
	 * This shader produces a greyscale luminance map that describes the absolute amount of light emitted by a scene. It can
	 * also be configured to output colors that are scaled with their respective luminance value. Additionally, a range may
	 * be provided to mask out undesired texels.
	 *
	 * The alpha channel always contains the luminance value.
	 */
	export class LuminanceMaterial extends ShaderMaterial {

		/**
		 * Constructs a new luminance material.
		 *
		 * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
		 * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
		 */
		constructor(colorOutput?: boolean, luminanceRange?: Vector2);
		set colorOutput(arg: boolean);
		/**
		 * Indicates whether color output is enabled.
		 *
		 * @type {Boolean}
		 */
		get colorOutput(): boolean;
		set luminanceRange(arg: boolean);
		/**
		 * The luminance range. Set to null to disable.
		 *
		 * @type {Boolean}
		 */
		get luminanceRange(): boolean;
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		set threshold(arg: number);
		/**
		 * The luminance threshold.
		 *
		 * @type {Number}
		 */
		get threshold(): number;
		/**
		 * Returns the luminance threshold.
		 *
		 * @deprecated Use threshold instead.
		 * @return {Number} The threshold.
		 */
		getThreshold(): number;
		/**
		 * Sets the luminance threshold.
		 *
		 * @deprecated Use threshold instead.
		 * @param {Number} value - The threshold.
		 */
		setThreshold(value: number): void;
		set smoothing(arg: number);
		/**
		 * The luminance threshold smoothing.
		 *
		 * @type {Number}
		 */
		get smoothing(): number;
		/**
		 * Returns the luminance threshold smoothing factor.
		 *
		 * @deprecated Use smoothing instead.
		 * @return {Number} The smoothing factor.
		 */
		getSmoothingFactor(): number;
		/**
		 * Sets the luminance threshold smoothing factor.
		 *
		 * @deprecated Use smoothing instead.
		 * @param {Number} value - The smoothing factor.
		 */
		setSmoothingFactor(value: number): void;
		set useThreshold(arg: boolean);
		/**
		 * Indicates whether the luminance threshold is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated Adjust the threshold or smoothing factor instead.
		 */
		get useThreshold(): boolean;
		/**
		 * Indicates whether color output is enabled.
		 *
		 * @deprecated Use colorOutput instead.
		 * @return {Boolean} Whether color output is enabled.
		 */
		isColorOutputEnabled(): boolean;
		/**
		 * Enables or disables color output.
		 *
		 * @deprecated Use colorOutput instead.
		 * @param {Boolean} value - Whether color output should be enabled.
		 */
		setColorOutputEnabled(value: boolean): void;
		set useRange(arg: boolean);
		/**
		 * Indicates whether luminance masking is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated
		 */
		get useRange(): boolean;
		/**
		 * Returns the current luminance range.
		 *
		 * @deprecated Use luminanceRange instead.
		 * @return {Vector2} The luminance range.
		 */
		getLuminanceRange(): Vector2;
		/**
		 * Sets a luminance range. Set to null to disable.
		 *
		 * @deprecated Use luminanceRange instead.
		 * @param {Vector2} value - The luminance range.
		 */
		setLuminanceRange(value: Vector2): void;

	}

	/**
	 * A mask function enumeration.
	 *
	 * @type {Object}
	 * @property {Number} DISCARD - Discards elements when the respective mask value is zero.
	 * @property {Number} MULTIPLY - Multiplies the input buffer with the mask texture.
	 * @property {Number} MULTIPLY_RGB_SET_ALPHA - Multiplies the input RGB values with the mask and sets alpha to the mask value.
	 * @property {Number} MULTIPLY_RGB - Multiplies the input RGB values with the mask and keeps the original alpha.
	 */
	export enum MaskFunction {
		DISCARD,
		MULTIPLY,
		MULTIPLY_RGB_SET_ALPHA,
		MULTIPLY_RGB
	}

	/**
	 * A mask shader material.
	 *
	 * This material applies a mask texture to a buffer.
	 */
	export class MaskMaterial extends ShaderMaterial {

		/**
		 * Constructs a new mask material.
		 *
		 * @param {Texture} [maskTexture] - The mask texture.
		 */
		constructor(maskTexture?: Texture);
		/**
		 * The input buffer.
		 *
		 * @type {Texture}
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		/**
		 * The mask texture.
		 *
		 * @type {Texture}
		 */
		set maskTexture(arg: Texture);
		/**
		 * Sets the mask texture.
		 *
		 * @deprecated Use maskTexture instead.
		 * @param {Texture} value - The texture.
		 */
		setMaskTexture(value: Texture): void;
		/**
		 * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
		 *
		 * @type {ColorChannel}
		 */
		set colorChannel(arg: ColorChannel);
		/**
		 * Sets the color channel to use for masking. Default is `ColorChannel.RED`.
		 *
		 * @deprecated Use colorChannel instead.
		 * @param {ColorChannel} value - The channel.
		 */
		setColorChannel(value: ColorChannel): void;
		/**
		 * The masking technique. Default is `MaskFunction.DISCARD`.
		 *
		 * @type {MaskFunction}
		 */
		set maskFunction(arg: MaskFunction);
		/**
		 * Sets the masking technique. Default is `MaskFunction.DISCARD`.
		 *
		 * @deprecated Use maskFunction instead.
		 * @param {MaskFunction} value - The function.
		 */
		setMaskFunction(value: MaskFunction): void;
		set inverted(arg: boolean);
		/**
		 * Indicates whether the masking is inverted.
		 *
		 * @type {Boolean}
		 */
		get inverted(): boolean;
		/**
		 * Indicates whether the masking is inverted.
		 *
		 * @deprecated Use inverted instead.
		 * @return {Boolean} Whether the masking is inverted.
		 */
		isInverted(): boolean;
		/**
		 * Determines whether the masking should be inverted.
		 *
		 * @deprecated Use inverted instead.
		 * @param {Boolean} value - Whether the masking should be inverted.
		 */
		setInverted(value: boolean): void;
		set strength(arg: number);
		/**
		 * The current mask strength.
		 *
		 * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.
		 *
		 * @type {Number}
		 */
		get strength(): number;
		/**
		 * Returns the current mask strength.
		 *
		 * @deprecated Use strength instead.
		 * @return {Number} The mask strength.
		 */
		getStrength(): number;
		/**
		 * Sets the mask strength.
		 *
		 * Has no effect when the mask function is set to `DISCARD`.
		 *
		 * @deprecated Use strength instead.
		 * @param {Number} value - The mask strength.
		 */
		setStrength(value: number): void;

	}

	/**
	 * An outline shader material.
	 *
	 * @implements {Resizable}
	 */
	export class OutlineMaterial extends ShaderMaterial implements Resizable {

		/**
		 * Constructs a new outline material.
		 *
		 * TODO Remove texelSize param.
		 * @param {Vector2} [texelSize] - The screen texel size.
		 */
		constructor(texelSize?: Vector2);
		/**
		 * The input buffer.
		 *
		 * @param {Texture} arg - The input buffer.
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		/**
		 * Sets the texel size.
		 *
		 * @deprecated Use setSize() instead.
		 * @param {Number} x - The texel width.
		 * @param {Number} y - The texel height.
		 */
		setTexelSize(x: number, y: number): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * An outline shader material.
	 */
	export type OutlineEdgesMaterial = OutlineMaterial;

	/**
	 * Subpixel Morphological Antialiasing.
	 *
	 * This material computes weights for detected edges.
	 *
	 * @implements {Resizable}
	 */
	export class SMAAWeightsMaterial extends ShaderMaterial implements Resizable {

		/**
		 * Constructs a new SMAA weights material.
		 *
		 * @param {Vector2} [texelSize] - The absolute screen texel size.
		 * @param {Vector2} [resolution] - The resolution.
		 */
		constructor(texelSize?: Vector2, resolution?: Vector2);
		/**
		 * The input buffer.
		 *
		 * @param {Texture} arg - The input buffer.
		 */
		set inputBuffer(arg: Texture);
		/**
		 * Sets the input buffer.
		 *
		 * @deprecated Use inputBuffer instead.
		 * @param {Texture} value - The input buffer.
		 */
		setInputBuffer(value: Texture): void;
		set searchTexture(arg: Texture);
		/**
		 * The search lookup texture.
		 *
		 * @type {Texture}
		 */
		get searchTexture(): Texture;
		set areaTexture(arg: Texture);
		/**
		 * The area lookup texture.
		 *
		 * @type {Texture}
		 */
		get areaTexture(): Texture;
		/**
		 * Sets the search and area lookup textures.
		 *
		 * @deprecated Use searchTexture and areaTexture instead.
		 * @param {Texture} search - The search lookup texture.
		 * @param {Texture} area - The area lookup texture.
		 */
		setLookupTextures(search: Texture, area: Texture): void;
		set orthogonalSearchSteps(arg: number);
		/**
		 * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
		 * Range: [0, 112].
		 *
		 * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
		 * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
		 *
		 * @type {Number}
		 */
		get orthogonalSearchSteps(): number;
		/**
		 * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
		 *
		 * @deprecated Use orthogonalSearchSteps instead.
		 * @param {Number} value - The search steps. Range: [0, 112].
		 */
		setOrthogonalSearchSteps(value: number): void;
		set diagonalSearchSteps(arg: number);
		/**
		 * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
		 * jumps one pixel at a time. Range: [0, 20].
		 *
		 * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
		 * significant impact on older machines.
		 *
		 * @type {Number}
		 */
		get diagonalSearchSteps(): number;
		/**
		 * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
		 *
		 * @deprecated Use diagonalSearchSteps instead.
		 * @param {Number} value - The search steps. Range: [0, 20].
		 */
		setDiagonalSearchSteps(value: number): void;
		set diagonalDetection(arg: boolean);
		/**
		 * Indicates whether diagonal pattern detection is enabled.
		 *
		 * @type {Boolean}
		 */
		get diagonalDetection(): boolean;
		/**
		 * Indicates whether diagonal pattern detection is enabled.
		 *
		 * @deprecated Use diagonalDetection instead.
		 * @return {Boolean} Whether diagonal pattern detection is enabled.
		 */
		isDiagonalDetectionEnabled(): boolean;
		/**
		 * Enables or disables diagonal pattern detection.
		 *
		 * @deprecated Use diagonalDetection instead.
		 * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
		 */
		setDiagonalDetectionEnabled(value: boolean): void;
		set cornerRounding(arg: number);
		/**
		 * Specifies how much sharp corners will be rounded. Range: [0, 100].
		 *
		 * @type {Number}
		 */
		get cornerRounding(): number;
		/**
		 * Specifies how much sharp corners will be rounded.
		 *
		 * @deprecated Use cornerRounding instead.
		 * @param {Number} value - The corner rounding amount. Range: [0, 100].
		 */
		setCornerRounding(value: number): void;
		set cornerDetection(arg: number);
		/**
		 * Indicates whether corner detection is enabled.
		 *
		 * @type {Number}
		 */
		get cornerDetection(): number;
		/**
		 * Indicates whether corner rounding is enabled.
		 *
		 * @deprecated Use cornerDetection instead.
		 * @return {Boolean} Whether corner rounding is enabled.
		 */
		isCornerRoundingEnabled(): boolean;
		/**
		 * Enables or disables corner rounding.
		 *
		 * @deprecated Use cornerDetection instead.
		 * @param {Boolean} value - Whether corner rounding should be enabled.
		 */
		setCornerRoundingEnabled(value: boolean): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * A Screen Space Ambient Occlusion (SSAO) shader material.
	 *
	 * @implements {Resizable}
	 */
	export class SSAOMaterial extends ShaderMaterial implements Resizable {

		/**
		 * Constructs a new SSAO material.
		 *
		 * @param {Camera} camera - A camera.
		 */
		constructor(camera: Camera);
		/**
		 * The combined normal-depth buffer.
		 *
		 * @param {Texture} arg - The buffer.
		 */
		set normalDepthBuffer(arg: Texture);
		/**
		 * Sets the combined normal-depth buffer.
		 *
		 * @deprecated Use normalDepthBuffer instead.
		 * @param {Texture} value - The buffer.
		 */
		setNormalDepthBuffer(value: Texture): void;
		/**
		 * The normal buffer.
		 *
		 * @param {Texture} arg - The buffer.
		 */
		set normalBuffer(arg: Texture);
		/**
		 * Sets the normal buffer.
		 *
		 * @deprecated Use normalBuffer instead.
		 * @param {Texture} value - The buffer.
		 */
		setNormalBuffer(value: Texture): void;
		/**
		 * The depth buffer.
		 *
		 * @param {Texture} arg - The buffer.
		 */
		set depthBuffer(arg: Texture);
		/**
		 * The depth packing strategy.
		 *
		 * @param {DepthPackingStrategies} arg - The depth packing strategy.
		 */
		set depthPacking(arg: DepthPackingStrategies);
		/**
		 * Sets the depth buffer.
		 *
		 * @deprecated Use depthBuffer and depthPacking instead.
		 * @param {Texture} buffer - The depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
		 */
		setDepthBuffer(
			buffer: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * The noise texture.
		 *
		 * @param {Texture} arg - The texture.
		 */
		set noiseTexture(arg: Texture);
		/**
		 * Sets the noise texture.
		 *
		 * @deprecated Use noiseTexture instead.
		 * @param {Texture} value - The texture.
		 */
		setNoiseTexture(value: Texture): void;
		set samples(arg: number);
		/**
		 * The sample count.
		 *
		 * @type {Number}
		 */
		get samples(): number;
		/**
		 * Returns the amount of occlusion samples per pixel.
		 *
		 * @deprecated Use samples instead.
		 * @return {Number} The sample count.
		 */
		getSamples(): number;
		/**
		 * Sets the amount of occlusion samples per pixel.
		 *
		 * @deprecated Use samples instead.
		 * @param {Number} value - The sample count.
		 */
		setSamples(value: number): void;
		set rings(arg: number);
		/**
		 * The sampling spiral ring count.
		 *
		 * @type {Number}
		 */
		get rings(): number;
		/**
		 * Returns the amount of spiral turns in the occlusion sampling pattern.
		 *
		 * @deprecated Use rings instead.
		 * @return {Number} The radius.
		 */
		getRings(): number;
		/**
		 * Sets the amount of spiral turns in the occlusion sampling pattern.
		 *
		 * @deprecated Use rings instead.
		 * @param {Number} value - The radius.
		 */
		setRings(value: number): void;
		/**
		 * The intensity.
		 *
		 * @type {Number}
		 * @deprecated Use SSAOEffect.intensity instead.
		 */
		get intensity(): number;
		set intensity(arg: number);
		/**
		 * Returns the intensity.
		 *
		 * @deprecated Use intensity instead.
		 * @return {Number} The intensity.
		 */
		getIntensity(): number;
		/**
		 * Sets the intensity.
		 *
		 * @deprecated Use intensity instead.
		 * @param {Number} value - The intensity.
		 */
		setIntensity(value: number): void;
		set fade(arg: number);
		/**
		 * The depth fade factor.
		 *
		 * @type {Number}
		 */
		get fade(): number;
		/**
		 * Returns the depth fade factor.
		 *
		 * @deprecated Use fade instead.
		 * @return {Number} The fade factor.
		 */
		getFade(): number;
		/**
		 * Sets the depth fade factor.
		 *
		 * @deprecated Use fade instead.
		 * @param {Number} value - The fade factor.
		 */
		setFade(value: number): void;
		set bias(arg: number);
		/**
		 * The depth bias. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get bias(): number;
		/**
		 * Returns the depth bias.
		 *
		 * @deprecated Use bias instead.
		 * @return {Number} The bias.
		 */
		getBias(): number;
		/**
		 * Sets the depth bias.
		 *
		 * @deprecated Use bias instead.
		 * @param {Number} value - The bias.
		 */
		setBias(value: number): void;
		set minRadiusScale(arg: number);
		/**
		 * The minimum radius scale for distance scaling. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get minRadiusScale(): number;
		/**
		 * Returns the minimum radius scale for distance scaling.
		 *
		 * @deprecated Use minRadiusScale instead.
		 * @return {Number} The minimum radius scale.
		 */
		getMinRadiusScale(): number;
		/**
		 * Sets the minimum radius scale for distance scaling.
		 *
		 * @deprecated Use minRadiusScale instead.
		 * @param {Number} value - The minimum radius scale.
		 */
		setMinRadiusScale(value: number): void;
		set radius(arg: number);
		/**
		 * The occlusion sampling radius. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get radius(): number;
		/**
		 * Returns the occlusion sampling radius.
		 *
		 * @deprecated Use radius instead.
		 * @return {Number} The radius.
		 */
		getRadius(): number;
		/**
		 * Sets the occlusion sampling radius.
		 *
		 * @deprecated Use radius instead.
		 * @param {Number} value - The radius. Range [1e-6, 1.0].
		 */
		setRadius(value: number): void;
		set distanceScaling(arg: boolean);
		/**
		 * Indicates whether distance-based radius scaling is enabled.
		 *
		 * @type {Boolean}
		 */
		get distanceScaling(): boolean;
		/**
		 * Indicates whether distance-based radius scaling is enabled.
		 *
		 * @deprecated Use distanceScaling instead.
		 * @return {Boolean} Whether distance scaling is enabled.
		 */
		isDistanceScalingEnabled(): boolean;
		/**
		 * Enables or disables distance-based radius scaling.
		 *
		 * @deprecated Use distanceScaling instead.
		 * @param {Boolean} value - Whether distance scaling should be enabled.
		 */
		setDistanceScalingEnabled(value: boolean): void;
		set distanceThreshold(arg: number);
		/**
		 * The occlusion distance threshold. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get distanceThreshold(): number;

		/**
		 * The occlusion distance falloff.
		 * The occlusion distance threshold in world units.
		 *
		 * @type {Number}
		 */

		get worldDistanceThreshold(): number;
		set worldDistanceThreshold(value: number);

		set distanceFalloff(arg: number);
		/**
		 * The occlusion distance falloff. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get distanceFalloff(): number;

		/**
		 * The occlusion distance falloff in world units.
		 *
		 * @type {Number}
		 */

		get worldDistanceFalloff(): number;
		set worldDistanceFalloff(value: number);

		/**
		 * Sets the occlusion distance cutoff.
		 *
		 * @deprecated Use distanceThreshold and distanceFalloff instead.
		 * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
		 * @param {Number} falloff - The falloff. Range [0.0, 1.0].
		 */
		setDistanceCutoff(threshold: number, falloff: number): void;
		set proximityThreshold(arg: number);
		/**
		 * The occlusion proximity threshold. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get proximityThreshold(): number;
		/**
		 * The occlusion proximity threshold in world units.
		 *
		 * @type {Number}
		 */
		get worldProximityThreshold(): number;
		set worldProximityThreshold(value: number);

		set proximityFalloff(arg: number);
		/**
		 * The occlusion proximity falloff. Range: [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get proximityFalloff(): number;

		/**
		 * The occlusion proximity falloff in world units.
		 *
		 * @type {Number}
		 */

		get worldProximityFalloff(): number;
		set worldProximityFalloff(value: number);

		/**
		 * Sets the occlusion proximity cutoff.
		 *
		 * @deprecated Use proximityThreshold and proximityFalloff instead.
		 * @param {Number} threshold - The range threshold. Range [0.0, 1.0].
		 * @param {Number} falloff - The falloff. Range [0.0, 1.0].
		 */
		setProximityCutoff(threshold: number, falloff: number): void;
		/**
		 * Sets the texel size.
		 *
		 * @deprecated Use setSize() instead.
		 * @param {Number} x - The texel width.
		 * @param {Number} y - The texel height.
		 */
		setTexelSize(x: number, y: number): void;
		/**
		 * Adopts the settings of the given camera.
		 *
		 * @param {Camera} camera - A camera.
		 */
		adoptCameraSettings(camera: Camera): void;
		/**
		 * Sets the size of this object.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * A resolution.
	 */
	export class Resolution extends EventDispatcher {

		/**
		 * An auto sizing constant.
		 *
		 * Can be used to automatically calculate the width or height based on the original aspect ratio.
		 *
		 * @type {Number}
		 */
		static get AUTO_SIZE(): number;
		/**
		 * Constructs a new resolution.
		 *
		 * TODO Remove resizable param.
		 * @param {Resizable} resizable - A resizable object.
		 * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
		 * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
		 * @param {Number} [scale=1.0] - A resolution scale.
		 */
		constructor(
			resizable: Resizable,
			width?: number,
			height?: number,
			scale?: number
		);

		/**
		 * A resizable object.
		 *
		 * @type {Resizable}
		 * @deprecated Use an event listener for "change" events instead.
		 */
		resizable: Resizable;
		/**
		 * The preferred resolution.
		 *
		 * @type {Vector2}
		 * @deprecated Added for backward-compatibility.
		 */
		target: Vector2;
		set width(arg: number);
		/**
		 * The effective width.
		 *
		 * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
		 *
		 * @type {Number}
		 */
		get width(): number;
		set preferredWidth(arg: number);
		/**
		 * The preferred width.
		 *
		 * @type {Number}
		 */
		get preferredWidth(): number;
		set height(arg: number);
		/**
		 * The effective height.
		 *
		 * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
		 *
		 * @type {Number}
		 */
		get height(): number;
		set preferredHeight(arg: number);
		/**
		 * The preferred height.
		 *
		 * @type {Number}
		 */
		get preferredHeight(): number;
		/**
		 * Returns the effective width.
		 *
		 * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
		 *
		 * @deprecated Use width instead.
		 * @return {Number} The effective width.
		 */
		getWidth(): number;
		/**
		 * Returns the effective height.
		 *
		 * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
		 *
		 * @deprecated Use height instead.
		 * @return {Number} The effective height.
		 */
		getHeight(): number;
		set scale(arg: number);
		/**
		 * The resolution scale.
		 *
		 * @type {Number}
		 */
		get scale(): number;
		/**
		 * Returns the current resolution scale.
		 *
		 * @deprecated Use scale instead.
		 * @return {Number} The scale.
		 */
		getScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
		 *
		 * @deprecated Use scale instead.
		 * @param {Number} value - The scale.
		 */
		setScale(value: number): void;
		set baseWidth(arg: number);
		/**
		 * The base width.
		 *
		 * @type {Number}
		 */
		get baseWidth(): number;
		/**
		 * Returns the base width.
		 *
		 * @deprecated Use baseWidth instead.
		 * @return {Number} The base width.
		 */
		getBaseWidth(): number;
		/**
		 * Sets the base width.
		 *
		 * @deprecated Use baseWidth instead.
		 * @param {Number} value - The width.
		 */
		setBaseWidth(value: number): void;
		set baseHeight(arg: number);
		/**
		 * The base height.
		 *
		 * @type {Number}
		 */
		get baseHeight(): number;
		/**
		 * Returns the base height.
		 *
		 * @deprecated Use baseHeight instead.
		 * @return {Number} The base height.
		 */
		getBaseHeight(): number;
		/**
		 * Sets the base height.
		 *
		 * @deprecated Use baseHeight instead.
		 * @param {Number} value - The height.
		 */
		setBaseHeight(value: number): void;
		/**
		 * Sets the base size.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setBaseSize(width: number, height: number): void;
		/**
		 * Returns the preferred width.
		 *
		 * @deprecated Use preferredWidth instead.
		 * @return {Number} The preferred width.
		 */
		getPreferredWidth(): number;
		/**
		 * Sets the preferred width.
		 *
		 * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
		 *
		 * @deprecated Use preferredWidth instead.
		 * @param {Number} value - The width.
		 */
		setPreferredWidth(value: number): void;
		/**
		 * Returns the preferred height.
		 *
		 * @deprecated Use preferredHeight instead.
		 * @return {Number} The preferred height.
		 */
		getPreferredHeight(): number;
		/**
		 * Sets the preferred height.
		 *
		 * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
		 *
		 * @deprecated Use preferredHeight instead.
		 * @param {Number} value - The height.
		 */
		setPreferredHeight(value: number): void;
		/**
		 * Sets the preferred size.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setPreferredSize(width: number, height: number): void;
		/**
		 * Copies the given resolution.
		 *
		 * @param {Resolution} resolution - The resolution.
		 */
		copy(resolution: Resolution): void;

	}

	export type Resizer = Resolution;

	/**
	 * An abstract pass.
	 *
	 * @implements {Initializable}
	 * @implements {Resizable}
	 * @implements {Disposable}
	 */
	export class Pass implements Initializable, Resizable, Disposable {

		/**
		 * Constructs a new pass.
		 *
		 * @param {String} [name] - The name of this pass. Does not have to be unique.
		 * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
		 * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
		 */
		constructor(name?: string, scene?: Scene, camera?: Camera);
		/**
		 * The name of this pass.
		 *
		 * @type {String}
		 */
		name: string;
		/**
		 * The renderer.
		 *
		 * @deprecated
		 * @type {WebGLRenderer}
		 * @protected
		 */
		protected renderer: WebGLRenderer;
		/**
		 * The scene to render.
		 *
		 * @type {Scene}
		 * @protected
		 */
		protected scene: Scene;
		/**
		 * The camera.
		 *
		 * @type {Camera}
		 * @protected
		 */
		protected camera: Camera;
		/**
		 * Only relevant for subclassing.
		 *
		 * Indicates whether the {@link EffectComposer} should swap the frame buffers after this pass has finished
		 * rendering. Set this to `false` if this pass doesn't render to the output buffer or the screen. Otherwise, the
		 * contents of the input buffer will be lost.
		 *
		 * @type {Boolean}
		 */
		needsSwap: boolean;
		/**
		 * Only relevant for subclassing.
		 *
		 * Indicates whether the {@link EffectComposer} should prepare a depth texture for this pass.
		 * Set this to `true` if this pass relies on depth information from a preceding {@link RenderPass}.
		 *
		 * @type {Boolean}
		 */
		needsDepthTexture: boolean;
		/**
		 * Indicates whether this pass is enabled.
		 *
		 * @type {Boolean}
		 */
		enabled: boolean;
		/**
		 * Sets the render to screen flag.
		 *
		 * If this flag is changed, the fullscreen material will be updated as well.
		 *
		 * @type {Boolean}
		 */
		set renderToScreen(arg: boolean);
		/**
		 * Indicates whether this pass should render to screen.
		 *
		 * @type {Boolean}
		 */
		get renderToScreen(): boolean;
		/**
		 * Sets the main scene.
		 *
		 * @type {Scene}
		 */
		set mainScene(arg: Scene);
		/**
		 * Sets the main camera.
		 *
		 * @type {Camera}
		 */
		set mainCamera(arg: Camera);
		/**
		 * Sets the renderer
		 *
		 * @deprecated
		 * @param {WebGLRenderer} renderer - The renderer.
		 */
		setRenderer(renderer: WebGLRenderer): void;
		/**
		 * Indicates whether this pass is enabled.
		 *
		 * @deprecated Use enabled instead.
		 * @return {Boolean} Whether this pass is enabled.
		 */
		isEnabled(): boolean;
		/**
		 * Enables or disables this pass.
		 *
		 * @deprecated Use enabled instead.
		 * @param {Boolean} value - Whether the pass should be enabled.
		 */
		setEnabled(value: boolean): void;
		set fullscreenMaterial(arg: Material);
		/**
		 * The fullscreen material.
		 *
		 * @type {Material}
		 */
		get fullscreenMaterial(): Material;
		/**
		 * Returns the current fullscreen material.
		 *
		 * @deprecated Use fullscreenMaterial instead.
		 * @return {Material} The current fullscreen material, or null if there is none.
		 */
		getFullscreenMaterial(): Material;
		/**
		 * Sets the fullscreen material.
		 *
		 * @deprecated Use fullscreenMaterial instead.
		 * @protected
		 * @param {Material} value - A fullscreen material.
		 */
		protected setFullscreenMaterial(value: Material): void;
		/**
		 * Returns the current depth texture.
		 *
		 * @return {Texture} The current depth texture, or null if there is none.
		 */
		getDepthTexture(): Texture;
		/**
		 * Sets the depth texture.
		 *
		 * This method will be called automatically by the {@link EffectComposer}.
		 * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
		 *
		 * @param {Texture} depthTexture - A depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
		 */
		setDepthTexture(
			depthTexture: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Renders this pass.
		 *
		 * This is an abstract method that must be overridden.
		 *
		 * @abstract
		 * @throws {Error} An error is thrown if the method is not overridden.
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

		/**
		 * Sets the size.
		 *
		 * You may override this method if you want to be informed about the size of the backbuffer/canvas.
		 * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * This method is called when this pass is added to an {@link EffectComposer}.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

		/**
		 * Performs a shallow search for disposable properties and deletes them.
		 *
		 * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
		 * memory when you're certain that you don't need this pass anymore.
		 */
		dispose(): void;

	}

	/**
	 * A pass that renders an adaptive luminance map.
	 */
	export class AdaptiveLuminancePass extends Pass {

		/**
		 * Constructs a new adaptive luminance pass.
		 *
		 * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.minLuminance=0.01] - The minimum luminance.
		 * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
		 */
		constructor(
			luminanceBuffer: Texture,
			{
				minLuminance,
				adaptationRate
			}?: {
				minLuminance?: number;
				adaptationRate?: number;
			}
		);

		/**
		 * The adaptive luminance texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the adaptive 1x1 luminance texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Sets the 1x1 mipmap level.
		 *
		 * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled
		 * average scene luminance.
		 *
		 * @type {Number}
		 * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.
		 */
		set mipLevel1x1(arg: number);
		/**
		 * @type {Number}
		 * @deprecated Use fullscreenMaterial.adaptationRate instead.
		 */
		set adaptationRate(arg: number);
		/**
		 * The luminance adaptation rate.
		 *
		 * @type {Number}
		 * @deprecated Use fullscreenMaterial.adaptationRate instead.
		 */
		get adaptationRate(): number;
		/**
		 * Renders the scene normals.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A Kawase blur pass.
	 */
	export class KawaseBlurPass extends Pass {

		/**
		 * An auto sizing flag.
		 *
		 * @type {Number}
		 * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
		 */
		static get AUTO_SIZE(): number;
		/**
		 * Constructs a new Kawase blur pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
		 */
		constructor({
			resolutionScale,
			resolutionX,
			resolutionY,
			width,
			height,
			kernelSize
		}?: {
			resolutionScale?: number;
			resolutionX?: number;
			resolutionY?: number;
			width?: number;
			height?: number;
			kernelSize?: KernelSize;
		});

		resolution: Resolution;
		/**
		 * The blur material.
		 *
		 * @type {KawaseBlurMaterial}
		 */
		blurMaterial: KawaseBlurMaterial;
		/**
		 * Indicates whether dithering is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated
		 */
		dithering: boolean;
		/**
		 * The kernel size.
		 *
		 * @type {KernelSize}
		 */
		kernelSize: KernelSize;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Sets the render width.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.preferredWidth instead.
		 */
		set width(arg: number);
		/**
		 * The current width of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.width instead.
		 */
		get width(): number;
		/**
		 * Sets the render height.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.preferredHeight instead.
		 */
		set height(arg: number);
		/**
		 * The current height of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.height instead.
		 */
		get height(): number;
		set scale(arg: number);
		/**
		 * The current blur scale.
		 *
		 * @type {Number}
		 * @deprecated Use blurMaterial.scale instead.
		 */
		get scale(): number;
		/**
		 * Returns the current blur scale.
		 *
		 * @deprecated Use blurMaterial.scale instead.
		 * @return {Number} The scale.
		 */
		getScale(): number;
		/**
		 * Sets the blur scale.
		 *
		 * This value influences the overall blur strength and should not be greater than 1. For larger blurs please increase
		 * the kernel size via {@link setKernelSize}!
		 *
		 * Note that the blur strength is closely tied to the resolution. For a smooth transition from no blur to full blur,
		 * set the width or the height to a high enough value.
		 *
		 * @deprecated Use blurMaterial.scale instead.
		 * @param {Number} value - The scale.
		 */
		setScale(value: number): void;
		/**
		 * Returns the kernel size.
		 *
		 * @deprecated Use kernelSize instead.
		 * @return {KernelSize} The kernel size.
		 */
		getKernelSize(): KernelSize;
		/**
		 * Sets the kernel size.
		 *
		 * Larger kernels require more processing power but scale well with larger render resolutions.
		 *
		 * @deprecated Use kernelSize instead.
		 * @param {KernelSize} value - The kernel size.
		 */
		setKernelSize(value: KernelSize): void;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * Blurs the input buffer and writes the result to the output buffer. The input buffer remains intact, unless it's
		 * also used as the output buffer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}


	/**
	 * A pass that disables the stencil test.
	 */
	export class ClearMaskPass extends Pass {

		/**
		 * Constructs a new clear mask pass.
		 */
		constructor();

		/**
		 * Disables the global stencil test.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that clears the input buffer or the screen.
	 */
	export class ClearPass extends Pass {

		/**
		 * Constructs a new clear pass.
		 *
		 * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
		 * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
		 * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
		 */
		constructor(color?: boolean, depth?: boolean, stencil?: boolean);
		/**
		 * Indicates whether the color buffer should be cleared.
		 *
		 * @type {Boolean}
		 * @deprecated Use setClearFlags() instead.
		 */
		color: boolean;
		/**
		 * Indicates whether the depth buffer should be cleared.
		 *
		 * @type {Boolean}
		 * @deprecated Use setClearFlags() instead.
		 */
		depth: boolean;
		/**
		 * Indicates whether the stencil buffer should be cleared.
		 *
		 * @type {Boolean}
		 * @deprecated Use setClearFlags() instead.
		 */
		stencil: boolean;
		/**
		 * An override clear color. Default is null.
		 *
		 * @type {Color}
		 */
		overrideClearColor: Color;
		/**
		 * An override clear alpha. Default is -1.
		 *
		 * @type {Number}
		 */
		overrideClearAlpha: number;
		/**
		 * Sets the clear flags.
		 *
		 * @param {Boolean} color - Whether the color buffer should be cleared.
		 * @param {Boolean} depth - Whether the depth buffer should be cleared.
		 * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
		 */
		setClearFlags(color: boolean, depth: boolean, stencil: boolean): void;
		/**
		 * Returns the override clear color. Default is null.
		 *
		 * @deprecated Use overrideClearColor instead.
		 * @return {Color} The clear color.
		 */
		getOverrideClearColor(): Color;
		/**
		 * Sets the override clear color.
		 *
		 * @deprecated Use overrideClearColor instead.
		 * @param {Color} value - The clear color.
		 */
		setOverrideClearColor(value: Color): void;
		/**
		 * Returns the override clear alpha. Default is -1.
		 *
		 * @deprecated Use overrideClearAlpha instead.
		 * @return {Number} The clear alpha.
		 */
		getOverrideClearAlpha(): number;
		/**
		 * Sets the override clear alpha.
		 *
		 * @deprecated Use overrideClearAlpha instead.
		 * @param {Number} value - The clear alpha.
		 */
		setOverrideClearAlpha(value: number): void;
		/**
		 * Clears the input buffer or the screen.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that copies the contents of an input buffer to another render target.
	 */
	export class CopyPass extends Pass {

		/**
		 * Constructs a new save pass.
		 *
		 * @param {WebGLRenderTarget} [renderTarget] - A render target.
		 * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
		 */
		constructor(renderTarget?: WebGLRenderTarget, autoResize?: boolean);
		/**
		 * Enables or disables auto resizing of the render target.
		 *
		 * @type {Boolean}
		 */
		autoResize: boolean;
		set resize(arg: boolean);
		/**
		 * Enables or disables auto resizing of the render target.
		 *
		 * @deprecated Use autoResize instead.
		 * @type {Boolean}
		 */
		get resize(): boolean;
		/**
		 * The output texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the output texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Enables or disables auto resizing of the render target.
		 *
		 * @deprecated Use autoResize instead.
		 * @param {Boolean} value - Whether the render target size should be updated automatically.
		 */
		setAutoResizeEnabled(value: boolean): void;
		/**
		 * Saves the input buffer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	export type SavePass = CopyPass;

	/**
	 * A pass that copies depth into a render target.
	 */
	export class DepthCopyPass extends Pass {

		/**
		 * Constructs a new depth save pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.
		 */
		constructor({ depthPacking }?: { depthPacking?: DepthPackingStrategies });
		/**
		 * The output depth texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the output depth texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * The output depth packing.
		 *
		 * @type {DepthPackingStrategies}
		 */
		get depthPacking(): DepthPackingStrategies;
		/**
		 * Returns the output depth packing.
		 *
		 * @deprecated Use depthPacking instead.
		 * @return {DepthPackingStrategies} The depth packing.
		 */
		getDepthPacking(): DepthPackingStrategies;
		/**
		 * Copies depth from a depth texture.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that downsamples the scene depth by picking the most representative depth in 2x2 texel neighborhoods. If a
	 * normal buffer is provided, the corresponding normals will be stored as well.
	 *
	 * This pass requires WebGL 2.
	 */
	export class DepthDownsamplingPass extends Pass {

		/**
		 * Constructs a new depth downsampling pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.
		 * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - The render width.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - The render height.
		 */
		constructor({
			normalBuffer,
			resolutionScale,
			width,
			height
		}?: {
			normalBuffer?: Texture;
			resolutionScale?: number;
			width?: number;
			height?: number;
		});

		resolution: Resolution;
		/**
		 * The normal(RGB) + depth(A) texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the normal(RGB) + depth(A) texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Downsamples depth and scene normals.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that renders a given scene into the input buffer or to screen.
	 *
	 * This pass uses a {@link ClearPass} to clear the target buffer.
	 */
	export class RenderPass extends Pass {

		/**
		 * Constructs a new render pass.
		 *
		 * @param {Scene} scene - The scene to render.
		 * @param {Camera} camera - The camera to use to render the scene.
		 * @param {Material} [overrideMaterial=null] - An override material.
		 */
		constructor(scene?: Scene, camera?: Camera, overrideMaterial?: Material);
		/**
		 * A clear pass.
		 *
		 * @type {ClearPass}
		 */
		clearPass: ClearPass;
		/**
		 * Indicates whether the scene background should be ignored.
		 *
		 * @type {Boolean}
		 */
		ignoreBackground: boolean;
		/**
		 * Indicates whether the shadow map auto update should be skipped.
		 *
		 * @type {Boolean}
		 */
		skipShadowMapUpdate: boolean;
		/**
		 * A selection of objects to render.
		 *
		 * @type {Selection}
		 */
		selection: Selection;
		set overrideMaterial(arg: Material);
		/**
		 * The current override material.
		 *
		 * @type {Material}
		 */
		get overrideMaterial(): Material;
		/**
		 * Returns the current override material.
		 *
		 * @deprecated Use overrideMaterial instead.
		 * @return {Material} The material.
		 */
		getOverrideMaterial(): Material;
		/**
		 * Sets the override material.
		 *
		 * @deprecated Use overrideMaterial instead.
		 * @param {Material} value - The material.
		 */
		setOverrideMaterial(value: Material): void;
		set clear(arg: boolean);
		/**
		 * Indicates whether the target buffer should be cleared before rendering.
		 *
		 * @type {Boolean}
		 * @deprecated Use clearPass.enabled instead.
		 */
		get clear(): boolean;
		/**
		 * Returns the selection. Default is `null` (no restriction).
		 *
		 * @deprecated Use selection instead.
		 * @return {Selection} The selection.
		 */
		getSelection(): Selection;
		/**
		 * Sets the selection. Set to `null` to disable.
		 *
		 * @deprecated Use selection instead.
		 * @param {Selection} value - The selection.
		 */
		setSelection(value: Selection): void;
		/**
		 * Indicates whether the scene background is disabled.
		 *
		 * @deprecated Use ignoreBackground instead.
		 * @return {Boolean} Whether the scene background is disabled.
		 */
		isBackgroundDisabled(): boolean;
		/**
		 * Enables or disables the scene background.
		 *
		 * @deprecated Use ignoreBackground instead.
		 * @param {Boolean} value - Whether the scene background should be disabled.
		 */
		setBackgroundDisabled(value: boolean): void;
		/**
		 * Indicates whether the shadow map auto update is disabled.
		 *
		 * @deprecated Use skipShadowMapUpdate instead.
		 * @return {Boolean} Whether the shadow map update is disabled.
		 */
		isShadowMapDisabled(): boolean;
		/**
		 * Enables or disables the shadow map auto update.
		 *
		 * @deprecated Use skipShadowMapUpdate instead.
		 * @param {Boolean} value - Whether the shadow map auto update should be disabled.
		 */
		setShadowMapDisabled(value: boolean): void;
		/**
		 * Returns the clear pass.
		 *
		 * @deprecated Use clearPass.enabled instead.
		 * @return {ClearPass} The clear pass.
		 */
		getClearPass(): ClearPass;
		/**
		 * Renders the scene.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that renders depth into an RGBA buffer.
	 */
	export class DepthPass extends Pass {

		/**
		 * Constructs a new depth pass.
		 *
		 * @param {Scene} scene - The scene to render.
		 * @param {Camera} camera - The camera to use to render the scene.
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
		 */
		constructor(
			scene?: Scene,
			camera?: Camera,
			{
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height,
				renderTarget
			}?: {
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
				renderTarget?: WebGLRenderTarget;
			}
		);

		resolution: Resolution;
		/**
		 * The depth texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the depth texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * Renders the scene depth.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A depth picking pass.
	 */
	export class DepthPickingPass extends DepthCopyPass {

		/**
		 * Constructs a new depth picking pass.
		 *
		 * @param {Object} [options] - The options.
		 * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.
		 * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.
		 */
		constructor({
			depthPacking,
			mode
		}?: {
			depthPacking?: DepthPackingStrategies;
			mode?: number;
		});

		/**
		 * Reads depth at a specific screen position.
		 *
		 * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the
		 * picking coordinates. Unresolved promises will be abandoned.
		 *
		 * @example
		 * const ndc = new Vector3();
		 * const clientRect = myViewport.getBoundingClientRect();
		 * const clientX = pointerEvent.clientX - clientRect.left;
		 * const clientY = pointerEvent.clientY - clientRect.top;
		 * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;
		 * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;
		 * const depth = await depthPickingPass.readDepth(ndc);
		 * ndc.z = depth * 2.0 - 1.0;
		 *
		 * const worldPosition = ndc.unproject(camera);
		 *
		 * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.
		 * @return {Promise<Number>} A promise that returns the depth on the next frame.
		 */
		readDepth(ndc: Vector2 | Vector3): Promise<number>;
		/**
		 * Copies depth and resolves depth picking promises.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A blend function enumeration.
	 * @type {Object}
	 * @property {Number} SKIP - Deprecated. Use DST instead. Warning: This blend function does NOT fully disable the effect.
	 * @property {Number} SET - Deprecated. Use SRC instead.
	 * @property {Number} ADD - Additive blending. Fast, but may produce washed out results.
	 * @property {Number} ALPHA - Alpha blending. Blends based on the alpha value of the new color.
	 * @property {Number} AVERAGE - Calculates the avarage of the new color and the base color.
	 * @property {Number} COLOR - Converts the colors to HSL and blends based on color.
	 * @property {Number} COLOR_BURN - Color burn.
	 * @property {Number} COLOR_DODGE - Color dodge.
	 * @property {Number} DARKEN - Prioritize darker colors.
	 * @property {Number} DIFFERENCE - Color difference.
	 * @property {Number} DIVIDE - Color division.
	 * @property {Number} DST - Overwrites the new color with the base color. Ignores opacity.
	 * @property {Number} EXCLUSION - Color exclusion.
	 * @property {Number} HARD_LIGHT - Hard light.
	 * @property {Number} HARD_MIX - Hard mix.
	 * @property {Number} HUE - Converts the colors to HSL and blends based on hue.
	 * @property {Number} INVERT - Overwrites the base color with the inverted new color.
	 * @property {Number} INVERT_RGB - Multiplies the new color with the inverted base color.
	 * @property {Number} LIGHTEN - Prioritize lighter colors.
	 * @property {Number} LINEAR_BURN - Linear burn.
	 * @property {Number} LINEAR_DODGE - Same as ADD but limits the result to 1.
	 * @property {Number} LINEAR_LIGHT - Linear light.
	 * @property {Number} LUMINOSITY - Converts the colors to HSL and blends based on luminosity.
	 * @property {Number} MULTIPLY - Color multiplication.
	 * @property {Number} NEGATION - Negates the base color using the new color.
	 * @property {Number} NORMAL - Overwrites the base color with the new one.
	 * @property {Number} OVERLAY - Color overlay.
	 * @property {Number} PIN_LIGHT - Pin light.
	 * @property {Number} REFLECT - Color reflection.
	 * @property {Number} SCREEN - Screen blending. The two colors are effectively projected on a white screen simultaneously.
	 * @property {Number} SRC - Overwrites the base color with the new one. Ignores opacity.
	 * @property {Number} SATURATION - Converts the colors to HSL and blends based on saturation.
	 * @property {Number} SOFT_LIGHT - Soft light.
	 * @property {Number} SUBTRACT - Subtracts the new color from the base color.
	 * @property {Number} VIVID_LIGHT - Vivid light.
	 */
	export enum BlendFunction {
		SKIP,
		SET,
		ADD,
		ALPHA,
		AVERAGE,
		COLOR,
		COLOR_BURN,
		COLOR_DODGE,
		DARKEN,
		DIFFERENCE,
		DIVIDE,
		DST,
		EXCLUSION,
		HARD_LIGHT,
		HARD_MIX,
		HUE,
		INVERT,
		INVERT_RGB,
		LIGHTEN,
		LINEAR_BURN,
		LINEAR_DODGE,
		LINEAR_LIGHT,
		LUMINOSITY,
		MULTIPLY,
		NEGATION,
		NORMAL,
		OVERLAY,
		PIN_LIGHT,
		REFLECT,
		SATURATION,
		SCREEN,
		SOFT_LIGHT,
		SRC,
		SUBTRACT,
		VIVID_LIGHT
	}

	/**
	 * A blend mode.
	 */
	export class BlendMode extends EventDispatcher {

		/**
		 * Constructs a new blend mode.
		 *
		 * @param {BlendFunction} blendFunction - The blend function.
		 * @param {Number} opacity - The opacity of the color that will be blended with the base color.
		 */
		constructor(blendFunction: BlendFunction, opacity?: number);
		/**
		 * A uniform that controls the opacity of this blend mode.
		 *
		 * TODO Add opacity accessors for uniform value.
		 * @type {Uniform}
		 */
		opacity: Uniform;
		/**
		 * Returns the opacity.
		 *
		 * @return {Number} The opacity.
		 */
		getOpacity(): number;
		/**
		 * Sets the opacity.
		 *
		 * @param {Number} value - The opacity.
		 */
		setOpacity(value: number): void;
		/**
		 * Returns the blend function.
		 *
		 * @deprecated Use blendFunction instead.
		 * @return {BlendFunction} The blend function.
		 */
		getBlendFunction(): BlendFunction;
		/**
		 * Sets the blend function.
		 *
		 * @deprecated Use blendFunction instead.
		 * @param {BlendFunction} value - The blend function.
		 */
		setBlendFunction(value: BlendFunction): void;
		/**
		 * Returns the blend function shader code.
		 *
		 * @return {String} The blend function shader code.
		 */
		getShaderCode(): string;
		/**
		 * The blend function.
		 *
		 * @type {BlendFunction}
		 */
		get blendFunction(): BlendFunction;
		set blendFunction(value: BlendFunction);

	}

	/**
	 * An abstract effect.
	 *
	 * Effects can be combined using the {@link EffectPass}.
	 *
	 * @implements {Initializable}
	 * @implements {Resizable}
	 * @implements {Disposable}
	 */
	export class Effect
		extends EventDispatcher
		implements Initializable, Resizable, Disposable {

		/**
		 * Constructs a new effect.
		 *
		 * @param {String} name - The name of this effect. Doesn't have to be unique.
		 * @param {String} fragmentShader - The fragment shader. This shader is required.
		 * @param {Object} [options] - Additional options.
		 * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
		 * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
		 * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
		 * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
		 * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
		 */
		constructor(
			name: string,
			fragmentShader: string,
			{
				attributes,
				blendFunction,
				defines,
				uniforms,
				extensions,
				vertexShader
			}?: {
				attributes?: EffectAttribute;
				blendFunction?: BlendFunction;
				defines?: Map<string, string>;
				uniforms?: Map<string, Uniform>;
				extensions?: Set<WebGLExtension>;
				vertexShader?: string;
			}
		);

		/**
		 * The name of this effect.
		 *
		 * @type {String}
		 */
		name: string;
		/**
		 * The renderer.
		 *
		 * @type {WebGLRenderer}
		 * @protected
		 * @deprecated
		 */
		protected renderer: WebGLRenderer;
		/**
		 * Preprocessor macro definitions.
		 *
		 * Call {@link Effect.setChanged} after changing macro definitions.
		 *
		 * @type {Map<String, String>}
		 */
		readonly defines: Map<string, string>;
		/**
		 * Shader uniforms.
		 *
		 * Call {@link Effect.setChanged} after adding or removing uniforms.
		 *
		 * @type {Map<String, Uniform>}
		 */
		readonly uniforms: Map<string, Uniform>;
		/**
		 * WebGL extensions that are required by this effect.
		 *
		 * Call {@link Effect.setChanged} after adding or removing extensions.
		 *
		 * @type {Set<WebGLExtension>}
		 */
		readonly extensions: Set<WebGLExtension>;
		/**
		 * The blend mode of this effect.
		 *
		 * @type {BlendMode}
		 */
		readonly blendMode: BlendMode;
		/**
		 * The input color space.
		 *
		 * @type {ColorSpace}
		 * @experimental
		 */
		get inputColorSpace(): ColorSpace;
		/**
		 * @type {ColorSpace}
		 * @protected
		 * @experimental
		 */
		protected set inputColorSpace(arg: ColorSpace);
		/**
		 * The output color space.
		 *
		 * Should only be changed if this effect converts the input colors to a different color space.
		 *
		 * @type {ColorSpace}
		 * @experimental
		 */
		get outputColorSpace(): ColorSpace;
		/**
		 * @type {ColorSpace}
		 * @protected
		 * @experimental
		 */
		protected set outputColorSpace(arg: ColorSpace);
		/**
		 * Sets the main scene.
		 *
		 * @type {Scene}
		 */
		set mainScene(arg: Scene);
		/**
		 * Sets the main camera.
		 *
		 * @type {Camera}
		 */
		set mainCamera(arg: Camera);
		/**
		 * Returns the name of this effect.
		 *
		 * @deprecated Use name instead.
		 * @return {String} The name.
		 */
		getName(): string;
		/**
		 * Sets the renderer.
		 *
		 * @deprecated
		 * @param {WebGLRenderer} renderer - The renderer.
		 */
		setRenderer(renderer: WebGLRenderer): void;
		/**
		 * Returns the preprocessor macro definitions.
		 *
		 * @deprecated Use defines instead.
		 * @return {Map<String, String>} The extensions.
		 */
		getDefines(): Map<string, string>;
		/**
		 * Returns the uniforms of this effect.
		 *
		 * @deprecated Use uniforms instead.
		 * @return {Map<String, Uniform>} The extensions.
		 */
		getUniforms(): Map<string, Uniform>;
		/**
		 * Returns the WebGL extensions that are required by this effect.
		 *
		 * @deprecated Use extensions instead.
		 * @return {Set<WebGLExtension>} The extensions.
		 */
		getExtensions(): Set<WebGLExtension>;
		/**
		 * Returns the blend mode.
		 *
		 * The result of this effect will be blended with the result of the previous effect using this blend mode.
		 *
		 * @deprecated Use blendMode instead.
		 * @return {BlendMode} The blend mode.
		 */
		getBlendMode(): BlendMode;
		/**
		 * Returns the effect attributes.
		 *
		 * @return {EffectAttribute} The attributes.
		 */
		getAttributes(): EffectAttribute;
		/**
		 * Sets the effect attributes.
		 *
		 * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
		 * imply a higher priority.
		 *
		 * @protected
		 * @param {EffectAttribute} attributes - The attributes.
		 */
		protected setAttributes(attributes: EffectAttribute): void;
		/**
		 * Returns the fragment shader.
		 *
		 * @return {String} The fragment shader.
		 */
		getFragmentShader(): string;
		/**
		 * Sets the fragment shader.
		 *
		 * @protected
		 * @param {String} fragmentShader - The fragment shader.
		 */
		protected setFragmentShader(fragmentShader: string): void;
		/**
		 * Returns the vertex shader.
		 *
		 * @return {String} The vertex shader.
		 */
		getVertexShader(): string;
		/**
		 * Sets the vertex shader.
		 *
		 * @protected
		 * @param {String} vertexShader - The vertex shader.
		 */
		protected setVertexShader(vertexShader: string): void;
		/**
		 * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
		 *
		 * Should be called after changing macros or extensions and after adding/removing uniforms.
		 *
		 * @protected
		 */
		protected setChanged(): void;
		/**
		 * Sets the depth texture.
		 *
		 * You may override this method if your effect requires direct access to the depth texture that is bound to the
		 * associated {@link EffectPass}.
		 *
		 * @param {Texture} depthTexture - A depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
		 */
		setDepthTexture(
			depthTexture: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Updates this effect by performing supporting operations.
		 *
		 * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
		 * blend function is set to `SKIP`.
		 *
		 * You may override this method if you need to update custom uniforms or render additional off-screen textures.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of this effect.
		 *
		 * You may override this method if you want to be informed about the size of the backbuffer/canvas.
		 * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

		/**
		 * Performs a shallow search for properties that define a dispose method and deletes them.
		 *
		 * The {@link EffectComposer} calls this method when it is being destroyed.
		 */
		dispose(): void;

	}

	/**
	 * An enumeration of effect attributes.
	 *
	 * Attributes can be concatenated using the bitwise OR operator.
	 *
	 * @type {Object}
	 * @property {Number} NONE - No attributes. Most effects don't need to specify any attributes.
	 * @property {Number} DEPTH - Describes effects that require a depth texture.
	 * @property {Number} CONVOLUTION - Describes effects that fetch additional samples from the input buffer. There cannot be more than one effect with this attribute per {@link EffectPass}.
	 * @example const attributes = EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH;
	 */
	export enum EffectAttribute {
		CONVOLUTION,
		DEPTH,
		NONE,
	}

	/**
	 * An enumeration of WebGL extensions.
	 *
	 * @type {Object}
	 * @property {String} DERIVATIVES - Enables derivatives by adding the functions dFdx, dFdy and fwidth.
	 * @property {String} FRAG_DEPTH - Enables gl_FragDepthEXT to set a depth value of a fragment from within the fragment shader.
	 * @property {String} DRAW_BUFFERS - Enables multiple render targets (MRT) support.
	 * @property {String} SHADER_TEXTURE_LOD - Enables explicit control of texture LOD.
	 */
	export enum WebGLExtension {
		DERIVATIVES = "derivatives",
		FRAG_DEPTH = "fragDepth",
		DRAW_BUFFERS = "drawBuffers",
		SHADER_TEXTURE_LOD = "shaderTextureLOD",
	}

	/**
	 * An effect pass.
	 *
	 * Use this pass to combine {@link Effect} instances.
	 */
	export class EffectPass extends Pass {

		/**
		 * Constructs a new effect pass.
		 *
		 * @param {Camera} camera - The main camera.
		 * @param {...Effect} effects - The effects that will be rendered by this pass.
		 */
		constructor(camera?: Camera, ...effects: Effect[]);
		/**
		 * The effects.
		 *
		 * Use `updateMaterial` or `recompile` after changing the effects and consider calling `dispose` to free resources
		 * of unused effects.
		 *
		 * @type {Effect[]}
		 * @protected
		 */
		private effects: Effect[];
		/**
		 * A time offset.
		 *
		 * Elapsed time will start at this value.
		 *
		 * @type {Number}
		 * @deprecated
		 */
		minTime: number;
		/**
		 * The maximum time.
		 *
		 * If the elapsed time exceeds this value, it will be reset.
		 *
		 * @type {Number}
		 * @deprecated
		 */
		maxTime: number;
		set encodeOutput(arg: boolean);
		/**
		 * Indicates whether this pass encodes its output when rendering to screen.
		 *
		 * @type {Boolean}
		 * @deprecated Use fullscreenMaterial.encodeOutput instead.
		 */
		get encodeOutput(): boolean;
		set dithering(arg: boolean);
		/**
		 * Indicates whether dithering is enabled.
		 *
		 * @type {Boolean}
		 */
		get dithering(): boolean;
		/**
		 * Updates the compound shader material.
		 */
		protected updateMaterial(): void;
		/**
		 * Rebuilds the shader material.
		 */
		recompile(): void;
		/**
		 * Sets the effects.
		 *
		 * @param effects - The effects.
		 */
		protected setEffects(effects: Effect[]): void;
		/**
		 * Returns the current depth texture.
		 * @returns The current depth texture, or null if there is none.
		 */
		getDepthTexture(): Texture;
		/**
		 * Sets the depth texture.
		 * @param depthTexture - A depth texture.
		 * @param [depthPacking = 0] - The depth packing.
		 */
		setDepthTexture(depthTexture: Texture, depthPacking?: number): void;
		/**
		 * Renders the effect.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

		/**
		 * Updates the size of this pass.
		 * @param width - The width.
		 * @param height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 * @param renderer - The renderer.
		 * @param alpha - Whether the renderer uses the alpha channel or not.
		 * @param frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

		/**
		 * Deletes disposable objects.
		 * This pass will be inoperative after this method was called!
		 */
		dispose(): void;
		/**
		 * Handles events.
		 *
		 * @param {Event} event - An event.
		 */
		handleEvent(event: Event): void;

	}

	/**
	 * A pass that executes a given function.
	 */
	export class LambdaPass extends Pass {

		/**
		 * Constructs a new lambda pass.
		 *
		 * @param {Function} f - A function.
		 */
		constructor(f: Function);

	}

	/**
	 * A pass that renders luminance.
	 */
	export class LuminancePass extends Pass {

		/**
		 * Constructs a new luminance pass.
		 *
		 * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
		 */
		constructor({
			resolutionScale,
			resolutionX,
			resolutionY,
			width,
			height,
			renderTarget
		}?: {
			resolutionScale?: number;
			resolutionX?: number;
			resolutionY?: number;
			width?: number;
			height?: number;
			renderTarget?: WebGLRenderTarget;
		});

		resolution: Resolution;
		/**
		 * The luminance texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the luminance texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Renders the luminance.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A stencil mask pass.
	 *
	 * This pass requires that the input and output buffers have a stencil buffer. You can enable the stencil buffer via the
	 * {@link EffectComposer} constructor.
	 */
	export class MaskPass extends Pass {

		/**
		 * Constructs a new mask pass.
		 *
		 * @param {Scene} scene - The scene to render.
		 * @param {Camera} camera - The camera to use.
		 */
		constructor(scene?: Scene, camera?: Camera);
		/**
		 * A clear pass.
		 *
		 * @type {ClearPass}
		 */
		clearPass: ClearPass;
		/**
		 * Inverse flag.
		 *
		 * @type {Boolean}
		 * @deprecated Use inverted instead.
		 */
		inverse: boolean;
		set inverted(arg: boolean);
		/**
		 * Indicates whether the mask should be inverted.
		 *
		 * @type {Boolean}
		 */
		get inverted(): boolean;
		set clear(arg: boolean);
		/**
		 * Indicates whether this pass should clear the stencil buffer.
		 *
		 * @type {Boolean}
		 * @deprecated Use clearPass.enabled instead.
		 */
		get clear(): boolean;
		/**
		 * Returns the internal clear pass.
		 *
		 * @deprecated Use clearPass.enabled instead.
		 * @return {ClearPass} The clear pass.
		 */
		getClearPass(): ClearPass;
		/**
		 * Indicates whether the mask is inverted.
		 *
		 * @deprecated Use inverted instead.
		 * @return {Boolean} Whether the mask is inverted.
		 */
		isInverted(): boolean;
		/**
		 * Enables or disable mask inversion.
		 *
		 * @deprecated Use inverted instead.
		 * @param {Boolean} value - Whether the mask should be inverted.
		 */
		setInverted(value: boolean): void;
		/**
		 * Renders the effect.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A pass that renders the normals of a given scene.
	 */
	export class NormalPass extends Pass {

		/**
		 * Constructs a new normal pass.
		 *
		 * @param {Scene} scene - The scene to render.
		 * @param {Camera} camera - The camera to use to render the scene.
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
		 */
		constructor(
			scene?: Scene,
			camera?: Camera,
			{
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height,
				renderTarget
			}?: {
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
				renderTarget?: WebGLRenderTarget;
			}
		);

		resolution: Resolution;
		/**
		 * The normal texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * The normal texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * Renders the scene normals.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * A shader pass.
	 *
	 * Renders any shader material as a fullscreen effect. This pass should not be used to create multiple chained effects.
	 * For a more efficient solution, please refer to the {@link EffectPass}.
	 */
	export class ShaderPass extends Pass {

		/**
		 * Constructs a new shader pass.
		 *
		 * @param {ShaderMaterial} material - A shader material.
		 * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
		 */
		constructor(material: ShaderMaterial, input?: string);
		/**
		 * Sets the name of the input buffer uniform.
		 *
		 * Most fullscreen materials modify texels from an input texture. This pass automatically assigns the main input
		 * buffer to the uniform identified by the given name.
		 *
		 * @param {String} input - The name of the input buffer uniform.
		 */
		setInput(input: string): void;
		/**
		 * Renders the effect.
		 * @param renderer - The renderer.
		 * @param inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
		 * @param [deltaTime] - The time between the last frame and the current one in seconds.
		 * @param [stencilTest] - Indicates whether a stencil mask is active.
		 */
		render(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget | null,
			outputBuffer: WebGLRenderTarget | null,
			deltaTime?: number,
			stencilTest?: boolean
		): void;

	}

	/**
	 * The EffectComposer may be used in place of a normal WebGLRenderer.
	 *
	 * The auto clear behaviour of the provided renderer will be disabled to prevent unnecessary clear operations.
	 *
	 * It is common practice to use a {@link RenderPass} as the first pass to automatically clear the buffers and render a
	 * scene for further processing.
	 *
	 * @implements {Resizable}
	 * @implements {Disposable}
	 */
	export class EffectComposer implements Resizable, Disposable {

		/**
		 * Constructs a new effect composer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer that should be used.
		 * @param {Object} [options] - The options.
		 * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
		 * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
		 * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
		 * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
		 * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
		 */
		constructor(
			renderer?: WebGLRenderer,
			{
				depthBuffer,
				stencilBuffer,
				multisampling,
				frameBufferType
			}?: {
				depthBuffer?: boolean;
				stencilBuffer?: boolean;
				alpha?: boolean;
				multisampling?: number;
				frameBufferType?: number;
			}
		);

		/**
		 * The input buffer.
		 *
		 * Two identical buffers are used to avoid reading from and writing to the same render target.
		 *
		 * @type {WebGLRenderTarget}
		 */
		inputBuffer: WebGLRenderTarget;
		/**
		 * The output buffer.
		 *
		 * @type {WebGLRenderTarget}
		 */
		outputBuffer: WebGLRenderTarget;
		/**
		 * The passes.
		 *
		 * @type {Pass[]}
		 */
		passes: Pass[];
		/**
		 * Determines whether the last pass automatically renders to screen.
		 *
		 * @type {Boolean}
		 */
		autoRenderToScreen: boolean;
		/**
		 * Sets the amount of MSAA samples.
		 *
		 * Requires WebGL 2. Set to zero to disable multisampling.
		 *
		 * @type {Number}
		 */
		set multisampling(arg: number);
		/**
		 * The current amount of samples used for multisample anti-aliasing.
		 *
		 * @type {Number}
		 */
		get multisampling(): number;
		/**
		 * Returns the internal timer.
		 *
		 * @return {Timer} The timer.
		 */
		getTimer(): Timer3;
		/**
		 * Returns the renderer.
		 *
		 * @return {WebGLRenderer} The renderer.
		 */
		getRenderer(): WebGLRenderer;
		/**
		 * Sets the renderer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 */
		setRenderer(renderer: WebGLRenderer): void;
		/**
		 * Replaces the current renderer with the given one.
		 *
		 * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
		 * previous one, all passes will be updated.
		 *
		 * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
		 * element of the new renderer will take its place.
		 *
		 * @deprecated Use setRenderer instead.
		 * @param {WebGLRenderer} renderer - The new renderer.
		 * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
		 * @return {WebGLRenderer} The old renderer.
		 */
		replaceRenderer(
			renderer: WebGLRenderer,
			updateDOM?: boolean
		): WebGLRenderer;
		/**
		 * Creates a new render target.
		 *
		 * @deprecated Create buffers manually via WebGLRenderTarget instead.
		 * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
		 * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
		 * @param {Number} type - The frame buffer type.
		 * @param {Number} multisampling - The number of samples to use for antialiasing.
		 * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
		 */
		createBuffer(
			depthBuffer: boolean,
			stencilBuffer: boolean,
			type: number,
			multisampling: number
		): WebGLRenderTarget;
		/**
		 * Can be used to change the main scene for all registered passes and effects.
		 *
		 * @param {Scene} scene - The scene.
		 */
		setMainScene(scene: Scene): void;
		/**
		 * Can be used to change the main camera for all registered passes and effects.
		 *
		 * @param {Camera} camera - The camera.
		 */
		setMainCamera(camera: Camera): void;
		/**
		 * Adds a pass, optionally at a specific index.
		 *
		 * @param {Pass} pass - A new pass.
		 * @param {Number} [index] - An index at which the pass should be inserted.
		 */
		addPass(pass: Pass, index?: number): void;
		/**
		 * Removes a pass.
		 *
		 * @param {Pass} pass - The pass.
		 */
		removePass(pass: Pass): void;
		/**
		 * Removes all passes.
		 */
		removeAllPasses(): void;
		/**
		 * Renders all enabled passes in the order in which they were added.
		 *
		 * @param {Number} [deltaTime] - The time since the last frame in seconds.
		 */
		render(deltaTime?: number): void;
		/**
		 * Sets the size of the buffers, passes and the renderer.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
		 */
		setSize(width: number, height: number, updateStyle?: boolean): void;
		/**
		 * Resets this composer by deleting all passes and creating new buffers.
		 */
		reset(): void;
		/**
		 * Disposes this composer and all passes.
		 */
		dispose(): void;

	}

	/**
	 * An override material manager.
	 *
	 * Includes a workaround that fixes override materials for skinned meshes and instancing. Doesn't fix uniforms such as
	 * normal maps and displacement maps. Using the workaround may have a negative impact on performance if the scene
	 * contains a lot of meshes.
	 *
	 * @implements {Disposable}
	 */
	export class OverrideMaterialManager implements Disposable {

		/**
		 * Enables or disables the override material workaround globally.
		 *
		 * This only affects post processing passes and effects.
		 *
		 * @type {Boolean}
		 */
		static set workaroundEnabled(arg: boolean);
		/**
		 * Indicates whether the override material workaround is enabled.
		 *
		 * @type {Boolean}
		 */
		static get workaroundEnabled(): boolean;
		/**
		 * Constructs a new override material manager.
		 *
		 * @param {Material} [material=null] - An override material.
		 */
		constructor(material?: Material);
		/**
		 * Sets the override material.
		 *
		 * @param {Material} material - The material.
		 */
		setMaterial(material: Material): void;
		/**
		 * Performs cleanup tasks.
		 */
		dispose(): void;

	}

	/**
	 * The Resizable contract.
	 *
	 * Implemented by objects that can be resized.
	 *
	 * @interface
	 */
	export interface Resizable {

		/**
		 * Sets the size of this object.
		 *
		 * @param {number} width - The width.
		 * @param {number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * A timer that provides read access to time data.
	 *
	 * @interface
	 */
	export interface ImmutableTimer {

		/**
		* The current delta time in seconds.
		*
		* @type {Number}
		*/
		getDelta(): number;
		/**
		* The elapsed time in seconds.
		*
		* @type {Number}
		*/
		getElapsed(): number;

	}

	/**
	 * An object selection.
	 *
	 * Object selections use render layers to facilitate quick and efficient visibility changes.
	 */
	export class Selection extends Set<Object3D> {

		/**
		 * Constructs a new selection.
		 *
		 * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
		 * @param {Number} [layer=10] - A dedicated render layer for selected objects.
		 */
		constructor(iterable?: Iterable<Object3D>, layer?: number);
		/**
		 * Controls whether objects that are added to this selection should be removed from all other layers.
		 *
		 * @type {Boolean}
		 */
		exclusive: boolean;
		set layer(arg: number);
		/**
		 * The render layer for selected objects.
		 *
		 * @type {Number}
		 */
		get layer(): number;
		/**
		 * Returns the current render layer for selected objects.
		 *
		 * The default layer is 10. If this collides with your own custom layers, please change it before rendering!
		 *
		 * @deprecated Use layer instead.
		 * @return {Number} The layer.
		 */
		getLayer(): number;
		/**
		 * Sets the render layer for selected objects.
		 *
		 * The current selection will be updated accordingly.
		 *
		 * @deprecated Use layer instead.
		 * @param {Number} value - The layer. Range is [0, 31].
		 */
		setLayer(value: number): void;
		/**
		 * Indicates whether objects that are added to this selection will be removed from all other layers.
		 *
		 * @deprecated Use exclusive instead.
		 * @return {Number} Whether this selection is exclusive. Default is false.
		 */
		isExclusive(): number;
		/**
		 * Controls whether objects that are added to this selection should be removed from all other layers.
		 *
		 * @deprecated Use exclusive instead.
		 * @param {Number} value - Whether this selection should be exclusive.
		 */
		setExclusive(value: number): void;
		/**
		 * Clears this selection.
		 *
		 * @return {Selection} This selection.
		 */
		clear(): this;
		/**
		 * Clears this selection and adds the given objects.
		 *
		 * @param {Iterable<Object3D>} objects - The objects that should be selected.
		 * @return {Selection} This selection.
		 */
		set(objects: Iterable<Object3D>): this;
		/**
		 * An alias for {@link has}.
		 *
		 * @param {Object3D} object - An object.
		 * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
		 * @deprecated Added for backward-compatibility.
		 */
		indexOf(object: Object3D): number;
		/**
		 * Adds an object to this selection.
		 *
		 * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
		 *
		 * @param {Object3D} object - The object that should be selected.
		 * @return {Selection} This selection.
		 */
		add(object: Object3D): this;
		/**
		 * Removes an existing object from the selection. If the object doesn't exist it's added instead.
		 *
		 * @param {Object3D} object - The object.
		 * @return {Boolean} Returns true if the object is added, false otherwise.
		 */
		toggle(object: Object3D): boolean;
		/**
		 * Sets the visibility of all selected objects.
		 *
		 * This method enables or disables render layer 0 of all selected objects.
		 *
		 * @param {Boolean} visible - Whether the selected objects should be visible.
		 * @return {Selection} This selection.
		 */
		setVisible(visible: boolean): this;

	}

	/**
	 * A timer.
	 *
	 * Original implementation by Michael Herzog (Mugen87).
	 *
 	 * @deprecated Use `three/addons/misc/Timer.js` instead.
	 * @implements {Disposable}
	 * @implements {EventListenerObject}
	 */
	export class Timer implements Disposable, EventListenerObject {
		handleEvent(object: Event): void;

		/**
		 * The current delta time in seconds.
		 */
		get delta(): number;
		/**
		 * The fixed delta time in seconds.
		 */
		get fixedDelta(): number;
		set fixedDelta(value: number);
		/**
		 * The elapsed time in seconds.
		 */
		get elapsed(): number;
		/**
		 * Determines whether this timer should use a fixed time step.
		 */
		useFixedDelta: boolean;
		/**
		 * The timescale.
		 */
		timescale: number;
		/**
		 * Enables or disables auto reset based on page visibility.
		 *
		 * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
		 * is hidden. Has no effect if the API is not supported.
		 *
		 */
		get autoReset(): boolean;
		set autoReset(value: boolean);
		/**
		 * Updates this timer.
		 *
		 * @param {Number} [timestamp] - The current time in milliseconds.
		 */
		update(timestamp?: number): void;
		/**
		 * Resets this timer.
		 *
		 * @return {Timer} This timer.
		 */
		reset(): Timer;
		/**
		 * Disposes this timer.
		 */
		dispose(): void;

	}

	export type BloomEffectOptions = {
		blendFunction?: BlendFunction;
		luminanceThreshold?: number;
		luminanceSmoothing?: number;
		mipmapBlur?: boolean;
		intensity?: number;
		radius?: number;
		levels?: number;
		kernelSize?: KernelSize;
		resolutionScale?: number;
		width?: number;
		height?: number;
		resolutionX?: number;
		resolutionY?: number;
	};

	/**
	 * A bloom effect.
	 */
	export class BloomEffect extends Effect {

		/**
		 * Constructs a new bloom effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
		 * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
		 * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
		 * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
		 * @param {Number} [options.intensity=1.0] - The bloom intensity.
		 * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
		 * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
		 * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
		 * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
		 */
		constructor({
			blendFunction,
			luminanceThreshold,
			luminanceSmoothing,
			mipmapBlur,
			intensity,
			radius,
			levels,
			kernelSize,
			resolutionScale,
			width,
			height,
			resolutionX,
			resolutionY
		}?: BloomEffectOptions);

		/**
		 * A luminance shader pass.
		 *
		 * This pass can be disabled to skip luminance filtering.
		 *
		 * @type {LuminancePass}
		 */
		luminancePass: LuminancePass;
		/**
		 * A blur pass.
		 *
		 * @type {KawaseBlurPass}
		 */
		blurPass: KawaseBlurPass;
		/**
		 * A texture that contains the intermediate result of this effect.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * Returns the generated bloom texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * The resolution of this effect.
		 *
		 * @type {Resolution}
		 */
		get resolution(): Resolution;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Returns the blur pass.
		 *
		 * @deprecated Use blurPass instead.
		 * @return {KawaseBlurPass} The blur pass.
		 */
		getBlurPass(): KawaseBlurPass;
		/**
		 * Returns the luminance pass.
		 *
		 * @deprecated Use luminancePass instead.
		 * @return {LuminancePass} The luminance pass.
		 */
		getLuminancePass(): LuminancePass;
		/**
		 * The luminance material.
		 *
		 * @type {LuminanceMaterial}
		 */
		get luminanceMaterial(): LuminanceMaterial;
		/**
		 * Returns the luminance material.
		 *
		 * @deprecated Use luminanceMaterial instead.
		 * @return {LuminanceMaterial} The material.
		 */
		getLuminanceMaterial(): LuminanceMaterial;
		set width(arg: number);
		/**
		 * The current width of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.width instead.
		 */
		get width(): number;
		set height(arg: number);
		/**
		 * The current height of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.height instead.
		 */
		get height(): number;
		set dithering(arg: boolean);
		/**
		 * Indicates whether dithering is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated Use EffectPass.fullscreenMaterial.dithering instead.
		 */
		get dithering(): boolean;
		set kernelSize(arg: KernelSize);
		/**
		 * The blur kernel size.
		 *
		 * @type {KernelSize}
		 * @deprecated Use blurPass.kernelSize instead.
		 */
		get kernelSize(): KernelSize;
		set distinction(arg: number);
		/**
		 * @type {Number}
		 * @deprecated Use luminanceMaterial instead.
		 */
		get distinction(): number;
		set intensity(arg: number);
		/**
		 * The bloom intensity.
		 *
		 * @type {Number}
		 */
		get intensity(): number;
		/**
		 * The bloom intensity.
		 *
		 * @deprecated Use intensity instead.
		 * @return {Number} The intensity.
		 */
		getIntensity(): number;
		/**
		 * Sets the bloom intensity.
		 *
		 * @deprecated Use intensity instead.
		 * @param {Number} value - The intensity.
		 */
		setIntensity(value: number): void;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A depth of field (bokeh) effect.
	 *
	 */
	export class BokehEffect extends Effect {

		/**
		 * Constructs a new bokeh effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.
		 * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.
		 * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.
		 * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.
		 */
		constructor({
			blendFunction,
			focus,
			dof,
			aperture,
			maxBlur
		}?: {
			blendFunction?: BlendFunction;
			focus?: number;
			dof?: number;
			aperture?: number;
			maxBlur?: number;
		});

	}

	/**
	 * A brightness/contrast effect.
	 *
	 */
	export class BrightnessContrastEffect extends Effect {

		/**
		 * Constructs a new brightness/contrast effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.
		 * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.
		 */
		constructor({
			blendFunction,
			brightness,
			contrast
		}?: {
			blendFunction?: BlendFunction;
			brightness?: number;
			contrast?: number;
		});

		set brightness(arg: number);
		/**
		 * The brightness.
		 *
		 * @type {Number}
		 */
		get brightness(): number;
		/**
		 * Returns the brightness.
		 *
		 * @deprecated Use brightness instead.
		 * @return {Number} The brightness.
		 */
		getBrightness(): number;
		/**
		 * Sets the brightness.
		 *
		 * @deprecated Use brightness instead.
		 * @param {Number} value - The brightness.
		 */
		setBrightness(value: number): void;
		set contrast(arg: number);
		/**
		 * The contrast.
		 *
		 * @type {Number}
		 */
		get contrast(): number;
		/**
		 * Returns the contrast.
		 *
		 * @deprecated Use contrast instead.
		 * @return {Number} The contrast.
		 */
		getContrast(): number;
		/**
		 * Sets the contrast.
		 *
		 * @deprecated Use contrast instead.
		 * @param {Number} value - The contrast.
		 */
		setContrast(value: number): void;

	}

	/**
	 * A chromatic aberration effect.
	 */
	export class ChromaticAberrationEffect extends Effect {

		/**
		 * Constructs a new chromatic aberration effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Vector2} [options.offset] - The color offset.
		 * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.
		 * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.
		 */
		constructor({
			blendFunction,
			offset,
			radialModulation,
			modulationOffset
		}?: {
			blendFunction?: BlendFunction;
			offset?: Vector2;
			radialModulation: boolean,
			modulationOffset: number
		});

		set offset(arg: Vector2);
		/**
		 * The color offset.
		 *
		 * @type {Vector2}
		 */
		get offset(): Vector2;
		/**
		 * Indicates whether radial modulation is enabled.
		 *
		 * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.
		 *
		 * @type {Boolean}
		 */
		get radialModulation(): boolean;
		set radialModulation(arg: boolean);
		/**
		 * The modulation offset.
		 *
		 * @type {Number}
		 */
		get modulationOffset(): number;
		set modulationOffset(arg: number);
		/**
		 * Returns the color offset vector.
		 *
		 * @deprecated Use offset instead.
		 * @return {Vector2} The offset.
		 */
		getOffset(): Vector2;
		/**
		 * Sets the color offset vector.
		 *
		 * @deprecated Use offset instead.
		 * @param {Vector2} value - The offset.
		 */
		setOffset(value: Vector2): void;

	}

	/**
	 * A fast greyscale effect.
	 */
	export class ColorAverageEffect extends Effect {

		/**
		 * Constructs a new color average effect.
		 *
		 * @param {BlendFunction} [blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 */
		constructor(blendFunction?: BlendFunction);

	}

	/**
	 * A color depth effect.
	 *
	 * Simulates a hardware limitation to achieve a retro feel. The real color depth will not be altered by this effect.
	 */
	export class ColorDepthEffect extends Effect {

		/**
		 * Constructs a new color depth effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.bits=16] - The color bit depth.
		 */
		constructor({
			blendFunction,
			bits
		}?: {
			blendFunction?: BlendFunction;
			bits?: number;
		});

		set bitDepth(arg: number);
		/**
		 * The virtual amount of color bits.
		 *
		 * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.
		 *
		 * @type {Number}
		 */
		get bitDepth(): number;
		/**
		 * Returns the current color bit depth.
		 *
		 * @return {Number} The bit depth.
		 */
		getBitDepth(): number;
		/**
		 * Sets the virtual amount of color bits.
		 *
		 * @param {Number} value - The bit depth.
		 */
		setBitDepth(value: number): void;

	}

	/**
	 * A depth visualization effect.
	 *
	 * Useful for debugging.
	 */
	export class DepthEffect extends Effect {

		/**
		 * Constructs a new depth effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.
		 */
		constructor({
			blendFunction,
			inverted
		}?: {
			blendFunction?: BlendFunction;
			inverted?: boolean;
		});

		set inverted(arg: boolean);
		/**
		 * Indicates whether depth should be inverted.
		 *
		 * @type {Boolean}
		 */
		get inverted(): boolean;
		/**
		 * Indicates whether the rendered depth is inverted.
		 *
		 * @deprecated Use inverted instead.
		 * @return {Boolean} Whether the rendered depth is inverted.
		 */
		isInverted(): boolean;
		/**
		 * Enables or disables depth inversion.
		 *
		 * @deprecated Use inverted instead.
		 * @param {Boolean} value - Whether depth should be inverted.
		 */
		setInverted(value: boolean): void;

	}

	/**
	 * A depth of field effect.
	 *
	 */
	export class DepthOfFieldEffect extends Effect {

		/**
		 * Constructs a new depth of field effect.
		 *
		 * @param {Camera} camera - The main camera.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.worldFocusDistance] - The focus distance in world units.
		 * @param {Number} [options.worldFocusRange] - The focus distance in world units.
		 * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].
		 * @param {Number} [options.focalLength=0.1] - The focal length. Range is [0.0, 1.0].
		 * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].
		 * @param {Number} [options.focalLength=0.1] - Deprecated.
		 * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 */
		constructor(
			camera?: Camera,
			{
				blendFunction,
				worldFocusDistance,
				worldFocusRange,
				focusDistance,
				focalLength,
				focusRange,
				bokehScale,
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height
			}?: {
				blendFunction?: BlendFunction;
				worldFocusDistance?: number;
				worldFocusRange?: number;
				focusDistance?: number;
				focalLength?: number;
				focusRange?: number;
				bokehScale?: number;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
			}
		);

		/**
		 * This pass blurs the foreground CoC buffer to soften edges.
		 *
		 * @type {KawaseBlurPass}
		 */
		readonly blurPass: KawaseBlurPass;
		/**
		 * A target position that should be kept in focus. Set to `null` to disable auto focus.
		 *
		 * @type {Vector3}
		 */
		target: Vector3;
		set bokehScale(arg: number);
		/**
		 * The current bokeh scale.
		 *
		 * @type {Number}
		 */
		get bokehScale(): number;
		/**
		 * The circle of confusion texture.
		 *
		 * @type {Texture}
		 */
		get cocTexture(): Texture;
		/**
		 * The mask function. Default is `MULTIPLY_RGB`.
		 *
		 * @type {MaskFunction}
		 */
		get maskFunction(): MaskFunction;
		set maskFunction(arg: MaskFunction);
		/**
		 * The circle of confusion material.
		 *
		 * @type {CircleOfConfusionMaterial}
		 */
		get cocMaterial(): CircleOfConfusionMaterial;
		/**
		 * The circle of confusion material.
		 *
		 * @deprecated Use cocMaterial instead.
		 * @type {CircleOfConfusionMaterial}
		 */
		get circleOfConfusionMaterial(): CircleOfConfusionMaterial;
		/**
		 * Returns the circle of confusion material.
		 *
		 * @deprecated Use cocMaterial instead.
		 * @return {CircleOfConfusionMaterial} The material.
		 */
		getCircleOfConfusionMaterial(): CircleOfConfusionMaterial;
		/**
		 * Returns the pass that blurs the foreground CoC buffer to soften edges.
		 *
		 * @deprecated Use blurPass instead.
		 * @return {KawaseBlurPass} The blur pass.
		 */
		getBlurPass(): KawaseBlurPass;
		/**
		 * The resolution of this effect.
		 *
		 * @type {Resolution}
		 */
		get resolution(): Resolution;
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * Returns the current bokeh scale.
		 *
		 * @deprecated Use bokehScale instead.
		 * @return {Number} The scale.
		 */
		getBokehScale(): number;
		/**
		 * Sets the bokeh scale.
		 *
		 * @deprecated Use bokehScale instead.
		 * @param {Number} value - The scale.
		 */
		setBokehScale(value: number): void;
		/**
		 * Returns the current auto focus target.
		 *
		 * @deprecated Use target instead.
		 * @return {Vector3} The target.
		 */
		getTarget(): Vector3;
		/**
		 * Sets the auto focus target.
		 *
		 * @deprecated Use target instead.
		 * @param {Vector3} value - The target.
		 */
		setTarget(value: Vector3): void;
		/**
		 * Calculates the focus distance from the camera to the given position.
		 *
		 * @param {Vector3} target - The target.
		 * @return {Number} The normalized focus distance.
		 */
		calculateFocusDistance(target: Vector3): number;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A dot screen effect.
	 */
	export class DotScreenEffect extends Effect {

		/**
		 * Constructs a new dot screen effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.angle=1.57] - The angle of the dot pattern.
		 * @param {Number} [options.scale=1.0] - The scale of the dot pattern.
		 */
		constructor({
			blendFunction,
			angle,
			scale
		}?: {
			blendFunction?: BlendFunction;
			angle?: number;
			scale?: number;
		});

		set angle(arg: number);
		/**
		 * The angle.
		 *
		 * @type {Number}
		 */
		get angle(): number;
		/**
		 * Returns the pattern angle.
		 *
		 * @deprecated Use angle instead.
		 * @return {Number} The angle in radians.
		 */
		getAngle(): number;
		/**
		 * Sets the pattern angle.
		 *
		 * @deprecated Use angle instead.
		 * @param {Number} value - The angle in radians.
		 */
		setAngle(value: number): void;
		set scale(arg: number);
		/**
		 * The scale.
		 *
		 * @type {Number}
		 */
		get scale(): number;

	}

	/**
	 * A gamma correction effect.
	 *
	 * @deprecated Set WebGLRenderer.outputEncoding to sRGBEncoding instead.
	 */
	export class GammaCorrectionEffect extends Effect {

		/**
		 * Constructs a new gamma correction effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.gamma=2.0] - The gamma factor.
		 */
		constructor({
			blendFunction,
			gamma
		}?: {
			blendFunction?: BlendFunction;
			gamma?: number;
		});

	}

	/**
	 * A tilt shift effect.
	 */
	export class TiltShiftEffect extends Effect {

		/**
		 * Constructs a new tilt shift Effect
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.
		 * @param {Number} [options.offset=0.0] - The relative offset of the focus area.
		 * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.
		 * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.
		 * @param {Number} [options.feather=0.3] - The softness of the focus area edges.
		 * @param {Number} [options.bias=0.06] - Deprecated.
		 * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
		 * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 */
		constructor({
			blendFunction,
			offset,
			rotation,
			focusArea,
			feather,
			bias,
			kernelSize,
			resolutionScale,
			resolutionX,
			resolutionY
		}?: {
			blendFunction?: BlendFunction,
			offset?: number,
			rotation?: number,
			focusArea?: number,
			feather?: number,
			bias?: number,
			kernelSize?: KernelSize,
			resolutionScale?: number,
			resolutionX?: number,
			resolutionY?: number
		});

		/**
		 * A blur pass.
		 *
		 * @type {KawaseBlurPass}
		 */
		readonly blurPass: KawaseBlurPass;
		/**
		 * The resolution.
		 *
		 * @type {Resolution}
		 * @readonly
		 */
		get resolution(): Resolution;
		/**
		 * The rotation of the focus area in radians.
		 *
		 * @type {Number}
		 */
		get rotation(): number;
		set rotation(arg: number);
		/**
		 * The relative offset of the focus area.
		 *
		 * @type {Number}
		 */
		get offset(): number;
		set offset(arg: number);
		/**
		 * The relative size of the focus area.
		 *
		 * @type {Number}
		 */

		get focusArea(): number;
		set focusArea(arg: number);
		/**
		 * The softness of the focus area edges.
		 *
		 * @type {Number}
		 */
		get feather(): number;
		set feather(arg: number);
		/**
		 * A blend bias.
		 *
		 * @type {Number}
		 * @deprecated
		 */
		get bias(): number;
		set bias(arg: number);
	}

	/**
	 * A glitch effect.
	 *
	 * This effect can be used in conjunction with the {@link ChromaticAberrationEffect}.
	 *
	 */
	export class GlitchEffect extends Effect {

		/**
		 * Constructs a new glitch effect.
		 *
		 * TODO Change ratio to 0.15.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.
		 * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.
		 * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.
		 * @param {Vector2} [options.strength] - The strength of weak and strong glitches.
		 * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.
		 * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.
		 * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.
		 * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.
		 */
		constructor({
			blendFunction,
			chromaticAberrationOffset,
			delay,
			duration,
			strength,
			columns,
			ratio,
			perturbationMap,
			dtSize
		}?: {
			blendFunction?: BlendFunction;
			chromaticAberrationOffset?: Vector2;
			delay?: Vector2;
			duration?: Vector2;
			strength?: Vector2;
			perturbationMap?: Texture;
			dtSize?: number;
			columns?: number;
			ratio?: number;
		});

		set perturbationMap(arg: Texture);
		/**
		 * The perturbation map.
		 *
		 * @type {Texture}
		 */
		get perturbationMap(): Texture;
		/**
		 * The minimum and maximum delay between glitch activations in seconds.
		 *
		 * @type {Vector2}
		 * @deprecated Use minDelay and maxDelay instead.
		 */
		delay: Vector2;
		/**
		 * The minimum and maximum duration of a glitch in seconds.
		 *
		 * @type {Vector2}
		 * @deprecated Use minDuration and maxDuration instead.
		 */
		duration: Vector2;
		/**
		 * The strength of weak and strong glitches.
		 *
		 * @type {Vector2}
		 * @deprecated Use minStrength and maxStrength instead.
		 */
		strength: Vector2;
		/**
		 * The effect mode.
		 *
		 * @type {GlitchMode}
		 */
		mode: GlitchMode;
		/**
		 * The ratio between weak (0.0) and strong (1.0) glitches. Range is [0.0, 1.0].
		 *
		 * This value is currently being treated as a threshold for strong glitches, i.e. it's inverted.
		 *
		 * TODO Resolve inversion.
		 * @type {Number}
		 */
		ratio: number;
		/**
		 * The chromatic aberration offset.
		 *
		 * @type {Vector2}
		 */
		chromaticAberrationOffset: Vector2;
		/**
		 * Indicates whether the glitch effect is currently active.
		 *
		 * @type {Boolean}
		 */
		get active(): boolean;
		/**
		 * Indicates whether the glitch effect is currently active.
		 *
		 * @deprecated Use active instead.
		 * @return {Boolean} Whether the glitch effect is active.
		 */
		isActive(): boolean;
		set minDelay(arg: number);
		/**
		 * The minimum delay between glitch activations.
		 *
		 * @type {Number}
		 */
		get minDelay(): number;
		/**
		 * Returns the minimum delay between glitch activations.
		 *
		 * @deprecated Use minDelay instead.
		 * @return {Number} The minimum delay in seconds.
		 */
		getMinDelay(): number;
		/**
		 * Sets the minimum delay between glitch activations.
		 *
		 * @deprecated Use minDelay instead.
		 * @param {Number} value - The minimum delay in seconds.
		 */
		setMinDelay(value: number): void;
		set maxDelay(arg: number);
		/**
		 * The maximum delay between glitch activations.
		 *
		 * @type {Number}
		 */
		get maxDelay(): number;
		/**
		 * Returns the maximum delay between glitch activations.
		 *
		 * @deprecated Use maxDelay instead.
		 * @return {Number} The maximum delay in seconds.
		 */
		getMaxDelay(): number;
		/**
		 * Sets the maximum delay between glitch activations.
		 *
		 * @deprecated Use maxDelay instead.
		 * @param {Number} value - The maximum delay in seconds.
		 */
		setMaxDelay(value: number): void;
		set minDuration(arg: number);
		/**
		 * The minimum duration of sporadic glitches.
		 *
		 * @type {Number}
		 */
		get minDuration(): number;
		/**
		 * Returns the minimum duration of sporadic glitches.
		 *
		 * @deprecated Use minDuration instead.
		 * @return {Number} The minimum duration in seconds.
		 */
		getMinDuration(): number;
		/**
		 * Sets the minimum duration of sporadic glitches.
		 *
		 * @deprecated Use minDuration instead.
		 * @param {Number} value - The minimum duration in seconds.
		 */
		setMinDuration(value: number): void;
		set maxDuration(arg: number);
		/**
		 * The maximum duration of sporadic glitches.
		 *
		 * @type {Number}
		 */
		get maxDuration(): number;
		/**
		 * Returns the maximum duration of sporadic glitches.
		 *
		 * @deprecated Use maxDuration instead.
		 * @return {Number} The maximum duration in seconds.
		 */
		getMaxDuration(): number;
		/**
		 * Sets the maximum duration of sporadic glitches.
		 *
		 * @deprecated Use maxDuration instead.
		 * @param {Number} value - The maximum duration in seconds.
		 */
		setMaxDuration(value: number): void;
		set minStrength(arg: number);
		/**
		 * The strength of weak glitches.
		 *
		 * @type {Number}
		 */
		get minStrength(): number;
		/**
		 * Returns the strength of weak glitches.
		 *
		 * @deprecated Use minStrength instead.
		 * @return {Number} The strength.
		 */
		getMinStrength(): number;
		/**
		 * Sets the strength of weak glitches.
		 *
		 * @deprecated Use minStrength instead.
		 * @param {Number} value - The strength.
		 */
		setMinStrength(value: number): void;
		set maxStrength(arg: number);
		/**
		 * The strength of strong glitches.
		 *
		 * @type {Number}
		 */
		get maxStrength(): number;
		/**
		 * Returns the strength of strong glitches.
		 *
		 * @deprecated Use maxStrength instead.
		 * @return {Number} The strength.
		 */
		getMaxStrength(): number;
		/**
		 * Sets the strength of strong glitches.
		 *
		 * @deprecated Use maxStrength instead.
		 * @param {Number} value - The strength.
		 */
		setMaxStrength(value: number): void;
		/**
		 * Returns the current glitch mode.
		 *
		 * @deprecated Use mode instead.
		 * @return {GlitchMode} The mode.
		 */
		getMode(): GlitchMode;
		/**
		 * Sets the current glitch mode.
		 *
		 * @deprecated Use mode instead.
		 * @param {GlitchMode} value - The mode.
		 */
		setMode(value: GlitchMode): void;
		/**
		 * Returns the glitch ratio.
		 *
		 * @deprecated Use ratio instead.
		 * @return {Number} The ratio.
		 */
		getGlitchRatio(): number;
		/**
		 * Sets the ratio of weak (0.0) and strong (1.0) glitches.
		 *
		 * @deprecated Use ratio instead.
		 * @param {Number} value - The ratio. Range is [0.0, 1.0].
		 */
		setGlitchRatio(value: number): void;
		set columns(arg: number);
		/**
		 * The glitch column size.
		 *
		 * @type {Number}
		 */
		get columns(): number;
		/**
		 * Returns the glitch column size.
		 *
		 * @deprecated Use columns instead.
		 * @return {Number} The glitch column size.
		 */
		getGlitchColumns(): number;
		/**
		 * Sets the glitch column size.
		 *
		 * @deprecated Use columns instead.
		 * @param {Number} value - The glitch column size.
		 */
		setGlitchColumns(value: number): void;
		/**
		 * Returns the chromatic aberration offset.
		 *
		 * @deprecated Use chromaticAberrationOffset instead.
		 * @return {Vector2} The offset.
		 */
		getChromaticAberrationOffset(): Vector2;
		/**
		 * Sets the chromatic aberration offset.
		 *
		 * @deprecated Use chromaticAberrationOffset instead.
		 * @param {Vector2} value - The offset.
		 */
		setChromaticAberrationOffset(value: Vector2): void;
		/**
		 * Returns the current perturbation map.
		 *
		 * @deprecated Use perturbationMap instead.
		 * @return {Texture} The current perturbation map.
		 */
		getPerturbationMap(): Texture;
		/**
		 * Replaces the current perturbation map with the given one.
		 *
		 * The current map will be disposed if it was generated by this effect.
		 *
		 * @deprecated Use perturbationMap instead.
		 * @param {Texture} value - The new perturbation map.
		 */
		setPerturbationMap(value: Texture): void;
		/**
		 * Generates a perturbation map.
		 *
		 * @deprecated Use NoiseTexture instead.
		 * @param {Number} [value=64] - The texture size.
		 * @return {DataTexture} The perturbation map.
		 */
		generatePerturbationMap(value?: number): DataTexture;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Deletes generated resources.
		 */
		dispose(): void;

	}

	/**
	 * A glitch mode enumeration.
	 *
	 * @type {Object}
	 * @property {Number} DISABLED - No glitches.
	 * @property {Number} SPORADIC - Sporadic glitches.
	 * @property {Number} CONSTANT_MILD - Constant mild glitches.
	 * @property {Number} CONSTANT_WILD - Constant wild glitches.
	 */
	export enum GlitchMode {
		DISABLED,
		SPORADIC,
		CONSTANT_MILD,
		CONSTANT_WILD,
	}

	/**
	 * A god rays effect.
	 */
	export class GodRaysEffect extends Effect {

		/**
		 * Constructs a new god rays effect.
		 *
		 * @param {Camera} [camera] - The main camera.
		 * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
		 * @param {Number} [options.samples=60.0] - The number of samples per pixel.
		 * @param {Number} [options.density=0.96] - The density of the light rays.
		 * @param {Number} [options.decay=0.9] - An illumination decay factor.
		 * @param {Number} [options.weight=0.4] - A light ray weight factor.
		 * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
		 * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
		 * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.
		 * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.
		 */
		constructor(
			camera?: Camera,
			lightSource?: Mesh | Points,
			{
				blendFunction,
				samples,
				density,
				decay,
				weight,
				exposure,
				clampMax,
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height,
				kernelSize,
				blur
			}?: {
				blendFunction?: BlendFunction;
				samples?: number;
				density?: number;
				decay?: number;
				weight?: number;
				exposure?: number;
				clampMax?: number;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
				kernelSize?: KernelSize;
				blur?: boolean;
			}
		);

		/**
		 * A blur pass that reduces aliasing artifacts and makes the light softer.
		 *
		 * This pass can be disabled to improve performance.
		 *
		 * @type {KawaseBlurPass}
		 */
		blurPass: KawaseBlurPass;
		/**
		 * Returns the blur pass that reduces aliasing artifacts and makes the light softer.
		 *
		 * @deprecated Use blurPass instead.
		 * @return {KawaseBlurPass} The blur pass.
		 */
		getBlurPass(): KawaseBlurPass;
		/**
		 * Sets the light source.
		 *
		 * @type {Mesh|Points}
		 */
		get lightSource(): Mesh | Points | null;
		set lightSource(value: Mesh | Points | null);
		/**
		 * A texture that contains the intermediate result of this effect.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		/**
		 * The depth mask material.
		 *
		 * @type {DepthMaskMaterial}
		 */
		get depthMaskMaterial(): DepthMaskMaterial;
		/**
		 * Returns the god rays texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * The internal god rays material.
		 *
		 * @type {GodRaysMaterial}
		 */
		get godRaysMaterial(): GodRaysMaterial;
		/**
		 * Returns the god rays material.
		 *
		 * @deprecated Use godRaysMaterial instead.
		 * @return {GodRaysMaterial} The material.
		 */
		getGodRaysMaterial(): GodRaysMaterial;
		/**
		 * The resolution of this effect.
		 *
		 * @type {Resolution}
		 */
		get resolution(): Resolution;
		/**
		 * Returns the resolution of this effect.
		 *
		 * @deprecated Use resolution instead.
		 * @return {GodRaysMaterial} The material.
		 */
		getResolution(): GodRaysMaterial;
		set width(arg: number);
		/**
		 * The current width of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.width instead.
		 */
		get width(): number;
		set height(arg: number);
		/**
		 * The current height of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.height instead.
		 */
		get height(): number;
		set dithering(arg: boolean);
		/**
		 * Indicates whether dithering is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated
		 */
		get dithering(): boolean;
		set blur(arg: boolean);
		/**
		 * Indicates whether the god rays should be blurred to reduce artifacts.
		 *
		 * @type {Boolean}
		 * @deprecated Use blurPass.enabled instead.
		 */
		get blur(): boolean;
		set kernelSize(arg: KernelSize);
		/**
		 * The blur kernel size.
		 *
		 * @type {KernelSize}
		 * @deprecated Use blurPass.kernelSize instead.
		 */
		get kernelSize(): KernelSize;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * A higher sample count improves quality at the cost of performance.
		 *
		 * @type {Number}
		 * @deprecated Use godRaysMaterial.samples instead.
		 */
		set samples(arg: number);
		/**
		 * The number of samples per pixel.
		 *
		 * @type {Number}
		 * @deprecated Use godRaysMaterial.samples instead.
		 */
		get samples(): number;
		/**
		 * Sets the depth texture.
		 *
		 * @param {Texture} depthTexture - A depth texture.
		 * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.
		 */
		setDepthTexture(depthTexture: Texture, depthPacking?: number): void;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A grid effect.
	 */
	export class GridEffect extends Effect {

		/**
		 * Constructs a new grid effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.
		 * @param {Number} [options.scale=1.0] - The scale of the grid pattern.
		 * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.
		 */
		constructor({
			blendFunction,
			scale,
			lineWidth
		}?: {
			blendFunction?: BlendFunction;
			scale?: number;
			lineWidth?: number;
		});

		set scale(arg: number);
		/**
		 * The scale.
		 *
		 * @type {Number}
		 */
		get scale(): number;
		set lineWidth(arg: number);
		/**
		 * The line width.
		 *
		 * @type {Number}
		 */
		get lineWidth(): number;
		/**
		 * Returns the current grid scale.
		 *
		 * @deprecated Use scale instead.
		 * @return {Number} The grid scale.
		 */
		getScale(): number;
		/**
		 * Sets the grid scale.
		 *
		 * @deprecated Use scale instead.
		 * @param {Number} value - The new grid scale.
		 */
		setScale(value: number): void;
		/**
		 * Returns the current grid line width.
		 *
		 * @deprecated Use lineWidth instead.
		 * @return {Number} The grid line width.
		 */
		getLineWidth(): number;
		/**
		 * Sets the grid line width.
		 *
		 * @deprecated Use lineWidth instead.
		 * @param {Number} value - The new grid line width.
		 */
		setLineWidth(value: number): void;
		/**
		 * Updates the size of this pass.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * A hue/saturation effect.
	 *
	 */
	export class HueSaturationEffect extends Effect {

		/**
		 * Constructs a new hue/saturation effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.hue=0.0] - The hue in radians.
		 * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.
		 */
		constructor({
			blendFunction,
			hue,
			saturation
		}?: {
			blendFunction?: BlendFunction;
			hue?: number;
			saturation?: number;
		});

		set hue(arg: number);
		/**
		 * The hue.
		 *
		 * @type {Number}
		 */
		get hue(): number;
		set saturation(arg: number);
		/**
		 * The saturation.
		 *
		 * @type {Number}
		 */
		get saturation(): number;
		/**
		 * Returns the saturation.
		 *
		 * @deprecated Use saturation instead.
		 * @return {Number} The saturation.
		 */
		getSaturation(): number;
		/**
		 * Sets the saturation.
		 *
		 * @deprecated Use saturation instead.
		 * @param {Number} value - The saturation.
		 */
		setSaturation(value: number): void;
		/**
		 * Returns the hue.
		 *
		 * @deprecated Use hue instead.
		 * @return {Number} The hue in radians.
		 */
		getHue(): number;
		/**
		 * Sets the hue.
		 *
		 * @deprecated Use hue instead.
		 * @param {Number} value - The hue in radians.
		 */
		setHue(value: number): void;

	}

	/**
	 * A 1D LUT effect.
	 */

	export class LUT1DEffect extends Effect {

		/**
		 * Constructs a new color grading effect.
		 *
		 * @param {Texture} lut - The lookup texture.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SET] - The blend function of this effect.
		 */
		constructor(
			lut: Texture,
			{
				blendFunction
			}?: {
				blendFunction?: BlendFunction;
			}
		);

	}
	/**
	 * A LUT effect.
	 */
	export class LUT3DEffect extends Effect {

		/**
		 * Constructs a new color grading effect.
		 *
		 * @param {Texture} lut - The lookup texture.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SET] - The blend function of this effect.
		 * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.
		 * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.
		 */
		constructor(
			lut: Texture,
			{
				blendFunction,
				tetrahedralInterpolation,
				inputColorSpace
			}?: {
				blendFunction?: BlendFunction;
				tetrahedralInterpolation?: boolean;
				inputColorSpace?: ColorSpace;
			}
		);

		/**
		 * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.
		 *
		 * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.
		 *
		 * @type {Boolean}
		 */
		get tetrahedralInterpolation(): boolean;
		set tetrahedralInterpolation(arg: boolean);
		/**
		 * The LUT.
		 *
		 * @type {Texture}
		 */
		get lut(): Texture;
		set lut(arg: Texture);
		/**
		 * Returns the current LUT.
		 *
		 * @deprecated Use lut instead.
		 * @return {Texture} The LUT.
		 */
		getLUT(): Texture;
		/**
		 * Sets the LUT.
		 *
		 * @deprecated Use lut instead.
		 * @param {Texture} value - The LUT.
		 */
		setLUT(value: Texture): void;
		/**
		 * Enables or disables tetrahedral interpolation.
		 *
		 * @deprecated Use tetrahedralInterpolation instead.
		 * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.
		 */
		setTetrahedralInterpolationEnabled(value: boolean): void;

	}

	/**
	 * A noise effect.
	 */
	export class NoiseEffect extends Effect {

		/**
		 * Constructs a new noise effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
		 * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.
		 */
		constructor({
			blendFunction,
			premultiply
		}?: {
			blendFunction?: BlendFunction;
			premultiply?: boolean;
		});

		set premultiply(arg: boolean);
		/**
		 * Indicates whether noise will be multiplied with the input colors prior to blending.
		 *
		 * @type {Boolean}
		 */
		get premultiply(): boolean;
		/**
		 * Indicates whether noise will be multiplied with the input colors prior to blending.
		 *
		 * @deprecated Use premultiply instead.
		 * @return {Boolean} Whether noise is premultiplied.
		 */
		isPremultiplied(): boolean;
		/**
		 * Controls whether noise should be multiplied with the input colors prior to blending.
		 *
		 * @deprecated Use premultiply instead.
		 * @param {Boolean} value - Whether noise should be premultiplied.
		 */
		setPremultiplied(value: boolean): void;

	}

	/**
	 * An outline effect.
	 */
	export class OutlineEffect extends Effect {

		/**
		 * Constructs a new outline effect.
		 *
		 * @param {Scene} scene - The main scene.
		 * @param {Camera} camera - The main camera.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.
		 * @param {Texture} [options.patternTexture=null] - A pattern texture.
		 * @param {Number} [options.patternScale=1.0] - The pattern scale.
		 * @param {Number} [options.edgeStrength=1.0] - The edge strength.
		 * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.
		 * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.
		 * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.
		 * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.
		 * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.
		 * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.
		 * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
		 * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 */
		constructor(
			scene?: Scene,
			camera?: Camera,
			{
				blendFunction,
				patternTexture,
				patternScale,
				edgeStrength,
				pulseSpeed,
				visibleEdgeColor,
				hiddenEdgeColor,
				multisampling,
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height,
				kernelSize,
				blur,
				xRay
			}?: {
				blendFunction?: BlendFunction;
				patternTexture?: Texture;
				patternScale?: number;
				edgeStrength?: number;
				pulseSpeed?: number;
				visibleEdgeColor?: number;
				hiddenEdgeColor?: number;
				multisampling?: number;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
				kernelSize?: KernelSize;
				blur?: boolean;
				xRay?: boolean;
			}
		);

		set patternTexture(arg: Texture);
		/**
		 * The pattern texture. Set to `null` to disable.
		 *
		 * @type {Texture}
		 */
		get patternTexture(): Texture;
		set xRay(arg: boolean);
		/**
		 * Indicates whether X-ray mode is enabled.
		 *
		 * @type {Boolean}
		 */
		get xRay(): boolean;
		/**
		 * A blur pass.
		 *
		 * @type {KawaseBlurPass}
		 */
		blurPass: KawaseBlurPass;
		/**
		 * A selection of objects that will be outlined.
		 *
		 * The default layer of this selection is 10.
		 *
		 * @type {Selection}
		 */
		selection: Selection;
		/**
		 * The pulse speed. Set to 0 to disable.
		 *
		 * @type {Number}
		 */
		pulseSpeed: number;
		/**
		 * The resolution of this effect.
		 *
		 * @type {Resolution}
		 */
		get resolution(): Resolution;
		/**
		 * Returns the resolution.
		 *
		 * @return {Resizer} The resolution.
		 */
		getResolution(): Resizer;
		set patternScale(arg: number);
		/**
		 * The pattern scale.
		 *
		 * @type {Number}
		 */
		get patternScale(): number;
		set edgeStrength(arg: number);
		/**
		 * The edge strength.
		 *
		 * @type {Number}
		 */
		get edgeStrength(): number;
		set visibleEdgeColor(arg: Color);
		/**
		 * The visible edge color.
		 *
		 * @type {Color}
		 */
		get visibleEdgeColor(): Color;
		set hiddenEdgeColor(arg: Color);
		/**
		 * The hidden edge color.
		 *
		 * @type {Color}
		 */
		get hiddenEdgeColor(): Color;
		/**
		 * The amount of MSAA samples.
		 *
		 * Requires WebGL 2. Set to zero to disable multisampling.
		 *
		 * @experimental Requires three >= r138.
		 * @type {Number}
		 */
		get multisampling(): number;
		set multisampling(arg: number);
		/**
		 * Returns the blur pass.
		 *
		 * @deprecated Use blurPass instead.
		 * @return {KawaseBlurPass} The blur pass.
		 */
		getBlurPass(): KawaseBlurPass;
		/**
		 * Returns the selection.
		 *
		 * @deprecated Use selection instead.
		 * @return {Selection} The selection.
		 */
		getSelection(): Selection;
		/**
		 * Returns the pulse speed.
		 *
		 * @deprecated Use pulseSpeed instead.
		 * @return {Number} The speed.
		 */
		getPulseSpeed(): number;
		/**
		 * Sets the pulse speed. Set to zero to disable.
		 *
		 * @deprecated Use pulseSpeed instead.
		 * @param {Number} value - The speed.
		 */
		setPulseSpeed(value: number): void;
		set width(arg: number);
		/**
		 * The current width of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.width instead.
		 */
		get width(): number;
		set height(arg: number);
		/**
		 * The current height of the internal render targets.
		 *
		 * @type {Number}
		 * @deprecated Use resolution.height instead.
		 */
		get height(): number;
		set selectionLayer(arg: number);
		/**
		 * The selection layer.
		 *
		 * @type {Number}
		 * @deprecated Use selection.layer instead.
		 */
		get selectionLayer(): number;
		set dithering(arg: boolean);
		/**
		 * Indicates whether dithering is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated
		 */
		get dithering(): boolean;
		set kernelSize(arg: KernelSize);
		/**
		 * The blur kernel size.
		 *
		 * @type {KernelSize}
		 * @deprecated Use blurPass.kernelSize instead.
		 */
		get kernelSize(): KernelSize;
		set blur(arg: boolean);
		/**
		 * Indicates whether the outlines should be blurred.
		 *
		 * @type {Boolean}
		 * @deprecated Use blurPass.enabled instead.
		 */
		get blur(): boolean;
		/**
		 * Indicates whether X-ray mode is enabled.
		 *
		 * @deprecated Use xRay instead.
		 * @return {Boolean} Whether X-ray mode is enabled.
		 */
		isXRayEnabled(): boolean;
		/**
		 * Enables or disables X-ray outlines.
		 *
		 * @deprecated Use xRay instead.
		 * @param {Boolean} value - Whether X-ray should be enabled.
		 */
		setXRayEnabled(value: boolean): void;
		/**
		 * Sets the pattern texture.
		 *
		 * @deprecated Use patternTexture instead.
		 * @param {Texture} value - The new texture.
		 */
		setPatternTexture(value: Texture): void;
		/**
		 * Returns the current resolution scale.
		 *
		 * @return {Number} The resolution scale.
		 * @deprecated Use resolution instead.
		 */
		getResolutionScale(): number;
		/**
		 * Sets the resolution scale.
		 *
		 * @param {Number} scale - The new resolution scale.
		 * @deprecated Use resolution instead.
		 */
		setResolutionScale(scale: number): void;
		/**
		 * Clears the current selection and selects a list of objects.
		 *
		 * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.
		 * @return {OutlineEffect} This pass.
		 * @deprecated Use selection.set() instead.
		 */
		setSelection(objects: Object3D[]): OutlineEffect;
		/**
		 * Clears the list of selected objects.
		 *
		 * @return {OutlineEffect} This pass.
		 * @deprecated Use selection.clear() instead.
		 */
		clearSelection(): OutlineEffect;
		/**
		 * Selects an object.
		 *
		 * @param {Object3D} object - The object that should be outlined.
		 * @return {OutlineEffect} This pass.
		 * @deprecated Use selection.add() instead.
		 */
		selectObject(object: Object3D): OutlineEffect;
		/**
		 * Deselects an object.
		 *
		 * @param {Object3D} object - The object that should no longer be outlined.
		 * @return {OutlineEffect} This pass.
		 * @deprecated Use selection.delete() instead.
		 */
		deselectObject(object: Object3D): OutlineEffect;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A pixelation effect.
	 *
	 * Warning: This effect cannot be merged with convolution effects.
	 */
	export class PixelationEffect extends Effect {

		/**
		 * Constructs a new pixelation effect.
		 *
		 * @param {Number} [granularity=30.0] - The pixel granularity.
		 */
		constructor(granularity?: number);
		set granularity(arg: number);
		/**
		 * The pixel granularity.
		 *
		 * A higher value yields coarser visuals.
		 *
		 * @type {Number}
		 */
		get granularity(): number;
		/**
		 * Returns the pixel granularity.
		 *
		 * @deprecated Use granularity instead.
		 * @return {Number} The granularity.
		 */
		getGranularity(): number;
		/**
		 * Sets the pixel granularity.
		 *
		 * @deprecated Use granularity instead.
		 * @param {Number} value - The new granularity.
		 */
		setGranularity(value: number): void;
		/**
		 * Updates the granularity.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

	}

	/**
	 * Depth of Field shader v2.4.
	 *
	 * Yields more realistic results but is also more demanding.
	 */
	export class RealisticBokehEffect extends Effect {

		/**
		 * Constructs a new bokeh effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.focus=1.0] - The focus distance in world units.
		 * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.
		 * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).
		 * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.
		 * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.
		 * @param {Number} [options.bias=0.5] - A blur bias.
		 * @param {Number} [options.fringe=0.7] - A blur offset.
		 * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.
		 * @param {Boolean} [options.rings=3] - The number of blur iterations.
		 * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.
		 * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.
		 * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.
		 * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.
		 */
		constructor({
			blendFunction,
			focus,
			focalLength,
			fStop,
			luminanceThreshold,
			luminanceGain,
			bias,
			fringe,
			maxBlur,
			rings,
			samples,
			showFocus,
			manualDoF,
			pentagon
		}?: {
			blendFunction?: BlendFunction;
			focus?: number;
			focalLength?: number;
			fStop?: number;
			luminanceThreshold?: number;
			luminanceGain?: number;
			bias?: number;
			fringe?: number;
			maxBlur?: number;
			rings?: boolean;
			samples?: boolean;
			showFocus?: boolean;
			manualDoF?: boolean;
			pentagon?: boolean;
		});

		set rings(arg: number);
		/**
		 * The amount of blur iterations.
		 *
		 * @type {Number}
		 */
		get rings(): number;
		set samples(arg: number);
		/**
		 * The amount of blur samples per ring.
		 *
		 * @type {Number}
		 */
		get samples(): number;
		set showFocus(arg: boolean);
		/**
		 * Indicates whether the focal point will be highlighted.
		 *
		 * @type {Boolean}
		 */
		get showFocus(): boolean;
		set manualDoF(arg: boolean);
		/**
		 * Indicates whether the Depth of Field should be calculated manually.
		 *
		 * If enabled, the Depth of Field can be adjusted via the `dof` uniform.
		 *
		 * @type {Boolean}
		 */
		get manualDoF(): boolean;
		set pentagon(arg: boolean);
		/**
		 * Indicates whether the blur shape should be pentagonal.
		 *
		 * @type {Boolean}
		 */
		get pentagon(): boolean;

	}

	/**
	 * A scanline effect.
	 *
	 */
	export class ScanlineEffect extends Effect {

		/**
		 * Constructs a new scanline effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.
		 * @param {Number} [options.density=1.25] - The scanline density.
		 */
		constructor({
			blendFunction,
			density
		}?: {
			blendFunction?: BlendFunction;
			density?: number;
		});

		set density(arg: number);
		/**
		 * The scanline density.
		 *
		 * @type {Number}
		 */
		get density(): number;
		/**
		 * Returns the current scanline density.
		 *
		 * @deprecated Use density instead.
		 * @return {Number} The scanline density.
		 */
		getDensity(): number;
		/**
		 * Sets the scanline density.
		 *
		 * @deprecated Use density instead.
		 * @param {Number} value - The new scanline density.
		 */
		setDensity(value: number): void;
		/**
		 * Updates the size of this pass.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * The scanline scroll speed. Default is 0 (disabled).
		 *
		 * @type {Number}
		 */
		get scrollSpeed(): number;
		set scrollSpeed(value: number);

	}

	/**
	 * A selective bloom effect.
	 *
	 * This effect applies bloom to selected objects only.
	 */
	export class SelectiveBloomEffect extends BloomEffect {

		/**
		 * Constructs a new selective bloom effect.
		 *
		 * @param {Scene} scene - The main scene.
		 * @param {Camera} camera - The main camera.
		 * @param {BloomEffectOptions} [options] - The options. See {@link BloomEffect} for details.
		 */
		constructor(scene?: Scene, camera?: Camera, options?: BloomEffectOptions);
		/**
		 * A selection of objects.
		 *
		 * The default layer of this selection is 11.
		 *
		 * @type {Selection}
		 */
		selection: Selection;
		/**
		 * Returns the selection.
		 *
		 * @deprecated Use selection instead.
		 * @return {Selection} The selection.
		 */
		getSelection(): Selection;
		set inverted(arg: boolean);
		/**
		 * Indicates whether the selection should be considered inverted.
		 *
		 * @type {Boolean}
		 */
		get inverted(): boolean;
		/**
		 * Indicates whether the mask is inverted.
		 *
		 * @deprecated Use inverted instead.
		 * @return {Boolean} Whether the mask is inverted.
		 */
		isInverted(): boolean;
		/**
		 * Enables or disable mask inversion.
		 *
		 * @deprecated Use inverted instead.
		 * @param {Boolean} value - Whether the mask should be inverted.
		 */
		setInverted(value: boolean): void;
		set ignoreBackground(arg: boolean);
		/**
		 * Indicates whether the background colors will be ignored.
		 *
		 * @type {Boolean}
		 */
		get ignoreBackground(): boolean;
		/**
		 * Indicates whether the background is disabled.
		 *
		 * @deprecated Use ignoreBackground instead.
		 * @return {Boolean} Whether the background is disabled.
		 */
		isBackgroundDisabled(): boolean;
		/**
		 * Enables or disables the background.
		 *
		 * @deprecated Use ignoreBackground instead.
		 * @param {Boolean} value - Whether the background should be disabled.
		 */
		setBackgroundDisabled(value: boolean): void;
		/**
		 * Sets the depth texture.
		 *
		 * @param {Texture} depthTexture - A depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
		 */
		setDepthTexture(
			depthTexture: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;

		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A sepia effect.
	 */
	export class SepiaEffect extends Effect {

		/**
		 * Constructs a new sepia effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Number} [options.intensity=1.0] - The intensity of the effect.
		 */
		constructor({
			blendFunction,
			intensity
		}?: {
			blendFunction?: BlendFunction;
			intensity?: number;
		});

		set intensity(arg: number);
		/**
		 * The intensity.
		 *
		 * @deprecated Use blendMode.opacity instead.
		 * @type {Number}
		 */
		get intensity(): number;
		/**
		 * Returns the current sepia intensity.
		 *
		 * @deprecated Use blendMode.opacity instead.
		 * @return {Number} The intensity.
		 */
		getIntensity(): number;
		/**
		 * Sets the sepia intensity.
		 *
		 * @deprecated Use blendMode.opacity instead.
		 * @param {Number} value - The intensity.
		 */
		setIntensity(value: number): void;

	}

	/**
	 * A shock wave effect.
	 */
	export class ShockWaveEffect extends Effect {

		/**
		 * Constructs a new shock wave effect.
		 *
		 * @param {Camera} camera - The main camera.
		 * @param {Vector3} [position] - The world position of the shock wave.
		 * @param {Object} [options] - The options.
		 * @param {Number} [options.speed=2.0] - The animation speed.
		 * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.
		 * @param {Number} [options.waveSize=0.2] - The wave size.
		 * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
		 */
		constructor(
			camera?: Camera,
			position?: Vector3,
			{
				speed,
				maxRadius,
				waveSize,
				amplitude
			}?: {
				speed?: number;
				maxRadius?: number;
				waveSize?: number;
				amplitude?: number;
			}
		);

		/**
		 * The position of the shock wave.
		 *
		 * @type {Vector3}
		 */
		position: Vector3;
		/**
		 * The speed of the shock wave animation.
		 *
		 * @type {Number}
		 */
		speed: number;
		set amplitude(arg: number);
		/**
		 * The amplitude.
		 *
		 * @type {Number}
		 */
		get amplitude(): number;
		set waveSize(arg: number);
		/**
		 * The wave size.
		 *
		 * @type {Number}
		 */
		get waveSize(): number;
		set maxRadius(arg: number);
		/**
		 * The maximum radius.
		 *
		 * @type {Number}
		 */
		get maxRadius(): number;
		set epicenter(arg: Vector3);
		/**
		 * The position of the shock wave.
		 *
		 * @type {Vector3}
		 * @deprecated Use position instead.
		 */
		get epicenter(): Vector3;
		/**
		 * Returns the position of the shock wave.
		 *
		 * @deprecated Use position instead.
		 * @return {Vector3} The position.
		 */
		getPosition(): Vector3;
		/**
		 * Sets the position of the shock wave.
		 *
		 * @deprecated Use position instead.
		 * @param {Vector3} value - The position.
		 */
		setPosition(value: Vector3): void;
		/**
		 * Returns the speed of the shock wave.
		 *
		 * @deprecated Use speed instead.
		 * @return {Number} The speed.
		 */
		getSpeed(): number;
		/**
		 * Sets the speed of the shock wave.
		 *
		 * @deprecated Use speed instead.
		 * @param {Number} value - The speed.
		 */
		setSpeed(value: number): void;
		/**
		 * Emits the shock wave.
		 */
		explode(): void;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [delta] - The time between the last frame and the current one in seconds.
		 */

		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			delta: number
		): void;

	}

	/**
	 * FXAAEffect
	 */
	export class FXAAEffect extends Effect {

		/**
		 * Constructs a new FXAA effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
		 */
		constructor({
			blendFunction
		}?: {
			blendFunction?: BlendFunction
		});

		/**
		 * The minimum edge detection threshold. Range is [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get minEdgeThreshold(): number;
		set minEdgeThreshold(arg: number);

		/**
		 * The maximum edge detection threshold. Range is [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get maxEdgeThreshold(): number;
		set maxEdgeThreshold(arg: number);

		/**
		 * The subpixel blend quality. Range is [0.0, 1.0].
		 *
		 * @type {Number}
		 */
		get subpixelQuality(): number;
		set subpixelQuality(arg: number);

		/**
		 * The maximum amount of edge detection samples.
		 *
		 * @type {Number}
		 */
		get samples(): number;
		set samples(arg: number);

	}

	/**
	 * Subpixel Morphological Antialiasing (SMAA).
	 */
	export class SMAAEffect extends Effect {

		/**
		 * The SMAA search image, encoded as a base64 data URL.
		 *
		 * @type {String}
		 * @deprecated
		 */
		static get searchImageDataURL(): string;
		/**
		 * The SMAA area image, encoded as a base64 data URL.
		 *
		 * @type {String}
		 * @deprecated
		 */
		static get areaImageDataURL(): string;
		/**
		 * Constructs a new SMAA effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
		 * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
		 * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
		 */
		constructor({
			preset,
			edgeDetectionMode,
			predicationMode
		}?: {
			preset?: SMAAPreset;
			edgeDetectionMode?: EdgeDetectionMode;
			predicationMode?: PredicationMode;
		});

		/**
		 * The edges texture.
		 *
		 * @type {Texture}
		 */
		get edgesTexture(): Texture;
		/**
		 * Returns the edges texture.
		 *
		 * @deprecated Use edgesTexture instead.
		 * @return {Texture} The texture.
		 */
		getEdgesTexture(): Texture;
		/**
		 * The edge weights texture.
		 *
		 * @type {Texture}
		 */
		get weightsTexture(): Texture;
		/**
		 * Returns the edge weights texture.
		 *
		 * @deprecated Use weightsTexture instead.
		 * @return {Texture} The texture.
		 */
		getWeightsTexture(): Texture;
		/**
		 * The edge detection material.
		 *
		 * @type {EdgeDetectionMaterial}
		 */
		get edgeDetectionMaterial(): EdgeDetectionMaterial;
		/**
		 * The edge detection material.
		 *
		 * @type {EdgeDetectionMaterial}
		 * @deprecated Use edgeDetectionMaterial instead.
		 */
		get colorEdgesMaterial(): EdgeDetectionMaterial;
		/**
		 * Returns the edge detection material.
		 *
		 * @deprecated Use edgeDetectionMaterial instead.
		 * @return {EdgeDetectionMaterial} The material.
		 */
		getEdgeDetectionMaterial(): EdgeDetectionMaterial;
		/**
		 * The edge weights material.
		 *
		 * @type {SMAAWeightsMaterial}
		 */
		get weightsMaterial(): SMAAWeightsMaterial;
		/**
		 * Returns the edge weights material.
		 *
		 * @deprecated Use weightsMaterial instead.
		 * @return {SMAAWeightsMaterial} The material.
		 */
		getWeightsMaterial(): SMAAWeightsMaterial;
		/**
		 * Sets the edge detection sensitivity.
		 *
		 * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
		 *
		 * @deprecated Use edgeDetectionMaterial instead.
		 * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
		 */
		setEdgeDetectionThreshold(threshold: number): void;
		/**
		 * Sets the maximum amount of horizontal/vertical search steps.
		 *
		 * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
		 *
		 * @deprecated Use weightsMaterial instead.
		 * @param {Number} steps - The search steps. Range: [0, 112].
		 */
		setOrthogonalSearchSteps(steps: number): void;
		/**
		 * Applies the given quality preset.
		 *
		 * @param {SMAAPreset} preset - The preset.
		 */
		applyPreset(preset: SMAAPreset): void;
		/**
		 * Sets the depth texture.
		 *
		 * @param {Texture} depthTexture - A depth texture.
		 * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
		 */
		setDepthTexture(
			depthTexture: Texture,
			depthPacking?: DepthPackingStrategies
		): void;

		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Updates the size of internal render targets.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * Deletes internal render targets and textures.
		 */
		dispose(): void;

	}

	/**
	 * An enumeration of SMAA presets.
	 *
	 * @type {Object}
	 * @property {Number} LOW - Results in around 60% of the maximum quality.
	 * @property {Number} MEDIUM - Results in around 80% of the maximum quality.
	 * @property {Number} HIGH - Results in around 95% of the maximum quality.
	 * @property {Number} ULTRA - Results in around 99% of the maximum quality.
	 */
	export enum SMAAPreset {
		LOW,
		MEDIUM,
		HIGH,
		ULTRA,
	}

	/**
	 * A Screen Space Ambient Occlusion (SSAO) effect.
	 *
	 */
	export class SSAOEffect extends Effect {

		/**
		 * Constructs a new SSAO effect.
		 *
		 * @todo Move normalBuffer to options.
		 * @param {Camera} [camera] - The main camera.
		 * @param {Texture} [normalBuffer] - A texture that contains the scene normals.
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.
		 * @param {Boolean} [options.distanceScaling=true] - Deprecated.
		 * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.
		 * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.
		 * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.
		 * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.
		 * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.
		 * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.
		 * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.
		 * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.
		 * @param {Number} [options.distanceThreshold=0.97] - Deprecated.
		 * @param {Number} [options.distanceFalloff=0.03] - Deprecated.
		 * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.
		 * @param {Number} [options.rangeFalloff=0.001] - Deprecated.
		 * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.
		 * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.
		 * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].
		 * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.
		 * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.
		 * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.
		 * @param {Color} [options.color=null] - The color of the ambient occlusion.
		 * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
		 * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
		 * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
		 * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
		 * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
		 */
		constructor(
			camera?: Camera,
			normalBuffer?: Texture,
			{
				blendFunction,
				distanceScaling,
				depthAwareUpsampling,
				normalDepthBuffer,
				samples,
				rings,
				worldDistanceThreshold,
				worldDistanceFalloff,
				worldProximityThreshold,
				worldProximityFalloff,
				distanceThreshold,
				distanceFalloff,
				rangeThreshold,
				rangeFalloff,
				minRadiusScale,
				luminanceInfluence,
				radius,
				intensity,
				bias,
				fade,
				color,
				resolutionScale,
				resolutionX,
				resolutionY,
				width,
				height
			}?: {
				blendFunction?: BlendFunction;
				distanceScaling?: boolean;
				depthAwareUpsampling?: boolean;
				normalDepthBuffer?: Texture;
				samples?: number;
				rings?: number;
				worldDistanceThreshold?: number;
				worldDistanceFalloff?: number;
				worldProximityThreshold?: number;
				worldProximityFalloff?: number;
				distanceThreshold?: number;
				distanceFalloff?: number;
				rangeThreshold?: number;
				rangeFalloff?: number;
				minRadiusScale?: number;
				luminanceInfluence?: number;
				radius?: number;
				intensity?: number;
				bias?: number;
				fade?: number;
				color?: Color;
				resolutionScale?: number;
				resolutionX?: number;
				resolutionY?: number;
				width?: number;
				height?: number;
			}
		);

		resolution: Resolution;
		/**
		 * Sets the normal buffer.
		 *
		 * @type {Texture}
		 */
		get normalBuffer(): Texture | null;
		set normalBuffer(value: Texture | null);
		/**
		 * Indicates whether depth-aware upsampling is enabled.
		 *
		 * @type {Boolean}
		 */
		get depthAwareUpsampling(): boolean;
		set depthAwareUpsampling(arg: boolean);
		/**
		 * The color of the ambient occlusion. Set to `null` to disable.
		 *
		 * @type {Color}
		 */
		get color(): Color;
		set color(arg: Color);
		/**
		 * Returns the resolution settings.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Resolution} The resolution.
		 */
		getResolution(): Resolution;
		/**
		 * The SSAO material.
		 *
		 * @type {SSAOMaterial}
		 */
		get ssaoMaterial(): SSAOMaterial;
		/**
		 * Returns the SSAO material.
		 *
		 * @deprecated Use ssaoMaterial instead.
		 * @return {SSAOMaterial} The material.
		 */
		getSSAOMaterial(): SSAOMaterial;
		/**
		 * The amount of occlusion samples per pixel.
		 *
		 * @type {Number}
		 * @deprecated Use ssaoMaterial.samples instead.
		 */
		get samples(): number;
		set samples(arg: number);
		/**
		 * The amount of spiral turns in the occlusion sampling pattern.
		 *
		 * @type {Number}
		 * @deprecated Use ssaoMaterial.rings instead.
		 */
		get rings(): number;
		set rings(arg: number);
		/**
		 * The occlusion sampling radius.
		 *
		 * @type {Number}
		 * @deprecated Use ssaoMaterial.radius instead.
		 */
		get radius(): number;
		set radius(arg: number);
		/**
		 * The intensity.
		 *
		 * @type {Number}
		 */
		get intensity(): number;
		set intensity(arg: number);
		/**
		 * Indicates whether depth-aware upsampling is enabled.
		 *
		 * @deprecated Use depthAwareUpsampling instead.
		 * @return {Boolean} Whether depth-aware upsampling is enabled.
		 */
		isDepthAwareUpsamplingEnabled(): boolean;
		/**
		 * Enables or disables depth-aware upsampling.
		 *
		 * @deprecated Use depthAwareUpsampling instead.
		 * @param {Boolean} value - Whether depth-aware upsampling should be enabled.
		 */
		setDepthAwareUpsamplingEnabled(value: boolean): void;
		/**
		 * Indicates whether distance-based radius scaling is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated Use ssaoMaterial.distanceScaling instead.
		 */
		get distanceScaling(): boolean;
		set distanceScaling(arg: boolean);
		/**
		 * Returns the color of the ambient occlusion.
		 *
		 * @deprecated Use color instead.
		 * @return {Color} The color.
		 */
		getColor(): Color;
		/**
		 * Sets the color of the ambient occlusion. Set to `null` to disable colorization.
		 *
		 * @deprecated Use color instead.
		 * @param {Color} value - The color.
		 */
		setColor(value: Color): void;
		/**
		 * Sets the occlusion distance cutoff.
		 *
		 * @deprecated Use ssaoMaterial instead.
		 * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
		 * @param {Number} falloff - The falloff. Range [0.0, 1.0].
		 */
		setDistanceCutoff(threshold: number, falloff: number): void;
		/**
		 * Sets the occlusion proximity cutoff.
		 *
		 * @deprecated Use ssaoMaterial instead.
		 * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].
		 * @param {Number} falloff - The falloff. Range [0.0, 1.0].
		 */
		setProximityCutoff(threshold: number, falloff: number): void;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;
		/**
		 * Sets the size.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 */
		setSize(width: number, height: number): void;
		/**
		 * The luminance influence factor. Range: [0.0, 1.0].
		 *
		 * @type {Boolean}
		 */
		get luminanceInfluence(): boolean;
		set luminanceInfluence(value: boolean);

	}

	/**
	 * A texture effect.
	 */
	export class TextureEffect extends Effect {

		/**
		 * Constructs a new texture effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Texture} [options.texture] - A texture.
		 * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.
		 */
		constructor({
			blendFunction,
			texture,
			aspectCorrection
		}?: {
			blendFunction?: BlendFunction;
			texture?: Texture;
			aspectCorrection?: boolean;
		});

		set texture(arg: Texture);
		/**
		 * The texture.
		 *
		 * @type {Texture}
		 */
		get texture(): Texture;
		set aspectCorrection(arg: number);
		/**
		 * Indicates whether aspect correction is enabled.
		 *
		 * @type {Number}
		 * @deprecated Adjust the texture's offset, repeat, rotation and center instead.
		 */
		get aspectCorrection(): number;
		/**
		 * Returns the texture.
		 *
		 * @deprecated Use texture instead.
		 * @return {Texture} The texture.
		 */
		getTexture(): Texture;
		/**
		 * Sets the texture.
		 *
		 * @deprecated Use texture instead.
		 * @param {Texture} value - The texture.
		 */
		setTexture(value: Texture): void;
		set uvTransform(arg: boolean);
		/**
		 * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.
		 *
		 * @type {Boolean}
		 * @deprecated Use texture.matrixAutoUpdate instead.
		 */
		get uvTransform(): boolean;
		/**
		 * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.
		 *
		 * @param {ColorChannel} r - The swizzle for the `r` component.
		 * @param {ColorChannel} [g=r] - The swizzle for the `g` component.
		 * @param {ColorChannel} [b=r] - The swizzle for the `b` component.
		 * @param {ColorChannel} [a=r] - The swizzle for the `a` component.
		 */
		setTextureSwizzleRGBA(
			r: ColorChannel,
			g?: ColorChannel,
			b?: ColorChannel,
			a?: ColorChannel
		): void;

		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */

		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime: number
		): void;

		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */

		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * A tone mapping mode enumeration.
	 *
	 * @type {Object}
	 * @property {Number} LINEAR - No tone mapping, only exposure.
	 * @property {Number} REINHARD - Simple Reinhard tone mapping.
	 * @property {Number} REINHARD2 - Modified Reinhard tone mapping.
	 * @property {Number} REINHARD2_ADAPTIVE - Simulates the optic nerve responding to the amount of light it is receiving.
	 * @property {Number} UNCHARTED2 - Uncharted 2 tone mapping. 
	 * @property {Number} OPTIMIZED_CINEON - Optimized filmic operator by Jim Hejl and Richard Burgess-Dawson.
	 * @property {Number} ACES_FILMIC - ACES tone mapping with a scale of 1.0/0.6.
	 * @property {Number} AGX - Filmic tone mapping. Requires three r160 or higher. 
	 * @property {Number} NEUTRAL - Neutral tone mapping by Khronos. Requires three r162 or higher. 
	 */
	export enum ToneMappingMode {
		LINEAR,
		REINHARD,
		REINHARD2,
		REINHARD2_ADAPTIVE,
		UNCHARTED2,
		OPTIMIZED_CINEON,
		ACES_FILMIC,
		AGX,
		NEUTRAL
	}

	/**
	 * A tone mapping effect.
	 */
	export class ToneMappingEffect extends Effect {

		/**
		 * Constructs a new tone mapping effect.
		 *
		 * The additional parameters only affect the Reinhard2 operator.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.
		 * @param {ToneMappingMode} [options.mode=ToneMappingMode.ACES_FILMIC] - The tone mapping mode.
		 * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.
		 * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.
		 * @param {Number} [options.whitePoint=4.0] - The white point.
		 * @param {Number} [options.middleGrey=0.6] - The middle grey factor.
		 * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.
		 * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.
		 * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.
		 */
		constructor({
			blendFunction,
			adaptive,
			mode,
			resolution,
			maxLuminance,
			whitePoint,
			middleGrey,
			minLuminance,
			averageLuminance,
			adaptationRate
		}?: {
			blendFunction?: BlendFunction;
			adaptive?: boolean;
			mode?: ToneMappingMode;
			resolution?: number;
			maxLuminance?: number;
			whitePoint?: number;
			middleGrey?: number;
			minLuminance?: number;
			averageLuminance?: number;
			adaptationRate?: number;
		});

		set resolution(arg: number);
		/**
		 * The resolution of the luminance texture. Must be a power of two.
		 *
		 * @type {Number}
		 */
		get resolution(): number;
		set mode(arg: ToneMappingMode);
		/**
		 * The tone mapping mode.
		 *
		 * @type {ToneMappingMode}
		 */
		get mode(): ToneMappingMode;
		/**
		 * The white point. Default is `16.0`.
		 *
		 * Only applies to Reinhard2 (Modified & Adaptive).
		 *
		 * @type {Number}
		 */
		get whitePoint(): number;
		/**
		 * The middle grey factor. Default is `0.6`.
		 *
		 * Only applies to Reinhard2 (Modified & Adaptive).
		 *
		 * @type {Number}
		 */
		get middleGrey(): number;
		/**
		 * The average luminance.
		 *
		 * Only applies to Reinhard2 (Modified).
		 *
		 * @type {Number}
		 */
		get averageLuminance(): number;
		/**
		 * Returns the current tone mapping mode.
		 *
		 * @deprecated Use mode instead.
		 * @return {ToneMappingMode} The tone mapping mode.
		 */
		getMode(): ToneMappingMode;
		/**
		 * Sets the tone mapping mode.
		 *
		 * @deprecated Use mode instead.
		 * @param {ToneMappingMode} value - The tone mapping mode.
		 */
		setMode(value: ToneMappingMode): void;
		/**
		 * The adaptive luminance material.
		 *
		 * @type {AdaptiveLuminanceMaterial}
		 */
		get adaptiveLuminanceMaterial(): AdaptiveLuminanceMaterial;
		/**
		 * Returns the adaptive luminance material.
		 *
		 * @deprecated Use adaptiveLuminanceMaterial instead.
		 * @return {AdaptiveLuminanceMaterial} The material.
		 */
		getAdaptiveLuminanceMaterial(): AdaptiveLuminanceMaterial;
		/**
		 * Returns the resolution of the luminance texture.
		 *
		 * @deprecated Use resolution instead.
		 * @return {Number} The resolution.
		 */
		getResolution(): number;
		/**
		 * Sets the resolution of the luminance texture. Must be a power of two.
		 *
		 * @deprecated Use resolution instead.
		 * @param {Number} value - The resolution.
		 */
		setResolution(value: number): void;
		set adaptive(arg: boolean);
		/**
		 * Indicates whether this pass uses adaptive luminance.
		 *
		 * @type {Boolean}
		 * @deprecated Use mode instead.
		 */
		get adaptive(): boolean;
		set adaptationRate(arg: number);
		/**
		 * The luminance adaptation rate.
		 *
		 * @type {Number}
		 * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.
		 */
		get adaptationRate(): number;
		set distinction(arg: number);
		/**
		 * @type {Number}
		 * @deprecated
		 */
		get distinction(): number;
		/**
		 * Updates this effect.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
		 * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
		 */
		update(
			renderer: WebGLRenderer,
			inputBuffer: WebGLRenderTarget,
			deltaTime?: number
		): void;

		/**
		 * Performs initialization tasks.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
		 * @param {Number} frameBufferType - The type of the main frame buffers.
		 */
		initialize(
			renderer: WebGLRenderer,
			alpha: boolean,
			frameBufferType: number
		): void;

	}

	/**
	 * An enumeration of Vignette techniques.
	 *
	 * @type {Object}
	 * @property {Number} DEFAULT - Produces a dusty look.
	 * @property {Number} ESKIL - Produces a burned look.
	 */
	export enum VignetteTechnique {
		DEFAULT,
		ESKIL,
	}
	/**
	 * A Vignette effect.
	 */
	export class VignetteEffect extends Effect {

		/**
		 * Constructs a new Vignette effect.
		 *
		 * @param {Object} [options] - The options.
		 * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
		 * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.
		 * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.
		 * @param {Number} [options.offset=0.5] - The Vignette offset.
		 * @param {Number} [options.darkness=0.5] - The Vignette darkness.
		 */
		constructor({
			blendFunction,
			technique,
			eskil,
			offset,
			darkness
		}?: {
			blendFunction?: BlendFunction;
			technique?: VignetteTechnique;
			eskil?: boolean;
			offset?: number;
			darkness?: number;
		});

		set technique(arg: VignetteTechnique);
		/**
		 * The Vignette technique.
		 *
		 * @type {VignetteTechnique}
		 */
		get technique(): VignetteTechnique;
		/**
		 * Indicates whether Eskil's Vignette technique is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated Use technique instead.
		 */
		set eskil(arg: boolean);
		/**
		 * Indicates whether Eskil's Vignette technique is enabled.
		 *
		 * @type {Boolean}
		 * @deprecated Use technique instead.
		 */
		get eskil(): boolean;
		/**
		 * Returns the Vignette technique.
		 *
		 * @deprecated Use technique instead.
		 * @return {VignetteTechnique} The technique.
		 */
		getTechnique(): VignetteTechnique;
		/**
		 * Sets the Vignette technique.
		 *
		 * @deprecated Use technique instead.
		 * @param {VignetteTechnique} value - The technique.
		 */
		setTechnique(value: VignetteTechnique): void;
		set offset(arg: number);
		/**
		 * The Vignette offset.
		 *
		 * @type {Number}
		 */
		get offset(): number;
		/**
		 * Returns the Vignette offset.
		 *
		 * @deprecated Use offset instead.
		 * @return {Number} The offset.
		 */
		getOffset(): number;
		/**
		 * Sets the Vignette offset.
		 *
		 * @deprecated Use offset instead.
		 * @param {Number} value - The offset.
		 */
		setOffset(value: number): void;
		set darkness(arg: number);
		/**
		 * The Vignette darkness.
		 *
		 * @type {Number}
		 */
		get darkness(): number;
		/**
		 * Returns the Vignette darkness.
		 *
		 * @deprecated Use darkness instead.
		 * @return {Number} The darkness.
		 */
		getDarkness(): number;
		/**
		 * Sets the Vignette darkness.
		 *
		 * @deprecated Use darkness instead.
		 * @param {Number} value - The darkness.
		 */
		setDarkness(value: number): void;

	}

	/**
	 * An enumeration of LUT worker operations.
	 *
	 * @type {Object}
	 * @property {String} SCALE_UP - Tetrahedral upscale operation.
	 */
	export enum LUTOperation {
		SCALE_UP = "lut.scaleup",
	}

	/**
	 * A tetrahedral upscaler that can be used to augment 3D LUTs.
	 *
	 */
	export class TetrahedralUpscaler {

		/**
		 * Expands the given data to the target size.
		 *
		 * @param {ArrayBufferView} data - The input RGBA data. Assumed to be cubic.
		 * @param {Number} size - The target size.
		 * @return {ArrayBufferView} The new data.
		 */
		static expand(data: ArrayBufferView, size: number): ArrayBufferView;

	}

	/**
	 * SMAA area image data.
	 *
	 * This texture allows to obtain the area for a certain pattern and distances to the left and right of identified lines.
	 *
	 */
	export class SMAAAreaImageData {

		/**
		 * Creates a new area image.
		 *
		 * @return {RawImageData} The generated image data.
		 */
		static generate(): RawImageData;

	}

	/**
	 * An SMAA image generator.
	 *
	 * This class uses a worker thread to generate the search and area images. The generated data URLs will be cached using
	 * localStorage, if available. To disable caching use {@link SMAAImageGenerator.setCacheEnabled}.
	 */
	export class SMAAImageGenerator {

		/**
		 * Indicates whether data image caching is disabled.
		 *
		 * @type {Boolean}
		 * @deprecated Use setCacheEnabled() instead.
		 */
		disableCache: boolean;
		/**
		 * Enables or disables caching via localStorage.
		 *
		 * @param {Boolean} value - Whether the cache should be enabled.
		 */
		setCacheEnabled(value: boolean): void;
		/**
		 * Generates the SMAA data images.
		 *
		 * @example
		 * SMAAImageGenerator.generate().then(([search, area]) => {
		 *		const smaaEffect = new SMAAEffect(search, area);
		 * });
		 * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.
		 */
		generate(): Promise<
		(new (width?: number, height?: number) => HTMLImageElement)[]
		>;

	}

	/**
	 * SMAA search image data.
	 *
	 * This image stores information about how many pixels the line search algorithm must advance in the last step.
	 */
	export class SMAASearchImageData {

		/**
		 * Creates a new search image.
		 *
		 * @return {RawImageData} The generated image data.
		 */
		static generate(): RawImageData;

	}

	/**
	 * A 3D lookup texture (LUT).
	 *
	 * This texture can be used as-is in a WebGL 2 context. It can also be converted into a 2D texture.
	 */
	export class LookupTexture extends Data3DTexture {

		/**
		 * Creates a new 3D LUT by copying a given LUT.
		 *
		 * Common image-based textures will be converted into 3D data textures.
		 *
		 * @param {Texture} texture - The LUT. Assumed to be cubic.
		 * @return {LookupTexture} A new 3D LUT.
		 */
		static from(texture: Texture): LookupTexture;
		/**
		 * Creates a neutral 3D LUT.
		 *
		 * @param {Number} size - The sidelength.
		 * @return {LookupTexture} A neutral 3D LUT.
		 */
		static createNeutral(size: number): LookupTexture;
		/**
		 * Constructs a cubic 3D lookup texture.
		 *
		 * @param {TypedArray} data - The pixel data. The default format is RGBA.
		 * @param {Number} size - The sidelength.
		 */
		constructor(data: ArrayBufferView, size: number);
		/**
		 * The lower bounds of the input domain.
		 *
		 * @type {Vector3}
		 */
		domainMin: Vector3;
		/**
		 * The upper bounds of the input domain.
		 *
		 * @type {Vector3}
		 */
		domainMax: Vector3;
		/**
		 * Indicates that this is an instance of LookupTexture3D.
		 *
		 * @type {Boolean}
		 * @deprecated
		 */
		get isLookupTexture3D(): boolean;
		/**
		 * Scales this LUT up to a given target size using tetrahedral interpolation.
		 *
		 * @param {Number} size - The target sidelength.
		 * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.
		 * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.
		 */
		scaleUp(size: number, transferData?: boolean): Promise<LookupTexture>;
		/**
		 * Applies the given LUT to this one.
		 *
		 * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.
		 * @return {LookupTexture} This texture.
		 */
		applyLUT(lut: LookupTexture): LookupTexture;
		/**
		 * Converts the LUT data into unsigned byte data.
		 *
		 * This is a lossy operation which should only be performed after all other transformations have been applied.
		 *
		 * @return {LookupTexture} This texture.
		 */
		convertToUint8(): LookupTexture;
		/**
		 * Converts the LUT data into float data.
		 *
		 * @return {LookupTexture} This texture.
		 */
		convertToFloat(): LookupTexture;
		/**
		 * Converts this LUT into RGBA data.
		 *
		 * @deprecated LUTs are RGBA by default since three r137.
		 * @return {LookupTexture} This texture.
		 */
		convertToRGBA(): LookupTexture;
		/**
		 * Converts the output of this LUT into sRGB color space.
		 *
		 * @return {LookupTexture} This texture.
		 */
		convertLinearToSRGB(): LookupTexture;
		/**
		 * Converts the output of this LUT into linear color space.
		 *
		 * @return {LookupTexture} This texture.
		 */
		convertSRGBToLinear(): LookupTexture;
		/**
		 * Converts this LUT into a 2D data texture.
		 *
		 * Please note that custom input domains are not carried over to 2D textures.
		 *
		 * @return {DataTexture} The texture.
		 */
		toDataTexture(): DataTexture;

	}

	export type LookupTexture3D = LookupTexture;

	/**
	 * A simple noise texture.
	 */
	export class NoiseTexture extends DataTexture {

		/**
		 * Constructs a new noise texture.
		 *
		 * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and
		 * `RGFormat` can be used in a WebGL 2 context.
		 *
		 * @param {Number} width - The width.
		 * @param {Number} height - The height.
		 * @param {Number} [format=LuminanceFormat] - The texture format.
		 * @param {Number} [type=UnsignedByteType] - The texture type.
		 */
		constructor(width: number, height: number, format?: number, type?: number);

	}

	/**
	 * A container for raw RGBA image data.
	 *
	 * @implements {ImageData}
	 */
	export class RawImageData implements ImageData {

		/**
		 * Creates a new image data container.
		 *
		 * @param {ImageData|Image} image - An image or plain image data.
		 * @return {RawImageData} The image data.
		 */
		static from(
			image:
			| ImageData
			| (new (width?: number, height?: number) => HTMLImageElement)
		): RawImageData;

		/**
		 * Constructs a new image data container.
		 *
		 * @param {Number} [width=0] - The width of the image.
		 * @param {Number} [height=0] - The height of the image.
		 * @param {Uint8ClampedArray} [data=null] - The image data.
		 */
		constructor(width?: number, height?: number, data?: Uint8ClampedArray);
        colorSpace: PredefinedColorSpace;
		/**
		 * The width of the image.
		 *
		 * @type {Number}
		 */
		width: number;
		/**
		 * The height of the image.
		 *
		 * @type {Number}
		 */
		height: number;
		/**
		 * The RGBA image data.
		 *
		 * @type {Uint8ClampedArray}
		 */
		data: Uint8ClampedArray;
		/**
		 * Creates a canvas from this image data.
		 *
		 * @return {HTMLCanvasElement} The canvas, or null if it couldn't be created.
		 */
		toCanvas(): HTMLCanvasElement;

	}

	/**
	 * An SMAA image loader.
	 *
	 * @experimental Added for testing, API might change in patch or minor releases. Requires three >= r108.
	 */
	export class SMAAImageLoader extends Loader {

		/**
		 * Loads the SMAA data images.
		 *
		 * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.
		 * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.
		 * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.
		 */
		load(
			url?: string | null,
			onLoad?: Function,
			onError?: Function
		): Promise<(new (width?: number, height?: number) => HTMLImageElement)[]>;

	}

	/**
	 * A 3D LUT loader that supports the .cube file format.
	 */
	export class LUTCubeLoader extends Loader {

		/**
		 * Loads a LUT.
		 *
		 * @param {String} url - The URL of the CUBE-file.
		 * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
		 * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
		 * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
		 * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
		 */
		load(
			url: string,
			onLoad?: Function,
			onProgress?: Function,
			onError?: Function
		): Promise<LookupTexture>;

		/**
		 * Parses the given data.
		 *
		 * @param {String} input - The LUT data.
		 * @return {LookupTexture} The lookup texture.
		 * @throws {Error} Fails if the data is invalid.
		 */
		parse(input: string): LookupTexture;

	}

	/**
	 * A 3D LUT loader that supports the .3dl file format.
	*/
	export class LUT3dlLoader extends Loader {

		/**
		 * Loads a LUT.
		 *
		 * @param {String} url - The URL of the 3dl-file.
		 * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.
		 * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.
		 * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.
		 * @return {Promise<LookupTexture>} A promise that returns the lookup texture.
		 */
		load(
			url: string,
			onLoad?: Function,
			onProgress?: Function,
			onError?: Function
		): Promise<LookupTexture>;

		/**
		 * Parses the given data.
		 *
		 * @param {String} input - The LUT data.
		 * @return {LookupTexture} The lookup texture.
		 * @throws {Error} Fails if the data is invalid.
		 */
		parse(input: string): LookupTexture;

	}

	/**
	 * Determines the texture inline decoding.
	 *
	 * @param {Texture} texture - A texture.
	 * @param {Boolean} isWebGL2 - Whether the context is WebGL 2.
	 * @return {String} The decoding.
	 * @ignore
	 */
	export function getTextureDecoding(
		texture: Texture,
		isWebGL2: boolean
	): string;

	/**
	 * Converts orthographic depth to view Z.
	 *
	 * @param {Number} depth - The linear clip Z.
	 * @param {Number} near - The camera near plane.
	 * @param {Number} far - The camera far plane.
	 * @return {Number} The view Z.
	 * @ignore
	 */
	export function orthographicDepthToViewZ(
		depth: number,
		near: number,
		far: number
	): number;

	/**
	 * Converts view Z to orthographic depth.
	 *
	 * @param {Number} viewZ - The view Z. Expected to be negative.
	 * @param {Number} near - The camera near plane.
	 * @param {Number} far - The camera far plane.
	 * @return {Number} The depth.
	 * @ignore
	 */
	export function viewZToOrthographicDepth(
		viewZ: number,
		near: number,
		far: number
	): number;

	/**
	 * A lens distortion effect.
	 *
	 */

	export class LensDistortionEffect extends Effect {

		/**
		* Constructs a new lens distortion effect.
		*
		* @param {Object} [options] - The options.
		* @param {Vector2} [options.distortion] - The distortion value.
		* @param {Vector2} [options.principalPoint] - The center point.
		* @param {Vector2} [options.focalLength] - The focal length.
		* @param {Number} [options.skew=0] - The skew value.
		*/

		constructor({
			distortion,
			principalPoint,
			focalLength,
			skew
		}?: {
			distortion: Vector2;
			principalPoint: Vector2;
			focalLength: Vector2;
			skew?: number;
		});

		/**
		 * The radial distortion coefficients. Default is (0, 0).
		 *
		 * @type {Vector2}
		 */

		get distortion(): Vector2;
		set distortion(value: Vector2);

		/**
		 * The principal point. Default is (0, 0).
		 *
		 * @type {Vector2}
		 */

		get principalPoint(): Vector2;
		set principalPoint(value: Vector2);

		/**
		 * The focal length. Default is (1, 1).
		 *
		 * @type {Vector2}
		 */

		get focalLength(): Vector2;
		set focalLength(value: Vector2);

		/**
		 * The skew factor in radians.
		 *
		 * @type {Number}
		 */

		get skew(): number;
		set skew(value: number);

	}


export  const __buildDate: any;

export  const __buildVerNo: any;

export  const __buildVersion: any;

export  const __DEV: any;

/**
 * Axis aligned bounding box class.
 */
 class AABB {
    /**
     * The lower bound of the bounding box
     */
    lowerBound: Vec3;
    /**
     * The upper bound of the bounding box
     */
    upperBound: Vec3;
    constructor(options?: {
        /**
         * The lower bound of the bounding box
         */
        upperBound?: Vec3;
        /**
         * The upper bound of the bounding box
         */
        lowerBound?: Vec3;
    });
    /**
     * Set the AABB bounds from a set of points.
     * @param points An array of Vec3's.
     * @return The self object
     */
    setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion_2, skinSize?: number): AABB;
    /**
     * Copy bounds from an AABB to this AABB
     * @param aabb Source to copy from
     * @return The this object, for chainability
     */
    copy(aabb: AABB): AABB;
    /**
     * Clone an AABB
     */
    clone(): AABB;
    /**
     * Extend this AABB so that it covers the given AABB too.
     */
    extend(aabb: AABB): void;
    /**
     * Returns true if the given AABB overlaps this AABB.
     */
    overlaps(aabb: AABB): boolean;
    volume(): number;
    /**
     * Returns true if the given AABB is fully contained in this AABB.
     */
    contains(aabb: AABB): boolean;
    getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void;
    /**
     * Get the representation of an AABB in another frame.
     * @return The "target" AABB object.
     */
    toLocalFrame(frame: Transform, target: AABB): AABB;
    /**
     * Get the representation of an AABB in the global frame.
     * @return The "target" AABB object.
     */
    toWorldFrame(frame: Transform, target: AABB): AABB;
    /**
     * Check if the AABB is hit by a ray.
     */
    overlapsRay(ray: Ray_2): boolean;
}

 type AbortCallback = () => void;

/**
 * Returns the number which is larger in absolute value.
 * @param a
 * @param b
 *
 * @category Maths
 */
export  function absMax(a: number, b: number): number;

export  class AbstractDecoratorBehavior extends Behavior {
    protected __source: Behavior;
    constructor();
    /**
     *
     * @return {Behavior}
     */
    getSource(): Behavior;
    /**
     *
     * @param {Behavior} source
     */
    setSource(source: Behavior): void;
    initialize(context: BehaviorContext): void;
    finalize(): void;
}

export  function acceleratedRaycast(raycaster: any, intersects: any): void;

 function acceleratedRaycast_2(raycaster: Raycaster, intersects: Array<Intersection>): void;

 const ACTION: Readonly<{
    readonly NONE: 0;
    readonly ROTATE: 1;
    readonly TRUCK: 2;
    readonly OFFSET: 4;
    readonly DOLLY: 8;
    readonly ZOOM: 16;
    readonly TOUCH_ROTATE: 32;
    readonly TOUCH_TRUCK: 64;
    readonly TOUCH_OFFSET: 128;
    readonly TOUCH_DOLLY: 256;
    readonly TOUCH_ZOOM: 512;
    readonly TOUCH_DOLLY_TRUCK: 1024;
    readonly TOUCH_DOLLY_OFFSET: 2048;
    readonly TOUCH_DOLLY_ROTATE: 4096;
    readonly TOUCH_ZOOM_TRUCK: 8192;
    readonly TOUCH_ZOOM_OFFSET: 16384;
    readonly TOUCH_ZOOM_ROTATE: 32768;
}>;

 type ACTION = number;

export  class ActionBehavior extends Behavior {
    #private;
    __action: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined;
    __context: any;
    /**
     *
     * @param {function(timeDelta:number)} func
     */
    constructor(func: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined, options?: {
        context?: any;
        isRepeat?: boolean;
    });
    tick(timeDelta: number): BehaviorStatus;
}

export  class Adapter {
    node: Node_2;
    isInput: boolean;
    paramIndex: number;
    type: NodeValueType;
    inputs: (Wire | undefined)[];
    outputs: Wire[][];
    constructor(type: NodeValueType, isInput: boolean, node: Node_2, paramIndex: number);
}

/**
 * 
 */
 function add<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

 const ADDITION: CSGOperation;

export  class AddObject3DCommand extends BaseCommand {
    private object;
    constructor(object: Object3D);
    execute(): void;
    undo(): void;
    redo(): void;
}

/**
 * disposedispose
 * resource 
 * count 1
 */
export  function addResourceRefCount(resource: Object3D | Material | Material[] | Texture | WebGLRenderTarget, count?: number): void;

/**
 * .
 * :
 *   `strategy`:  JavaScript `inject``eval` `href`.
 *   `injectLocation`:  `document.querySelector`  `head`.
 *   `async`: 
 *   `src`: 
 * @method
 * @async
 * @param {typeof defaultOptions |  Array<typeof defaultOptions>} scripts - Options for a script
 * @return {Promise<void>}
 * @example
 * // you can add multiple loads
 * awit addScript([{
 *  src: "https://code.jquery.com/jquery-3.5.0.js"
 * }, {
 *  src: "https://code.jquery.com/jquery-3.2.0.js",
 *  async: true
 * }, {
 *  src: "https://code.jquery.com/jquery-3.3.0.js",
 *  async: true,
 *  injectLocation: '#main div.test',
 * }, {
 *  src: "https://code.jquery.com/jquery-3.4.0.js",
 *  strategy: 'eval',
 * }, {
 * // link tag
 * // css autodetected
 *  src: "https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap-grid.min.css",
 * }])
 */
export  function addScript(scripts: ScriptDefaultOptions | ScriptDefaultOptions[]): Promise<unknown[]>;

/**
 * Decrypts ciphertext encrypted with aesGcmEncrypt() using supplied password.
 *                                                                      (c) Chris Veness MIT Licence
 *
 * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
 * Modified to work with Uint8Array and string content.
 *
 * @param ciphertext - Ciphertext to be decrypted.
 * @param password - Password to use to decrypt ciphertext.
 * @returns Decrypted content. If ciphertext is a string, the plaintext is a string. If ciphertext is a Uint8Array, the plaintext is a new Uint8Array.
 *
 * @example
 *   const plaintext = await aesGcmDecrypt(ciphertext, 'pw');
 *   aesGcmDecrypt(ciphertext, 'pw').then(function(plaintext) { console.log(plaintext); });
 *
 * @category Encryption
 */
export  function aesGcmDecrypt<T extends string | Uint8Array>(ciphertext: T, password: string | Uint8Array): Promise<T>;

/**
 * Encrypts plaintext using AES-GCM with supplied password, for decryption with aesGcmDecrypt().
 *                                                                      (c) Chris Veness MIT Licence
 * https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
 * Modified to work with Uint8Array and string content.
 *
 * @param content - Plaintext or Uint8 Buffer to be encrypted.
 * @param password - Plaintext or Uint8 Buffer Password to use to encrypt content.
 * @param prefix - Optional prefix to prepend to the ciphertext.
 * @returns Encrypted ciphertext. If content is a string, the ciphertext is a string. If content is a Uint8Array, the ciphertext is a new Uint8Array.
 *
 *
 * @example
 *   const ciphertext = await aesGcmEncrypt('my secret text', 'pw');
 *   aesGcmEncrypt('my secret text', 'pw').then(function(ciphertext) { console.log(ciphertext); });
 *
 * @category Encryption
 */
export  function aesGcmEncrypt<T extends string | Uint8Array>(content: T, password: string | Uint8Array, prefix?: string | Uint8Array): Promise<T>;

 namespace AlgorithmPluginType {
    export {
        getTriangleDefinitions,
        logTriangleDefinitions,
        generateRandomTriangleColors,
        computeMeshVolume,
        createProjectionTask,
        computeBoundsTree_2 as computeBoundsTree,
        disposeBoundsTree_2 as disposeBoundsTree,
        acceleratedRaycast_2 as acceleratedRaycast,
        estimateMemoryInBytes,
        getBVHExtremes,
        validateBounds,
        getJSONStructure,
        getTriangleHitPointInfo,
        mergeGeometries,
        mergeAttributes,
        interleaveAttributes,
        estimateBytesUsed,
        mergeVertices,
        toTrianglesDrawMode,
        computeMorphedAttributes,
        computeMikkTSpaceTangents,
        mergeGroups,
        toCreasedNormals,
        Brush,
        TypedAttributeData,
        CSGOperation,
        ADDITION,
        SUBTRACTION,
        REVERSE_SUBTRACTION,
        INTERSECTION,
        DIFFERENCE,
        HOLLOW_SUBTRACTION,
        HOLLOW_INTERSECTION,
        Evaluator,
        Operation,
        OperationGroup,
        CullableTriangle,
        TrianglePool,
        TriangleSplitter,
        HalfEdgeMap,
        GridMaterial,
        TriangleSetHelper,
        EdgesHelper,
        TriangleIntersectData,
        TriangleIntersectionSets,
        OperationDebugData,
        PointsHelper,
        HalfEdgeHelper,
        ProjectionGenerator,
        SilhouetteGenerator,
        SplitStrategy,
        CENTER,
        AVERAGE,
        SAH,
        ShapecastIntersection,
        NOT_INTERSECTED,
        INTERSECTED,
        CONTAINED,
        HitPointInfo,
        MeshBVHOptions,
        MeshBVHSerializeOptions,
        MeshBVHDeserializeOptions,
        MeshBVH,
        SerializedBVH,
        MeshBVHHelper,
        ExtremeInfo,
        TreeNode,
        HitTriangleInfo,
        MeshBVHUniformStruct,
        shaderStructs,
        shaderFunctions,
        ExtendedTriangle,
        OrientedBox,
        StaticGeometryGenerator,
        Delatin
    }
}
export { AlgorithmPluginType }

/**
 * Make two bezier arrays aligns on structure. To have better animation.
 *
 * It will:
 * Make two bezier arrays have same number of subpaths.
 * Make each subpath has equal number of bezier curves.
 *
 * array is the convert result of pathToBezierCurves.
 */
 function alignBezierCurves(array1: number[][], array2: number[][]): any[][];

export  type AllowedTypes = number | Vector3 | Quaternion | Euler | ColorRepresentation;

export  type Anchor = 'center' /**  */ | 'top' /**  */ | 'bottom' /**  */ | 'left' /**  */ | 'right' /**  */ | 'top-left' /**  */ | 'top-right' /**  */ | 'bottom-left' /**  */ | 'bottom-right';

export  type Anchor3d = "default" /**  */ | 'front-center' /** - */ | 'front-top' /** - */ | 'front-bottom' /** - */ | 'front-left' /** - */ | 'front-right' /** - */ | 'front-top-left' /** - */ | 'front-top-right' /** - */ | 'front-bottom-left' /** - */ | 'front-bottom-right' /** - */ | 'middle-center' /** - */ | 'middle-top' /** - */ | 'middle-bottom' /** - */ | 'middle-left' /** - */ | 'middle-right' /** - */ | 'middle-top-left' /** - */ | 'middle-top-right' /** - */ | 'middle-bottom-left' /** - */ | 'middle-bottom-right' /** - */ | 'back-center' /** - */ | 'back-top' /** - */ | 'back-bottom' /** - */ | 'back-left' /** - */ | 'back-right' /** - */ | 'back-top-left' /** - */ | 'back-top-right' /** - */ | 'back-bottom-left' /** - */ | 'back-bottom-right';

export  const anchorOrigin: {
    center: string;
    top: string;
    'top-left': string;
    'top-right': string;
    bottom: string;
    'bottom-left': string;
    'bottom-right': string;
    left: string;
    right: string;
};

export  const anchorTranslate: {
    center: string;
    top: string;
    'top-left': string;
    'top-right': string;
    bottom: string;
    'bottom-left': string;
    'bottom-right': string;
    left: string;
    right: string;
};

export  class AnimateMarkerBase {
    protected options: AnimateMarkerLayerOption;
    protected markersElement: any;
    protected features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    };
    constructor(features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setFeatures(features: FeatureCollection): void;
    getMarkersElement(): any;
    getElement(index?: number): any;
    getPosition(index?: number): any;
    createMarker2d(options?: Marker2dOptions, index?: number): Marker2D;
    createMarker3d(options?: Marker3dOptions, index?: number): Marker3D;
    setMarkersTextField(textField: string): void;
    setMarkersText(text: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    protected _getColorWithOpacity(color: string, opacity: string | number): string;
    protected _getTextContainer(feature: any, className: string): HTMLDivElement;
    set16ToRgb(str: string): string;
    getColorWithOpacity(color: string, opacity: string | number): string;
}

export  interface AnimateMarkerLayerOption {
    /** breathingAperture */
    type?: AnimateMarkerType;
    /**  */
    width?: number;
    /**  */
    height?: number;
    /**  */
    colors?: string[];
    /**  */
    textFontSize?: number;
    /**  */
    textColor?: string;
    /** name) */
    textField?: string;
}

/**
 * breathingAperture .
 * rotatingAperture 
 * haloRing 
 * diffusedAperture 
 * rotatingTextBorder 
 * fluorescence 
 */
export  type AnimateMarkerType = "breathingAperture" | 'rotatingAperture' | 'haloRing' | 'diffusedAperture' | 'rotatingTextBorder' | 'fluorescence';

/** Tween */
export  function animation<T extends Record<string, any>>(props: {
    /** id */
    id?: string;
    /**  */
    tag?: string;
    /** ({value: 0}) */
    from?: T;
    /** ({value: 1) */
    to?: T;
    /** trueto */
    by?: boolean;
    /**  */
    duration: number;
    /** easing  linear */
    easing?: Easing;
    /**  */
    yoyoForever?: boolean;
    /**  */
    yoyoTimes?: number;
    /**  */
    repeatForever?: boolean;
    /**  */
    repeatTimes?: number;
    /**  */
    delay?: number;
    /**  */
    autoPlay?: boolean;
    /**
     * A callback function to execute when the animation completes.
     * @param target - The target object that was tweened.
     */
    onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
    /**
     * A callback function to execute when the animation starts.
     * @param target - The target object that is being tweened.
     */
    onStart?: (target: T) => void;
    /**
     * A callback function to be executed after each property has been updated.
     * @param target - The target object that is being tweened.
     */
    onUpdate?: (target: T) => void;
    /**
     * A callback function to be executed before each property is updated.
     * @param target - The target object that is being tweened.
     * @param key - The key or property being animated.
     * @param start - The initial value of the animated property.
     * @param end - The final value of the animated property.
     * @param alpha - The current animation progress as a normalized value (0 to 1).
     * @returns If `false`, will not assign a new value to the property.
     */
    onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
}): Tween<T>;

/**
 * @example
 *     const animation = new Animation();
 *     const obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start();
 */
 class Animation_2 extends Eventful {
    stage: Stage;
    private _head;
    private _tail;
    private _running;
    private _time;
    private _pausedTime;
    private _pauseStart;
    private _paused;
    constructor(opts?: AnimationOption);
    /**
     * Add clip
     */
    addClip(clip: Clip): void;
    /**
     * Add animator
     */
    addAnimator(animator: Animator_2<any>): void;
    /**
     * Delete animation clip
     */
    removeClip(clip: Clip): void;
    /**
     * Delete animation clip
     */
    removeAnimator(animator: Animator_2<any>): void;
    update(notTriggerFrameAndStageUpdate?: boolean): void;
    _startLoop(): void;
    /**
     * Start animation.
     */
    start(): void;
    /**
     * Stop animation.
     */
    stop(): void;
    /**
     * Pause animation.
     */
    pause(): void;
    /**
     * Resume animation.
     */
    resume(): void;
    /**
     * Clear animation.
     */
    clear(): void;
    /**
     * Whether animation finished.
     */
    isFinished(): boolean;
    /**
     * Creat animator for a target, whose props can be animated.
     */
    animate<T>(target: T, options: {
        loop?: boolean;
    }): Animator_2<T>;
}

/** Tweenpromise, */
export  function animationAsync<T extends Record<string, any>>(props: {
    /** id */
    id?: string;
    /**  */
    tag?: string;
    /** ({value: 0}) */
    from?: T;
    /** ({value: 1) */
    to?: T;
    /** trueto */
    by?: boolean;
    /**  */
    duration: number;
    /** easing  linear */
    easing?: Easing;
    /**  */
    yoyoForever?: boolean;
    /**  */
    yoyoTimes?: number;
    /**  */
    repeatForever?: boolean;
    /**  */
    repeatTimes?: number;
    /**  */
    delay?: number;
    /**  */
    autoPlay?: boolean;
    /**
     * A callback function to execute when the animation completes.
     * @param target - The target object that was tweened.
     */
    onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
    /**
     * A callback function to execute when the animation starts.
     * @param target - The target object that is being tweened.
     */
    onStart?: (target: T) => void;
    /**
     * A callback function to be executed after each property has been updated.
     * @param target - The target object that is being tweened.
     */
    onUpdate?: (target: T) => void;
    /**
     * A callback function to be executed before each property is updated.
     * @param target - The target object that is being tweened.
     * @param key - The key or property being animated.
     * @param start - The initial value of the animated property.
     * @param end - The final value of the animated property.
     * @param alpha - The current animation progress as a normalized value (0 to 1).
     * @returns If `false`, will not assign a new value to the property.
     */
    onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
}): Promise<unknown>;

export  class AnimationBehavior extends Behavior {
    animation: AnimationTrackPlayback;
    /**
     *
     * @param {AnimationTrackPlayback} animation
     */
    constructor(animation: AnimationTrackPlayback);
    /**
     *
     * @param {number} timeDelta
     * @returns {BehaviorStatus}
     */
    tick(timeDelta: any): BehaviorStatus.Running | BehaviorStatus.Succeeded;
    initialize(): void;
}

/**
 * 
 */
export  interface AnimationClipOptions {
    /**  */
    name?: string;
    /**  */
    duration?: number;
    /**  */
    blendMode?: AnimationBlendMode;
    /** uuid */
    uuid?: number;
    /**  */
    fps?: number;
    /**  */
    tracks: {
        /**  */
        type: "double" | "float" | "number" | "integer" | "vector" | "vector2" | "vector3" | "vector4" | "color" | "quaternion" | "bool" | "boolean" | "string";
        /**  */
        name?: string;
        /**  */
        times: number[];
        /**  */
        values: any[];
        /**  */
        interpolation?: InterpolationModes;
    }[];
}

 type AnimationEasing = keyof typeof easingFuncs | easingFunc;

 interface AnimationOption {
    stage?: Stage;
}

export  class AnimationTrack {
    properties: String[];
    propertyCount: number;
    keyValues: any;
    keyTimes: any;
    timeStart: number;
    timeEnd: number;
    transitionKeys: any[];
    transitionFunctions: any[];
    constructor(properties: String[]);
    optimize(): void;
    /**
     *
     * @param {number} keyTime
     * @param {number[]} values
     */
    addKey(keyTime: number, values: number[]): void;
    /**
     *
     * @param {number} startKeyIndex
     * @param {function(number):number} transitionFunction
     */
    addTransition(startKeyIndex: number, transitionFunction: (number: any) => number): void;
    /**
     *
     * @param {number} time
     * @returns {number}
     */
    keyLowerBoundIndexAt(time: number): number;
    /**
     *
     * @param {number} time
     * @returns {number}
     */
    transitionIndexAt(time: number): number;
    /**
     *
     * @param {number} keyIndex
     * @param {number[]} result
     */
    readKeyValues(keyIndex: number, result: number[]): void;
}

/**
 *
 * @param {AnimationTrack} track
 * @param updateCallback
 * @param {Object} [updateTarget]
 * @constructor
 * @property {AnimationTrack} track
 * @property {number} position Current playback time
 */
export  class AnimationTrackPlayback {
    track: AnimationTrack;
    position: number;
    updateCallback: any;
    updateTraget: any;
    __lastKeyIndex: number;
    __lastTransitionIndex: number;
    __nextKeyIndex: number;
    __nextKeyTime: number;
    __loop: boolean;
    __valueBuffer: any;
    on: {
        ended: any;
    };
    constructor(track: AnimationTrack, updateCallback?: Function, updateTarget?: any);
    /**
     *
     * @returns {Promise<void>}
     */
    promiseEnded(): Promise<unknown>;
    /**
     *
     * @param {boolean} v
     */
    setLoop(v: any): void;
    isLoop(): boolean;
    reset(): void;
    /**
     *
     * @param {number} time
     */
    setPosition(time: number): void;
    /**
     *
     * @returns {boolean} Indicated whenever or not a key was advanced, no advancement is possible past end of the sequence
     */
    advanceKey(): boolean;
    /**
     * Advance animation by given time delta
     * @param {number} timeDelta
     */
    advance(timeDelta: number): void;
    update(): void;
    /**
     *
     * @param {number[]} result
     */
    readCurrentValues(result: number[]): void;
}

/**
 * 
 */
export  class Animator {
    #private;
    uiConfig: UiObjectConfig;
    animateMixer: AnimationMixer;
    animationClips: AnimationClip[];
    isAnimator: boolean;
    signal: {
        onLoop: Signal;
        onFinished: Signal;
    };
    constructor(options: AnimatorOptions);
    /**
     * 
     */
    stopAllAction(): AnimationMixer;
    /**
     * 
     */
    getClipNames(): string[];
    /**
     * 
     */
    setTime(timeInSeconds: number): AnimationMixer;
    /**
     * 
     * @param clip
     * @returns
     */
    addAnimationClip(clip: AnimatorOptions | AnimationClip): AnimationClip;
    /**
     * 
     * @returns
     */
    getAnimateMixer(): AnimationMixer;
    /**
     * 
     * @returns
     */
    getAnimationClips(): AnimationClip[];
    /**
     * 
     * @param name 
     * @returns
     */
    getClip(name: string | number | AnimationClip): AnimationClip;
    /**
     * 
     * @param sourceClip 
     * @param startFrame 
     * @param endFrame 
     * @param subclipName 
     * @param fps 
     */
    addAnimationSubclip(sourceClip: string | number | AnimationClip, startFrame: number, endFrame?: number, subclipName?: string, fps?: number): void;
    /**
     * 
     * @param name 
     * @returns
     */
    getclipAction(name: string | number | AnimationClip): AnimationAction;
    /**
     * 
     * @param name  1
     * @returns
     */
    play(name?: string | number | AnimationClip): AnimationAction;
    /**
     * 
     * @param name  
     * @returns
     */
    stop(name?: string | number | AnimationClip): AnimationAction;
    /**
     * 
     * @param name 
     * @returns
     */
    reset(name: string | number | AnimationClip): AnimationAction;
    /**
     * 
     * @param name 
     * @returns
     */
    isRunning(name: string | number | AnimationClip): boolean;
    /**
     * true (isRunning)
     * @param name 
     * @returns
     */
    isScheduled(name: string | number | AnimationClip): boolean;
    /**
     * 
     *
     * @param {string} name 
     * @param {boolean} clampWhenFinished  clampWhenFinished true,   clampWhenFinished false, enabled false, 
     * @memberof Animation
     */
    setClampWhenFinished(name: string | number | AnimationClip, clampWhenFinished: boolean): void;
    /**
     * 
     *
     * @param {string} name 
     * @param {boolean} enabled 
     * @memberof Animation
     */
    setEnable(name: string | number | AnimationClip, enabled: boolean): void;
    /**
     * 
     * @param name 
     * @param time 
     * @returns
     */
    startAt(name: string | number | AnimationClip, time: number): AnimationAction;
    /**
     * 
     * @param name 
     * @param mode 
     * @param repetitions 
     * @returns mode 
     */
    setLoop(name: string | number | AnimationClip, mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
    /**
     * 
     * @param name 
     * @param weight 
     * @returns
     */
    setEffectiveWeight(name: string | number | AnimationClip, weight: number): AnimationAction;
    /**
     * 
     * @param name 
     * @returns
     */
    getEffectiveWeight(name: string | number | AnimationClip): number;
    /**
     * weight01
     * @param name 
     * @param duration 
     * @returns
     */
    fadeIn(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * weight10
     * @param name 
     * @param duration 
     * @returns
     */
    fadeOut(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * (fade in),
     * @param name 
     * @param fadeOutAction 
     * @param duration 
     * @param warp true,  warping ()
     * @returns
     */
    crossFadeFrom(name: string | number | AnimationClip, fadeOutAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
    /**
     * , fade out
     * @param name 
     * @param fadeInAction 
     * @param duration 
     * @param warp true,  warping ()
     * @returns
     */
    crossFadeTo(name: string | number | AnimationClip, fadeInAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
    /**
     * fading
     * @param name 
     * @returns
     */
    stopFading(name: string | number | AnimationClip): AnimationAction;
    /**
     * timeScale)
     * @param name 
     * @param timeScale 
     * @returns
     */
    setEffectiveTimeScale(name: string | number | AnimationClip, timeScale: number): AnimationAction;
    /**
     * 
     * @param name 
     * @returns
     */
    getEffectiveTimeScale(name: string | number | AnimationClip): number;
    /**
     * (timeScale)
     * @param name 
     * @returns
     */
    setDuration(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * 
     * @param name 
     * @param action 
     * @returns
     */
    syncWith(name: string | number | AnimationClip, action: AnimationAction): AnimationAction;
    /**
     * (timeScale)0
     * @param name 
     * @param duration 
     * @returns
     */
    halt(name: string | number | AnimationClip, duration: number): AnimationAction;
    /**
     * timeScalestartTimeScaleendTimeScale
     * @param name 
     * @param statTimeScale 
     * @param endTimeScale 
     * @param duration 
     * @returns
     */
    warp(name: string | number | AnimationClip, statTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
    /**
     * warping
     * @param name 
     * @returns
     */
    stopWarping(name: string | number | AnimationClip): AnimationAction;
    /**
     * 
     * @param period  3s = 60 * 3
     * @param axis  y "y"
     * @param name 
     */
    addRotationAnimation(period?: number, axis?: string, name?: any): AnimationClip;
    /**
     * 
     * @param period  3s = 60 * 3
     * @param axis  y "y"
     * @param name 
     */
    addScaleAxisAnimation(period?: number, axis?: string, name?: any): AnimationClip;
    /**
     * 
     * @param period  3s = 60 * 3
     * @param shakeScale   1.2
     * @param name 
     */
    addShakeAnimation(duration?: number, shakeScale?: Vector3 | number, name?: any): AnimationClip;
    /**
     * 
     * @param period  3s = 60 * 3
     * @param pulseScale  1.2
     * @param name 
     */
    addPulsationAnimation(duration?: number, pulseScale?: number, name?: any): AnimationClip;
    /**
     * 
     * @param period  0.5
     * @param name 
     */
    addVisibilityAnimation(duration?: number, name?: any): AnimationClip;
    /**
     * 
     * @param period  3s = 60 * 3
     * @param colors 
     * @param name 
     */
    addMaterialColorAnimation(duration?: number, colors?: {
        r: number;
        g: number;
        b: number;
    }[], name?: any): AnimationClip;
    update(delta: number): void;
    dispose(): void;
    /**
     * 
     * @param app
     * @param autoPlay 
     * @returns
     */
    addTo(app: App, autoPlay?: boolean): void;
    /**
     * 
     * @returns
     */
    remove(): void;
}

 class Animator_2<T> {
    animation?: Animation_2;
    targetName?: string;
    scope?: string;
    __fromStateTransition?: string;
    private _tracks;
    private _trackKeys;
    private _target;
    private _loop;
    private _delay;
    private _maxTime;
    /**
     * If force run regardless of empty tracks when duration is set.
     */
    private _force;
    /**
     * If animator is paused
     * @default false
     */
    private _paused;
    private _started;
    /**
     * If allow discrete animation
     * @default false
     */
    private _allowDiscrete;
    private _additiveAnimators;
    private _doneCbs;
    private _onframeCbs;
    private _abortedCbs;
    private _clip;
    constructor(target: T, loop: boolean, allowDiscreteAnimation?: boolean, // If doing discrete animation on the values can't be interpolated
    additiveTo?: Animator_2<any>[]);
    getMaxTime(): number;
    getDelay(): number;
    getLoop(): boolean;
    getTarget(): T;
    /**
     * Target can be changed during animation
     * For example if style is changed during state change.
     * We need to change target to the new style object.
     */
    changeTarget(target: T): void;
    /**
     * Set Animation keyframe
     * @param time time of keyframe in ms
     * @param props key-value props of keyframe.
     * @param easing
     */
    when(time: number, props: Dictionary<any>, easing?: AnimationEasing): this;
    whenWithKeys(time: number, props: Dictionary<any>, propNames: string[], easing?: AnimationEasing): this;
    pause(): void;
    resume(): void;
    isPaused(): boolean;
    /**
     * Set duration of animator.
     * Will run this duration regardless the track max time or if trackes exits.
     * @param duration
     * @returns
     */
    duration(duration: number): this;
    private _doneCallback;
    private _abortedCallback;
    private _setTracksFinished;
    private _getAdditiveTrack;
    /**
     * Start the animation
     * @param easing
     * @return
     */
    start(easing?: AnimationEasing): this;
    /**
     * Stop animation
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stop(forwardToLast?: boolean): void;
    /**
     * Set when animation delay starts
     * @param time ms
     */
    delay(time: number): this;
    /**
     * 
     * @param callback
     */
    during(cb: OnframeCallback_2<T>): this;
    /**
     * Add callback for animation end
     * @param cb
     */
    done(cb: DoneCallback): this;
    aborted(cb: AbortCallback): this;
    getClip(): Clip;
    getTrack(propName: string): Track;
    getTracks(): Track[];
    /**
     * Return true if animator is not available anymore.
     */
    stopTracks(propNames: string[], forwardToLast?: boolean): boolean;
    /**
     * Save values of final state to target.
     * It is mainly used in state mangement. When state is switching during animation.
     * We need to save final state of animation to the normal state. Not interpolated value.
     *
     * @param target
     * @param trackKeys
     * @param firstOrLast If save first frame or last frame
     */
    saveTo(target: T, trackKeys?: readonly string[], firstOrLast?: boolean): void;
    __changeFinalValue(finalProps: Dictionary<any>, trackKeys?: readonly string[]): void;
}

export  const AnimatorFrameMaterial: (new (parameters?: ShaderMaterialParameters & Partial<AnimatorFrameMaterialProps>, uniforms?: Partial<AnimatorFrameMaterialProps>) => ShaderMaterial & AnimatorFrameMaterialProps) & {
    key: string;
};

export  type AnimatorFrameMaterialProps = {
    /**  */
    color?: Color;
    /**  */
    imageWidth: number;
    /**  */
    imageHeight: number;
    /**  */
    rowCount: number;
    /**  */
    colCount: number;
    /**   */
    spriteCount?: number;
    /**   */
    spriteWidth?: number;
    /**   */
    spriteHeight?: number;
    /**  */
    curRunFrameCount?: number;
    /**  */
    isStop?: boolean;
    /** sprite 0 */
    stopSpriteIndex?: number;
    /**  */
    time?: Vector4 | {
        value: Vector4;
    };
    /** Material side, default: BackSide */
    side?: Side;
    /** Material depthWrite, default: false */
    depthWrite?: boolean;
    /**  */
    map?: Texture;
    [key: string]: any;
};

/**
 * 
 */
export  class AnimatorModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    animators: Animator[];
    constructor(entity: Entity, options?: AnimatorModuleOptions | Animator);
    setupUiConfig(): UiObjectConfig;
    /**
     * 0
     * @param index 
     */
    getAnimator(index?: number): Animator;
    /**
     * 
     * @param index
     */
    addAnimator(options: AnimatorOptions): Animator;
    /**
     * 
     * @param index
     */
    removeAnimator(index: number | Animator): void;
    onAppUpdate(time: Time): void;
}

/**
 * 
 */
export  interface AnimatorModuleOptions {
    /**  */
    object?: Object3D | Object3D[] | Entity | Entity[];
    /**  */
    animations?: AnimationClip[] | AnimationClip | AnimationClipOptions | AnimationClipOptions[];
}

/**
 * 
 */
export  interface AnimatorOptions {
    /**  */
    object: Object3D | Object3D[] | Entity | Entity[];
    /**  */
    animations?: AnimationClip[] | AnimationClip | AnimationClipOptions | AnimationClipOptions[];
}

/**
 * Type for any function
 */
export  type AnyFunction = (...args: any[]) => any;

/**
 * Type for any object
 */
export  type AnyOptions = Record<string, any>;

export  class App extends AppBase implements IWebGLRendererModule, ISceneModule, ICameraModule, ICSS2DRendererModule, ICSS3DRendererModule, ICoordSystemModule, IEntityManagerModule, IEntityQueryModule, IStatModule, IInputModule, IOrbitControlModule, IPickModule, IRectCollideModule, IToolStateModule, ICommandModule, IParticleRenderModule, IPhysicsManagerModule, IUiModule, IPostProcessModule {
    #private;
    /**  */
    readonly renderer: WebGLRenderer;
    /** 2d */
    readonly css2dRenderer: CSS2DRenderer;
    /** marker2d */
    getMarker2Ds: () => Marker2D[];
    /**popup2d */
    getPopup2Ds: () => Popup2D[];
    /** popup */
    readonly popup2d: Popup2D;
    /** css3d */
    readonly css3dRenderer: CSS3DRenderer;
    /** css3d */
    readonly css3dOccludeRenderer: CSS3DRenderer;
    /** 3d */
    setCss3dObjectCanOcclude: (object: CSS3DObject, canOcclude?: boolean) => void;
    /**  */
    getScreenshot: (params?: Screenshot) => Promise<Blob | null | undefined>;
    /**  */
    readonly isMapMode: boolean;
    readonly commonUniforms: {
        time: Uniform_2<Vector4>;
        resolution: Uniform_2<Vector2>;
        iGlobalTime: Uniform_2<number>;
        iTime: Uniform_2<number>;
        iTimeDelta: Uniform_2<number>;
        iResolution: Uniform_2<Vector3>;
        iMouse: Uniform_2<Vector4>;
        iFrame: Uniform_2<number>;
        iDate: Uniform_2<Vector4>;
        iSampleRate: Uniform_2<number>;
        iChannelTime: Uniform_2<[number, number, number, number]>;
    };
    /**  */
    addScene: (scene?: Scene, camera?: CameraOptions) => Scene;
    /**  */
    activeScene: (_scene: Scene) => Promise<void>;
    /**  */
    setScene: (scene?: Scene, camera?: CameraOptions) => Promise<Scene>;
    /**  */
    removeScene: (_scene: Scene) => Promise<void>;
    /**  */
    initScene: (scene: Scene) => void;
    /**  */
    clearScenes: () => void;
    /**  */
    readonly sceneEntity: Entity;
    /**  */
    addDefaultLights: (scene?: Scene) => {};
    /**  */
    getSceneStatData: () => {
        /**  */
        objects: number;
        /**  */
        vertices: number;
        /**  */
        triangles: number;
    };
    /**  */
    readonly envConfig: EnvConfigOption & {
        [key: string]: any;
    };
    /**  */
    setEnvConfig: (key: keyof EnvConfigOption | string, value: any) => void;
    /**  */
    setBackgroundEnvironment: (options?: BackgroundEnvironmentOptions) => Promise<void>;
    /**  */
    setFocus: () => void;
    /**  */
    loadResources: (_resources: ResourceItem[], options?: loadResourcesOptions) => Promise<RosourceItemsReturnType>;
    /** loadResources */
    getLoadedResources: () => RosourceItemsReturnType;
    getEntities: () => Entity[];
    getRayQueryEntities: () => Entity[];
    addSelectedEntity: (ent: Entity) => {};
    removeSelectEntity: (ent: Entity) => {};
    getSelectObjects: () => Object3D[];
    getSelectObjectsRef: () => ShallowReactive<Object3D[]>;
    addBloomEntity: (ent: Entity) => {};
    removeBloomEntity: (ent: Entity) => {};
    getBloomObjects: () => Object3D[];
    getBloomObjectsRef: () => ShallowReactive<Object3D[]>;
    addOutlineEntity: (ent: Entity) => {};
    removeOutlineEntity: (ent: Entity) => {};
    getOutlineObjects: () => Object3D[];
    getOutlineObjectsRef: () => ShallowReactive<Object3D[]>;
    setSelectBoomRefreshFlag: () => void;
    showStat: boolean;
    /** */
    viewHelperEnable: boolean;
    /**
     * 
     * @param position 
     * @param lookAt 
     * @param options 
     */
    setCameraLookAt: (position: Vector3, lookAt: Vector3, options?: boolean | Record<string, any>) => void;
    /**  */
    enableCameraControl: boolean;
    /**  */
    enableCameraControlRef: Ref<boolean>;
    /**  */
    enableWheelWhenCtrlDisabled: boolean;
    /**
     * 
     * @param x
     * @param y
     * @param opts (undefined false , true)   (-1  1 )  (xz)     
     * @param retIntersectObject object
     */
    unproject: (x: number | Vector2, y?: number, opts?: UnProjectOpts, retIntersectObject?: {}) => Vector3 | undefined;
    /**
     *  unproject 
     * @param x  x
     * @param y y
     * @param opts (false , true) "depth"    (-1  1 )  (xz)     
     * @param retIntersectObject object
     */
    unprojectAsync: (x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}) => Promise<Vector3 | undefined>;
    /**
     * 
     */
    project: (x: number | Vector3, y?: number, z?: number) => Vector2;
    /**
     * NDC
     */
    screenToNdc: (x: number | Vector2, y?: number) => Vector2;
    /**
     * NDC
     */
    ndcToScreen: (x: number | Vector2, y?: number) => Vector2;
    /**
     * 
     */
    centerOrigin: Vector3 | undefined;
    /**
     * x,y,z1
     */
    scaleOrigin: number | undefined;
    /**
     * 
     */
    isFreeStatus: boolean;
    /**
     * 
     */
    isFreeStatusRef: Ref<boolean>;
    /**
     * 
     */
    pickPoint: (opts?: PickPointOptions) => Promise<{
        cancel: boolean;
        point?: Vector3;
        reason?: string;
        intersectObject?: any;
        event?: InteractiveEvent;
    }>;
    /**
     * 
     */
    pickEntity: (opts?: PickEntityOptions) => Promise<{
        cancel: boolean;
        entities: Entity[];
        reason?: string;
        clearHighlight: Function;
    }>;
    /**
     * 
     */
    drawSelectBox: (style?: Record<string, any>) => Promise<{
        cancel: boolean;
        reason?: string;
    } | [Vector2, Vector2]>;
    /**
     * 
     */
    actionDrawPoint: (opts?: IDrawPointEnterOptions) => Promise<{
        isCancel?: boolean;
        data: SymbolItemData;
    }>;
    /**
     * 
     */
    actionDrawLineSting: (opts?: IDrawLineEnterOptions) => Promise<{
        isCancel?: boolean;
        data: PolylineItemData;
    }>;
    /**
     * 
     */
    actionDrawPolygon: (opts?: IDrawPolygonEnterOptions) => Promise<{
        isCancel?: boolean;
        data: PolygonItemData;
    }>;
    actionDrawEdit: (opts?: IDrawEditEnterOptions) => Promise<{}>;
    /**  */
    actionPickSelect: (opts?: PickEnterOptions) => Promise<{
        isCancel: boolean;
        info?: TLEventHandler;
        select?: InteractiveObject;
    }>;
    /**  */
    getDrawLayer: (layerName?: string, noCreateStyle?: Record<string, any>) => {
        symbol: () => SymbolEntity | undefined;
        polylines: () => PolylinesEntity | undefined;
        polygons: () => PolygonsEntity | undefined;
        addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
        addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
        addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
        updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
        updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
        updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
        deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
        deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
        deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
    };
    addPointerEventsObject: (entity: Entity) => {};
    removePointerEventsObject: (entity: Entity) => {};
    Input: {
        /**  exam: getKeyDown("KeyW") */
        getKeyDown: (keyCode: string) => boolean;
        /**   Space Enter ShiftLeft ControlLeft */
        getKeyPressed: (keyCode: string) => boolean;
        /**  */
        getKeyUp: (keyCode: string) => boolean;
        x: () => number;
        y: () => number;
        movementX: () => number;
        movementY: () => number;
        isMoving: () => boolean;
        isDragging: () => boolean;
        isLeftButtonDown: () => boolean;
        isLeftButtonPressed: () => boolean;
        isLeftButtonUp: () => boolean;
        isRightButtonDown: () => boolean;
        isRightButtonPressed: () => boolean;
        isRightButtonUp: () => boolean;
        isMidButtonDown: () => boolean;
        isMidButtonPressed: () => boolean;
        isMidButtonUp: () => boolean;
        enabled: () => boolean;
        setEnable: (b: boolean) => {};
        /**  */
        enabledRef: () => Ref<boolean>;
        /**  */
        closestObject: () => InteractiveObject | undefined | null;
    };
    /**
     *  `contextMenuPreOpen`, `contextMenuOpened`, `contextMenuNoContent`
     * @param menu 
     * @param key setMenukeykeykeynullContextMenu
     */
    setMenu: (menu?: (event: InteractiveEvent | any, object?: InteractiveObject) => ContextMenu | null | undefined, key?: string) => void;
    /**
     * 
     */
    queryEntitiesByCamera: (option?: EntityQueryOption) => InteractiveObject;
    /**
     * 
     */
    queryEntitiesByRaycast: (ray: Ray, option?: EntityQueryOption) => InteractiveObject;
    /**
     * 
     */
    queryEntitiesByScreenPos: (x: number, y: number, option?: EntityQueryOption) => InteractiveObject;
    /**
     * 
     */
    queryEntitiesByBox: (startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number) => InteractiveObject[];
    /**
     * 
     */
    getRayByScreenPos: (x: number, y: number, camera?: Camera) => Ray;
    /**
     * 
     */
    getQueryRaycaster: () => Raycaster;
    /**  */
    readonly composer: EffectComposer;
    /**  */
    isComposerEnable: () => boolean;
    /**  */
    setComposerEnable: (b: boolean) => void;
    /**  */
    addEffectRenderPass: (pass: Pass, orderIndex?: number) => void;
    /**  */
    removeEffectRenderPass: (pass: Pass) => void;
    /**  foreceUpdate*/
    refreshEffectRenderPass: (foreceUpdate?: boolean) => void;
    /**  */
    getDepth: (x: number, y: number) => Promise<number>;
    /** OutlineEffect */
    readonly outlineEffect: OutlineEffect;
    /** bloomEffect */
    readonly bloomEffect: SelectiveBloomEffect;
    /** selectedEffect */
    readonly selectedEffect: OutlineEffect;
    /**  */
    readonly isPostProcessIdle: boolean;
    /**  */
    addCollideRectObject: (item: IRectCollide) => void;
    /**  */
    removeCollideRectObject: (item: IRectCollide) => void;
    /**  */
    updateCollideRect: () => void;
    /**  */
    setCollideRectDirty: () => void;
    readonly rootState: StateNode;
    getStatePath: () => string;
    stateIsIn: (path: string) => boolean;
    stateInAny: (...paths: string[]) => boolean;
    setCurrentTool: (id?: string, info?: Record<string, any>) => App;
    getCurrentTool: () => StateNode;
    getCurrentToolId: () => string;
    getStateDescendant: <T extends StateNode>(path: string) => T | undefined;
    addTool: (Tool: TLStateNodeConstructor) => void;
    removeTool: (Tool: TLStateNodeConstructor) => void;
    /**
     * 
     */
    isInActiveTool: () => boolean;
    /**
     * 
     */
    isInteracting: () => boolean;
    /**
     *  
     */
    transformObject: (options: TransformEnterOptions) => Promise<StateNode>;
    readonly commandHistory: CommandHistory;
    /**  */
    clearCommands: () => void;
    /**  */
    executeCommand: (cmd: ICommand) => void;
    /**  */
    executeAllCommands: (cmds: ICommand[]) => void;
    /**  */
    executeManyCommands: (...cmds: ICommand[]) => void;
    /**  */
    addCommand: (cmd: ICommand) => void;
    /**  */
    addAllCommands: (cmds: ICommand[]) => void;
    /**  */
    addManyCommands: (...cmds: ICommand[]) => void;
    /**  */
    undo: () => any;
    /**  */
    redo: () => any;
    /**
     *  ( `control.onAdd(this)` ).
     *
     * @param control .
     * @param {string} [position] . 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
     */
    addControl: (control: IControl, position?: ControlPosition) => App;
    /**
     * .
     *
     * @param {IControl} control .

     */
    removeControl: (control: IControl) => App;
    /**
     * .
     *
     * @param {IControl} control .
     */
    hasControl: (control: IControl) => void;
    /**
     * 
     * @param cur 
     */
    setCursor: (cur: string) => void;
    /**
     * 
     */
    getConfigPane: (opts?: {
        /**  */
        isReset?: boolean;
        /**  */
        title?: string;
        /**  */
        style?: Partial<CSSStyleDeclaration>;
    }) => Promise<{
        configPane: any;
        rootPane: any;
        element: HTMLElement;
        isInit: boolean;
        setVisible: (b: boolean) => void;
        isVisible: () => boolean;
        reset: () => void;
        appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
        renderUiConfig: (uiConfig: UiObjectConfig) => void;
        renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
    }>;
    /**
     * 
     * text
     * type  "log"
     * time  2500
     */
    logInfo: (text: string, type?: logInfoType | number, time?: number) => void;
    readonly particleRenderer: BatchedRenderer;
    /**
     *  
     * @param system   
     * @param parent  parent nullundefinedparentparent
     * @param disposeWhenEnd true
     * @returns
     */
    addParticleSystem: (system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean) => void;
    /**  */
    addParticle: (opts: {
        /**  */
        system: ParticleSystemParameters;
        /**   */
        simulations?: Simulation | Simulation[];
        /**  */
        name?: string;
        /**   */
        position?: Vector3 | [number, number, number];
        /**  */
        rotation?: Vector3 | [number, number, number];
        /**  */
        scale?: Vector3 | [number, number, number] | number;
        /** parent nullundefinedparentparent */
        parent?: Object3D;
        /** true */
        disposeWhenEnd?: boolean;
    }) => ParticleEmitter<Object3DEventMap>;
    /**  */
    loadParticle: (url: string, opts?: {
        /**  */
        system?: ParticleSystemParameters;
        /**  */
        simulations?: Simulation | Simulation[];
        /**  */
        name?: string;
        /**  */
        position?: Vector3 | [number, number, number];
        /**  */
        rotation?: Vector3 | [number, number, number];
        /**  */
        scale?: Vector3 | [number, number, number] | number;
        /** parent nullundefinedparentparent */
        parent?: Object3D;
        /** true */
        disposeWhenEnd?: boolean;
        /** json json */
        onData?: (data: any) => any;
        /**  */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        crossOrigin?: string;
        withCredentials?: boolean;
        urlPath?: string;
        resourcePath?: string;
        requestHeader?: {
            [header: string]: string;
        };
    }) => Promise<ParticleEmitter<Object3DEventMap>>;
    /** JSON */
    loadParticleFromJson: (json: string | JSON, opts?: {
        /**  */
        system?: ParticleSystemParameters;
        /**   */
        simulations?: Simulation | Simulation[];
        /**  */
        name?: string;
        /**   */
        position?: Vector3 | [number, number, number];
        /**  */
        rotation?: Vector3 | [number, number, number];
        /**  */
        scale?: Vector3 | [number, number, number] | number;
        /** parent nullundefinedparentparent */
        parent?: Object3D;
        /** true */
        disposeWhenEnd?: boolean;
        /**  */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
        /**  */
        onData?: (data: any) => any;
    }) => ParticleEmitter<Object3DEventMap>;
    /**  */
    loadParticleFromRes: (obj: Object3D, opts?: {
        /**  */
        system?: ParticleSystemParameters;
        /**   */
        simulations?: Simulation | Simulation[];
        /**  */
        name?: string;
        /**   */
        position?: Vector3 | [number, number, number];
        /**  */
        rotation?: Vector3 | [number, number, number];
        /**  */
        scale?: Vector3 | [number, number, number] | number;
        /** parent nullundefinedparentparent */
        parent?: Object3D;
        /** true */
        disposeWhenEnd?: boolean;
        /**  */
        onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
    }) => ParticleEmitter<Object3DEventMap>;
    /**  */
    removeParticle: (obj: ParticleEmitter<Object3DEventMap>) => void;
    /**  */
    physicsEnable: boolean;
    /**  */
    readonly physicsWorld: World;
    /**  */
    readonly physicsEngine: typeof CANNON;
    /**  */
    enablePhysicsEngine: () => Promise<typeof CANNON>;
    /**  */
    addPhysicsBody: (phyObject: MeshPhysicsObjectParams) => MeshPhysicsObjectParams;
    /**  */
    removePhysicsObject: (object: Object3D | Entity) => void;
    /**  */
    addPhysicsGround: () => CANNON.Plane;
    /**  */
    setPhysicsDebugger: (enable: boolean) => void;
    isApp: boolean;
    static defaultModules: Array<AppModuleConstructor | [AppModuleConstructor, string]>;
    /**  */
    static registerModules: Set<EntityModuleConstructor>;
    signal: {
        /**  */
        onSelectedChange: Signal;
        onEntitySelected: Signal;
        onEntityUnSelected: Signal;
        onBloomedChange: Signal;
        onEntityBloomed: Signal;
        onEntityUnBloomed: Signal;
        onOutlineChange: Signal;
        onEntityOutline: Signal;
        onEntityUnOutline: Signal;
        onMouseUp: Signal;
        onMouseMove: Signal;
        onMouseDown: Signal;
        onMousePreClick: Signal;
        onMouseClick: Signal;
        onMouseDblClick: Signal;
        onMouseOver: Signal;
        onMouseOut: Signal;
        onMouseEnter: Signal;
        onMouseLeave: Signal;
        onContextMenu: Signal;
        onPointerDown: Signal;
        onPointerMove: Signal;
        onPointerUp: Signal;
        /**  */
        onPointerDownUp: Signal;
        onPointerCancel: Signal;
        onMouseWheel: Signal;
        onKeyDown: Signal;
        onKeyUp: Signal;
        onAppBeforeUpdate: Signal;
        onAppUpdate: Signal;
        onAppAfterUpdate: Signal;
        onAppBeforeRender: Signal;
        onAppRender: Signal;
        onAppAfterRender: Signal;
        onAppBeforeAddEntity: Signal;
        onAppAddEntity: Signal;
        onAppBeforeRemoveObject: Signal;
        onAppRemoveObject: Signal;
        onAppBeforeRemoveEntity: Signal;
        onAppRemoveEntity: Signal;
        /**  */
        onContainerSizeChange: Signal;
        /**  */
        onCameraControl: Signal;
        /**  */
        onCameraUpdate: Signal;
        /**  */
        onCameraChange: Signal;
        /**  */
        contextMenuPreOpen: Signal;
        /**   */
        contextMenuOpened: Signal;
        /**  */
        contextMenuNoContent: Signal;
        /**  */
        contextMenuCancel: Signal;
        /**  */
        onCustomEvent: Signal;
        /**  */
        onAddScene: Signal;
        /**  */
        onActiveScene: Signal;
        /**  */
        onRemoveScene: Signal;
    };
    /**  */
    mapViewEntity: MapViewEntity;
    svc: Service;
    constructor(svc: Service, options?: AppOptions);
    setupUiConfig(): UiObjectConfig;
    dispose(): void;
    fromJSON(json: Record<string, any>): Promise<void>;
    toJSON(): {
        metadata: {};
        project: {};
        camera: any;
        scene: any;
        entities: any[];
    };
}

export  class AppBase extends EventDispatcher {
    #private;
    readonly _modules: ModuleBase[];
    readonly options: AppBaseOptions;
    needRenderUpdate: boolean;
    readonly moduleManager: ModuleManager;
    data: ShallowReactive<{
        container?: HTMLElement;
        domElement?: HTMLElement;
        camera?: Camera;
        scene?: Scene;
        [key: string]: any;
    }>;
    containerSize: {
        width: number;
        height: number;
    };
    tweenManager: TweenManager;
    [key: string]: any;
    private _uiConfig;
    get uiConfig(): UiObjectConfig<any, string, any>;
    constructor(param?: AppBaseOptions);
    private readonly _animate;
    get container(): HTMLElement;
    set container(value: HTMLElement);
    get domElement(): HTMLElement;
    set domElement(value: HTMLElement);
    get camera(): Camera;
    set camera(value: Camera);
    get scene(): Scene;
    set scene(value: Scene);
    get cameraControl(): CameraControls;
    /**
     * Whether the engine is paused.
     */
    get isPaused(): boolean;
    /**
     * vSyncCount00
     vSyncCount160Hz60FPS
     vSyncCount260Hz30FPS
     * @remarks 0 means that the vertical synchronization is turned off.
     */
    get vSyncCount(): number;
    set vSyncCount(value: number);
    /**
     * The time information of the engine.
     */
    get time(): Time;
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
    get targetFrameRate(): number;
    set targetFrameRate(value: number);
    /**
     * 
     */
    onNextFrame(callback: (app: AppBase) => void): void;
    /**
     * Pause the engine.
     */
    pause(): void;
    /**
     * Resume the engine.
     */
    resume(): void;
    /**
     * Execution engine loop.
     */
    run(): void;
    /**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */
    update(): void;
    /**
     * Indicates whether the engine is destroyed.
     */
    get destroyed(): boolean;
    private _destroy;
    /**
     * Destroy engine.
     * @remarks If call during frame execution will delay until the end of the frame
     */
    destroy(): void;
    /**
     * this.add(xxx)
     */
    addModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T, params?: U): T;
    /**
     * this.addModule(xxx)
     */
    add<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T, params?: U): T;
    getModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T): T;
    removeModule<T extends AppModuleBase, U>(type: new (app?: any, obj?: U) => T): void;
    removeAllModules(): void;
    callModules(methodName: string, ...args: any): void;
}

export  interface AppBaseOptions {
    /**  */
    container?: string | HTMLElement;
    /** true */
    autoStart?: boolean;
    /** tween true*/
    enableTweenManager?: boolean;
    /** app */
    isTemp?: boolean;
    /**  */
    offscreenCanvas?: {
        width: number;
        height: number;
    };
}

/**
 * Apply collision to particles from a physics resolver.
 */
export  class ApplyCollision implements Simulation {
    resolver: PhysicsResolver;
    bounce: number;
    type: string;
    tempV: Vector3;
    constructor(resolver: PhysicsResolver, bounce: number);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

/**
 * Apply a global force to particles.
 */
export  class ApplyForce implements Simulation {
    direction: Vector3;
    magnitude: ValueGenerator;
    type: string;
    magnitudeValue: number;
    constructor(direction: Vector3, magnitude: ValueGenerator);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

export  const applyMixins: (toClassInst: any, fromClasseInst: any, methodNames: string[]) => () => void;

export  class ApplyRoute implements Simulation {
    type: string;
    paths: [number, number, number][];
    _allDistance: number;
    _segmentDist: number[];
    _nextPoint: [number, number, number];
    _time: number;
    _curtime: number;
    constructor(paths: [number, number, number][], time?: number);
    initialize(particle: Particle): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
    reset(): void;
}

/**
 * Apply sequences to particles.
 * {@link Sequencer}
 */
export  class ApplySequences implements Simulation {
    static BEZIER: Bezier;
    type: string;
    sequencers: Array<[IntervalValue, Sequencer]>;
    time: number;
    index: number;
    pCount: number;
    delay: number;
    tempV: Vector3;
    constructor(delayBetweenParticles: number);
    initialize(particle: Particle): void;
    reset(): void;
    update(particle: Particle, delta: number): void;
    frameUpdate(delta: number): void;
    appendSequencer(range: IntervalValue, sequencer: Sequencer): void;
    toJSON(): any;
    static fromJSON(json: any): Simulation;
    clone(): Simulation;
}

/**
 * 
 */
 function applyTransform<T extends VectorArray>(out: T, v: VectorArray, m: MatrixArray): T;

export  class AppModuleBase extends ModuleBase {
    constructor(app?: App);
}

export  type AppModuleConstructor = new (obj: any) => AppModuleBase;

/**
 * EntityBase.
 */
export  abstract class AppObject extends EventDispatcher {
    #private;
    private static _instanceIdCounter;
    readonly instanceId: number;
    _app?: App;
    onSetApp: Signal;
    data: ShallowReactive<{
        [key: string]: any;
    }>;
    extData: {
        [key: string]: any;
    };
    private _uiConfig;
    get uiConfig(): UiObjectConfig<any, string, any>;
    protected _destroyed: boolean;
    constructor(app?: App);
    get app(): App;
    set app(value: App);
    /**
     * Whether it has been destroyed.
     */
    get destroyed(): boolean;
    /**
     * Destroy self.
     */
    destroy(): void;
    effectScope(fn: () => any): void;
    applyMixinsTo(toClassInst: any, methodNames?: string[], addMethods?: string[], filterName?: string[]): void;
    addDispose(cb: Function): void;
    removeDispose(cb: Function): void;
}

export  interface AppOptions extends AppBaseOptions {
    render?: WebGLRendererModuleOptions;
    control?: OrbitControlModuleOptions;
    camera?: CameraModuleOptions;
    input?: InputModuleOptions;
    stat?: StatModuleOptions;
    scene?: SceneModuleOptions;
    css2dRender?: CSS2DRendererModuleOptions;
    css3dRender?: CSS3DRendererModuleOptions;
    modules?: Array<AppModuleConstructor | [AppModuleConstructor, string]>;
    postProcess?: PostProcessModuleOptions;
    coordSystem?: CoordSystemOption;
    entityOutline?: EntityOutlineModuleOptions;
    physics?: PhysicsManagerModuleOptions;
    ui?: UiModuleOptions;
}

export  function approxArrayEquals(a: number[], b: number[], error?: number): boolean;

/**  */
export  function approxEquals(a: number, b: number, error?: number): boolean;

/**  */
export  function approxZero(number: number, error?: number): boolean;

 class Arc extends Path<ArcProps> {
    shape: ArcShape;
    constructor(opts?: ArcProps);
    getDefaultStyle(): {
        stroke: string;
        fill: string;
    };
    getDefaultShape(): ArcShape;
    buildPath(ctx: CanvasRenderingContext2D, shape: ArcShape): void;
}

 interface ArcProps extends PathProps {
    shape?: Partial<ArcShape>;
}

 class ArcShape {
    cx: number;
    cy: number;
    r: number;
    startAngle: number;
    endAngle: number;
    clockwise?: boolean;
}

/**
 * Convert an ArrayBuffer to Base64 string
 * @param buffer - ArrayBuffer to convert
 * @category ArrayBuffer
 */
export  function arrayBufferToBase64(buffer: ArrayBuffer): string;

/**
 * Collision "matrix".
 * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 */
 class ArrayCollisionMatrix {
    /**
     * The matrix storage.
     */
    matrix: number[];
    constructor();
    /**
     * Get an element
     */
    get(bi: Body_2, bj: Body_2): number;
    /**
     * Set an element
     */
    set(bi: Body_2, bj: Body_2, value: boolean): void;
    /**
     * Sets all elements to zero
     */
    reset(): void;
    /**
     * Sets the max number of objects
     */
    setNumObjects(n: number): void;
}

/**
 * Not readonly ArrayLike
 * Include Array, TypedArray
 */
 type ArrayLike_2<T> = {
    [key: number]: T;
    length: number;
};

 function assert(condition: any, message?: string): void;

export  type AtlasData = {
    data: Uint8ClampedArray;
    width: number;
    height: number;
    charInfo: Record<string, CharInfo>;
    maxAscent: number;
    lineHeight: number;
};

 const AVERAGE: SplitStrategy;

export  class AxisAngleGenerator implements RotationGenerator {
    axis: Vector3;
    angle: FunctionValueGenerator | ValueGenerator;
    type: 'rotation';
    constructor(axis: Vector3, angle: FunctionValueGenerator | ValueGenerator);
    genValue(quat: Quaternion, t?: number): Quaternion;
    toJSON(): FunctionJSON;
    static fromJSON(json: FunctionJSON): AxisAngleGenerator;
    clone(): RotationGenerator;
}

export  interface BackgroundEnvironmentOptions {
    /**  */
    roomEnvironment?: boolean;
    /**  */
    background?: ColorRepresentation | BackgroundTexture;
    /**  */
    environment?: BackgroundTexture;
    /** . (0-1)  0 */
    backgroundBlurriness?: number;
    /**  1. */
    backgroundIntensity?: number;
    /**  true*/
    environmentSameAsBackground?: boolean;
    /**  */
    showAxesHelper?: boolean;
    /**  */
    axesHelperSize?: number;
    defaultLights?: boolean;
    /**  */
    gridHelper?: GridHelperModuleOptions;
}

export  interface BackgroundTexture {
    isHdr?: boolean;
    path?: string;
    texture?: DataTexture;
    url?: string | string[];
}

/**
 * Convert a Base64 string to ArrayBuffer
 * @param base64 - Base64 string to convert
 * @category ArrayBuffer
 */
export  function base64ToArrayBuffer(base64: string): ArrayBuffer | Uint8Array;

export  abstract class BaseCommand implements ICommand {
    app: App;
    /**  */
    autoExecute?: boolean;
    callbacks?: ICommandCallback;
    abstract execute(): void;
    abstract undo(): void;
    redo(): void;
}

 abstract class BaseCompiler {
    static Instance: BaseCompiler;
    constructor();
    visited: Set<string>;
    debug: boolean;
    protected buildExecutionOrder(graph: NodeGraph, context: ExecutionContext): void;
    private _traverseWire;
    private _traverse;
    abstract run(graph: NodeGraph, context: ExecutionContext): void;
    abstract build(graph: NodeGraph, context: ExecutionContext): string;
}

 type BaseTypes = string | number | boolean;

export  abstract class BaseUvAtlas {
    api: any;
    abstract init(onLoad: () => void, onProgress: (mode: any, progress: any) => void, wasmFilePath: string, workerFilePath?: string): void;
}

export  abstract class BaseUVUnwrapper {
    THREE: {
        BufferAttribute: Class_2<BufferAttribute>;
    };
    packOptions: PackOptions;
    chartOptions: ChartOptions;
    useNormals: boolean;
    timeUnwrap: boolean;
    logProgress: boolean;
    private xAtlas;
    /**
     *
     * @param THREE - for reference to BufferAttribute
     * @param packOptions - options for packing
     * @param chartOptions - options for unwrapping
     * @param useNormals - If true, will use the normals to calculate the uv
     * @param timeUnwrap - Logs the time taken to unwrap geometries
     * @param logProgress - Logs the unwrapping progress
     */
    constructor(THREE: {
        BufferAttribute: Class_2<BufferAttribute>;
    }, packOptions?: PackOptions, chartOptions?: ChartOptions, useNormals?: boolean, timeUnwrap?: boolean, logProgress?: boolean);
    private _libraryLoaded;
    loadLibrary(onProgress?: (mode: any, progress: any) => void, wasmFilePath?: string, workerFilePath?: string): Promise<void>;
    private _isUnwrapping;
    /**
     * Pack multiple geometry into a single atlas
     * @param nodeList - list of geometries to unwrap
     * @param outputUv - Attribute to write the output uv to
     * @param inputUv - Attribute to write the input uv to (if any)
     */
    packAtlas(nodeList: BufferGeometry[], outputUv?: 'uv' | 'uv2', inputUv?: 'uv' | 'uv2'): Promise<BufferGeometry[]>;
    /**
     * Unwraps a geometry to generate uv
     * @param geometry
     * @param outputUv
     * @param inputUv
     */
    unwrapGeometry(geometry: BufferGeometry, outputUv?: 'uv' | 'uv2', inputUv?: 'uv' | 'uv2'): Promise<BufferGeometry<NormalBufferAttributes>[]>;
    protected abstract _createUvAtlas(): any;
}

/**
 * the class represents the batch renderer. a three.js scene should only have one batchedRenderer
 * It keeps references of all particle systems and rendering batch.
 * It batches all particle systems that has the same rendering pipeline to a single VFXBatch.
 */
export  class BatchedRenderer extends Object3D {
    /**
     * Batches for rendering.
     * @type {Array<VFXBatch>}
     */
    batches: Array<VFXBatch>;
    /**
     * Map of systems to batch indices.
     * @type {Map<IParticleSystem, number>}
     */
    systemToBatchIndex: Map<IParticleSystem, number>;
    type: string;
    /**
     * Depth texture.
     * @type {Texture | null}
     */
    depthTexture: Texture | null;
    constructor();
    private static equals;
    /**
     * Adds a particle system to a batch.
     * @param {IParticleSystem} system - The particle system to add.
     */
    addSystem(system: IParticleSystem): void;
    /**
     * Deletes a particle system from its batch.
     * @param {IParticleSystem} system - The particle system to delete.
     */
    deleteSystem(system: IParticleSystem): void;
    /**
     * Sets the depth texture for all batches. it will be used for soft particles.
     * @param {Texture | null} depthTexture - The depth texture to set.
     */
    setDepthTexture(depthTexture: Texture | null): void;
    /**
     * Updates a particle system when the particle system has changed requires reloading.
     * @param {IParticleSystem} system - The particle system to update.
     */
    updateSystem(system: IParticleSystem): void;
    /**
     * Updates all batches.
     * @param {number} delta - The time delta for the update.
     */
    update(delta: number): void;
}

 type BBox = BBox2d | BBox3d;

/**
 * Bounding box
 *
 * https://tools.ietf.org/html/rfc7946#section-5
 * A GeoJSON object MAY have a member named 'bbox' to include information on the coordinate range for its Geometries, Features, or FeatureCollections.
 * The value of the bbox member MUST be an array of length 2*n where n is the number of dimensions represented in the contained geometries,
 * with all axes of the most southwesterly point followed by all axes of the more northeasterly point.
 * The axes order of a bbox follows the axes order of geometries.
 */
 type BBox2d = [number, number, number, number];

 type BBox3d = [number, number, number, number, number, number];

/**
 * Base class of behavior tree implementation
 */
export  class Behavior {
    /**
     * Any internal state used by the behavior
     * This provides a way to interact with the outside as well as to pass data between themselves
     */
    context: BehaviorContext;
    /**
     * Dispatched after initialization is complete
     * @readonly
     */
    onInitialized: Signal;
    /**
     * Dispatched after finalization is complete
     * @readonly
     */
    onFinalized: Signal;
    isBehavior: boolean;
    typeName: string;
    /**
     * Main update function. Every behavior executes some logic, some behaviors are long-running and some are instantaneous
     * @param {number} timeDelta time step in seconds
     * @returns {BehaviorStatus} signals status of the behavior, "success" or "failure" are used to signal completion of the behavior
     */
    tick(timeDelta: number): BehaviorStatus;
    /**
     * Called before behavior gets executed via tick for the first time
     * Used to prepare the behavior for execution
     * You can think of it as "start"
     */
    initialize(context: BehaviorContext): void;
    /**
     * Called when behavior is finished, or interrupted
     * Used to clean up any resources
     * You can think of it as "stop"
     */
    finalize(): void;
}

export  interface BehaviorContext {
    entity: Entity;
}

export  class BehaviorModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    behaviors: Behavior[];
    ids: string[];
    constructor(entity: Entity, behavior?: Behavior | Behavior[]);
    addBehavior(behavior: Behavior, id?: string): string;
    addAction(func: (context: {
        entity: Entity;
        timeDelta: number;
        elapsed: number;
        [key: string]: any;
    }) => BehaviorStatus | void | undefined, id?: string): string;
    removeBehavior(behavior: Behavior): void;
    removeBehaviorByTypeName(typename: string): void;
    removeBehaviorById(id: string): void;
    getBehaviorById(id: string): Behavior;
    getBehaviors(): Behavior[];
    onAppUpdate(time: Time): void;
    setupUiConfig(): UiObjectConfig;
}

/**
 *
 * @enum {number}
 */
export  enum BehaviorStatus {
    Initial = 0,
    Running = 1,
    Succeeded = 2,
    Failed = 3,
    Suspended = 4,
    Invalid = 5
}

export  class BetterRaycastingPoints extends Points {
    isMapMode: boolean;
    raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}

export  class Bezier {
    p: number[];
    constructor(p1: number, p2: number, p3: number, p4: number);
    genValue(t: number): number;
    derivativeCoefficients(points: number[]): number[][];
    getSlope(t: number): number;
    controlCurve(d0: number, d1: number): void;
    hull(t: number): any[];
    split(t: number): {
        left: Bezier;
        right: Bezier;
        span: any[];
    };
    clone(): Bezier;
    toJSON(): {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    };
    static fromJSON(json: {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    }): Bezier;
}

 class BezierCurve extends Path<BezierCurveProps> {
    shape: BezierCurveShape;
    constructor(opts?: BezierCurveProps);
    getDefaultStyle(): {
        stroke: string;
        fill: string;
    };
    getDefaultShape(): BezierCurveShape;
    buildPath(ctx: CanvasRenderingContext2D, shape: BezierCurveShape): void;
    /**
     * Get point at percent
     */
    pointAt(t: number): number[];
    /**
     * Get tangent at percent
     */
    tangentAt(t: number): number[];
}

 interface BezierCurveProps extends PathProps {
    shape?: Partial<BezierCurveShape>;
}

 class BezierCurveShape {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    cpx1: number;
    cpy1: number;
    cpx2?: number;
    cpy2?: number;
    percent: number;
}

export  class BidirectionalMap {
    fwdMap: {
        [sid: string]: number;
    };
    revMap: {
        [index: number]: string;
    };
    constructor(map: {
        [key: string]: number;
    });
    get(key: string): number | undefined;
    getByValue(value: number): string;
    add(sid: string, index: number): void;
    remove(sid: string): void;
    removeByValue(index: number): void;
}

export  const Billboard: ({ object, follow, lockX, lockY, lockZ, baseOnPreRotation, }: BillboardProps) => BillboardType;

/**
 * 
 */
export  class BillboardModule extends EntityModuleBase implements IEntityModuleBase {
    static moduleName: string;
    options: BillboardProps;
    billboard: BillboardType;
    constructor(entity: Entity, options?: BillboardProps);
    setupUiConfig(): UiObjectConfig;
    onAppUpdate(time: Time): void;
}

export  type BillboardProps = {
    object?: Object3D;
    /**
     * @default true
     */
    follow?: boolean;
    /**
     * @default false
     */
    lockX?: boolean;
    /**
     * @default false
     */
    lockY?: boolean;
    /**
     * @default false
     */
    lockZ?: boolean;
    /**
     * 
     * @default false
     */
    baseOnPreRotation?: boolean;
};

export  interface BillBoardSettings {
}

export  type BillboardType = {
    object: Object3D;
    /**
     * Should called every frame to update the billboard
     */
    update: (camera: Camera) => void;
    dispose: () => void;
    updateProps: (newProps: Partial<BillboardProps>) => void;
};

 const bind: FunctionBind;

 type Bind1<F, Ctx> = F extends (this: Ctx, ...args: infer A) => infer R ? (...args: A) => R : unknown;

 type Bind2<F, Ctx, T1> = F extends (this: Ctx, a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;

 type Bind3<F, Ctx, T1, T2> = F extends (this: Ctx, a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;

 type Bind4<F, Ctx, T1, T2, T3> = F extends (this: Ctx, a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;

 type Bind5<F, Ctx, T1, T2, T3, T4> = F extends (this: Ctx, a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param fns list of member function names
 * @param context the context value
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
export  function bindAll(fns: string[], context: Object): void;

 type BindFunc<Ctx> = (this: Ctx, ...arg: any[]) => any;

/**
 * Dynamically sized bit field
 * @constructor
 */
export  function BitSet(): void;

export  namespace BitSet {
    var fixedSize: (x: any) => any;
}



/**
 * Convert a blob to a data url.
 * @param blob - blob to convert
 * @category Browser
 */
export  function blobToDataURL(blob: Blob): Promise<string>;



 class BlurPass {
    renderTargetA: WebGLRenderTarget;
    renderTargetB: WebGLRenderTarget;
    convolutionMaterial: ConvolutionMaterial;
    scene: Scene;
    camera: Camera;
    screen: Mesh;
    renderToScreen: boolean;
    constructor({ gl, resolution, width, height, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, }: BlurPassProps);
    render(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, outputBuffer: WebGLRenderTarget): void;
}

 interface BlurPassProps {
    gl: WebGLRenderer;
    resolution: number;
    width?: number;
    height?: number;
    minDepthThreshold?: number;
    maxDepthThreshold?: number;
    depthScale?: number;
    depthToBlurRatioBias?: number;
}

/**
 * Base class for all body types.
 * @example
 *     const shape = new CANNON.Sphere(1)
 *     const body = new CANNON.Body({
 *       mass: 1,
 *       shape,
 *     })
 *     world.addBody(body)
 */
 class Body_2 extends EventTarget_2 {
    static idCounter: number;
    /**
     * Dispatched after two bodies collide. This event is dispatched on each
     * of the two bodies involved in the collision.
     * @event collide
     * @param body The body that was involved in the collision.
     * @param contact The details of the collision.
     */
    static COLLIDE_EVENT_NAME: string;
    /**
     * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
     */
    static DYNAMIC: 1;
    /**
     * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
     */
    static STATIC: 2;
    /**
     * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
     */
    static KINEMATIC: 4;
    /**
     * AWAKE
     */
    static AWAKE: 0;
    /**
     * SLEEPY
     */
    static SLEEPY: 1;
    /**
     * SLEEPING
     */
    static SLEEPING: 2;
    /**
     * Dispatched after a sleeping body has woken up.
     * @event wakeup
     */
    static wakeupEvent: {
        type: string;
    };
    /**
     * Dispatched after a body has gone in to the sleepy state.
     * @event sleepy
     */
    static sleepyEvent: {
        type: string;
    };
    /**
     * Dispatched after a body has fallen asleep.
     * @event sleep
     */
    static sleepEvent: {
        type: string;
    };
    /**
     * Identifier of the body.
     */
    id: number;
    /**
     * Position of body in World.bodies. Updated by World and used in ArrayCollisionMatrix.
     */
    index: number;
    /**
     * Reference to the world the body is living in.
     */
    world: World | null;
    vlambda: Vec3;
    /**
     * The collision group the body belongs to.
     * @default 1
     */
    collisionFilterGroup: number;
    /**
     * The collision group the body can collide with.
     * @default -1
     */
    collisionFilterMask: number;
    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
     */
    collisionResponse: boolean;
    /**
     * World space position of the body.
     */
    position: Vec3;
    previousPosition: Vec3;
    /**
     * Interpolated position of the body.
     */
    interpolatedPosition: Vec3;
    /**
     * Initial position of the body.
     */
    initPosition: Vec3;
    /**
     * World space velocity of the body.
     */
    velocity: Vec3;
    /**
     * Initial velocity of the body.
     */
    initVelocity: Vec3;
    /**
     * Linear force on the body in world space.
     */
    force: Vec3;
    /**
     * The mass of the body.
     * @default 0
     */
    mass: number;
    invMass: number;
    /**
     * The physics material of the body. It defines the body interaction with other bodies.
     */
    material: Material_2 | null;
    /**
     * How much to damp the body velocity each step. It can go from 0 to 1.
     * @default 0.01
     */
    linearDamping: number;
    /**
     * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
     */
    type: BodyType;
    /**
     * If true, the body will automatically fall to sleep.
     * @default true
     */
    allowSleep: boolean;
    /**
     * Current sleep state.
     */
    sleepState: BodySleepState;
    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @default 0.1
     */
    sleepSpeedLimit: number;
    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @default 1
     */
    sleepTimeLimit: number;
    timeLastSleepy: number;
    wakeUpAfterNarrowphase: boolean;
    /**
     * World space rotational force on the body, around center of mass.
     */
    torque: Vec3;
    /**
     * World space orientation of the body.
     */
    quaternion: Quaternion_2;
    /**
     * Initial quaternion of the body.
     */
    initQuaternion: Quaternion_2;
    previousQuaternion: Quaternion_2;
    /**
     * Interpolated orientation of the body.
     */
    interpolatedQuaternion: Quaternion_2;
    /**
     * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
     */
    angularVelocity: Vec3;
    /**
     * Initial angular velocity of the body.
     */
    initAngularVelocity: Vec3;
    /**
     * List of Shapes that have been added to the body.
     */
    shapes: Shape[];
    /**
     * Position of each Shape in the body, given in local Body space.
     */
    shapeOffsets: Vec3[];
    /**
     * Orientation of each Shape, given in local Body space.
     */
    shapeOrientations: Quaternion_2[];
    /**
     * The inertia of the body.
     */
    inertia: Vec3;
    invInertia: Vec3;
    invInertiaWorld: Mat3;
    invMassSolve: number;
    invInertiaSolve: Vec3;
    invInertiaWorldSolve: Mat3;
    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
     * @default false
     */
    fixedRotation: boolean;
    /**
     * How much to damp the body angular velocity each step. It can go from 0 to 1.
     * @default 0.01
     */
    angularDamping: number;
    /**
     * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
     */
    linearFactor: Vec3;
    /**
     * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
     */
    angularFactor: Vec3;
    /**
     * World space bounding box of the body and its shapes.
     */
    aabb: AABB;
    /**
     * Indicates if the AABB needs to be updated before use.
     */
    aabbNeedsUpdate: boolean;
    /**
     * Total bounding radius of the Body including its shapes, relative to body.position.
     */
    boundingRadius: number;
    wlambda: Vec3;
    /**
     * When true the body behaves like a trigger. It does not collide
     * with other bodies but collision events are still triggered.
     * @default false
     */
    isTrigger: boolean;
    entity?: Entity;
    object3d?: Object3D;
    constructor(options?: {
        /**
         * The collision group the body belongs to.
         * @default 1
         */
        collisionFilterGroup?: number;
        /**
         * The collision group the body can collide with.
         * @default -1
         */
        collisionFilterMask?: number;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
         */
        collisionResponse?: boolean;
        /**
         * World space position of the body.
         */
        position?: Vec3;
        /**
         * World space velocity of the body.
         */
        velocity?: Vec3;
        /**
         * The mass of the body.
         * @default 0
         */
        mass?: number;
        /**
         * The physics material of the body. It defines the body interaction with other bodies.
         */
        material?: Material_2;
        /**
         * How much to damp the body velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        linearDamping?: number;
        /**
         * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
         */
        type?: BodyType;
        /**
         * If true, the body will automatically fall to sleep.
         * @default true
         */
        allowSleep?: boolean;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @default 0.1
         */
        sleepSpeedLimit?: number;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @default 1
         */
        sleepTimeLimit?: number;
        /**
         * World space orientation of the body.
         */
        quaternion?: Quaternion_2;
        /**
         * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
         */
        angularVelocity?: Vec3;
        /**
         * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
         * @default false
         */
        fixedRotation?: boolean;
        /**
         * How much to damp the body angular velocity each step. It can go from 0 to 1.
         * @default 0.01
         */
        angularDamping?: number;
        /**
         * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
         */
        linearFactor?: Vec3;
        /**
         * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
         */
        angularFactor?: Vec3;
        /**
         * Add a Shape to the body.
         */
        shape?: Shape;
        /**
         * When true the body behaves like a trigger. It does not collide
         * with other bodies but collision events are still triggered.
         * @default false
         */
        isTrigger?: boolean;
    });
    /**
     * Wake the body up.
     */
    wakeUp(): void;
    /**
     * Force body sleep
     */
    sleep(): void;
    /**
     * Called every timestep to update internal sleep timer and change sleep state if needed.
     * @param time The world time in seconds
     */
    sleepTick(time: number): void;
    /**
     * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
     */
    updateSolveMassProperties(): void;
    /**
     * Convert a world point to local body frame.
     */
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a world vector to local body frame.
     */
    vectorToLocalFrame(worldVector: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a local body point to world frame.
     */
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;
    /**
     * Convert a local body point to world frame.
     */
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
    /**
     * Add a shape to the body with a local offset and orientation.
     * @return The body object, for chainability.
     */
    addShape(shape: Shape, _offset?: Vec3, _orientation?: Quaternion_2): Body_2;
    /**
     * Remove a shape from the body.
     * @return The body object, for chainability.
     */
    removeShape(shape: Shape): Body_2;
    /**
     * Update the bounding radius of the body. Should be done if any of the shapes are changed.
     */
    updateBoundingRadius(): void;
    /**
     * Updates the .aabb
     */
    updateAABB(): void;
    /**
     * Update `.inertiaWorld` and `.invInertiaWorld`
     */
    updateInertiaWorld(force?: boolean): void;
    /**
     * Apply force to a point of the body. This could for example be a point on the Body surface.
     * Applying force this way will add to Body.force and Body.torque.
     * @param force The amount of force to add.
     * @param relativePoint A point relative to the center of mass to apply the force on.
     */
    applyForce(force: Vec3, relativePoint?: Vec3): void;
    /**
     * Apply force to a local point in the body.
     * @param force The force vector to apply, defined locally in the body frame.
     * @param localPoint A local point in the body to apply the force on.
     */
    applyLocalForce(localForce: Vec3, localPoint?: Vec3): void;
    /**
     * Apply torque to the body.
     * @param torque The amount of torque to add.
     */
    applyTorque(torque: Vec3): void;
    /**
     * Apply impulse to a point of the body. This could for example be a point on the Body surface.
     * An impulse is a force added to a body during a short period of time (impulse = force * time).
     * Impulses will be added to Body.velocity and Body.angularVelocity.
     * @param impulse The amount of impulse to add.
     * @param relativePoint A point relative to the center of mass to apply the force on.
     */
    applyImpulse(impulse: Vec3, relativePoint?: Vec3): void;
    /**
     * Apply locally-defined impulse to a local point in the body.
     * @param force The force vector to apply, defined locally in the body frame.
     * @param localPoint A local point in the body to apply the force on.
     */
    applyLocalImpulse(localImpulse: Vec3, localPoint?: Vec3): void;
    /**
     * Should be called whenever you change the body shape or mass.
     */
    updateMassProperties(): void;
    /**
     * Get world velocity of a point in the body.
     * @param worldPoint
     * @param result
     * @return The result vector.
     */
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;
    /**
     * Move the body forward in time.
     * @param dt Time step
     * @param quatNormalize Set to true to normalize the body quaternion
     * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
     */
    integrate(dt: number, quatNormalize: boolean, quatNormalizeFast: boolean): void;
}

/**
 * BODY_SLEEP_STATES
 */
 const BODY_SLEEP_STATES: {
    /** AWAKE */
    readonly AWAKE: 0;
    /** SLEEPY */
    readonly SLEEPY: 1;
    /** SLEEPING */
    readonly SLEEPING: 2;
};

/**
 * BODY_TYPES
 */
 const BODY_TYPES: {
    /** DYNAMIC */
    readonly DYNAMIC: 1;
    /** STATIC */
    readonly STATIC: 2;
    /** KINEMATIC */
    readonly KINEMATIC: 4;
};

 type BodyOptions = ConstructorParameters<typeof Body_2>[0];

/**
 * BodySleepState
 */
 type BodySleepState = typeof BODY_SLEEP_STATES[keyof typeof BODY_SLEEP_STATES];

/**
 * BodyType
 */
 type BodyType = typeof BODY_TYPES[keyof typeof BODY_TYPES];

 class BoundingRect {
    x: number;
    y: number;
    width: number;
    height: number;
    constructor(x: number, y: number, width: number, height: number);
    union(other: BoundingRect): void;
    applyTransform(m: matrix.MatrixArray): void;
    calculateTransform(b: RectLike): matrix.MatrixArray;
    intersect(b: RectLike, mtv?: PointLike): boolean;
    contain(x: number, y: number): boolean;
    clone(): BoundingRect;
    /**
     * Copy from another rect
     */
    copy(other: RectLike): void;
    plain(): RectLike;
    /**
     * If not having NaN or Infinity with attributes
     */
    isFinite(): boolean;
    isZero(): boolean;
    static create(rect: RectLike): BoundingRect;
    static copy(target: RectLike, source: RectLike): void;
    static applyTransform(target: RectLike, source: RectLike, m: matrix.MatrixArray): void;
}

/**
 * A 3d box shape.
 * @example
 *     const size = 1
 *     const halfExtents = new CANNON.Vec3(size, size, size)
 *     const boxShape = new CANNON.Box(halfExtents)
 *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
 *     world.addBody(boxBody)
 */
 class Box extends Shape {
    /**
     * The half extents of the box.
     */
    halfExtents: Vec3;
    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example.
     */
    convexPolyhedronRepresentation: ConvexPolyhedron;
    constructor(halfExtents: Vec3);
    /**
     * Updates the local convex polyhedron representation used for some collisions.
     */
    updateConvexPolyhedronRepresentation(): void;
    /**
     * Calculate the inertia of the box.
     */
    calculateLocalInertia(mass: number, target?: Vec3): Vec3;
    static calculateInertia(halfExtents: Vec3, mass: number, target: Vec3): void;
    /**
     * Get the box 6 side normals
     * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
     * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
     */
    getSideNormals(sixTargetVectors: Vec3[], quat: Quaternion_2): Vec3[];
    /**
     * Returns the volume of the box.
     */
    volume(): number;
    /**
     * updateBoundingSphereRadius
     */
    updateBoundingSphereRadius(): void;
    /**
     * forEachWorldCorner
     */
    forEachWorldCorner(pos: Vec3, quat: Quaternion_2, callback: (x: number, y: number, z: number) => void): void;
    /**
     * calculateWorldAABB
     */
    calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
}

export  class BoxHelper extends Group_2 {
    lineSegs: LineSegments;
    object: Object3D;
    mesh: Mesh;
    options: BoxHelperOptions;
    box3: Box3;
    constructor(object: Object3D | Box3, options?: BoxHelperOptions);
    update(): void;
    setFromObject(object: Object3D): this;
    copy(source: any, recursive: any): this;
    dispose(): void;
}

export  interface BoxHelperOptions {
    /**  */
    lineColor?: ColorRepresentation;
    /**  */
    fillColor?: ColorRepresentation;
    /**  */
    fillOpacity?: number;
    /**  */
    lineMaterialParam?: LineBasicMaterialParameters;
    /**  */
    fillMaterialParam?: MeshBasicMaterialParameters;
}

export  type BoxParameters = {
    x: number;
    y: number;
    z: number;
};

/**
 * Utility behavior that works just like an IF/ELSE statement
 * If you are not sure if this is the right behavior for your use-case, consider using a selector behavior instead,
 * as selector is a more commonly applicable behavior type
 */
export  class BranchBehavior extends Behavior {
    #private;
    constructor();
    /**
     *
     * @param {Behavior} condition
     * @param {Behavior} successBranch
     * @param {Behavior} failureBranch
     */
    static from(condition: Behavior, successBranch?: Behavior, failureBranch?: Behavior): BranchBehavior;
    initialize(context: BehaviorContext): void;
    tick(timeDelta: number): any;
    finalize(): void;
}

/**
 * .
 */
export  class BreathingApertureMarker extends AnimateMarkerBase {
    constructor(features: FeatureCollection | {
        position: [number, number, number?];
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    _createMarker(): void;
    private _createMakerElement;
    setMarkersWidth(width: number, index?: number): void;
    private _setBreathingApertureWidth;
    setDotSize(size: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
}

/**
 * Base class for broadphase implementations
 * @author schteppe
 */
 class Broadphase {
    /**
     * The world to search for collisions in.
     */
    world: World | null;
    /**
     * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
     */
    useBoundingBoxes: boolean;
    /**
     * Set to true if the objects in the world moved.
     */
    dirty: boolean;
    constructor();
    /**
     * Get the collision pairs from the world
     * @param world The world to search in
     * @param p1 Empty array to be filled with body objects
     * @param p2 Empty array to be filled with body objects
     */
    collisionPairs(world: World, p1: Body_2[], p2: Body_2[]): void;
    /**
     * Check if a body pair needs to be intersection tested at all.
     */
    needBroadphaseCollision(bodyA: Body_2, bodyB: Body_2): boolean;
    /**
     * Check if the bounding volumes of two bodies intersect.
     */
    intersectionTest(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Check if the bounding spheres of two bodies are intersecting.
     * @param pairs1 bodyA is appended to this array if intersection
     * @param pairs2 bodyB is appended to this array if intersection
     */
    doBoundingSphereBroadphase(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Check if the bounding boxes of two bodies are intersecting.
     */
    doBoundingBoxBroadphase(bodyA: Body_2, bodyB: Body_2, pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * Removes duplicate pairs from the pair arrays.
     */
    makePairsUnique(pairs1: Body_2[], pairs2: Body_2[]): void;
    /**
     * To be implemented by subcasses
     */
    setWorld(world: World): void;
    /**
     * Check if the bounding spheres of two bodies overlap.
     */
    static boundingSphereCheck(bodyA: Body_2, bodyB: Body_2): boolean;
    /**
     * Returns all the bodies within the AABB.
     */
    aabbQuery(world: World, aabb: AABB, result: Body_2[]): Body_2[];
}

 class Brush extends Mesh {
    isBrush: boolean;
    markUpdated(): void;
    isDirty(): boolean;
    prepareGeometry(): void;
    disposeCacheData(): void;
}

export  class BufferShader {
    width: number;
    height: number;
    common: string;
    outputBuffer: WebGLRenderTarget;
    readBuffer: WebGLRenderTarget;
    opacityColor?: Color;
    materialParameters?: MaterialParameters;
    uniformsDefs: string;
    hsbExpr: string;
    iChannel: (Texture | BufferShader)[];
    uniforms: {
        iChannel0: {
            value: Texture;
        };
        iChannel1: {
            value: Texture;
        };
        iChannel2: {
            value: Texture;
        };
        iChannel3: {
            value: Texture;
        };
    };
    camera: OrthographicCamera;
    scene: Scene;
    enabled: boolean;
    plane: Mesh<PlaneGeometry, Material | Material[]>;
    set shader(value: string);
    constructor(width: number, height: number, opacityColor?: Color, materialParameters?: MaterialParameters, renderTargetOptions?: RenderTargetOptions, uniformsDefs?: string, hsbExpr?: string);
    swap(): void;
    private getIChannel;
    render(renderer: WebGLRenderer): void;
}

/**
 * Topo
 */
export  function buildPathTubeTopo(input: {
    /**  */
    paths: [number, number, number][];
    /**  false */
    disableMergeNode?: boolean;
    /**  */
    [key: string]: any;
}[], opts?: {
    /** 6 */
    decimalPrecision?: number;
    /** nodeIntersect nodeIntersect nodeEqual  */
    topoStrategy?: "nodeIntersect" | "nodeEqual";
}): {
    inputData: {
        [key: string]: any;
        /**  */
        paths: [number, number, number][];
        /**  false */
        disableMergeNode?: boolean;
    }[];
    topo: {
        /**  */
        tubes: {
            /** ID */
            tubeIndex: number;
            /**  */
            data: Record<string, any>;
            /** ID */
            startNodeId: string;
            /** ID */
            endNodeId: string;
        }[];
        /**  <ID > */
        nodes: Map<string, number[]>;
    };
};

/**
 * topo
 * @param lines 
 * @param precision  , 
 * @param hasDirection 
 * @return {{topo: any, graph: {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => NodeId[], addNode: (node: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => NodeId[], shortestPath: (source: NodeId, destination: NodeId) => NodeId[] & {weight?: EdgeWeight}, setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => NodeId[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, ...}}}
             */
         export  function buildTopoGraph(lines: Array<{
             points: GeoPoint[];
             id?: string;
             weight?: number;
         }>, precision?: number, hasDirection?: boolean): {
             graph: {
                 addNode: (node: string) => any;
                 removeNode: (node: string) => any;
                 nodes: () => string[];
                 adjacent: (node: string) => string[];
                 addEdge: (u: string, v: string, weight?: number) => any;
                 removeEdge: (u: string, v: string) => any;
                 hasEdge: (u: string, v: string) => boolean;
                 setEdgeWeight: (u: string, v: string, weight: number) => any;
                 getEdgeWeight: (u: string, v: string) => number;
                 indegree: (node: string) => number;
                 outdegree: (node: string) => number;
                 depthFirstSearch: (sourceNodes?: string[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
                 hasCycle: () => boolean;
                 lowestCommonAncestors: (node1: string, node2: string) => string[];
                 topologicalSort: (sourceNodes?: string[], includeSourceNodes?: boolean) => string[];
                 shortestPath: (source: string, destination: string) => string[] & {
                     weight?: number;
                 };
                 serialize: () => Serialized;
                 deserialize: (serialized: Serialized) => any;
             };
             topo: any;
         };

          type Builtin = Primitive | Function | Date | Error | RegExp;

          type BuiltinTextPosition = 'left' | 'right' | 'top' | 'bottom' | 'inside' | 'insideLeft' | 'insideRight' | 'insideTop' | 'insideBottom' | 'insideTopLeft' | 'insideTopRight' | 'insideBottomLeft' | 'insideBottomRight';

         export  interface BurstParameters {
             time: number;
             count: ValueGenerator | FunctionValueGenerator;
             cycle: number;
             interval: number;
             probability: number;
         }

         /**
          * Interface representing the JSON parameters for a burst.
          */
         export  interface BurstParametersJSON {
             /**
              * The time of the burst.
              */
             time: number;
             /**
              * The count of particles to emit, can be a number or a function.
              */
             count: FunctionJSON | number;
             /**
              * The cycle of the burst.
              */
             cycle: number;
             /**
              * The interval between bursts.
              */
             interval: number;
             /**
              * The probability of the burst occurring.
              */
             probability: number;
         }

         /**  */
         export  class ButtonGroupControl {
             app: App;
             container: HTMLElement;
             style: Record<string, any>;
             panel: HTMLElement;
             options: ButtonGroupControlOptions;
             constructor(options: ButtonGroupControlOptions);
             _insertControl(): void;
             onAdd(app: any): HTMLElement;
             onRemove(): void;
             setTheme(isLightTheme?: boolean): void;
             getDefaultPosition(): string;
         }

         export  interface ButtonGroupControlOptions {
             buttons: {
                 id: string;
                 /**  */
                 icon?: string;
                 /** html (icon)*/
                 html?: string;
                 /**  */
                 title?: string;
                 /**  */
                 toggle?: boolean;
                 /**  */
                 onclick?: Function;
                 /**  */
                 classList?: string[];
                 /**  */
                 checked?: boolean;
                 /**  */
                 round?: boolean;
                 /**  */
                 style?: Partial<CSSStyleDeclaration>;
             }[];
             direction?: "row" | "column";
             lightTheme?: boolean;
             barSelectMode?: boolean;
             barCurSelectId?: string;
         }

         export  class CallFunctionCommand<T> extends BaseCommand {
             private target;
             private executeFn;
             private executeArgs;
             private undoFn?;
             private undoArgs?;
             constructor(target: T, executeFn: (this: T, ...args: any[]) => void, executeArgs: any[], undoFn?: (this: T, ...args: any[]) => void, undoArgs?: any[]);
             execute(): void;
             undo(): void;
             redo(): void;
         }

         export  class CameraControls extends EventDispatcher {
             #private;
             static install(): void;
             /**
              * list all ACTIONs
              * @category Statics
              */
             static get ACTION(): typeof ACTION;
             /**
              * Minimum vertical angle in radians.
              * The angle has to be between `0` and `.maxPolarAngle` inclusive.
              * The default value is `0`.
              *
              * e.g.
              * ```
              * cameraControls.maxPolarAngle = 0;
              * ```
              * @category Properties
              */
             minPolarAngle: number;
             /**
              * Maximum vertical angle in radians.
              * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
              * The default value is `Math.PI`.
              *
              * e.g.
              * ```
              * cameraControls.maxPolarAngle = Math.PI;
              * ```
              * @category Properties
              */
             maxPolarAngle: number;
             /**
              * Minimum horizontal angle in radians.
              * The angle has to be less than `.maxAzimuthAngle`.
              * The default value is `- Infinity`.
              *
              * e.g.
              * ```
              * cameraControls.minAzimuthAngle = - Infinity;
              * ```
              * @category Properties
              */
             minAzimuthAngle: number;
             /**
              * Maximum horizontal angle in radians.
              * The angle has to be greater than `.minAzimuthAngle`.
              * The default value is `Infinity`.
              *
              * e.g.
              * ```
              * cameraControls.maxAzimuthAngle = Infinity;
              * ```
              * @category Properties
              */
             maxAzimuthAngle: number;
             /**
              * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
              * PerspectiveCamera only.
              * @category Properties
              */
             minDistance: number;
             /**
              * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
              * PerspectiveCamera only.
              * @category Properties
              */
             maxDistance: number;
             /**
              * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
              * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
              * @category Properties
              */
             infinityDolly: boolean;
             /**
              * Minimum camera zoom.
              * @category Properties
              */
             minZoom: number;
             /**
              * Maximum camera zoom.
              * @category Properties
              */
             maxZoom: number;
             /**
              * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
              * @category Properties
              */
             smoothTime: number;
             /**
              * the smoothTime while dragging
              * @category Properties
              */
             draggingSmoothTime: number;
             /**
              * Max transition speed in unit-per-seconds
              * @category Properties
              */
             maxSpeed: number;
             /**
              * Speed of azimuth (horizontal) rotation.
              * @category Properties
              */
             azimuthRotateSpeed: number;
             /**
              * Speed of polar (vertical) rotation.
              * @category Properties
              */
             polarRotateSpeed: number;
             /**
              * Speed of mouse-wheel dollying.
              * @category Properties
              */
             dollySpeed: number;
             /**
              * `true` to invert direction when dollying or zooming via drag
              * @category Properties
              */
             dollyDragInverted: boolean;
             /**
              * Speed of drag for pan and pedestal.
              * @category Properties
              */
             truckSpeed: number;
             /**
              * `true` to enable Dolly-in to the mouse cursor coords.
              * @category Properties
              */
             dollyToCursor: boolean;
             /**
              * @category Properties
              */
             dragToOffset: boolean;
             /**
              * if true, pan in screen-space
              * @category Properties
              */
             verticalDragToForward: boolean;
             /**
              * Friction ratio of the boundary.
              * @category Properties
              */
             boundaryFriction: number;
             /**
              * Controls how soon the `rest` event fires as the camera slows.
              * @category Properties
              */
             restThreshold: number;
             /**
              * An array of Meshes to collide with camera.
              * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
              * @category Properties
              */
             colliderMeshes: Object3D[];
             /**
              * User's mouse input config.
              *
              * | button to assign      | behavior |
              * | --------------------- | -------- |
              * | `mouseButtons.left`   | `CameraControls.ACTION.ROTATE`* \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
              * | `mouseButtons.right`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK`* \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
              * | `mouseButtons.wheel`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
              * | `mouseButtons.middle`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY`* \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
              *
              * 1. Mouse wheel event for scroll "up/down" on mac "up/down/left/right"
              * 2. Mouse click on wheel event "button"
              * - \* is the default.
              * - The default of `mouseButtons.wheel` is:
              *   - `DOLLY` for Perspective camera.
              *   - `ZOOM` for Orthographic camera, and can't set `DOLLY`.
              * @category Properties
              */
             mouseButtons: MouseButtons;
             /**
              * User's touch input config.
              *
              * | fingers to assign     | behavior |
              * | --------------------- | -------- |
              * | `touches.one` | `CameraControls.ACTION.TOUCH_ROTATE`* \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.DOLLY` | `CameraControls.ACTION.ZOOM` | `CameraControls.ACTION.NONE` |
              * | `touches.two` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `ACTION.TOUCH_DOLLY` \| `ACTION.TOUCH_ZOOM` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
              * | `touches.three` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
              *
              * - \* is the default.
              * - The default of `touches.two` and `touches.three` is:
              *   - `TOUCH_DOLLY_TRUCK` for Perspective camera.
              *   - `TOUCH_ZOOM_TRUCK` for Orthographic camera, and can't set `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY`.
              * @category Properties
              */
             touches: Touches;
             dblClickSetToCenter: boolean;
             /**
              * Force cancel user dragging.
              * @category Methods
              */
             cancel: () => void;
             /**
              * Still an experimental feature.
              * This could change at any time.
              * @category Methods
              */
             lockPointer: () => void;
             /**
              * Still an experimental feature.
              * This could change at any time.
              * @category Methods
              */
             unlockPointer: () => void;
             protected _enabled: boolean;
             enableWheelWhenCtrlDisabled: boolean;
             eventFromInputModule: boolean;
             protected _camera: PerspectiveCamera | OrthographicCamera;
             protected _yAxisUpSpace: Quaternion;
             protected _yAxisUpSpaceInverse: Quaternion;
             protected _state: ACTION;
             protected _domElement?: HTMLElement;
             protected _viewport: Vector4 | null;
             protected _target: Vector3;
             protected _targetEnd: Vector3;
             protected _focalOffset: Vector3;
             protected _focalOffsetEnd: Vector3;
             protected _spherical: Spherical;
             protected _sphericalEnd: Spherical;
             protected _lastDistance: number;
             protected _zoom: number;
             protected _zoomEnd: number;
             protected _lastZoom: number;
             protected _cameraUp0: Vector3;
             protected _target0: Vector3;
             protected _position0: Vector3;
             protected _zoom0: number;
             protected _focalOffset0: Vector3;
             protected _dollyControlCoord: Vector2;
             protected _changedDolly: number;
             protected _changedZoom: number;
             protected _nearPlaneCorners: [Vector3, Vector3, Vector3, Vector3];
             protected _hasRested: boolean;
             protected _boundary: Box3;
             protected _boundaryEnclosesCamera: boolean;
             protected _needsUpdate: boolean;
             protected _updatedLastTime: boolean;
             protected _elementRect: DOMRect;
             protected _isDragging: boolean;
             protected _activePointers: PointerInput[];
             protected _lockedPointer: PointerInput | null;
             protected _interactiveArea: DOMRect;
             protected _isUserControllingRotate: boolean;
             protected _isUserControllingDolly: boolean;
             protected _isUserControllingTruck: boolean;
             protected _isUserControllingOffset: boolean;
             protected _isUserControllingZoom: boolean;
             protected _lastDollyDirection: DOLLY_DIRECTION;
             protected _thetaVelocity: RefTypeValue;
             protected _phiVelocity: RefTypeValue;
             protected _radiusVelocity: RefTypeValue;
             protected _targetVelocity: Vector3;
             protected _focalOffsetVelocity: Vector3;
             protected _zoomVelocity: RefTypeValue;
             protected _targetMarker: Marker2D;
             app: App;
             /**
              * Creates a `CameraControls` instance.
              *
              * Note:
              * You **must install** three.js before using camera-controls. see [#install](#install)
              * Not doing so will lead to runtime errors (`undefined` references to THREE).
              *
              * e.g.
              * ```
              * CameraControls.install( { THREE } );
              * const cameraControls = new CameraControls( camera, domElement );
              * ```
              *
              * @param camera A `PerspectiveCamera` or `OrthographicCamera` to be controlled.
              * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
              * @category Constructor
              */
             constructor(app: App, domElement?: HTMLElement, eventFromInputModule?: boolean);
             /**
              * The camera to be controlled
              * @category Properties
              */
             get camera(): PerspectiveCamera | OrthographicCamera;
             set camera(camera: PerspectiveCamera | OrthographicCamera);
             /**
              * Whether or not the controls are enabled.
              * `false` to disable user dragging/touch-move, but all methods works.
              * @category Properties
              */
             get enabled(): boolean;
             set enabled(enabled: boolean);
             /**
              * Returns `true` if the controls are active updating.
              * readonly value.
              * @category Properties
              */
             get active(): boolean;
             /**
              * Getter for the current `ACTION`.
              * readonly value.
              * @category Properties
              */
             get currentAction(): ACTION;
             /**
              * get/set Current distance.
              * @category Properties
              */
             get distance(): number;
             set distance(distance: number);
             /**
              * get/set the azimuth angle (horizontal) in radians.
              * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
              * @category Properties
              */
             get azimuthAngle(): number;
             set azimuthAngle(azimuthAngle: number);
             /**
              * get/set the polar angle (vertical) in radians.
              * @category Properties
              */
             get polarAngle(): number;
             set polarAngle(polarAngle: number);
             /**
              * Whether camera position should be enclosed in the boundary or not.
              * @category Properties
              */
             get boundaryEnclosesCamera(): boolean;
             set boundaryEnclosesCamera(boundaryEnclosesCamera: boolean);
             /**
              * Set drag-start, touches and wheel enable area in the domElement.
              * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
              * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
              * @category Properties
              */
             set interactiveArea(interactiveArea: DOMRect | {
                 x: number;
                 y: number;
                 width: number;
                 height: number;
             });
             /**
              * Adds the specified event listener.
              * Applicable event types (which is `K`) are:
              * | Event name          | Timing |
              * | ------------------- | ------ |
              * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
              * | `'control'`         | When the user controls the camera (dragging). |
              * | `'controlend'`      | When the user ends to control the camera.  |
              * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
              * | `'update'`          | When the camera position is updated. |
              * | `'wake'`            | When the camera starts moving. |
              * | `'rest'`            | When the camera movement is below `.restThreshold` . |
              * | `'sleep'`           | When the camera end moving. |
              *
              * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
              * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
              *
              * e.g.
              * ```
              * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
              * ```
              * @param type event name
              * @param listener handler function
              * @category Methods
              */
             addEventListener<K extends keyof CameraControlsEventMap>(type: K, listener: (event: CameraControlsEventMap[K]) => any): void;
             /**
              * Removes the specified event listener
              * e.g.
              * ```
              * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
              * ```
              * @param type event name
              * @param listener handler function
              * @category Methods
              */
             removeEventListener<K extends keyof CameraControlsEventMap>(type: K, listener: (event: CameraControlsEventMap[K]) => any): void;
             /**
              * Rotate azimuthal angle(horizontal) and polar angle(vertical).
              * Every value is added to the current value.
              * @param azimuthAngle Azimuth rotate angle. In radian.
              * @param polarAngle Polar rotate angle. In radian.
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             rotate(azimuthAngle: number, polarAngle: number, enableTransition?: boolean): Promise<void>;
             /**
              * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
              *
              * e.g.
              * ```
              * cameraControls.rotateAzimuthTo( 30 * MathUtils.DEG2RAD, true );
              * ```
              * @param azimuthAngle Azimuth rotate angle. In radian.
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             rotateAzimuthTo(azimuthAngle: number, enableTransition?: boolean): Promise<void>;
             /**
              * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
              *
              * e.g.
              * ```
              * cameraControls.rotatePolarTo( 30 * MathUtils.DEG2RAD, true );
              * ```
              * @param polarAngle Polar rotate angle. In radian.
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             rotatePolarTo(polarAngle: number, enableTransition?: boolean): Promise<void>;
             /**
              * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
              * Camera view will rotate over the orbit pivot absolutely:
              *
              * azimuthAngle
              * ```
              *       0
              *         \
              * 90 -----+----- -90
              *           \
              *           180
              * ```
              * | direction | angle                  |
              * | --------- | ---------------------- |
              * | front     | 0                     |
              * | left      | 90 (`Math.PI / 2`)    |
              * | right     | -90 (`- Math.PI / 2`) |
              * | back      | 180 (`Math.PI`)       |
              *
              * polarAngle
              * ```
              *     180
              *      |
              *      90
              *      |
              *      0
              * ```
              * | direction            | angle                  |
              * | -------------------- | ---------------------- |
              * | top/sky              | 180 (`Math.PI`)       |
              * | horizontal from view | 90 (`Math.PI / 2`)    |
              * | bottom/floor         | 0                     |
              *
              * @param azimuthAngle Azimuth rotate angle to. In radian.
              * @param polarAngle Polar rotate angle to. In radian.
              * @param enableTransition  Whether to move smoothly or immediately
              * @category Methods
              */
             rotateTo(azimuthAngle: number, polarAngle: number, enableTransition?: boolean): Promise<void>;
             /**
              * Dolly in/out camera position.
              * @param distance Distance of dollyIn. Negative number for dollyOut.
              * @param enableTransition Whether to move smoothly or immediately.
              * @category Methods
              */
             dolly(distance: number, enableTransition?: boolean): Promise<void>;
             /**
              * Dolly in/out camera position to given distance.
              * @param distance Distance of dolly.
              * @param enableTransition Whether to move smoothly or immediately.
              * @category Methods
              */
             dollyTo(distance: number, enableTransition?: boolean): Promise<void>;
             protected _dollyToNoClamp(distance: number, enableTransition?: boolean): Promise<void>;
             /**
              * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
              * Specify a negative value for dolly out.
              * @param distance Distance of dolly.
              * @param enableTransition Whether to move smoothly or immediately.
              * @category Methods
              */
             dollyInFixed(distance: number, enableTransition?: boolean): Promise<void>;
             /**
              * Zoom in/out camera. The value is added to camera zoom.
              * Limits set with `.minZoom` and `.maxZoom`
              * @param zoomStep zoom scale
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             zoom(zoomStep: number, enableTransition?: boolean): Promise<void>;
             /**
              * Zoom in/out camera to given scale. The value overwrites camera zoom.
              * Limits set with .minZoom and .maxZoom
              * @param zoom
              * @param enableTransition
              * @category Methods
              */
             zoomTo(zoom: number, enableTransition?: boolean): Promise<void>;
             /**
              * pan and pedestal camera using current azimuthal angle
              * @param x Horizontal translate amount
              * @param y Vertical translate amount
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             pan(x: number, y: number, enableTransition?: boolean): Promise<void>;
             /**
              * Move forward / backward.
              * @param distance Amount to move forward / backward. Negative value to move backward
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             forward(distance: number, enableTransition?: boolean): Promise<void>;
             /**
              * Move up / down.
              * @param height Amount to move up / down. Negative value to move down
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             elevate(height: number, enableTransition?: boolean): Promise<void>;
             /**
              * Move target position to given point.
              * @param x x coord to move center position
              * @param y y coord to move center position
              * @param z z coord to move center position
              * @param enableTransition Whether to move smoothly or immediately
              * @category Methods
              */
             moveTo(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
             /**
              * Look in the given point direction.
              * @param x point x.
              * @param y point y.
              * @param z point z.
              * @param enableTransition Whether to move smoothly or immediately.
              * @returns Transition end promise
              * @category Methods
              */
             lookInDirectionOf(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
             /**
              * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
              * set `cover: true` to fill enter screen.
              * e.g.
              * ```
              * cameraControls.fitToBox( myMesh );
              * ```
              * @param box3OrObject Axis aligned bounding box to fit the view.
              * @param enableTransition Whether to move smoothly or immediately.
              * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
              * @returns Transition end promise
              * @category Methods
              */
             fitToBox(box3OrObject: Box3 | Object3D, enableTransition: boolean, { cover, paddingLeft, paddingRight, paddingBottom, paddingTop }?: Partial<FitToOptions>): Promise<void[]>;
             /**
              * Fit the viewport to the sphere or the bounding sphere of the object.
              * @param sphereOrMesh
              * @param enableTransition
              * @category Methods
              */
             fitToSphere(sphereOrMesh: Sphere | Object3D, enableTransition: boolean): Promise<void[]>;
             fitToRect(rect: {
                 width: number;
                 height: number;
                 center: [number, number, number];
                 normal: [number, number, number];
             }): void;
             /**
              * Look at the `target` from the `position`.
              * @param positionX
              * @param positionY
              * @param positionZ
              * @param targetX
              * @param targetY
              * @param targetZ
              * @param enableTransition
              * @category Methods
              */
             setLookAt(positionX: number, positionY: number, positionZ: number, targetX: number, targetY: number, targetZ: number, enableTransition?: boolean): Promise<void>;
             /**
              * Similar to setLookAt, but it interpolates between two states.
              * @param positionAX
              * @param positionAY
              * @param positionAZ
              * @param targetAX
              * @param targetAY
              * @param targetAZ
              * @param positionBX
              * @param positionBY
              * @param positionBZ
              * @param targetBX
              * @param targetBY
              * @param targetBZ
              * @param t
              * @param enableTransition
              * @category Methods
              */
             lerpLookAt(positionAX: number, positionAY: number, positionAZ: number, targetAX: number, targetAY: number, targetAZ: number, positionBX: number, positionBY: number, positionBZ: number, targetBX: number, targetBY: number, targetBZ: number, t: number, enableTransition?: boolean): Promise<void>;
             /**
              * Set angle and distance by given position.
              * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
              * @param positionX
              * @param positionY
              * @param positionZ
              * @param enableTransition
              * @category Methods
              */
             setPosition(positionX: number, positionY: number, positionZ: number, enableTransition?: boolean): Promise<void>;
             /**
              * Set the target position where gaze at.
              * An alias of `setLookAt()`, without position change. Thus keep the same position.
              * @param targetX
              * @param targetY
              * @param targetZ
              * @param enableTransition
              * @category Methods
              */
             setTarget(targetX: number, targetY: number, targetZ: number, enableTransition?: boolean): Promise<void>;
             /**
              * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
              * @param x
              * @param y
              * @param z
              * @param enableTransition
              * @category Methods
              */
             setFocalOffset(x: number, y: number, z: number, enableTransition?: boolean): Promise<void>;
             /**
              * Set orbit point without moving the camera.
              * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
              * @param targetX
              * @param targetY
              * @param targetZ
              * @category Methods
              */
             setOrbitPoint(targetX: number, targetY: number, targetZ: number): void;
             /**
              * Set the boundary box that encloses the target of the camera. box3 is in Box3
              * @param box3
              * @category Methods
              */
             setBoundary(box3?: Box3): void;
             /**
              * Set (or unset) the current viewport.
              * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
              * @param viewportOrX
              * @param y
              * @param width
              * @param height
              * @category Methods
              */
             setViewport(viewportOrX: Vector4 | number | null, y: number, width: number, height: number): void;
             /**
              * Calculate the distance to fit the box.
              * @param width box width
              * @param height box height
              * @param depth box depth
              * @returns distance
              * @category Methods
              */
             getDistanceToFitBox(width: number, height: number, depth: number, cover?: boolean): number;
             /**
              * Calculate the distance to fit the sphere.
              * @param radius sphere radius
              * @returns distance
              * @category Methods
              */
             getDistanceToFitSphere(radius: number): number;
             /**
              * Returns the orbit center position, where the camera looking at.
              * @param out The receiving Vector3 instance to copy the result
              * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
              * @category Methods
              */
             getTarget(out: Vector3, receiveEndValue?: boolean): Vector3;
             /**
              * Returns the camera position.
              * @param out The receiving Vector3 instance to copy the result
              * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
              * @category Methods
              */
             getPosition(out: Vector3, receiveEndValue?: boolean): Vector3;
             /**
              * Returns the spherical coordinates of the orbit.
              * @param out The receiving Spherical instance to copy the result
              * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
              * @category Methods
              */
             getSpherical(out: Spherical, receiveEndValue?: boolean): Spherical;
             /**
              * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
              * @param out The receiving Vector3 instance to copy the result
              * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
              * @category Methods
              */
             getFocalOffset(out: Vector3, receiveEndValue?: boolean): Vector3;
             /**
              * Normalize camera azimuth angle rotation between 0 and 360 degrees.
              * @category Methods
              */
             normalizeRotations(): void;
             /**
              * Reset all rotation and position to defaults.
              * @param enableTransition
              * @category Methods
              */
             reset(enableTransition?: boolean): Promise<void[]>;
             /**
              * Set current camera position as the default position.
              * @category Methods
              */
             saveState(): CameraState;
             /**
              * load current camera position
              */
             loadState(state: CameraState, enableTransition?: boolean): void;
             /**
              * load current camera position
              */
             loadStateAsync(state: CameraState, duration?: number, opts?: {
                 /** id */
                 id?: string;
                 /**  */
                 tag?: string;
                 /** easing */
                 easing?: Easing;
                 /**  */
                 yoyoTimes?: number;
                 /**  */
                 repeatTimes?: number;
             }): Promise<unknown>;
             /**
              * Sync camera-up direction.
              * When camera-up vector is changed, `.updateCameraUp()` must be called.
              * @category Methods
              */
             updateCameraUp(): void;
             /**
              * Apply current camera-up direction to the camera.
              * The orbit system will be re-initialized with the current position.
              * @category Methods
              */
             applyCameraUp(): void;
             /**
              * Update camera position and directions.
              * This should be called in your tick loop every time, and returns true if re-rendering is needed.
              * @param delta
              * @returns updated
              * @category Methods
              */
             update(delta: number): boolean;
             dispatchEvent(event: string, ...data: any): void;
             /**
              * Get all state in JSON string
              * @category Methods
              */
             toJSON(): string;
             /**
              * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
              * @param json
              * @param enableTransition
              * @category Methods
              */
             fromJSON(json: string, enableTransition?: boolean): void;
             /**
              * Attach all internal event handlers to enable drag control.
              * @category Methods
              */
             connect(domElement: HTMLElement): void;
             /**
              * Detach all internal event handlers to disable drag control.
              */
             disconnect(): void;
             /**
              * Dispose the cameraControls instance itself, remove all eventListeners.
              * @category Methods
              */
             dispose(): void;
             protected _getTargetDirection(out: Vector3): Vector3;
             protected _getCameraDirection(out: Vector3): Vector3;
             protected _findPointerById(pointerId: number): PointerInput | undefined;
             protected _findPointerByMouseButton(mouseButton: MOUSE_BUTTON): PointerInput | undefined;
             protected _disposePointer(pointer: PointerInput): void;
             protected _encloseToBoundary(position: Vector3, offset: Vector3, friction: number): Vector3;
             protected _updateNearPlaneCorners(): void;
             protected _truckInternal: (deltaX: number, deltaY: number, dragToOffset: boolean) => void;
             protected _rotateInternal: (deltaX: number, deltaY: number) => void;
             protected _dollyInternal: (delta: number, x: number, y: number) => void;
             protected _zoomInternal: (delta: number, x: number, y: number) => void;
             protected _collisionTest(): number;
             /**
              * Get its client rect and package into given `DOMRect` .
              */
             protected _getClientRect(target: DOMRect): DOMRect | undefined;
             protected _createOnRestPromise(resolveImmediately: boolean): Promise<void>;
             protected _addAllEventListeners(_domElement: HTMLElement): void;
             protected _removeAllEventListeners(): void;
             static createBoundingSphere(object3d: Object3D, out?: Sphere): Sphere;
             /**
              * 
              * @param enabledControl  false
              * @param enableWheelWhenCtrlDisabled   true
              * @returns
              */
             getStatus(enabledControl?: boolean, enableWheelWhenCtrlDisabled?: boolean): {
                 push: () => void;
                 pop: () => void;
             };
             /**
              * 
              * @param duration  (ms)   1000
              * @param frequency   10
              * @param strength   1
              * @param isLoop   false
              */
             shake(duration?: number, frequency?: number, strength?: number, isLoop?: boolean): {
                 cancelShake: () => boolean;
             };
         }

          interface CameraControlsEventMap {
             update: {
                 type: 'update';
             };
             wake: {
                 type: 'wake';
             };
             rest: {
                 type: 'rest';
             };
             sleep: {
                 type: 'sleep';
             };
             transitionstart: {
                 type: 'transitionstart';
             };
             controlstart: {
                 type: 'controlstart';
             };
             control: {
                 type: 'control';
             };
             controlend: {
                 type: 'controlend';
             };
         }

         /**
          * z ()
          */
         export  function cameraDistance2NdcZ(camera: PerspectiveCamera, dist: number): number;

         export  class CameraModule extends AppModuleBase implements IAppModuleBase {
             #private;
             static moduleName: string;
             options: CameraModuleOptions;
             viewHelper: ViewHelper;
             constructor(app?: App, options?: CameraModuleOptions);
             onAwake(): void;
             /**
              * 
              * @param position 
              * @param lookAt 
              * @param enableTransition  true
              */
             setCameraLookAt(position: Vector3, lookAt: Vector3, enableTransition?: boolean): void;
             get viewHelperEnable(): boolean;
             set viewHelperEnable(b: boolean);
             onAppAfterRender(): void;
             updateSceneBox(): void;
             setupUiConfig(): UiObjectConfig;
         }

         export  interface CameraModuleOptions extends CameraOptions {
             autoNearFar?: number | boolean;
             viewHelper?: {
                 enable?: boolean;
                 position?: "leftTop" | "rightTop" | "leftBottom" | "rightBottom";
                 size?: number;
             };
         }

         export  interface CameraOptions {
             fov?: number;
             /**   /  */
             aspect?: number;
             near?: number;
             far?: number;
             left?: number;
             right?: number;
             top?: number;
             bottom?: number;
             isOrthographicCamera?: boolean;
             /**  [0, 10, 10] */
             position?: Vector3 | [number, number, number];
             lookAt?: Vector3 | [number, number, number];
         }

         export  interface CameraState {
             cameraUp?: Vector3;
             cameraTarget: Vector3;
             cameraPosition: Vector3;
             cameraZoom?: number;
             cameraFocalOffset?: Vector3;
         }

         /**  */
         export  const cameraWorldDirection: (app?: App, camera?: Camera) => Vector3;

         /**
          * Cancelable promises extend base promises and provide a cancel functionality than can be used to cancel the execution or task of the promise.
          *
          * These type of promises can be used to prevent additional processing when the data is not longer required (e.g. HTTP request for data that is not longer necessary)
          */
         export  class CancelablePromise<T> {
             onResolve: (value: any) => void;
             onReject: (error: any) => void;
             onCancel: () => void;
             /**
              * Flag to indicate if the promise has been fulfilled.
              *
              * Promise has ben fulfilled when value/error is set.
              */
             fulfilled: boolean;
             /**
              * Flag to indicate if the promise was rejected.
              *
              * Only set when the promise is fulfilled.
              */
             rejected: boolean;
             /**
              * Flag set true when the resolve or reject method are called.
              */
             called: boolean;
             /**
              * Output value of the promise.
              *
              * Set with the output value if promise was fulfilled and not rejected.
              *
              * Stores the error value if the promise was rejected.
              */
             value: T;
             constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void);
             /**
              * Request to cancel the promise execution.
              *
              * @returns True if the promise is canceled successfully, false otherwise.
              */
             cancel(): boolean;
             /**
              * Executed after the promise is fulfilled.
              *
              * @param callback - Callback to receive the value.
              * @returns Promise for chainning.
              */
             then(callback: (value: any) => void): CancelablePromise<T>;
             /**
              * Catch any error that occurs in the promise.
              *
              * @param callback - Method to catch errors.
              * @returns Promise for chainning.
              */
             catch(callback: (error: any) => void): CancelablePromise<T>;
             /**
              * Finally callback
              *
              * @param callback - Method to be called.
              * @returns Promise for chainning.
              */
             finally(callback: Function): CancelablePromise<T>;
             /**
              * Create a resolved promise.
              *
              * @param val - Value to pass.
              * @returns Promise created with resolve value.
              */
             static resolve<T>(val: T): CancelablePromise<T>;
             /**
              * Create a rejected promise.
              *
              * @param reason - Reason to reject the promise.
              * @returns Promise created with rejection reason.
              */
             static reject(reason: any): CancelablePromise<any>;
             /**
              * Wait for a set of promises to finish, creates a promise that waits for all running promises.
              *
              * If any of the promises fail it will reject altough some of them may have been completed with success.
              *
              * @param promises - List of promisses to syncronize.
              * @returns Promise that will resolve when all of the running promises are fullfilled.
              */
             static all(promises: CancelablePromise<any>[]): CancelablePromise<any>;
         }

         export  class CancelledCommandException {
             constructor(command: any);
             toString(): string;
         }

          namespace CANNON {
             export {
                 AABB,
                 ArrayCollisionMatrix,
                 Body_2 as Body,
                 BODY_SLEEP_STATES,
                 BODY_TYPES,
                 BodyOptions,
                 BodySleepState,
                 BodyType,
                 Box,
                 Broadphase,
                 COLLISION_TYPES,
                 CollisionType,
                 ConeEquation,
                 ConeTwistConstraint,
                 ConeTwistConstraintOptions,
                 Constraint,
                 ConstraintOptions,
                 ContactEquation,
                 ContactMaterial,
                 ContactMaterialOptions,
                 ConvexPolyhedron,
                 ConvexPolyhedronContactPoint,
                 Cylinder,
                 DistanceConstraint,
                 Equation,
                 EventTarget_2,
                 FrictionEquation,
                 GridBroadphase,
                 GSSolver,
                 Heightfield,
                 HeightfieldOptions,
                 HeightfieldPillar,
                 HingeConstraint,
                 HingeConstraintOptions,
                 JacobianElement,
                 LockConstraint,
                 LockConstraintOptions,
                 Mat3,
                 Material_2 as Material,
                 MaterialOptions,
                 NaiveBroadphase,
                 Narrowphase,
                 ObjectCollisionMatrix,
                 Octree,
                 OctreeNode,
                 OverlapKeeper,
                 Particle2,
                 Plane_2 as Plane,
                 PointToPointConstraint,
                 Pool,
                 Quaternion_2 as Quaternion,
                 Ray_2 as Ray,
                 RAY_MODES,
                 RaycastCallback,
                 RaycastResult,
                 RaycastVehicle,
                 RaycastVehicleOptions,
                 RayMode,
                 RayOptions,
                 RigidVehicle,
                 RigidVehicleOptions,
                 RotationalEquation,
                 RotationalEquationOptions,
                 RotationalMotorEquation,
                 SAPBroadphase,
                 Shape,
                 SHAPE_TYPES,
                 ShapeOptions2,
                 ShapeType,
                 Solver,
                 Sphere_2 as Sphere,
                 SPHSystem,
                 SplitSolver,
                 SplitSolverNode,
                 Spring,
                 SpringOptions,
                 Transform,
                 TransformOptions,
                 Trimesh,
                 TupleDictionary,
                 Vec3,
                 Vec3Pool,
                 WheelInfo,
                 WheelInfoOptions,
                 WheelRaycastResult,
                 World,
                 WorldOptions
             }
         }
         export { CANNON }

         /**
          * Returns a new canvas with the image/canvas-content flipped vertically.
          * Useful for putImageData(as it does not respect scale and translate) and WebGL textures, which are flipped vertically.
          * @param canvas
          */
         export  function canvasFlipY(canvas: Exclude<CanvasImageSource, SVGImageElement>): HTMLCanvasElement;

         /**
          * Contains utils to handle canvas element manipulation and common canvas operations.
          */
         export  class CanvasUtils {
             /**
              * Create a offscreen canvas, used to draw content that will not be displayed using DOM.
              *
              * If OffscreenCanvas object is no available creates a regular DOM canvas object instead.
              *
              * @param width - Width of the canvas in pixels.
              * @param height - Height of the canvas in pixels.
              */
             static createOffscreenCanvas(width: number, height: number): (HTMLCanvasElement | OffscreenCanvas);
         }

          type CbThis<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;

          type CbThis_2<Ctx, Impl> = unknown extends Ctx ? Impl : Ctx;

          const CENTER: SplitStrategy;

          function centroid(array: number[]): number[];

         export  type ChangeArgs = [ChangeEvent, ...any[]] | never[];

         /**
          * Change the emit direction of particles.
          */
         export  class ChangeEmitDirection implements Simulation {
             angle: ValueGenerator;
             type: string;
             _temp: Vector3;
             _q: Quaternion;
             constructor(angle: ValueGenerator);
             initialize(particle: Particle): void;
             update(particle: Particle, delta: number): void;
             frameUpdate(delta: number): void;
             toJSON(): any;
             static fromJSON(json: any): Simulation;
             clone(): Simulation;
             reset(): void;
         }

         export  interface ChangeEvent {
             target?: UiObjectConfig;
             type: 'change';
             last?: boolean;
             config?: UiObjectConfig;
             configPath?: UiObjectConfig[];
             value?: any;
         }

         export  type CharInfo = {
             atlasX: number;
             atlasY: number;
             width: number;
             height: number;
             yOffset: number;
             xAdvance: number;
         };

         export  type CharLayoutInfo = {
             left: number;
             top: number;
             width: number;
             height: number;
             xAdvance: number;
             boxTop: number;
             boxHeight: number;
             atlasX: number;
             atlasY: number;
         };

         export  interface ChartOptions {
             maxIterations?: number;
             straightnessWeight?: number;
             textureSeamWeight?: number;
             useInputMeshUvs?: boolean;
             maxChartArea?: number;
             normalDeviationWeight?: number;
             maxCost?: number;
             roundnessWeight?: number;
             maxBoundaryLength?: number;
             normalSeamWeight?: number;
             fixWinding?: boolean;
         }

         

          class Circle extends Path<CircleProps> {
             shape: CircleShape;
             constructor(opts?: CircleProps);
             getDefaultShape(): CircleShape;
             buildPath(ctx: CanvasRenderingContext2D, shape: CircleShape): void;
         }

         /**
          * a particle emitter that emits particles from a circle.
          */
         export  class CircleEmitter implements EmitterShape {
             type: string;
             radius: number;
             arc: number;
             thickness: number;
             mode: EmitterMode;
             spread: number;
             speed: ValueGenerator | FunctionValueGenerator;
             private currentValue;
             constructor(parameters?: CircleEmitterParameters);
             update(system: ParticleSystem, delta: number): void;
             initialize(p: Particle, emissionState: EmissionState): void;
             toJSON(): ShapeJSON;
             static fromJSON(json: any): CircleEmitter;
             clone(): EmitterShape;
         }

         /**
          * Interface representing the parameters for a circle emitter.
          */
         export  interface CircleEmitterParameters {
             /**
              * The radius of the circle.
              */
             radius?: number;
             /**
              * The arc of the circle.
              */
             arc?: number;
             /**
              * The thickness of the ring.
              * 1 is a full circle, 0 is a ring with 0 radius.
              */
             thickness?: number;
             /**
              * The mode of the emitter.
              * {@link EmitterMode}
              */
             mode?: EmitterMode;
             /**
              * The length of segment of which emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
              * {@link EmitterMode}
              */
             spread?: number;
             /**
              * The speed of the emitter start point travels when mode is EmitterMode.Loop or EmitterMode.PingPong.
              * {@link EmitterMode}
              */
             speed?: ValueGenerator | FunctionValueGenerator;
         }

          interface CircleProps extends PathProps {
             shape?: Partial<CircleShape>;
         }

          class CircleShape {
             cx: number;
             cy: number;
             r: number;
         }

         /**  */
         export  function clamp(value: number, min: number, max: number): number;

         /**
          * Generic type for class.
          * @example
          * ```ts
          * interface A {
          *    a: number
          * }
          * class B implements A {
          *  a = 1
          * }
          *
          * // Store class in variable
          * const c: Class<A> = B
          * console.log(typeof c === Class<B>) // true
          *
          * // Passing class to function
          * function f(p: Class<A>) {
          *     console.log(p)
          * }
          * f(B) // ok
          * ```
          *
          *
          */
         export  type Class<T> = new (...args: any[]) => T;

          type Class_2<T> = new (...args: any[]) => T;

         /**
          * Clears the bit at the given position.
          * @param number - the number to update
          * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
          */
         export  function clearBit(number: number, bitPosition: number): number;

          class Clip {
             private _life;
             private _delay;
             private _inited;
             private _startTime;
             private _pausedTime;
             private _paused;
             animation: Animation_2;
             loop: boolean;
             easing: AnimationEasing;
             easingFunc: (p: number) => number;
             next: Clip;
             prev: Clip;
             onframe: OnframeCallback;
             ondestroy: ondestroyCallback;
             onrestart: onrestartCallback;
             constructor(opts: ClipProps);
             step(globalTime: number, deltaTime: number): boolean;
             pause(): void;
             resume(): void;
             setEasing(easing: AnimationEasing): void;
         }

          interface ClipProps {
             life?: number;
             delay?: number;
             loop?: boolean;
             easing?: AnimationEasing;
             onframe?: OnframeCallback;
             ondestroy?: ondestroyCallback;
             onrestart?: onrestartCallback;
         }

         /**
          * Clone a new matrix.
          */
          function clone(a: MatrixArray): MatrixArray;

         /**
          * 
          */
          function clone_2(v: VectorArray): VectorArray;

         /**
          * Those data types can be cloned:
          *     Plain object, Array, TypedArray, number, string, null, undefined.
          * Those data types will be assgined using the orginal data:
          *     BUILTIN_OBJECT
          * Instance of user defined class will be cloned to a plain object, without
          * properties in prototype.
          * Other data types is not supported (not sure what will happen).
          *
          * Caution: do not support clone Date, for performance consideration.
          * (There might be a large number of date in `series.data`).
          * So date should not be modified in and out of .
          */
          function clone_3<T extends any>(source: T): T;

         /**
          * Deep clone of object.
          *
          * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
          * object), `Date` and `RegExp`s and cycles.
          *
          * Throws error if enounters object with `prototype` assuming that in general class instances
          * cannot be reliably cloned by generic algorithm.
          */
         export  function cloneDeep<T>(obj: T): T;

         /**
          * 
          * @param material
          */
         export  const cloneMaterial: (material: Mesh | Material | Material[]) => any;

         /**
          * Clone a path.
          */
          function clonePath(sourcePath: Path, opts?: {
             /**
              * If bake global transform to path.
              */
             bakeTransform?: boolean;
             /**
              * Convert global transform to local.
              */
             toLocal?: boolean;
         }): Path<PathProps>;

         /**
          * 
          * @param p
          * @param points
          */
         export  function closestPointOnPolyline(p: GeoPoint, points: GeoPoint[]): {
             closestLength: number;
             closestPoint: GeoPoint;
             closestIndex: number;
             closestPrePointDist: number;
         };

         /**
          * 
          * @param p
          * @param lines
          */
         export  function closestPointOnPolylines(p: GeoPoint, lines: GeoPoint[][]): {
             closestLength: number;
             closestPoint: GeoPoint;
             closestIndex: number;
             closestPointIndex: number;
             closestPrePointDist: number;
         };

         /**
          * 
          * @param p
          * @param p1
          * @param p2
          * @return {GeoPoint}
          */
         export  function closestPointOnSegment(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): GeoPoint;

         /**
          * 3d
          * @param p
          * @param p1
          * @param p2
          * @return {GeoPoint}
          */
         export  function closestToSegment3d(point: GeoPoint, segmentStart: GeoPoint, segmentEnd: GeoPoint): GeoPoint;

          type CollectionTypes = IterableCollections | WeakCollections;

          const COLLISION_TYPES: {
             sphereSphere: 1;
             spherePlane: 3;
             boxBox: 4;
             sphereBox: 5;
             planeBox: 6;
             convexConvex: 16;
             sphereConvex: 17;
             planeConvex: 18;
             boxConvex: 20;
             sphereHeightfield: 33;
             boxHeightfield: 36;
             convexHeightfield: 48;
             sphereParticle: 65;
             planeParticle: 66;
             boxParticle: 68;
             convexParticle: 80;
             cylinderCylinder: 128;
             sphereCylinder: 129;
             planeCylinder: 130;
             boxCylinder: 132;
             convexCylinder: 144;
             heightfieldCylinder: 160;
             particleCylinder: 192;
             sphereTrimesh: 257;
             planeTrimesh: 258;
         };

          type CollisionType = typeof COLLISION_TYPES[keyof typeof COLLISION_TYPES];

         /**
          * Color particles by their speed.
          */
         export  class ColorBySpeed implements Simulation {
             color: FunctionColorGenerator | MemorizedFunctionColorGenerator;
             speedRange: IntervalValue;
             type: string;
             constructor(color: FunctionColorGenerator | MemorizedFunctionColorGenerator, speedRange: IntervalValue);
             initialize(particle: Particle): void;
             update(particle: Particle, delta: number): void;
             frameUpdate(delta: number): void;
             toJSON(): any;
             static fromJSON(json: any): Simulation;
             clone(): Simulation;
             reset(): void;
         }

         

         export  interface ColorGenerator {
             type: 'value';
             genColor(color: Vector4): Vector4;
             toJSON(): FunctionJSON;
             clone(): ColorGenerator;
         }

         export  function ColorGeneratorFromJSON(json: FunctionJSON): RandomColor | ColorRange | Gradient | RandomColorBetweenGradient | ConstantColor;

         /**
          * Color particles by their life.
          */
         export  class ColorOverLife implements Simulation {
             color: FunctionColorGenerator | MemorizedFunctionColorGenerator;
             type: string;
             constructor(color: FunctionColorGenerator | MemorizedFunctionColorGenerator);
             initialize(particle: Particle): void;
             update(particle: Particle, delta: number): void;
             frameUpdate(delta: number): void;
             toJSON(): any;
             static fromJSON(json: any): Simulation;
             clone(): Simulation;
             reset(): void;
         }

         export  class ColorRange implements ColorGenerator {
             a: Vector4;
             b: Vector4;
             constructor(a: Vector4, b: Vector4);
             genColor(color: Vector4, t?: number): Vector4;
             type: 'value';
             toJSON(): FunctionJSON;
             static fromJSON(json: FunctionJSON): ColorRange;
             clone(): ColorGenerator;
         }

         /**
          * Creates an image data url from a color string.
          * @param color - color string (css compatible color)
          * @param width - width of the image (default: 1)
          * @param height - height of the image (default: 1)
          * @return {string} - data url
          */
         export  function colorToDataUrl(color: string, width?: number, height?: number): string;

          namespace colorTool {
             export {
                 parse,
                 lift,
                 toHex,
                 fastLerp,
                 lerp_3 as lerp,
                 modifyHSL,
                 modifyAlpha,
                 stringify,
                 lum,
                 random,
                 liftColor,
                 fastMapToColor,
                 mapToColor
             }
         }

          interface CombineConfig extends ElementAnimateConfig {
             /**
              * Transform of returned will be ignored.
              */
             dividePath?: DividePath;
             /**
              * delay of each individual.
              * Because individual are sorted on z-order. The index is also sorted top-left / right-down.
              */
             individualDelay?: IndividualDelay;
         }

         /**
          * Make combine morphing from many paths to one.
          * Will return a group to replace the original path.
          */
          function combineMorph(fromList: (CombineMorphingPath | Path)[], toPath: Path, animationOpts: CombineConfig): {
             fromIndividuals: Path<PathProps>[];
             toIndividuals: any[];
             count: number;
         };

          interface CombineMorphingPath extends Path {
             childrenRef(): (CombineMorphingPath | Path)[];
             __isCombineMorphing: boolean;
         }

         export  class CommandHistory {
             #private;
             app: App;
             private undos;
             private redos;
             MaxHistroyLength: number;
             constructor(app: App);
             get debug(): boolean;
             set debug(d: boolean);
             clear(): void;
             execute(cmd: ICommand): void;
             executeAll(cmds: ICommand[]): void;
             executeMany(...cmds: ICommand[]): void;
             undo(): void;
             redo(): any;
         }

         export  class CommandModule extends AppModuleBase implements IAppModuleBase {
             #private;
             static moduleName: string;
             options: CommandModuleOptions;
             constructor(app?: App, options?: CommandModuleOptions);
             get commandHistory(): CommandHistory;
             onAwake(): void;
             clearCommands(): void;
             addCommand(cmd: ICommand): void;
             executeCommand(cmd: ICommand): void;
             executeAllCommands(cmds: ICommand[]): void;
             addAllCommands(cmds: ICommand[]): void;
             executeManyCommands(...cmds: ICommand[]): void;
             addManyCommands(...cmds: ICommand[]): void;
             undo(): void;
             redo(): any;
             setupUiConfig(): UiObjectConfig;
         }

         export  interface CommandModuleOptions {
             maxHistroyLength?: number;
             debugInfo?: boolean;
             autoListenKeyToUnRedo?: boolean;
             autoListenKeyToUiConfig?: boolean;
         }

          interface CommonStyleProps {
             shadowBlur?: number;
             shadowOffsetX?: number;
             shadowOffsetY?: number;
             shadowColor?: string;
             opacity?: number;
             /**
              * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
              */
             blend?: string;
         }

         /**
          * Abstract class
          */
         export  class CompositeBehavior extends Behavior {
             __children: Behavior[];
             constructor();
             /**
              *
              * @param {Behavior} child
              */
             addChild(child: Behavior): void;
             /**
              *
              * @param {Behavior[]} children
              */
             addChildren(children: Behavior[]): void;
             /**
              * NOTE: do not modify obtained value
              * @return {Behavior[]}
              */
             getChildren(): Behavior[];
             /**
              *
              * @param {Behavior} child
              * @returns {boolean}
              */
             removeChild(child: Behavior): boolean;
             clearChildren(): void;
         }

          class CompoundPath extends Path {
             type: string;
             shape: CompoundPathShape;
             private _updatePathDirty;
             beforeBrush(): void;
             buildPath(ctx: PathProxy | CanvasRenderingContext2D, shape: CompoundPathShape): void;
             afterBrush(): void;
             getBoundingRect(): any;
         }

          interface CompoundPathShape {
             paths: Path[];
         }

         export  function computeBoundsTree(options: any): any;

          function computeBoundsTree_2(options?: MeshBVHOptions): MeshBVH;

         /**
          * Takes a getter function and returns a readonly reactive ref object for the
          * returned value from the getter. It can also take an object with get and set
          * functions to create a writable ref object.
          *
          * @example
          * ```js
          * // Creating a readonly computed ref:
          * const count = ref(1)
          * const plusOne = computed(() => count.value + 1)
          *
          * console.log(plusOne.value) // 2
          * plusOne.value++ // error
          * ```
          *
          * ```js
          * // Creating a writable computed ref:
          * const count = ref(1)
          * const plusOne = computed({
          *   get: () => count.value + 1,
          *   set: (val) => {
          *     count.value = val - 1
          *   }
          * })
          *
          * plusOne.value = 1
          * console.log(count.value) // 0
          * ```
          *
          * @param getter - Function that produces the next value.
          */
          function computed<T>(getter: ComputedGetter<T>, debugOptions?: any): ComputedRef<T>;

          function computed<T>(options: WritableComputedOptions<T>, debugOptions?: any): WritableComputedRef<T>;

          type ComputedGetter<T> = (...args: any[]) => T;

          interface ComputedRef<T = any> extends WritableComputedRef<T> {
             readonly value: T;
             [ComputedRefSymbol]: true;
         }

          const ComputedRefSymbol: unique symbol;

          type ComputedSetter<T> = (v: T) => void;

          function computeMeshVolume(mesh: Mesh | BufferGeometry): Number;

          function computeMikkTSpaceTangents(geometry: BufferGeometry, MikkTSpace: unknown, negateSign?: boolean): BufferGeometry;

          function computeMorphedAttributes(object: Mesh | Line_2 | Points): object;

          function concatArray<T, R>(a: ArrayLike_2<T>, b: ArrayLike_2<R>): ArrayLike_2<T | R>;

         export  class ConditionalBehavior extends AbstractDecoratorBehavior {
             condition: Behavior;
             constructor();
             /**
              *
              * @param {Behavior} behavior
              */
             setCondition(behavior: Behavior): void;
             tick(timeDelta: number): BehaviorStatus;
             finalize(): void;
             /**
              *
              * @param {Behavior} condition
              * @param {Behavior} source
              * @return {ConditionalBehavior}
              */
             static from(condition: Behavior, source: Behavior): ConditionalBehavior;
         }

         export  class ConditionBehavior extends Behavior {
             __accessor: Function;
             /**
              *
              * @param {function():boolean} accessor
              */
             constructor(accessor: any);
             tick(timeDelta: number): BehaviorStatus.Succeeded | BehaviorStatus.Failed;
         }

         export  class ConeEmitter implements EmitterShape {
             type: string;
             radius: number;
             arc: number;
             thickness: number;
             angle: number;
             mode: EmitterMode;
             spread: number;
             speed: ValueGenerator | FunctionValueGenerator;
             private currentValue;
             constructor(parameters?: ConeEmitterParameters);
             update(system: ParticleSystem, delta: number): void;
             initialize(p: Particle, emissionState: EmissionState): void;
             toJSON(): ShapeJSON;
             static fromJSON(json: ShapeJSON): ConeEmitter;
             clone(): EmitterShape;
         }

         /**
          * Interface representing the parameters for a cone emitter.
          */
         export  interface ConeEmitterParameters {
             /**
              * The radius of the cone base.
              */
             radius?: number;
             /**
              * The arc of the cone.
              */
             arc?: number;
             /**
              * The thickness of the cone. 1 is a full cone, 0 is a cone with 0 thickness.
              */
             thickness?: number;
             /**
              * The angle of the cone, ranging from 0 to Math.PI / 2.
              */
             angle?: number;
             /**
              * The mode of the emitter.
              * {@link EmitterMode}
              */
             mode?: EmitterMode;
             /**
              * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
              * {@link EmitterMode}
              */
             spread?: number;
             /**
              * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
              * {@link EmitterMode}
              */
             speed?: ValueGenerator | FunctionValueGenerator;
         }

         /**
          * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
          */
          class ConeEquation extends Equation {
             /**
              * Local axis in A
              */
             axisA: Vec3;
             /**
              * Local axis in B
              */
             axisB: Vec3;
             /**
              * The "cone angle" to keep
              */
             angle: number;
             constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                 /**
                  * @default 1e6
                  */
                 maxForce?: number;
                 axisA?: Vec3;
                 axisB?: Vec3;
                 angle?: number;
             });
             computeB(h: number): number;
         }

         /**
          * A Cone Twist constraint, useful for ragdolls.
          */
          class ConeTwistConstraint extends PointToPointConstraint {
             /**
              * The axis direction for the constraint of the body A.
              */
             axisA: Vec3;
             /**
              * The axis direction for the constraint of the body B.
              */
             axisB: Vec3;
             /**
              * The aperture angle of the cone.
              */
             angle: number;
             /**
              * The twist angle of the joint.
              */
             twistAngle: number;
             coneEquation: ConeEquation;
             twistEquation: RotationalEquation;
             constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                 /**
                  * The pivot point for bodyA.
                  */
                 pivotA?: Vec3;
                 /**
                  * The pivot point for bodyB.
                  */
                 pivotB?: Vec3;
                 /**
                  * The axis direction for the constraint of the body A.
                  */
                 axisA?: Vec3;
                 /**
                  * The axis direction for the constraint of the body B.
                  */
                 axisB?: Vec3;
                 /**
                  * The aperture angle of the cone.
                  * @default 0
                  */
                 angle?: number;
                 /**
                  * The twist angle of the joint.
                  * @default 0
                  */
                 twistAngle?: number;
                 /**
                  * The maximum force that should be applied to constrain the bodies.
                  * @default 1e6
                  */
                 maxForce?: number;
                 /**
                  * Wether to collide the connected bodies or not.
                  * @default false
                  */
                 collideConnected?: boolean;
             });
             update(): void;
         }

          type ConeTwistConstraintOptions = ConstructorParameters<typeof ConeTwistConstraint>[2];

         export  interface Config<T = unknown> {
             url?: string;
             method: keyof Methods;
             data?: Document | BodyInit;
             headers: {
                 [key: string]: string;
             };
             dump: (data: T) => string;
             load: (str: string) => T;
             xmlHttpRequest: () => XMLHttpRequest;
             promise: (fn: () => Promise<unknown>) => Promise<unknown>;
             abort?: any;
             params?: string[][] | Record<string, string> | string | URLSearchParams;
             withCredentials: boolean;
             raw?: boolean;
             events?: {
                 [key: string]: () => void;
             };
         }

         export  class ConstantColor implements ColorGenerator {
             color: Vector4;
             constructor(color: Vector4);
             genColor(color: Vector4): Vector4;
             type: 'value';
             toJSON(): FunctionJSON;
             static fromJSON(json: FunctionJSON): ConstantColor;
             clone(): ColorGenerator;
         }

         export  class ConstantValue implements ValueGenerator {
             value: number;
             type: "value";
             constructor(value: number);
             genValue(): number;
             toJSON(): FunctionJSON;
             static fromJSON(json: FunctionJSON): ConstantValue;
             clone(): ValueGenerator;
         }

         export  interface ConstInput {
             getValue(context: ExecutionContext): any;
         }

         /**
          * Constraint base class
          */
          class Constraint {
             /**
              * Equations to be solved in this constraint.
              */
             equations: Equation[];
             /**
              * Body A.
              */
             bodyA: Body_2;
             /**
              * Body B.
              */
             bodyB: Body_2;
             id: number;
             /**
              * Set to false if you don't want the bodies to collide when they are connected.
              */
             collideConnected: boolean;
             static idCounter: number;
             constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                 /**
                  * Set to false if you don't want the bodies to collide when they are connected.
                  * @default true
                  */
                 collideConnected?: boolean;
                 /**
                  * Set to false if you don't want the bodies to wake up when they are connected.
                  * @default true
                  */
                 wakeUpBodies?: boolean;
             });
             /**
              * Update all the equations with data.
              */
             update(): void;
             /**
              * Enables all equations in the constraint.
              */
             enable(): void;
             /**
              * Disables all equations in the constraint.
              */
             disable(): void;
         }

          type ConstraintOptions = ConstructorParameters<typeof Constraint>[2];

         export  interface Constructable<T> {
             new (...args: any): T;
         }

         /**
          * Contact/non-penetration constraint equation
          */
          class ContactEquation extends Equation {
             /**
              * "bounciness": u1 = -e*u0
              */
             restitution: number;
             /**
              * World-oriented vector that goes from the center of bi to the contact point.
              */
             ri: Vec3;
             /**
              * World-oriented vector that starts in body j position and goes to the contact point.
              */
             rj: Vec3;
             /**
              * Contact normal, pointing out of body i.
              */
             ni: Vec3;
             constructor(bodyA: Body_2, bodyB: Body_2, maxForce?: number);
             computeB(h: number): number;
             /**
              * Get the current relative velocity in the contact point.
              */
             getImpactVelocityAlongNormal(): number;
         }

         /**
          * Defines what happens when two materials meet.
          * @todo Refactor materials to materialA and materialB
          */
          class ContactMaterial {
             /**
              * Identifier of this material.
              */
             id: number;
             /**
              * Participating materials.
              */
             materials: [Material_2, Material_2];
             /**
              * Friction coefficient.
              * @default 0.3
              */
             friction: number;
             /**
              * Restitution coefficient.
              * @default 0.3
              */
             restitution: number;
             /**
              * Stiffness of the produced contact equations.
              * @default 1e7
              */
             contactEquationStiffness: number;
             /**
              * Relaxation time of the produced contact equations.
              * @default 3
              */
             contactEquationRelaxation: number;
             /**
              * Stiffness of the produced friction equations.
              * @default 1e7
              */
             frictionEquationStiffness: number;
             /**
              * Relaxation time of the produced friction equations
              * @default 3
              */
             frictionEquationRelaxation: number;
             static idCounter: number;
             constructor(m1: Material_2, m2: Material_2, options: {
                 /**
                  * Friction coefficient.
                  * @default 0.3
                  */
                 friction?: number;
                 /**
                  * Restitution coefficient.
                  * @default 0.3
                  */
                 restitution?: number;
                 /**
                  * Stiffness of the produced contact equations.
                  * @default 1e7
                  */
                 contactEquationStiffness?: number;
                 /**
                  * Relaxation time of the produced contact equations.
                  * @default 3
                  */
                 contactEquationRelaxation?: number;
                 /**
                  * Stiffness of the produced friction equations.
                  * @default 1e7
                  */
                 frictionEquationStiffness?: number;
                 /**
                  * Relaxation time of the produced friction equations
                  * @default 3
                  */
                 frictionEquationRelaxation?: number;
             });
         }

          type ContactMaterialOptions = ConstructorParameters<typeof ContactMaterial>[2];

          const CONTAINED: ShapecastIntersection;

         /**
          * 
          * @param object3D
          */
         export  function containSkeleton(object3D: Object3D): boolean;

         /**
          * .
          *
          **/
         export  class ContextMenu {
             private options;
             private menuControl;
             private position;
             /**
              * Creates a new ContextMenu menu
              * @param {object} opts options which build the menu e.g. position and items
              * @param {number} opts.width sets the width of the menu including children
              * @param {object} opts.event 
              * @param {theme} opts.theme darklightdark
              * @param {boolean} opts.isSticky sets how the menu apears, follow the mouse or sticky
              * @param {Array<ContextMenuItem>} opts.items sets the default items in the menu
              */
             constructor(opts: ContextMenuOptions);
             /**
              * Adds item to this ContextMenu menu instance
              * @param {ContextMenuItem} item item to add to the ContextMenu menu
              */
             add(item: any): void;
             /**
              * Makes this ContextMenu menu visible
              */
             show(): void;
             /**
              * Hides this ContextMenu menu
              */
             hide(): void;
             /**
              * Toggle visibility of menu
              */
             toggle(): void;
         }

         /**
          * .
          *
          **/
         export  interface ContextMenuOptions {
             /** . */
             event?: Event;
             /** ),150px. */
             width?: string;
             /** .(darklight,dark)*/
             theme?: string;
             /** window  map.getContainer().getBoundingClientRect().width */
             innerWidth?: number;
             /** window  map.getContainer().getBoundingClientRect().height */
             innerHeight?: number;
             /**  */
             items: ContextMenuSubItemOptions[];
             /** event . */
             position?: [number, number];
         }

         /**
          * .
          *
          **/
         export  interface ContextMenuSubItemOptions {
             /** . */
             type?: "custom" | "multi" | "Button" | "seperator" | "submenu" | "hovermenu" | "normal";
             /** 'custom'html */
             markup?: string;
             /** 'multi'*/
             items?: ContextMenuSubItemOptions[];
             /** */
             onClick?: Function;
             /** */
             label?: string;
             /** */
             shortcut?: string;
             /** */
             enabled?: boolean;
             /** css*/
             cssIcon?: string;
             /**  "checked"*/
             icon?: string;
         }

          class ContinuousLinearFunction<T extends ObjectValueType<T> | number> {
             keys: Array<[T, number]>;
             type: 'function';
             subType: 'Number' | 'Vector3' | 'Vector4' | 'Color';
             constructor(keys: Array<[T, number]>, subType: 'Number' | 'Vector3' | 'Vector4' | 'Color');
             findKey(t: number): number;
             getStartX(index: number): number;
             getEndX(index: number): number;
             genValue(value: T, t: number): T;
             toJSON(): FunctionJSON;
             static fromJSON(json: FunctionJSON): ContinuousLinearFunction<any>;
             clone(): ContinuousLinearFunction<any>;
         }

          class Controller {
             isController: boolean;
             object: object;
             property: string;
             callback?: Function;
             _defaultValue?: any;
             _label?: string;
             _type?: string;
             _bounds?: [number, number];
             value?: any;
             getValue?: () => any;
             setValue?: (value: any, ...args: ChangeArgs) => void;
             hidden?: ValOrFunc<boolean>;
             disabled?: ValOrFunc<boolean>;
             readOnly?: ValOrFunc<boolean>;
             tags?: ValOrArr<string>;
             onClick?: (...args: any[]) => void;
             bounds?: ValOrFunc<number[]>;
             stepSize?: ValOrFunc<number>;
             expanded?: ValOrFunc<boolean>;
             onExpand?: (c: UiObjectConfig) => void;
             inlinePicker?: ValOrFunc<boolean>;
             children?: Array<UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>>;
             constructor(object: object, property: string);
             onChange(callback: Function): this;
             on(eventName: any, callback: Function): this;
             defaultValue(v: any): this;
             label(val: string): this;
             name(val: string): this;
             type(val: string): this;
             options(val: any[]): this;
             min(min: number): this;
             max(max: number): this;
             step(step: number): this;
             toJson(): {
                 type: string;
                 label: string;
                 property: (string | object)[];
                 onChange: Function;
                 value: any;
                 getValue: () => any;
                 setValue: (value: any, ...args: ChangeArgs) => void;
                 hidden: ValOrFunc<boolean>;
                 disabled: ValOrFunc<boolean>;
                 readOnly: ValOrFunc<boolean>;
                 tags: ValOrArr<string>;
                 onClick: (...args: any[]) => void;
                 bounds: ValOrFunc<number[]>;
                 stepSize: ValOrFunc<number>;
                 expanded: ValOrFunc<boolean>;
                 onExpand: (c: UiObjectConfig<any, string, any>) => void;
                 inlinePicker: ValOrFunc<boolean>;
                 children: (UiObjectConfig<any, string, any> | Fof<ValOrArrOp<UiObjectConfig<any, string, any>>>)[];
             };
         }

         export  interface ControlMarginOptions {
             /** x, 0 */
             posTopLeftMarginX?: number;
             /** y, 0 */
             posTopLeftMarginY?: number;
             /** x, 0 */
             posTopRightMarginX?: number;
             /** y, 0 */
             posTopRightMarginY?: number;
             /** x, 0 */
             posBottomLeftMarginX?: number;
             /** y, 0 */
             posBottomLeftMarginY?: number;
             /** x, 0 */
             posBottomRightMarginX?: number;
             /** y, 0 */
             posBottomRightMarginY?: number;
         }

         export  type ControlPosition = "top-left" | "top-right" | "bottom-left" | "bottom-right";

         /**
          * transform
          *
          * @param {geojson|GeoPointLike|GeoPointLike[]|string} input
          * @returns {geojson|GeoPointLike | GeoPointLike[]} output
          */
          function convert<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(input: T | string, crsFrom: ((pt: GeoPoint) => GeoPoint) | CRSTypes, crsTo?: CRSTypes): T;

         export  const convertToMaterialParameters: (params: any, material?: any) => any;

         /**
          * A set of polygons describing a convex shape.
          *
          * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
          * in the same 3D plane), instead these should be merged into one polygon.
          *
          * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
          * @author schteppe / https://github.com/schteppe
          * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
          *
          * @todo Move the clipping functions to ContactGenerator?
          * @todo Automatically merge coplanar polygons in constructor.
          * @example
          *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
          *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
          *     world.addBody(convexBody)
          */
          class ConvexPolyhedron extends Shape {
             /** vertices */
             vertices: Vec3[];
             /**
              * Array of integer arrays, indicating which vertices each face consists of
              */
             faces: number[][];
             /** faceNormals */
             faceNormals: Vec3[];
             /** worldVertices */
             worldVertices: Vec3[];
             /** worldVerticesNeedsUpdate */
             worldVerticesNeedsUpdate: boolean;
             /** worldFaceNormals */
             worldFaceNormals: Vec3[];
             /** worldFaceNormalsNeedsUpdate */
             worldFaceNormalsNeedsUpdate: boolean;
             /**
              * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
              */
             uniqueAxes: Vec3[] | null;
             /** uniqueEdges */
             uniqueEdges: Vec3[];
             /**
              * @param vertices An array of Vec3's
              * @param faces Array of integer arrays, describing which vertices that is included in each face.
              */
             constructor(props?: {
                 /** An array of Vec3's */
                 vertices?: Vec3[];
                 /** Array of integer arrays, describing which vertices that is included in each face. */
                 faces?: number[][];
                 /** normals */
                 normals?: Vec3[];
                 /** axes */
                 axes?: Vec3[];
                 /** boundingSphereRadius */
                 boundingSphereRadius?: number;
             });
             /**
              * Computes uniqueEdges
              */
             computeEdges(): void;
             /**
              * Compute the normals of the faces.
              * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
              */
             computeNormals(): void;
             /**
              * Compute the normal of a face from its vertices
              */
             getFaceNormal(i: number, target: Vec3): void;
             /**
              * Get face normal given 3 vertices
              */
             static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;
             /**
              * @param minDist Clamp distance
              * @param result The an array of contact point objects, see clipFaceAgainstHull
              */
             clipAgainstHull(posA: Vec3, quatA: Quaternion_2, hullB: ConvexPolyhedron, posB: Vec3, quatB: Quaternion_2, separatingNormal: Vec3, minDist: number, maxDist: number, result: ConvexPolyhedronContactPoint[]): void;
             /**
              * Find the separating axis between this hull and another
              * @param target The target vector to save the axis in
              * @return Returns false if a separation is found, else true
              */
             findSeparatingAxis(hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion_2, posB: Vec3, quatB: Quaternion_2, target: Vec3, faceListA?: number[] | null, faceListB?: number[] | null): boolean;
             /**
              * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
              * @return The overlap depth, or FALSE if no penetration.
              */
             testSepAxis(axis: Vec3, hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion_2, posB: Vec3, quatB: Quaternion_2): number | false;
             /**
              * calculateLocalInertia
              */
             calculateLocalInertia(mass: number, target: Vec3): void;
             /**
              * @param face_i Index of the face
              */
             getPlaneConstantOfFace(face_i: number): number;
             /**
              * Clip a face against a hull.
              * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
              * @param minDist Distance clamping
              * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
              */
             clipFaceAgainstHull(separatingNormal: Vec3, posA: Vec3, quatA: Quaternion_2, worldVertsB1: Vec3[], minDist: number, maxDist: number, result: ConvexPolyhedronContactPoint[]): void;
             /**
              * Clip a face in a hull against the back of a plane.
              * @param planeConstant The constant in the mathematical plane equation
              */
             clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3[];
             /**
              * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
              */
             computeWorldVertices(position: Vec3, quat: Quaternion_2): void;
             computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void;
             /**
              * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
              */
             computeWorldFaceNormals(quat: Quaternion_2): void;
             /**
              * updateBoundingSphereRadius
              */
             updateBoundingSphereRadius(): void;
             /**
              * calculateWorldAABB
              */
             calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
             /**
              * Get approximate convex volume
              */
             volume(): number;
             /**
              * Get an average of all the vertices positions
              */
             getAveragePointLocal(target?: Vec3): Vec3;
             /**
              * Transform all local points. Will change the .vertices
              */
             transformAllPoints(offset: Vec3, quat: Quaternion_2): void;
             /**
              * Checks whether p is inside the polyhedra. Must be in local coords.
              * The point lies outside of the convex hull of the other points if and only if the direction
              * of all the vectors from it to those other points are on less than one half of a sphere around it.
              * @param p A point given in local coordinates
              */
             pointIsInside(p: Vec3): 1 | -1 | false;
             /**
              * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
              * Results are saved in the array maxmin.
              * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
              */
             static project(shape: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion_2, result: number[]): void;
         }

         /** ConvexPolyhedronContactPoint */
          type ConvexPolyhedronContactPoint = {
             point: Vec3;
             normal: Vec3;
             depth: number;
         };

         export  type ConvexPolyhedronParameters = {
             vertices: Float32Array;
             faces: number[][];
         };

         export  class ConvolutionMaterial extends ShaderMaterial {
             readonly kernel: Float32Array;
             constructor(texelSize?: Vector2);
             setTexelSize(x: number, y: number): void;
             setResolution(resolution: Vector2): void;
         }

         export  class CoordSystemModule extends AppModuleBase implements IAppModuleBase {
             #private;
             static moduleName: string;
             options: CoordSystemOption;
             constructor(app?: App, options?: CoordSystemOption);
             onAwake(): void;
             get centerOrigin(): Vector3;
             set centerOrigin(v: Vector3);
             get scaleOrigin(): number;
             set scaleOrigin(v: number);
             /**
              *  unproject 
              * @param x  x
              * @param y y
              * @param opts (false , true) "depth"    (-1  1 )  (xz)     
              * @param retIntersectObject object
              */
             unprojectAsync(x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}): Promise<Vector3>;
             /**
              * 
              * @param x  x
              * @param y y
              * @param opts (false , true)    (-1  1 )  (xz)     
              * @param retIntersectObject object
              */
             unproject(x: number | Vector2, y?: number, opts?: UnProjectOpts, retIntersectObject?: {}): any;
             /**
              * 
              */
             project(x: number | Vector3, y?: number, z?: number): Vector2;
             /**
              * NDC
              */
             screenToNdc(x: number | Vector2, y?: number): Vector2;
             /**
              * NDC
              */
             ndcToScreen(x: number | Vector2, y?: number): Vector2;
             setupUiConfig(): UiObjectConfig;
         }

         /**
          * 
          */
         export  interface CoordSystemOption {
             centerOrigin?: Vector3;
             scaleOrigin?: number;
         }

         /**
          * 
          */
          function copy(out: MatrixArray, m: MatrixArray): MatrixArray;

         /**
          * 
          */
          function copy_2<T extends VectorArray>(out: T, v: VectorArray): T;

         

         /**
          * Copy properties from source to dest. Similar to Object.assign, but only copies properties that exist in source, dest and propList.
          * @param source - source object
          * @param dest - destination object
          * @param propList - list of properties to copy
          *
          * @category JS Object
          */
         export  function copyProps<T = AnyOptions>(source: Record<keyof T, any>, dest: T, propList: Array<keyof T>): T;

         /**
          * 
          */
         export  const creataMeasureRuler: (app: App, opts: MeasureRulerOptions) => Entity;

         /**
          * Create a identity matrix.
          */
          function create(): MatrixArray;

         /**
          * 
          */
          function create_2(x?: number, y?: number): VectorArray;

         export  const createAnimatorFrameSpriteMaterial: (props: SpriteMaterialParameters & AnimatorFrameMaterialProps, app: App) => SpriteMaterial;

          const createCanvas: () => HTMLCanvasElement;

         /**
          * Creates a HTML canvas element.
          * @category DOM
          */
         export  function createCanvasElement(): HTMLCanvasElement;

         export  const createDefaultMarkerElement: (options?: {
             /**  */
             anchor?: Anchor;
             /** html */
             element?: HTMLElement;
             /**  */
             offset?: [number, number];
             /** (0-360) */
             rotation?: number;
             /**  */
             color?: string;
             /**  */
             scale?: number;
         }) => HTMLElement;

         /**
          * Creates a HTML div element.
          * @param innerHTML - HTML string to add to the div
          * @param id - id of the div
          * @param classList - list of classes to add to the div
          * @param addToBody - add the div to the body
          * @param elementTag - tag of the element to create (default: div)
          *
          * @category DOM
          */
         export  function createDiv<T extends keyof HTMLElementTagNameMap = "div">({ innerHTML, id, classList, addToBody, elementTag }: Partial<InnerHTML> & {
             id?: string;
             classList?: string[];
             addToBody?: boolean;
             elementTag?: T;
         }): HTMLElementTagNameMap[T];

         /**
          * 
          */
         export  const createFlowGradientMaterial: (app: App, options: {
             /** minmax */
             object?: Object3D;
             /**  */
             min?: Vector3;
             /**  */
             max?: Vector3;
             /** () */
             lightScale?: number;
             /**  */
             circleTime?: number;
             /**  */
             color?: ColorRepresentation;
             /**  */
             opacity?: number;
             /**  */
             lightColor?: ColorRepresentation;
             /**  */
             topColor?: ColorRepresentation;
             /**  */
             gradient?: boolean;
             /**   */
             heightScale?: number;
             /**  */
             heightOffset?: number;
             /**  */
             topOpacity?: number;
             /**  */
             uLightCount?: number;
             /**  */
             axis?: "X" | "Y" | "Z";
             /**   */
             boxinLocalSpace?: boolean;
         } & MaterialParameters) => CustomShaderMaterial<MaterialConstructor>;

         export  const createFlyline: (opts?: {
             /**  */
             source?: [number, number, number] | Vector3;
             /**  */
             target?: [number, number, number] | Vector3;
             /**  */
             height?: number;
             /**  */
             size?: number;
             /** 1  */
             color: ColorRepresentation;
             /** 2  */
             color2: ColorRepresentation;
             /**   */
             count?: number;
             /**  */
             range?: number;
             /**  */
             speed?: number;
             /**  */
             opacity?: number;
         }, app?: App) => Entity;

         /**
          * Create a Path object from path string data
          * http://www.w3.org/TR/SVG/paths.html#PathData
          * @param  opts Other options
          */
          function createFromString(str: string, opts?: SVGPathOption): SVGPath;

          function createHashMap<T, KEY extends string | number = string | number>(obj?: HashMap<T, KEY> | {
             [key in KEY]?: T;
         } | KEY[]): HashMap<T, KEY>;

         /**
          * Creates a HTML image element from a url.
          * @param url - url of the image
          *
          * @category DOM
          */
         export  function createImage(url: string): Promise<HTMLImageElement>;

         /**  */
         export  const createLabel: (opts: LabelOptions) => Label;

         export  function createMapApp(map: any, options?: AppOptions): App;

          function createObject<T>(proto?: object, properties?: T): T;

          function createPathGetter(ctx: any, path: string): () => any;

          function createProjectionTask({ model, silhouette, outlines, updateProgressCb, updateVisible, ANGLE_THRESHOLD }?: any): {
             onUpdate: () => void;
             cancel: () => boolean;
             promise: (tm?: any) => Promise<any>;
         };

         /** mesh */
         export  function createReflectorShaderMesh<TGeometry extends BufferGeometry = BufferGeometry>(geomerty?: TGeometry | null, materialOptions?: {
             /**  ReflectorMaterial */
             reflectorMaterialType?: "ReflectorMaterial" | "ReflectorDudvMaterial";
             color?: Color;
             map?: Texture | string;
             normalMap?: Texture | string;
             normalScale?: Vector2;
             reflectivity?: number;
             mirror?: number;
             mixStrength?: number;
             fog?: Fog;
             dithering?: boolean;
         } & MaterialParameters, ignoreObjects?: Object3D[], includeObjects?: Object3D[]): {
             mesh: any;
             material: any;
             attachMesh: (mesh: Mesh, useMeshMap?: boolean) => void;
             detachMesh: (mesh: any) => void;
         };

         /**
          * 2d
          * @param elements 
          * @param autoCanvasSize 
          */
         export  const createRender2dTexture: (opts: Render2dTextureOptions) => {
             texture: (param?: {
                 copyData?: boolean;
                 outputImageDebug?: boolean;
                 dispose?: boolean;
                 expandRect?: number | [number, number, number, number];
             }) => Texture;
             update: (cb: (context: {
                 group: render2d.Group;
                 render: render2d.Render2dType;
                 canvas: HTMLCanvasElement;
             }) => boolean) => boolean;
             dispatchEvent: (eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number) => void;
             dispose: () => void;
             render: render2d.Render2dType;
         };

         export  const createRenderElementFlowMaterial: (app: App, options: RenderElementFlowMaterialOptions) => ShaderMaterial & FlowMaterialProps;

         /**  */
         export  const createScreenSpaceEntity: (app?: App) => {
             /**  */
             entity: Entity;
             /**  */
             group: Group_2;
             /**  */
             pixelToPosition: (pixel: any) => Vector3;
             /**  */
             pixelHeightToLength: (pixelHeight: number) => number;
             /**  */
             addObject: (obj: Object3D, pixel?: [number, number]) => void;
             /**  */
             dispose: () => void;
         };

         /**
          * Creates a HTML script element from a url.
          * @param url - url of the script
          * @param root - root element to add the script to (default: head)
          *
          * @category DOM
          */
         export  function createScriptFromURL(url: string, root?: HTMLHeadElement): Promise<HTMLScriptElement>;

         export  const createSpriteAnimator: ({ startFrame, endFrame, fps, frameName, textureDataURL, textureImageURL, loop, numberOfFrames, autoPlay, animationNames, onStart, onEnd, onLoopEnd, onFrame, play, pause, flipX, alphaTest, asSprite, }: SpriteAnimatorProps) => SpriteAnimatorType;

         /**
          * Creates a HTML style element with the given styles.
          * @param styles - CSS string
          * @param root - root element to add the style to (default: head)
          *
          * @category DOM
          */
         export  function createStyles(styles: string, root?: Element | undefined): HTMLStyleElement;

         export  const createSymbolMaterial: (props: SymbolMaterialProps) => PointsMaterial;

         export  const createTextFlowMaterial: (app: App, options: TextFlowMaterialOptions) => ShaderMaterial & FlowMaterialProps;

         export  const createTextMesh: ({ sdfGlyphSize, anchorX, anchorY, fontSize, ...restProps }: TextProps) => Promise<TextType>;

         export  const createUnProjectMenu: (e: MouseEvent, obj: {
             UnProjectOpts: UnProjectOpts | "depth";
         }, opts?: {
             /** ),150px. */
             width?: string;
             /** .(darklight,dark)*/
             theme?: string;
             /** window  map.getContainer().getBoundingClientRect().width */
             innerWidth?: number;
             /** window  map.getContainer().getBoundingClientRect().height */
             innerHeight?: number;
             /**  */
             items: ContextMenuSubItemOptions[];
             /** event . */
             position?: [number, number];
         }, app?: App) => ContextMenu;

         /**  */
         export  const createWallBufferGeometry: (opts: {
             /**  */
             points: [number, number][];
             /**  */
             height: number;
             /**  */
             isClose?: boolean;
             /**  */
             axisUp?: "x" | "y" | "z";
             /** ,  */
             isUseCenter?: boolean;
         }) => {
             geometry: BufferGeometry<NormalBufferAttributes>;
             center: [number, number, number];
         };

         export  function createWorker(obj: Function | string, funcContext?: Record<string, Function | string>): Worker;

         export  function createWorkerWrap(obj: Function | string, funcContext?: Record<string, Function | string>, target?: any): {
             worker: Worker;
             wrap: any;
         };

          enum CRSTypes {
             WGS84 = "WGS84",
             WGS1984 = "WGS84",
             EPSG4326 = "WGS84",
             GCJ02 = "GCJ02",
             AMap = "GCJ02",
             BD09 = "BD09",
             BD09LL = "BD09",
             Baidu = "BD09",
             BMap = "BD09",
             BD09MC = "BD09MC",
             BD09Meter = "BD09MC",
             EPSG3857 = "EPSG3857",
             EPSG900913 = "EPSG3857",
             EPSG102100 = "EPSG3857",
             WebMercator = "EPSG3857",
             WM = "EPSG3857"
         }

          enum CSGOperation {
         }

         /**
          * A template literal tag that does nothing. Useful for syntax highlighting of CSS code.
          *
          * @example
          * ```js
          * const vertexShader = css`
          *    .my-class {
          *        color: red;
          *    }
          * `
          * ```
          * @category Template Literals
          */
         export  const css: (strings: any, ...rest: any[]) => string;

         export  class CSS2DRendererModule extends AppModuleBase implements IAppModuleBase {
             #private;
             static moduleName: string;
             options: CSS2DRendererModuleOptions;
             _popup2d: Popup2D;
             constructor(app?: App, options?: CSS2DRendererModuleOptions);
             get popup2d(): Popup2D;
             get css2dRenderer(): CSS2DRenderer;
             getMarker2Ds(): Marker2D[];
             getPopup2Ds(): Popup2D[];
             onAwake(): void;
             updateMarker2d(): void;
             onAppRender(time: Time): void;
             setupUiConfig(): UiObjectConfig;
         }

         export  interface CSS2DRendererModuleOptions extends CSS2DParameters {
             /** marker500 */
             refreshMarkerOpacityTimeout?: number;
             /**  0 */
             occlusionDistanceDelta?: number;
             /** popup2d */
             popup2dStyle?: PopupOptions;
             /**  */
             parent?: HTMLElement;
         }

         export  class CSS3DRendererModule extends AppModuleBase implements IAppModuleBase {
             #private;
             static moduleName: string;
             options: CSS3DRendererModuleOptions;
             constructor(app?: App, options?: CSS3DRendererModuleOptions);
             get css3dRenderer(): CSS3DRenderer;
             get css3dOccludeRenderer(): CSS3DRenderer;
             onAwake(): void;
             getMarker3Ds(): unknown[];
             setCss3dObjectCanOcclude(object: CSS3DObject, canOcclude?: boolean): void;
             updateMarker3d(): void;
             onAppRender(time: Time): void;
             setupUiConfig(): UiObjectConfig;
         }

         export  interface CSS3DRendererModuleOptions extends CSS3DParameters {
             pixelRatio?: number;
             className?: string;
             style?: Partial<CSSStyleDeclaration>;
             parent?: HTMLElement;
             /** marker500 */
             refreshMarkerOpacityTimeout?: number;
         }

         export  class CubeEmitter implements EmitterShape {
             type: string;
             width: number;
             height: number;
             thickness: number;
             mode: EmitterMode;
             spread: number;
             speed: ValueGenerator | FunctionValueGenerator;
             emissionState: EmissionState;
             constructor(parameters?: CubeEmitterParameters);
             private currentValue;
             update(system: ParticleSystem, delta: number): void;
             initialize(p: Particle): void;
             toJSON(): ShapeJSON;
             static fromJSON(json: any): CubeEmitter;
             clone(): EmitterShape;
         }

         export  interface CubeEmitterParameters {
             width?: number;
             height?: number;
             thickness?: number;
             mode?: EmitterMode;
             spread?: number;
             speed?: ValueGenerator | FunctionValueGenerator;
             emissionState?: EmissionState;
         }

          class CullableTriangle extends Triangle {
             initFrom(other: Triangle): void;
             updateSide(plane: Plane, triangle: Triangle, coplanarIndex: number): void;
         }

          function curry<F extends CurryFunc, T1 extends Parameters<F>[0]>(func: F, a: T1): Curry1<F, T1>;

          function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, a: T1, b: T2): Curry2<F, T1, T2>;

          function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, a: T1, b: T2, c: T3): Curry3<F, T1, T2, T3>;

          function curry<F extends CurryFunc, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, a: T1, b: T2, c: T3, d: T4): Curry4<F, T1, T2, T3, T4>;

          type Curry1<F, T1> = F extends (a: T1, ...args: infer A) => infer R ? (...args: A) => R : unknown;

          type Curry2<F, T1, T2> = F extends (a: T1, b: T2, ...args: infer A) => infer R ? (...args: A) => R : unknown;

          type Curry3<F, T1, T2, T3> = F extends (a: T1, b: T2, c: T3, ...args: infer A) => infer R ? (...args: A) => R : unknown;

          type Curry4<F, T1, T2, T3, T4> = F extends (a: T1, b: T2, c: T3, d: T4, ...args: infer A) => infer R ? (...args: A) => R : unknown;

          type CurryFunc = (...arg: any[]) => any;

         /**
          * Creates a customized ref with explicit control over its dependency tracking
          * and updates triggering.
          *
          * @param factory - The function that receives the `track` and `trigger` callbacks.
          */
          function customRef<T>(factory: CustomRefFactory<T>): Ref<T>;

          type CustomRefFactory<T> = (track: () => void, trigger: () => void) => {
             get: () => T;
             set: (value: T) => void;
         };

         export  class CustomShaderMaterial<T extends MaterialConstructor> extends Material {
             uniforms: Uniform;
             private __csm;
             constructor({ baseMaterial, //
                 fragmentShader, vertexShader, uniforms, patchMap, cacheKey, silent, ...opts }: iCSMParams<T>);
             /**
              *
              * Update the material with new arguments.
              * TODO: Fix memory leak.
              *
              * @param opts Options to update the material with.
              *
              * @deprecated This method leaks memory.
              */
             update(opts?: iCSMUpdateParams<T>): void;
             /**
              * Returns a new instance of this material with the same options.
              *
              * @returns A clone of this material.
              */
             clone(): this;
             /**
              * Internally calculates the cache key for this instance of CSM.
              * If no specific CSM inputs are provided, the cache key is the same as the default
              * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
              *
              * This method is quite expensive owing to the hashing function and string manip.
              *
              * TODO:
              * - Optimize string manip.
              * - Find faster hash function
              *
              * @returns {string} A cache key for this instance of CSM.
              */
             private _getCacheHash;
             /**
              * Does the internal shader generation. Not meant to be called directly.
              *
              * @param fragmentShader
              * @param vertexShader
              * @param uniforms
              */
             private _generateMaterial;
             /**
              * Patches input shader with custom shader. Not meant to be called directly.
              * @param customShader
              * @param shader
              * @param isFrag
              * @returns
              */
             private _patchShader;
             /**
              * Gets the material type as a string. Not meant to be called directly.
              * @returns
              */
             private _getMaterialDefine;
             /**
              * Gets the right patch map for the material. Not meant to be called directly.
              * @returns
              */
             private _getPatchMapForMaterial;
         }

         /**
          * Cylinder class.
          * @example
          *     const radiusTop = 0.5
          *     const radiusBottom = 0.5
          *     const height = 2
          *     const numSegments = 12
          *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
          *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
          *     world.addBody(cylinderBody)
          */
          class Cylinder extends ConvexPolyhedron {
             /** The radius of the top of the Cylinder. */
             radiusTop: number;
             /** The radius of the bottom of the Cylinder. */
             radiusBottom: number;
             /** The height of the Cylinder. */
             height: number;
             /** The number of segments to build the cylinder out of. */
             numSegments: number;
             /**
              * @param radiusTop The radius of the top of the Cylinder.
              * @param radiusBottom The radius of the bottom of the Cylinder.
              * @param height The height of the Cylinder.
              * @param numSegments The number of segments to build the cylinder out of.
              */
             constructor(radiusTop?: number, radiusBottom?: number, height?: number, numSegments?: number);
         }

         export  type CylinderParameters = {
             radiusTop: number;
             radiusBottom: number;
             height: number;
             segments: number;
         };

          interface Debounce {
             <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "leading" | "both"): (...args: Args) => Result;
             <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailing"): (...args: Args) => Result | undefined;
             <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailingPromise"): (...args: Args) => Promise<Result>;
         }

         export  const debounce: Debounce;

         export  function decryptFromBase64(str: string): string;

         /**
          * Access property in an object using a string path. Similar to lodash.get
          * @param access - path to access
          * @param tar - target object
          * @param throwOnInvalid - throw error if invalid access or property is undefined. Default is false
          *
          * @example
          * ```js
          * const obj = {a: {b: {c: 1}}}
          * const c = deepAccessObject(['a', 'b', 'c'], obj)
          * console.log(c) // 1
          * ```
          *
          * @category JS Object
          */
         export  function deepAccessObject(access: string | string[], tar: any, throwOnInvalid?: boolean): any;

          type DeepReadonly<T> = T extends Builtin ? T : T extends Map<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends WeakMap<infer K, infer V> ? WeakMap<DeepReadonly<K>, DeepReadonly<V>> : T extends Set<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends ReadonlySet<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends WeakSet<infer U> ? WeakSet<DeepReadonly<U>> : T extends Promise<infer U> ? Promise<DeepReadonly<U>> : T extends Ref<infer U> ? Readonly<Ref<DeepReadonly<U>>> : T extends {} ? {
             readonly [K in keyof T]: DeepReadonly<T[K]>;
         } : Readonly<T>;

         /** The default easing function used when no easing is specified. */
         export  let DEFAULT_EASING: string;

          type DefaultEventDefinition = Dictionary<EventCallback<any[]>>;

          function defaults<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overlay?: boolean): T & S;

          type DefaultTextStyle = Pick<TextStyleProps, 'fill' | 'stroke' | 'align' | 'verticalAlign'> & {
             autoStroke?: boolean;
         };

         export  class DefaultTool extends StateNode {
             static id: string;
             static initial: string;
             static children: () => (typeof Idle)[];
         }

          function deferredComputed<T>(getter: () => T): ComputedRef<T>;

         export  const DEG2RAD: number;

         export  function degToRad(degrees: number): number;

          class Delatin {
             data: number[];
             width: number;
             height: number;
             coords: any[];
             triangles: any[];
             _halfedges: any[];
             _candidates: any[];
             _queueIndices: any[];
             _queue: any[];
             _errors: any[];
             _rms: any[];
             _pending: any[];
             _pendingLen: number;
             _rmsSum: number;
             constructor(data: number[], width: number, height: number);
             run(maxError?: number): void;
             refine(): void;
             getMaxError(): any;
             getRMSD(): number;
             heightAt(x: any, y: any): number;
         }

         /**
          * Wait for a certain amount of time
          */
         export  class DelayBehavior extends Behavior {
             value: number;
             elapsed: number;
             constructor();
             fromJSON({ value, elapsed }: {
                 value: any;
                 elapsed?: number;
             }): void;
             /**
              *
              * @param json
              * @return {DelayBehavior}
              */
             static fromJSON(json: {
                 value: number;
                 elapsed?: number;
             }): DelayBehavior;
             /**
              *
              * @param {number} seconds in seconds
              * @return {DelayBehavior}
              */
             static from(seconds: number): DelayBehavior;
             initialize(ctx: BehaviorContext): void;
             tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
         }

         export  function deleteArrItem<T>(arr: T[], item: T): void;

          type Dep = Set<ReactiveEffect> & TrackedMarkers;

         export  class DependencyError extends Error {
             constructor(classInstance: any, message: any, activeModule: any, dependencyModule?: boolean);
         }

         

         

         

         export  class DestoryBehavior extends Behavior {
             constructor();
             static create(): DestoryBehavior;
             tick(timeDelta: number): BehaviorStatus;
         }

          type Dictionary<T> = {
             [key: string]: T;
         };

          const DIFFERENCE: CSGOperation;

         /**
          * .
          */
         export  class DiffusedApertureMarker extends AnimateMarkerBase {
             constructor(features: FeatureCollection | {
                 position: [number, number, number?];
                 text?: string;
             }, options?: AnimateMarkerLayerOption);
             setMarkersWidth(width: number, index?: number): void;
             setMarkersColors(colors: string[], index?: number): void;
             _createMarker(): void;
         }

         /**
          * 
          */
         export  function disableBloom(object: Object3D, enable?: boolean): void;

         /**
          * 
          */
         export  function disableBloomSelectedRayQuery(object: Object3D, enable?: boolean, excludeObjs?: Object3D[]): void;

         /**
          * 
          */
         export  function disableOutline(object: Object3D, enable?: boolean): void;

         /**
          * 
          */
         export  function disableRayQuery(object: Object3D, enable?: boolean): void;

         /**
          * 
          */
         export  function disableSelected(object: Object3D, enable?: boolean): void;

          function disableUserSelect(dom: HTMLElement): void;

         export  class DispatchEvent {
             type: string;
             cancelBubble: boolean;
             data: Record<string, any>;
             constructor(type: string);
             stopPropagation(): void;
         }

         /**
          *
          * @param {SignalHandler[]} handlers
          * @param {Array} [args]
          */
         export  function dispatchViaProxy(handlers: any, args: any): void;

          interface Displayable<Props extends DisplayableProps = DisplayableProps> {
             animate(key?: '', loop?: boolean): Animator_2<this>;
             animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
             getState(stateName: string): DisplayableState;
             ensureState(stateName: string): DisplayableState;
             states: Dictionary<DisplayableState>;
             stateProxy: (stateName: string) => DisplayableState;
         }

          class Displayable<Props extends DisplayableProps = DisplayableProps> extends Element_2<Props> {
             /**
              * Whether the displayable object is visible. when it is true, the displayable object
              * is not drawn, but the mouse event can still trigger the object.
              */
             invisible: boolean;
             z: number;
             z2: number;
             /**
              * The z level determines the displayable object can be drawn in which layer canvas.
              */
             zlevel: number;
             /**
              * If enable culling
              */
             culling: boolean;
             /**
              * Mouse cursor when hovered
              */
             cursor: string;
             /**
              * If hover area is bounding rect
              */
             rectHover: boolean;
             /**
              * For increamental rendering
              */
             incremental: boolean;
             /**
              * Never increase to target size
              */
             ignoreCoarsePointer?: boolean;
             style: Dictionary<any>;
             protected _normalState: DisplayableState;
             protected _rect: BoundingRect;
             protected _paintRect: BoundingRect;
             protected _prevPaintRect: BoundingRect;
             dirtyRectTolerance: number;
             /************* Properties will be inejected in other modules. *******************/
             useHoverLayer?: boolean;
             __hoverStyle?: CommonStyleProps;
             __clipPaths?: Path[];
             __canvasFillGradient: CanvasGradient;
             __canvasStrokeGradient: CanvasGradient;
             __canvasFillPattern: CanvasPattern;
             __canvasStrokePattern: CanvasPattern;
             __svgEl: SVGElement;
             constructor(props?: Props);
             protected _init(props?: Props): void;
             beforeBrush(): void;
             afterBrush(): void;
             innerBeforeBrush(): void;
             innerAfterBrush(): void;
             shouldBePainted(viewWidth: number, viewHeight: number, considerClipPath: boolean, considerAncestors: boolean): boolean;
             /**
              * If displayable element contain coord x, y
              */
             contain(x: number, y: number): boolean;
             traverse<Context>(cb: (this: Context, el: this) => void, context?: Context): void;
             /**
              * If bounding rect of element contain coord x, y
              */
             rectContain(x: number, y: number): boolean;
             getPaintRect(): BoundingRect;
             setPrevPaintRect(paintRect: BoundingRect): void;
             getPrevPaintRect(): BoundingRect;
             /**
              * Alias for animate('style')
              * @param loop
              */
             animateStyle(loop: boolean): Animator_2<this["style"]>;
             updateDuringAnimation(targetKey: string): void;
             attrKV(key: DisplayableKey, value: DisplayablePropertyType): void;
             setStyle(obj: Props['style']): this;
             setStyle<T extends keyof Props['style']>(obj: T, value: Props['style'][T]): this;
             dirtyStyle(notRedraw?: boolean): void;
             dirty(): void;
             /**
              * Is style changed. Used with dirtyStyle.
              */
             styleChanged(): boolean;
             /**
              * Mark style updated. Only useful when style is used for caching. Like in the text.
              */
             styleUpdated(): void;
             /**
              * Create a style object with default values in it's prototype.
              */
             createStyle(obj?: Props['style']): Props["style"];
             /**
              * Replace style property.
              * It will create a new style if given obj is not a valid style object.
              */
             useStyle(obj: Props['style']): void;
             /**
              * Determine if an object is a valid style object.
              * Which means it is created by `createStyle.`
              *
              * A valid style object will have all default values in it's prototype.
              * To avoid get null/undefined values.
              */
             isStyleObject(obj: Props['style']): any;
             protected _innerSaveToNormal(toState: DisplayableState): void;
             protected _applyStateObj(stateName: string, state: DisplayableState, normalState: DisplayableState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
             protected _mergeStates(states: DisplayableState[]): DisplayableState;
             protected _mergeStyle(targetStyle: CommonStyleProps, sourceStyle: CommonStyleProps): CommonStyleProps;
             getAnimationStyleProps(): MapToType<DisplayableProps, boolean>;
             /**
              * The string value of `textPosition` needs to be calculated to a real postion.
              * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
              * by default. See `contain/text.js#calculateTextPosition` for more details.
              * But some coutom shapes like "pin", "flag" have center that is not exactly
              * `[width/2, height/2]`. So we provide this hook to customize the calculation
              * for those shapes. It will be called if the `style.textPosition` is a string.
              * @param out Prepared out object. If not provided, this method should
              *        be responsible for creating one.
              * @param style
              * @param rect {x, y, width, height}
                  * @return out The same as the input out.
                  *         {
                  *             x: number. mandatory.
                  *             y: number. mandatory.
                  *             textAlign: string. optional. use style.textAlign by default.
                  *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
                  *         }
                  */
              protected static initDefaultProps: void;
             }

              type DisplayableKey = keyof DisplayableProps;

              type DisplayablePropertyType = PropType<DisplayableProps, DisplayableKey>;

              interface DisplayableProps extends ElementProps {
                 style?: Dictionary<any>;
                 zlevel?: number;
                 z?: number;
                 z2?: number;
                 culling?: boolean;
                 cursor?: string;
                 rectHover?: boolean;
                 progressive?: boolean;
                 incremental?: boolean;
                 ignoreCoarsePointer?: boolean;
                 batch?: boolean;
                 invisible?: boolean;
             }

              type DisplayableState = Pick<DisplayableProps, DisplayableStatePropNames> & ElementCommonState;

              type DisplayableStatePropNames = ElementStatePropNames | 'style' | 'z' | 'z2' | 'invisible';

             /**
              * Dispose render2d instance
              */
              function dispose(zr: Render2D): void;

             /**
              * Dispose all render2d instances
              */
              function disposeAll(): void;

             export  function disposeBoundsTree(): void;

              function disposeBoundsTree_2(): void;

             /**
              * 
              * @param material
              */
             export  const disposeMaterial: (material: Mesh | Material | Material[]) => any;

             /**
              * 
              * @param object3D
              */
             export  function disposeObject3D(object3D: Object3D): boolean;

              const dist: typeof distance;

             /**  */
             export  function dist2d(coord1: [number, number], coord2: [number, number]): number;

             /**
              * 
              */
              function distance(v1: VectorArray, v2: VectorArray): number;

             /**
              * Constrains two bodies to be at a constant distance from each others center of mass.
              */
              class DistanceConstraint extends Constraint {
                 /**
                  * The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
                  */
                 distance: number;
                 distanceEquation: ContactEquation;
                 /**
                  * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB.
                  * @param maxForce The maximum force that should be applied to constrain the bodies.
                  */
                 constructor(bodyA: Body_2, bodyB: Body_2, distance?: number, maxForce?: number);
                 /**
                  * update
                  */
                 update(): void;
             }

             /**
              * 
              */
              function distanceSquare(v1: VectorArray, v2: VectorArray): number;

              const distSquare: typeof distanceSquare;

             /**
              * 
              */
              function div<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

              interface DividePath {
                 (params: DividePathParams): Path[];
             }

              interface DividePathParams {
                 path: Path;
                 count: number;
             }

              const DOLLY_DIRECTION: {
                 readonly NONE: 0;
                 readonly IN: 1;
                 readonly OUT: -1;
             };

              type DOLLY_DIRECTION = typeof DOLLY_DIRECTION[keyof typeof DOLLY_DIRECTION];

             export  class DOM {
                 static create(tagName: string, className?: string, container?: HTMLElement): HTMLElement;
                 static createNS(namespaceURI: string, tagName: string): Element;
                 static isMobile(): boolean;
                 static setTransform(el: HTMLElement, value: string): void;
                 static remove(node: HTMLElement): void;
                 /** htmlcssdiv */
                 static createStyledDiv(htmlContent: string, cssString?: string): HTMLDivElement;
             }

              type DoneCallback = () => void;

             export  class DonutEmitter implements EmitterShape {
                 type: string;
                 radius: number;
                 donutRadius: number;
                 arc: number;
                 thickness: number;
                 mode: EmitterMode;
                 spread: number;
                 speed: ValueGenerator | FunctionValueGenerator;
                 constructor(parameters?: DonutEmitterParameters);
                 private currentValue;
                 update(system: ParticleSystem, delta: number): void;
                 initialize(p: Particle, emissionState: EmissionState): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any): DonutEmitter;
                 clone(): EmitterShape;
             }

             /**
              * Interface representing the parameters for a donut emitter.
              */
             export  interface DonutEmitterParameters {
                 /**
                  * The radius of the donut.
                  */
                 radius?: number;
                 /**
                  * The arc of the donut.
                  */
                 arc?: number;
                 /**
                  * The thickness of the ring. 1 is a full donut, 0 is a ring with 0 radius.
                  */
                 thickness?: number;
                 /**
                  * The radius of the hole in the center of the donut.
                  */
                 donutRadius?: number;
                 /**
                  * The mode of the emitter.
                  * {@link EmitterMode}
                  */
                 mode?: EmitterMode;
                 /**
                  * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
                  * {@link EmitterMode}
                  */
                 spread?: number;
                 /**
                  * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
                  * {@link EmitterMode}
                  */
                 speed?: ValueGenerator | FunctionValueGenerator;
             }

             /**
              * 
              */
              function dot(v1: VectorArray, v2: VectorArray): number;

             

             /**
              * Download a blob as a file in the browser.
              * @param b - blob to download
              * @param name - name of the file
              * @category Browser
              */
             export  function downloadBlob(b: Blob | string, name: string, options?: BlobPropertyBag): void;

             /**
              * Download a file in the browser.
              * @param b - file to download
              * @param name - name of the file (optional)
              * @category Browser
              */
             export  function downloadFile(b: File, name?: string): void;

              class DrawLine extends StateNode {
                 #private;
                 static id: string;
                 polylines: PolylinesEntity;
                 data: PolylineItemData;
                 drawOptions?: Record<string, any>;
                 highLightSymbolEntity: SymbolEntity;
                 snapSymbolEntity: SymbolEntity;
                 snapSymbolData: SymbolItemData[];
                 onPointerUp: (info: TLEventHandler) => Promise<void>;
                 onPointerMove: (info: TLEventHandler) => Promise<void>;
                 onMouseDblClick: (info: TLEventHandler) => void;
                 onKeyUp: (info: TLEventHandler) => void;
                 onContextMenu: (info: TLEventHandler) => ContextMenu;
                 onEnter: (info: any) => void;
                 onExit: (info: TLEventType, from: string) => void;
                 complete(isDblClick?: boolean): void;
             }

              class DrawPoint extends StateNode {
                 #private;
                 static id: string;
                 symbol: SymbolEntity;
                 data: SymbolItemData;
                 drawOptions?: Record<string, any>;
                 highLightSymbolEntity: SymbolEntity;
                 snapSymbolEntity: SymbolEntity;
                 snapSymbolData: SymbolItemData[];
                 onPointerUp: (info: TLEventHandler) => Promise<void>;
                 onPointerMove: (info: TLEventHandler) => Promise<void>;
                 onKeyUp: (info: TLEventHandler) => void;
                 onContextMenu: (info: TLEventHandler) => ContextMenu;
                 onEnter: (info: any) => void;
                 onExit: (info: TLEventType, from: string) => void;
                 complete(isDblClick?: boolean): void;
             }

              class DrawPolygon extends StateNode {
                 #private;
                 static id: string;
                 polygons: PolygonsEntity;
                 polyEdge: PolylinesEntity;
                 data: PolygonItemData;
                 drawOptions?: Record<string, any>;
                 highLightSymbolEntity: SymbolEntity;
                 snapSymbolEntity: SymbolEntity;
                 snapSymbolData: SymbolItemData[];
                 onPointerUp: (info: TLEventHandler) => Promise<void>;
                 onPointerMove: (info: TLEventHandler) => Promise<void>;
                 onMouseDblClick: (info: TLEventHandler) => void;
                 onKeyUp: (info: TLEventHandler) => void;
                 onContextMenu: (info: TLEventHandler) => ContextMenu;
                 onEnter: (info: any) => void;
                 onExit: (info: TLEventType, from: string) => void;
                 complete(isDblClick?: boolean): void;
             }

             export  class DrawShapeTool extends StateNode {
                 static id: string;
                 static initial: string;
                 static children: () => (typeof DrawLine | typeof DrawPoint | typeof DrawPolygon | typeof Edit | typeof Idle_2)[];
                 onExit: () => void;
             }

              class Droplet extends Path<DropletProps> {
                 shape: DropletShape;
                 constructor(opts?: DropletProps);
                 getDefaultShape(): DropletShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: DropletShape): void;
             }

              interface DropletProps extends PathProps {
                 shape?: Partial<DropletShape>;
             }

              class DropletShape {
                 cx: number;
                 cy: number;
                 width: number;
                 height: number;
             }

             export  interface DynamicEnvConfig {
                 envmap1: Texture;
                 envmap2: Texture;
             }

             /**  */
             export  class DynamicEnvironment {
                 #private;
                 app: App;
                 fbo: any;
                 material: ShaderMaterial;
                 quad: FullScreenQuad;
                 constructor(app: App, config?: Partial<DynamicEnvConfig>);
                 dispose(): void;
                 update(): void;
                 get texture(): any;
                 setWeight(value: number): void;
                 setIntensity(value: number): void;
                 lerpWeight(value: number, duration: number): void;
                 lerpIntensity(value: number, duration: number): void;
             }

             export  class DynamicInstancedMesh extends InstancedMesh {
                 maxCapacity: number;
                 constructor(geometry: any, material: any, count: any);
                 addInstance(matrix4: any, color: any, computeBoundingSphere?: boolean): number;
                 removeInstance(i: any, computeBoundingSphere?: boolean): boolean;
             }

             /**
              * 
              */
              function each<I extends Dictionary<any> | any[] | readonly any[] | ArrayLike_2<any>, Context>(arr: I, cb: (this: Context, value: I extends (infer T)[] | readonly (infer T)[] | ArrayLike_2<infer T> ? T : I extends Dictionary<any> ? I extends Record<infer K, infer T> ? T : unknown : unknown, index?: I extends any[] | readonly any[] | ArrayLike_2<any> ? number : keyof I & string, // keyof Dictionary will return number | string
             arr?: I) => void, context?: Context): void;

             /** Type representing an easing type, which can be either a predefined easing function or a custom easing function. */
             export  type Easing = keyof Easings | EasingFunction | 'linear' | 'easeInSine' | 'easeOutSine' | 'easeInOutSine' | 'easeInQuad' | 'easeOutQuad' | 'easeInOutQuad' | 'easeInCubic' | 'easeOutCubic' | 'easeInOutCubic' | 'easeInQuart' | 'easeOutQuart' | 'easeInOutQuart' | 'easeInQuint' | 'easeOutQuint' | 'easeInOutQuint' | 'easeInExpo' | 'easeOutExpo' | 'easeInOutExpo' | 'easeInCirc' | 'easeOutCirc' | 'easeInOutCirc' | 'easeInBack' | 'easeOutBack' | 'easeInOutBack' | 'easeInElastic' | 'easeOutElastic' | 'easeInOutElastic' | 'easeInBounce' | 'easeOutBounce' | 'easeInOutBounce';

              type easingFunc = (percent: number) => number;

              const easingFuncs: {
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 linear(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quadraticIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quadraticOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quadraticInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 cubicIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 cubicOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 cubicInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quarticIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quarticOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quarticInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quinticIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quinticOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 quinticInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 sinusoidalIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 sinusoidalOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 sinusoidalInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 exponentialIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 exponentialOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 exponentialInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 circularIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 circularOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 circularInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 elasticIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 elasticOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 elasticInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 backIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 backOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 backInOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 bounceIn(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 bounceOut(k: number): number;
                 /**
                  * @param {number} k
                  * @return {number}
                  */
                 bounceInOut(k: number): number;
             };

             /** Type representing an easing function that takes a single numeric parameter and returns a numeric result. */
             export  type EasingFunction = (x: number) => number;

             /**
              * Class that provides various easing functions for tweening animations.
              * For more info on these easing functions, check https://easings.net.
              */
             export  class Easings {
                 static linear(x: number): number;
                 static easeInSine(x: number): number;
                 static easeOutSine(x: number): number;
                 static easeInOutSine(x: number): number;
                 static easeInQuad(x: number): number;
                 static easeOutQuad(x: number): number;
                 static easeInOutQuad(x: number): number;
                 static easeInCubic(x: number): number;
                 static easeOutCubic(x: number): number;
                 static easeInOutCubic(x: number): number;
                 static easeInQuart(x: number): number;
                 static easeOutQuart(x: number): number;
                 static easeInOutQuart(x: number): number;
                 static easeInQuint(x: number): number;
                 static easeOutQuint(x: number): number;
                 static easeInOutQuint(x: number): number;
                 static easeInExpo(x: number): number;
                 static easeOutExpo(x: number): number;
                 static easeInOutExpo(x: number): number;
                 static easeInCirc(x: number): number;
                 static easeOutCirc(x: number): number;
                 static easeInOutCirc(x: number): number;
                 static easeInBack(x: number): number;
                 static easeOutBack(x: number): number;
                 static easeInOutBack(x: number): number;
                 static easeInElastic(x: number): number;
                 static easeOutElastic(x: number): number;
                 static easeInOutElastic(x: number): number;
                 static easeInBounce(x: number): number;
                 static easeOutBounce(x: number): number;
                 static easeInOutBounce(x: number): number;
             }

             

              class EdgesHelper extends LineSegments {
                 constructor(edges?: Line3[]);
                 setEdges(edges: Line3[]): void;
             }

              type EdgeWeight = number;

              class Edit extends StateNode {
                 #private;
                 static id: string;
                 editOptions?: Record<string, any>;
                 queryEntities(info: TLEventHandler, ents?: Entity[]): InteractiveObject;
                 onPointerDown: (info: TLEventHandler) => void;
                 onPointerMove: (info: TLEventHandler) => void;
                 onKeyUp: (info: TLEventHandler) => void;
                 onContextMenu: (info: TLEventHandler) => void;
                 complete(delay?: boolean): void;
                 onPointerUp: (info: TLEventHandler) => void;
                 onMouseDblClick: (info: TLEventHandler) => void;
                 onEnter: (info: TLEventType) => void;
                 clearSelection(isGotoChildEdit?: boolean): void;
                 onExit: (info: TLEventType, from: string) => void;
             }

             

             /**
              * Registers the given function to track reactive updates.
              *
              * The given function will be run once immediately. Every time any reactive
              * property that's accessed within it gets updated, the function will run again.
              *
              * @param fn - The function that will track reactive updates.
              * @param options - Allows to control the effect's behaviour.
              * @returns A runner that can be used to control the effect after creation.
              */
              function effect<T = any>(fn: () => T, options?: ReactiveEffectOptions): ReactiveEffectRunner;

             

             

             

              type EffectScheduler = (...args: any[]) => any;

              class EffectScope {
                 detached: boolean;
                 constructor(detached?: boolean);
                 get active(): boolean;
                 run<T>(fn: () => T): T | undefined;
                 stop(fromParent?: boolean): void;
             }

             /**
              * Creates an effect scope object which can capture the reactive effects (i.e.
              * computed and watchers) created within it so that these effects can be
              * disposed together. For detailed use cases of this API, please consult its
              *
              * @param detached - Can be used to create a "detached" effect scope.
              */
              function effectScope(detached?: boolean): EffectScope;

              interface Element_2<Props extends ElementProps = ElementProps> extends Transformable, Eventful<{
                 [key in ElementEventName]: (e: ElementEvent) => void | boolean;
             } & {
                 [key in string]: (...args: any) => void | boolean;
             }>, ElementEventHandlerProps {
             }

              class Element_2<Props extends ElementProps = ElementProps> {
                 id: number;
                 /**
                  * Element type
                  */
                 type: string;
                 /**
                  * Element name
                  */
                 name: string;
                 /**
                  * If ignore drawing and events of the element object
                  */
                 ignore: boolean;
                 /**
                  * Whether to respond to mouse events.
                  */
                 silent: boolean;
                 /**
                  *  Group
                  */
                 isGroup: boolean;
                 /**
                  * Whether it can be dragged.
                  */
                 draggable: boolean | 'horizontal' | 'vertical';
                 /**
                  * Whether is it dragging.
                  */
                 dragging: boolean;
                 parent: Group;
                 animators: Animator_2<any>[];
                 /**
                  * If ignore clip from it's parent or hosts.
                  * Applied on itself and all it's children.
                  *
                  * NOTE: It won't affect the clipPath set on the children.
                  */
                 ignoreClip: boolean;
                 /**
                  * If element is used as a component of other element.
                  */
                 __hostTarget: Element_2;
                 /**
                  * Render2D instance will be assigned when element is associated with render2d
                  */
                 __zr: Render2dType;
                 /**
                  * Dirty bits.
                  * From which painter will determine if this displayable object needs brush.
                  */
                 __dirty: number;
                 /**
                  * If element was painted on the screen
                  */
                 __isRendered: boolean;
                 /**
                  * If element has been moved to the hover layer.
                  *
                  * If so, dirty will only trigger the render2d refresh hover layer
                  */
                 __inHover: boolean;
                 /**
                  * path to clip the elements and its children, if it is a group.
                  * @see http://www.w3.org/TR/2dcontext/#clipping-region
                  */
                 private _clipPath?;
                 /**
                  * Attached text element.
                  * `position`, `style.textAlign`, `style.textVerticalAlign`
                  * of element will be ignored if textContent.position is set
                  */
                 private _textContent?;
                 /**
                  * Text guide line.
                  */
                 private _textGuide?;
                 /**
                  * Config of textContent. Inlcuding layout, color, ...etc.
                  */
                 textConfig?: ElementTextConfig;
                 /**
                  * Config for guide line calculating.
                  *
                  * NOTE: This is just a property signature. READ and WRITE are all done in .
                  */
                 textGuideLineConfig?: ElementTextGuideLineConfig;
                 /**
                  * Id for mapping animation
                  */
                 anid: string;
                 extra: Dictionary<unknown>;
                 currentStates?: string[];
                 prevStates?: string[];
                 /**
                  * Store of element state.
                  * '__normal__' key is preserved for default properties.
                  */
                 states: Dictionary<ElementState>;
                 /**
                  * Animation config applied on state switching.
                  */
                 stateTransition: ElementAnimateConfig;
                 /**
                  * Proxy function for getting state with given stateName.
                  * Render2D will first try to get with stateProxy. Then find from states if stateProxy returns nothing
                  *
                  * targetStates will be given in useStates
                  */
                 stateProxy?: (stateName: string, targetStates?: string[]) => ElementState;
                 protected _normalState: ElementState;
                 private _innerTextDefaultStyle;
                 constructor(props?: Props);
                 protected _init(props?: Props): void;
                 /**
                  * Drift element
                  * @param {number} dx dx on the global space
                  * @param {number} dy dy on the global space
                  */
                 drift(dx: number, dy: number, e?: ElementEvent): void;
                 /**
                  * Hook before update
                  */
                 beforeUpdate(): void;
                 /**
                  * Hook after update
                  */
                 afterUpdate(): void;
                 /**
                  * Update each frame
                  */
                 update(): void;
                 updateInnerText(forceUpdate?: boolean): void;
                 protected canBeInsideText(): boolean;
                 protected getInsideTextFill(): string | undefined;
                 protected getInsideTextStroke(textFill: string): string | undefined;
                 protected getOutsideFill(): string | undefined;
                 protected getOutsideStroke(textFill: string): string;
                 traverse<Context>(cb: (this: Context, el: Element_2<Props>) => void, context?: Context): void;
                 protected attrKV(key: string, value: unknown): void;
                 /**
                  * Hide the element
                  */
                 hide(): void;
                 /**
                  * Show the element
                  */
                 show(): void;
                 attr(keyOrObj: Props): this;
                 attr<T extends keyof Props>(keyOrObj: T, value: Props[T]): this;
                 saveCurrentToNormalState(toState: ElementState): void;
                 protected _innerSaveToNormal(toState: ElementState): void;
                 protected _savePrimaryToNormal(toState: Dictionary<any>, normalState: Dictionary<any>, primaryKeys: readonly string[]): void;
                 /**
                  * If has any state.
                  */
                 hasState(): boolean;
                 /**
                  * Get state object
                  */
                 getState(name: string): ElementState;
                 /**
                  * Ensure state exists. If not, will create one and return.
                  */
                 ensureState(name: string): ElementState;
                 /**
                  * Clear all states.
                  */
                 clearStates(noAnimation?: boolean): void;
                 /**
                  * Use state. State is a collection of properties.
                  * Will return current state object if state exists and stateName has been changed.
                  *
                  * @param stateName State name to be switched to
                  * @param keepCurrentState If keep current states.
                  *      If not, it will inherit from the normal state.
                  */
                 useState(stateName: string, keepCurrentStates?: boolean, noAnimation?: boolean, forceUseHoverLayer?: boolean): any;
                 /**
                  * Apply multiple states.
                  * @param states States list.
                  */
                 useStates(states: string[], noAnimation?: boolean, forceUseHoverLayer?: boolean): void;
                 /**
                  * Return if el.silent or any ancestor element has silent true.
                  */
                 isSilent(): boolean;
                 /**
                  * Update animation targets when reference is changed.
                  */
                 private _updateAnimationTargets;
                 /**
                  * Remove state
                  * @param state State to remove
                  */
                 removeState(state: string): void;
                 /**
                  * Replace exists state.
                  * @param oldState
                  * @param newState
                  * @param forceAdd If still add when even if replaced target not exists.
                  */
                 replaceState(oldState: string, newState: string, forceAdd: boolean): void;
                 /**
                  * Toogle state.
                  */
                 toggleState(state: string, enable: boolean): void;
                 protected _mergeStates(states: ElementState[]): ElementState;
                 protected _applyStateObj(stateName: string, state: ElementState, normalState: ElementState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
                 /**
                  * Component is some elements attached on this element for specific purpose.
                  * Like clipPath, textContent
                  */
                 private _attachComponent;
                 private _detachComponent;
                 /**
                  * Get clip path
                  */
                 getClipPath(): Path<PathProps>;
                 /**
                  * Set clip path
                  *
                  * clipPath can't be shared between two elements.
                  */
                 setClipPath(clipPath: Path): void;
                 /**
                  * Remove clip path
                  */
                 removeClipPath(): void;
                 /**
                  * Get attached text content.
                  */
                 getTextContent(): ZRText;
                 /**
                  * Attach text on element
                  */
                 setTextContent(textEl: ZRText): void;
                 /**
                  * Set layout of attached text. Will merge with the previous.
                  */
                 setTextConfig(cfg: ElementTextConfig): void;
                 /**
                  * Remove text config
                  */
                 removeTextConfig(): void;
                 /**
                  * Remove attached text element.
                  */
                 removeTextContent(): void;
                 getTextGuideLine(): Polyline;
                 setTextGuideLine(guideLine: Polyline): void;
                 removeTextGuideLine(): void;
                 /**
                  * Mark element needs to be repainted
                  */
                 markRedraw(): void;
                 /**
                  * Besides marking elements to be refreshed.
                  * It will also invalid all cache and doing recalculate next frame.
                  */
                 dirty(): void;
                 private _toggleHoverLayerFlag;
                 /**
                  * Add self from render2d instance.
                  * Not recursively because it will be invoked when element added to storage.
                  */
                 addSelfToZr(zr: Render2dType): void;
                 /**
                  * Remove self from render2d instance.
                  * Not recursively because it will be invoked when element added to storage.
                  */
                 removeSelfFromZr(zr: Render2dType): void;
                 /**
                  * 
                  *
                  * @param path The key to fetch value from object. Mostly style or shape.
                  * @param loop Whether to loop animation.
                  * @param allowDiscreteAnimation Whether to allow discrete animation
                  * @example:
                  *     el.animate('style', false)
                  *         .when(1000, {x: 10} )
                  *         .done(function(){ // Animation done })
                  *         .start()
                  */
                 animate(key?: string, loop?: boolean, allowDiscreteAnimation?: boolean): Animator_2<any>;
                 addAnimator(animator: Animator_2<any>, key: string): void;
                 updateDuringAnimation(key: string): void;
                 /**
                  * 
                  * @param {boolean} forwardToLast If move to last frame before stop
                  */
                 stopAnimation(scope?: string, forwardToLast?: boolean): this;
                 /**
                  * @param animationProps A map to specify which property to animate. If not specified, will animate all.
                  * @example
                  *  // Animate position
                  *  el.animateTo({
                  *      position: [10, 10]
                  *  }, { done: () => { // done } })
                  *
                  *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
                  *  el.animateTo({
                  *      shape: {
                  *          width: 500
                  *      },
                  *      style: {
                  *          fill: 'red'
                  *      }
                  *      position: [10, 10]
                  *  }, {
                  *      duration: 100,
                  *      delay: 100,
                  *      easing: 'cubicOut',
                  *      done: () => { // done }
                  *  })
                  */
                 animateTo(target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
                 /**
                  * Animate from the target state to current state.
                  * The params and the value are the same as `this.animateTo`.
                  */
                 animateFrom(target: Props, cfg: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
                 protected _transitionState(stateName: string, target: Props, cfg?: ElementAnimateConfig, animationProps?: MapToType<Props, boolean>): void;
                 /**
                  * Interface of getting the minimum bounding box.
                  */
                 getBoundingRect(): BoundingRect;
                 getPaintRect(): BoundingRect;
                 /**
                  * The string value of `textPosition` needs to be calculated to a real postion.
                  * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
                  * by default. See `contain/text.js#calculateTextPosition` for more details.
                  * But some coutom shapes like "pin", "flag" have center that is not exactly
                  * `[width/2, height/2]`. So we provide this hook to customize the calculation
                  * for those shapes. It will be called if the `style.textPosition` is a string.
                  * @param {Obejct} [out] Prepared out object. If not provided, this method should
                  *        be responsible for creating one.
                  * @param {module:render2d/graphic/Style} style
                  * @param {Object} rect {x, y, width, height}
                  * @return {Obejct} out The same as the input out.
                  *         {
                  *             x: number. mandatory.
                  *             y: number. mandatory.
                  *             align: string. optional. use style.textAlign by default.
                  *             verticalAlign: string. optional. use style.textVerticalAlign by default.
                  *         }
                  */
                 calculateTextPosition: ElementCalculateTextPosition;
                 protected static initDefaultProps: void;
             }

              interface ElementAnimateConfig {
                 duration?: number;
                 delay?: number;
                 easing?: AnimationEasing;
                 during?: (percent: number) => void;
                 done?: Function;
                 aborted?: Function;
                 scope?: string;
                 /**
                  * If force animate
                  * Prevent stop animation and callback
                  * immediently when target values are the same as current values.
                  */
                 force?: boolean;
                 /**
                  * If use additive animation.
                  */
                 additive?: boolean;
                 /**
                  * If set to final state before animation started.
                  * It can be useful if something you want to calcuate depends on the final state of element.
                  * Like bounding rect for text layouting.
                  *
                  * Only available in animateTo
                  */
                 setToFinal?: boolean;
             }

              type ElementCalculateTextPosition = (out: TextPositionCalculationResult, style: ElementTextConfig, rect: RectLike) => TextPositionCalculationResult;

              type ElementCommonState = {
                 hoverLayer?: boolean;
             };

              interface ElementEvent {
                 type: ElementEventName;
                 event: ZRRawEvent;
                 target: Element_2;
                 topTarget: Element_2;
                 cancelBubble: boolean;
                 offsetX: number;
                 offsetY: number;
                 gestureEvent: string;
                 pinchX: number;
                 pinchY: number;
                 pinchScale: number;
                 wheelDelta: number;
                 zrByTouch: boolean;
                 which: number;
                 stop: (this: ElementEvent) => void;
             }

              type ElementEventCallback<Ctx, Impl> = (this: CbThis<Ctx, Impl>, e: ElementEvent) => boolean | void;

              interface ElementEventHandlerProps {
                 onclick: ElementEventCallback<unknown, unknown>;
                 ondblclick: ElementEventCallback<unknown, unknown>;
                 onmouseover: ElementEventCallback<unknown, unknown>;
                 onmouseout: ElementEventCallback<unknown, unknown>;
                 onmousemove: ElementEventCallback<unknown, unknown>;
                 onmousewheel: ElementEventCallback<unknown, unknown>;
                 onmousedown: ElementEventCallback<unknown, unknown>;
                 onmouseup: ElementEventCallback<unknown, unknown>;
                 oncontextmenu: ElementEventCallback<unknown, unknown>;
                 ondrag: ElementEventCallback<unknown, unknown>;
                 ondragstart: ElementEventCallback<unknown, unknown>;
                 ondragend: ElementEventCallback<unknown, unknown>;
                 ondragenter: ElementEventCallback<unknown, unknown>;
                 ondragleave: ElementEventCallback<unknown, unknown>;
                 ondragover: ElementEventCallback<unknown, unknown>;
                 ondrop: ElementEventCallback<unknown, unknown>;
             }

              type ElementEventName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseover' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu' | 'drag' | 'dragstart' | 'dragend' | 'dragenter' | 'dragleave' | 'dragover' | 'drop' | 'globalout';

              interface ElementProps extends Partial<ElementEventHandlerProps>, Partial<Pick<Transformable, TransformProp>> {
                 name?: string;
                 ignore?: boolean;
                 isGroup?: boolean;
                 draggable?: boolean | 'horizontal' | 'vertical';
                 silent?: boolean;
                 ignoreClip?: boolean;
                 globalScaleRatio?: number;
                 textConfig?: ElementTextConfig;
                 textContent?: ZRText;
                 clipPath?: Path;
                 drift?: Element_2['drift'];
                 extra?: Dictionary<unknown>;
                 anid?: string;
             }

              type ElementSSRData = zrUtil.HashMap<unknown>;

              type ElementSSRDataGetter<T> = (el: Element_2) => zrUtil.HashMap<T>;

              type ElementState = Pick<ElementProps, ElementStatePropNames> & ElementCommonState;

              type ElementStatePropNames = (typeof PRIMARY_STATES_KEYS)[number] | 'textConfig';

              interface ElementTextConfig {
                 /**
                  * Position relative to the element bounding rect
                  * @default 'inside'
                  */
                 position?: BuiltinTextPosition | (number | string)[];
                 /**
                  * Rotation of the label.
                  */
                 rotation?: number;
                 /**
                  * Rect that text will be positioned.
                  * Default to be the rect of element.
                  */
                 layoutRect?: RectLike;
                 /**
                  * Offset of the label.
                  * The difference of offset and position is that it will be applied
                  * in the rotation
                  */
                 offset?: number[];
                 /**
                  * Origin or rotation. Which is relative to the bounding box of the attached element.
                  * Can be percent value. Relative to the bounding box.
                  * If specified center. It will be center of the bounding box.
                  *
                  * Only available when position and rotation are both set.
                  */
                 origin?: (number | string)[] | 'center';
                 /**
                  * Distance to the rect
                  * @default 5
                  */
                 distance?: number;
                 /**
                  * If use local user space. Which will apply host's transform
                  * @default false
                  */
                 local?: boolean;
                 /**
                  * `insideFill` is a color string or left empty.
                  * If a `textContent` is "inside", its final `fill` will be picked by this priority:
                  * `textContent.style.fill` > `textConfig.insideFill` > "auto-calculated-fill"
                  * In most cases, "auto-calculated-fill" is white.
                  */
                 insideFill?: string;
                 /**
                  * `insideStroke` is a color string or left empty.
                  * If a `textContent` is "inside", its final `stroke` will be picked by this priority:
                  * `textContent.style.stroke` > `textConfig.insideStroke` > "auto-calculated-stroke"
                  *
                  * The rule of getting "auto-calculated-stroke":
                  * If (A) the `fill` is specified in style (either in `textContent.style` or `textContent.style.rich`)
                  * or (B) needed to draw text background (either defined in `textContent.style` or `textContent.style.rich`)
                  * "auto-calculated-stroke" will be null.
                  * Otherwise, "auto-calculated-stroke" will be the same as `fill` of this element if possible, or null.
                  *
                  * The reason of (A) is not decisive:
                  * 1. If users specify `fill` in style and still use "auto-calculated-stroke", the effect
                  * is not good and unexpected in some cases. It not easy and seams uncessary to auto calculate
                  * a proper `stroke` for the given `fill`, since they can specify `stroke` themselve.
                  * 2. Backward compat.
                  */
                 insideStroke?: string;
                 /**
                  * `outsideFill` is a color string or left empty.
                  * If a `textContent` is "inside", its final `fill` will be picked by this priority:
                  * `textContent.style.fill` > `textConfig.outsideFill` > #000
                  */
                 outsideFill?: string;
                 /**
                  * `outsideStroke` is a color string or left empth.
                  * If a `textContent` is not "inside", its final `stroke` will be picked by this priority:
                  * `textContent.style.stroke` > `textConfig.outsideStroke` > "auto-calculated-stroke"
                  *
                  * The rule of getting "auto-calculated-stroke":
                  * If (A) the `fill` is specified in style (either in `textContent.style` or `textContent.style.rich`)
                  * or (B) needed to draw text background (either defined in `textContent.style` or `textContent.style.rich`)
                  * "auto-calculated-stroke" will be null.
                  * Otherwise, "auto-calculated-stroke" will be a neer white color to distinguish "front end"
                  * label with messy background (like other text label, line or other graphic).
                  */
                 outsideStroke?: string;
                 /**
                  * Tell render2d I can sure this text is inside or not.
                  * In case position is not using builtin `inside` hints.
                  */
                 inside?: boolean;
             }

              interface ElementTextGuideLineConfig {
                 /**
                  * Anchor for text guide line.
                  * Notice: Won't work
                  */
                 anchor?: Point;
                 /**
                  * If above the target element.
                  */
                 showAbove?: boolean;
                 /**
                  * Candidates of connectors. Used when autoCalculate is true and anchor is not specified.
                  */
                 candidates?: ('left' | 'top' | 'right' | 'bottom')[];
             }

              class Ellipse extends Path<EllipseProps> {
                 shape: EllipseShape;
                 constructor(opts?: EllipseProps);
                 getDefaultShape(): EllipseShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: EllipseShape): void;
             }

              interface EllipseProps extends PathProps {
                 shape?: Partial<EllipseShape>;
             }

              class EllipseShape {
                 cx: number;
                 cy: number;
                 rx: number;
                 ry: number;
             }

             /**
              * Find all URLs in svg, download them and replace with the URL in svg with the downloaded data URLs.
              * @param str - string
              * @param downloader - function to download the URLs in svg and return the data URL
              *
              * @category HTML To Image
              */
             export  function embedUrlRefs(str: string, downloader?: (p: string) => Promise<string>): Promise<string>;

             export  interface EmissionState {
                 burstIndex: number;
                 burstWaveIndex: number;
                 burstParticleIndex: number;
                 burstParticleCount: number;
                 isBursting: boolean;
                 time: number;
                 waitEmiting: number;
                 travelDistance: number;
                 previousWorldPos?: Vector3;
             }

              interface EmissionState_2 {
                 time: number;
             }

             /**
              * Emit a sub particle system from particles.
              */
             export  class EmitSubParticleSystem implements Simulation {
                 private particleSystem;
                 useVelocityAsBasis: boolean;
                 subParticleSystem: ParticleEmitter<Object3DEventMap> | undefined;
                 mode: SubParticleEmitMode;
                 emitProbability: number;
                 type: string;
                 private q_;
                 private v_;
                 private v2_;
                 private subEmissions;
                 constructor(particleSystem: ParticleSystem, useVelocityAsBasis: boolean, subParticleSystem: ParticleEmitter<Object3DEventMap> | undefined, mode?: SubParticleEmitMode, emitProbability?: number);
                 initialize(particle: Particle): void;
                 update(particle: Particle, delta: number): void;
                 private emit;
                 frameUpdate(delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any, particleSystem: ParticleSystem): Simulation;
                 clone(): Simulation;
                 reset(): void;
                 private setMatrixFromParticle;
             }

             export  function EmitterFromJSON(json: ShapeJSON, meta: JsonMetaData): EmitterShape;

             /**
              * Enum representing the emitter modes for particles.
              */
             export  enum EmitterMode {
                 /**
                  * Emit particles randomly over the specified duration.
                  */
                 Random = 0,
                 /**
                  * Emit particles in a continuous loop.
                  */
                 Loop = 1,
                 /**
                  * Emit particles back and forth in a ping-pong manner.
                  */
                 PingPong = 2,
                 /**
                  * Emit particles in bursts.
                  */
                 Burst = 3
             }

             export  interface EmitterShape {
                 type: string;
                 initialize(particle: Particle, emissionState: EmissionState): void;
                 toJSON(): ShapeJSON;
                 update(system: ParticleSystem, delta: number): void;
                 clone(): EmitterShape;
             }

             export  interface EmitterShapeParticlePlugin {
                 type: string;
                 constructor: Constructable<EmitterShape>;
                 params: ParameterPair[];
                 loadJSON: (json: any, meta: JsonMetaData) => EmitterShape;
             }

             export  const EmitterShapes: {
                 [key: string]: EmitterShapeParticlePlugin;
             };

             /**
              * 
              * @param material
              */
             export  const enableMaterialVerticeOpacity: (material: Material) => void;

             /**  */
             export  const enableRealisticRender: (renderer: WebGLRenderer) => void;

             /**  */
             export  const enableShadow: (renderer: WebGLRenderer) => void;

             /** sRGB */
             export  const enableSRGBColorSpace: (renderer: WebGLRenderer) => void;

             /**
              * Re-enables effect tracking (if it was paused).
              */
              function enableTracking(): void;

             export  function encryptToBase64(str: string): string;

             export  class Entity extends EntityBase {
                 #private;
                 static defaultModules: Array<EntityModuleConstructor | [EntityModuleConstructor, any]>;
                 /**
                  * 
                  */
                 entityType: string;
                 isEntity: boolean;
                 _node: Object3D;
                 _pointerEventsRef: Ref<boolean | undefined>;
                 options: EntityOptions;
                 _childrens: Entity[];
                 _ownerScene?: Scene;
                 _sceneData?: Record<string, any>;
                 _boxHelperObject: BoxHelper;
                 /**  */
                 _positionRef: Vector3;
                 /**  */
                 _rotationRef: Euler;
                 /**  */
                 _quaternionRef: Quaternion;
                 /**  */
                 _scaleRef: Vector3;
                 /**  */
                 _matrixRef: Matrix4;
                 /**  */
                 _matrixWorldRef: Matrix4;
                 /**  */
                 _visualRef: Ref<boolean>;
                 /**  */
                 _selectedRef: Ref<boolean>;
                 /**  */
                 _outlineRef: Ref<boolean>;
                 /**  */
                 _bloomRef: Ref<boolean>;
                 /**  */
                 _boxHelperRef: Ref<boolean>;
                 /**  true*/
                 _rayIntersectRecursive?: boolean;
                 /**  1*/
                 _rayQueryType?: RayQueryType;
                 /** */
                 _isDisposed?: boolean;
                 /** entity.node */
                 rayIntersectObject?: Object3D;
                 signal: {
                     onBeforeAdd: Signal;
                     onAdd: Signal;
                     onBeforeRemove: Signal;
                     onRemove: Signal;
                     onRayIntersect: Signal;
                     onMouseUp: Signal;
                     onMouseMove: Signal;
                     onMouseDown: Signal;
                     onMouseClick: Signal;
                     onMouseDblClick: Signal;
                     onMouseOver: Signal;
                     onMouseOut: Signal;
                     onMouseEnter: Signal;
                     onMouseLeave: Signal;
                     onPointerDown: Signal;
                     onPointerMove: Signal;
                     onPointerUp: Signal;
                     /**  */
                     onPointerDownUp: Signal;
                     onPointerCancel: Signal;
                     onMouseWheel: Signal;
                     onKeyDown: Signal;
                     onKeyUp: Signal;
                 };
                 constructor(options?: EntityOptions);
                 /**  */
                 static create(options?: EntityOptions): Entity;
                 /**  */
                 static fromModule(mod: EntityModuleConstructor | Array<EntityModuleConstructor | [EntityModuleConstructor, any]>, options?: any): Entity;
                 /** object3d */
                 static fromObject3d: (objs: Object3D | Object3D[]) => Entity;
                 /** object3d */
                 static fromObjectModule: (objs: Object3D | Object3D[], mod: EntityModuleConstructor | Array<EntityModuleConstructor | [EntityModuleConstructor, any]>, options?: any) => Entity;
                 /**
                  * obejct
                  * @param object 
                  * @param canChildEntity false.  falsetrue
                  */
                 static getOwerEntity(object: Object3D, canChildEntity?: boolean): Entity | undefined;
                 get isDisposed(): boolean;
                 get visibleRef(): Ref<boolean>;
                 get visible(): boolean;
                 set visible(val: boolean);
                 get selectedRef(): Ref<boolean>;
                 get selected(): boolean;
                 set selected(val: boolean);
                 get bloomRef(): Ref<boolean>;
                 get bloom(): boolean;
                 set bloom(val: boolean);
                 get outlineRef(): Ref<boolean>;
                 get outline(): boolean;
                 set outline(val: boolean);
                 get boxHelperRef(): Ref<boolean>;
                 get boxHelper(): boolean | BoxHelperOptions;
                 set boxHelper(val: boolean | BoxHelperOptions);
                 get castShadow(): boolean;
                 set castShadow(val: boolean);
                 get receiveShadow(): boolean;
                 set receiveShadow(val: boolean);
                 get frustumCulled(): boolean;
                 set frustumCulled(val: boolean);
                 get position(): Vector3;
                 get scale(): Vector3;
                 get rotation(): Euler;
                 get quaternion(): Quaternion;
                 get matrix(): Matrix4;
                 get matrixWorld(): Matrix4;
                 get parent(): Entity | undefined;
                 set parent(val: Entity | undefined);
                 get pointerEvents(): boolean;
                 get pointerEventsRef(): Ref<boolean>;
                 set pointerEvents(b: boolean);
                 get node(): Object3D<Object3DEventMap>;
                 set node(obj: Object3D<Object3DEventMap>);
                 get rayIntersectRecursive(): boolean;
                 set rayIntersectRecursive(b: boolean);
                 get rayQueryType(): RayQueryType;
                 set rayQueryType(b: RayQueryType);
                 onEntityAwake(callback: (app: App) => void): void;
                 tween(id?: string): Tween<Entity>;
                 addObjects(objs: Object3D | Object3D[]): void;
                 removeObjects(objs: Object3D | Object3D[]): void;
                 addChildEntity(ent: Entity): void;
                 removeChildEntity(ent: Entity): void;
                 addTo(target?: App | Entity | Object3D, app?: App): this;
                 /**
                  * 
                  * @param obj 
                  * @param splitSubEntity  false)
                  * @param overwriteEntity  false)
                  * @param app 
                  * @returns
                  */
                 static attchObject(obj: Object3D, splitSubEntity?: boolean, overwriteEntity?: boolean, app?: App): Entity;
                 remove(): void;
                 get childrens(): Entity[];
                 set childrens(child: Entity[]);
                 traverse(callback: (ent: Entity) => any, filter?: (ent: Entity) => boolean): void;
                 traverseVisible(callback: (ent: Entity) => any, filter?: (ent: Entity) => boolean): void;
                 getObjectByName(name: string): Object3D<Object3DEventMap>;
                 getObjectById(id: string): Object3D<Object3DEventMap>;
                 getObjectByUuid(uuid: string): Object3D<Object3DEventMap>;
                 getObjectsByName(name: string): Object3D<Object3DEventMap>[];
                 getObjectByProperty(name: string, value: string): Object3D<Object3DEventMap>;
                 getObjectsByProperty(name: string, value: string): Object3D<Object3DEventMap>[];
                 getEntityByName(name: string): Entity;
                 getEntityById(id: string): Entity;
                 getEntityByUuid(uuid: string): Entity;
                 getMeshEntityByProperty(name: string, value: string): MeshEntity | undefined;
                 getMeshEntityByName(name: string): MeshEntity | undefined;
                 getMeshEntityById(id: string): MeshEntity | undefined;
                 getMeshEntityByUuid(uuid: string): MeshEntity | undefined;
                 getEntitiesByName(name: string): Entity[];
                 getEntityByProperty(name: string, value: string): Entity;
                 getEntitiesByProperty(name: string, value: string): Entity[];
                 getObjectPropertyValueCount(name: string): Map<any, number>;
                 getEntitiesByModule(module: EntityModuleConstructor | EntityModuleConstructor[]): Entity[];
                 /** meshmesh */
                 isLikeMeshEntity(): boolean;
                 /** Mesh */
                 getMeshEntities(): MeshEntity[];
                 /**  */
                 getLeafEntities(): Entity[];
                 /**  */
                 getPointerEventsEntities(leafEventNode?: boolean): Entity[];
                 /**
                  * 
                  * @param option
                  * @param isHideMesh meshfalse)
                  */
                 addEdges(option?: LineBasicMaterialParameters, isHideMesh?: boolean): void;
                 /**
                  * 
                  */
                 clearEdges(): void;
                 /**
                  * 
                  */
                 replaceMaterial(material: Material | Material[]): void;
                 /**
                  * 
                  */
                 resetMaterial(): void;
                 /**
                  * 
                  */
                 isHighlight(): boolean;
                 /**
                  * 
                  */
                 setHighlight(color?: ColorRepresentation, opacity?: number): void;
                 /**
                  * 
                  */
                 clearHighlight(): void;
                 /**
                  * 
                  * @param opacity  0()-1()
                  * @param isAccOpacity (turefalse)
                  */
                 setOpacity(opacity: number, isAccOpacity?: boolean): void;
                 /**
                  * false
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
                 /**
                  * 
                  * @param inLocalSpace 
                  * @param mapModeSceneSpace 
                  */
                 getBoundingBox(inLocalSpace?: boolean, mapModeSceneSpace?: boolean): Box3;
                 /**
                  * 
                  * @param func 
                  * @param id id
                  */
                 addAction(func: (context: {
                     entity: Entity;
                     timeDelta: number;
                     elapsed: number;
                     [key: string]: any;
                 }) => BehaviorStatus | void | undefined, id?: string): () => void;
                 /**
                  * 
                  * @param id id
                  */
                 removeAction(id: string): void;
                 /**
                  * 
                  * @param func 
                  * @param id id
                  */
                 addAnimationAction(opts: {
                     /**  */
                     duration: number;
                     /** easing  linear */
                     easing?: Easing;
                     /**  */
                     yoyoForever?: boolean;
                     /**  */
                     yoyoTimes?: number;
                     /**  */
                     repeatForever?: boolean;
                     /**  */
                     repeatTimes?: number;
                     /**  */
                     delay?: number;
                 }, func: (context: {
                     entity: Entity;
                     alpha: number;
                     reversed: boolean;
                     isComplete: boolean;
                     isEnd: boolean;
                     isStop: boolean;
                     [key: string]: any;
                 }) => void, id?: string): {
                     stop: () => void;
                     animation: typeof animation;
                 };
                 toJSON(): any;
                 static fromJSON(json: Record<string, any>, objects: Map<string, Object3D>): Entity;
                 setupUiConfig(): any;
             }

             export  class EntityBase extends AppObject implements IEntityModuleBase {
                 #private;
                 options: EntityBaseOptions;
                 uuid: string;
                 readonly moduleManager: ModuleManager;
                 constructor(options?: EntityBaseOptions);
                 get modules(): EntityModuleBase[];
                 /**
                  * ,this.add(xxx)
                  * @param type 
                  * @param params 
                  */
                 addModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T, params?: U): T;
                 /**
                  * ,this.addModule(xxx)
                  */
                 add<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T, params?: U): T;
                 /**
                  * 
                  * @param type 
                  * @returns
                  */
                 getModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T): T;
                 /**
                  * 
                  * @param type 
                  * @returns
                  */
                 removeModule<T extends EntityModuleBase, U>(type: new (entity?: any, obj?: U) => T): void;
                 /**
                  * 
                  * @returns
                  */
                 removeAllModules(): void;
                 /**
                  * 
                  * @returns
                  */
                 callModules(methodName: string, ...args: any): void;
             }

             export  interface EntityBaseOptions {
                 app?: App;
                 parent?: EntityBase;
             }

             export  class EntityManagerModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 selectObjects: ShallowReactive<Object3D[]>;
                 bloomObjects: ShallowReactive<Object3D[]>;
                 outlineObjects: ShallowReactive<Object3D[]>;
                 constructor(app?: App);
                 getEntities(): Entity[];
                 getRayQueryEntities(): any[];
                 onAwake(): void;
                 onAppAddEntity(ent: Entity): void;
                 onAppRemoveEntity(ent: Entity): void;
                 addSelectedEntity(ent: Entity): void;
                 removeSelectEntity(ent: Entity): void;
                 getSelectObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 getSelectObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 addBloomEntity(ent: Entity): void;
                 removeBloomEntity(ent: Entity): void;
                 getBloomObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 getBloomObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 addOutlineEntity(ent: Entity): void;
                 removeOutlineEntity(ent: Entity): void;
                 getOutlineObjects(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 getOutlineObjectsRef(): ShallowReactive<Object3D<Object3DEventMap>[]>;
                 setSelectBoomRefreshFlag(): void;
                 onAppBeforeUpdate(): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  class EntityModuleBase extends ModuleBase {
                 entity: Entity;
                 constructor(entity: Entity);
             }

             export  type EntityModuleConstructor = new (obj: any) => EntityModuleBase;

             export  interface EntityOptions extends EntityBaseOptions {
                 node?: Object3D;
                 pointerEvents?: boolean;
                 parent?: EntityBase;
                 modules?: Array<EntityModuleConstructor | [EntityModuleConstructor, any]>;
                 object3ds?: Object3D | Object3D[];
             }

             /**
              *  ent.data._outline_config = {...}
              */
             export  class EntityOutlineModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: EntityOutlineModuleOptions;
                 constructor(app?: App, options?: EntityOutlineModuleOptions);
                 onAwake(): void;
             }

             export  interface EntityOutlineModuleOptions extends OutlinesProps {
                 enable?: boolean;
             }

             export  class EntityQueryModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 constructor(app?: App);
                 /**
                  * 
                  */
                 getQueryRaycaster(): Raycaster;
                 onAwake(): void;
                 /**
                  * 
                  */
                 queryEntitiesByCamera(option?: EntityQueryOption): InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByRaycast(ray: Ray, option?: EntityQueryOption): InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByScreenPos(x: number, y: number, option?: EntityQueryOption): InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByBox(startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number): InteractiveObject[];
                 /**
                  * 
                  */
                 getRayByScreenPos(x: number, y: number, camera?: Camera): Ray;
             }

             /**
              * 
              */
             export  interface EntityQueryOption {
                 entities?: Entity[];
                 filter?: (ent: Entity) => boolean;
                 camera?: Camera;
                 raycasterParameters?: RaycasterParameters;
             }

             export  interface EnvConfigOption {
                 /**  (clickOtherPosition) none ;  clickOtherPosition () clickOtherEntity  */
                 cancelSelectMode?: "none" | "clickOtherPosition" | "clickOtherEntity";
                 /** (clickOtherPosition) none ;  clickOtherPosition () clickOtherEntity  */
                 cancelHighlight?: "none" | "clickOtherPosition" | "clickOtherEntity";
                 /**  */
                 highlightColor?: ColorRepresentation;
                 /**  */
                 highlightOpacity?: number;
                 /**  */
                 popupBackgroundColor?: string;
                 /**  */
                 popupButtonColor?: string;
                 /**  */
                 boxHelper?: BoxHelperOptions;
                 /**  */
                 activeScreenEnableTransition?: boolean;
                 /** () */
                 sceneExitBlurTime?: number;
                 /** unProjectundefined  "ShiftLeft + KeyR"  "none" */
                 unProjectOptions?: Record<string, UnProjectOpts>;
             }

             /**  */
             export  class Environment {
                 #private;
                 fbo: any;
                 cubeCamera: any;
                 virtualScene: any;
                 ignoreObjects: any;
                 app: App;
                 constructor(app: any, config?: {
                     resolution?: number;
                     near?: number;
                     far?: number;
                     scene?: Scene | Object3D[];
                     renderOptions?: RenderTargetOptions;
                     textureType: TextureDataType;
                     ignoreObjects?: Object3D[];
                 });
                 pause(): void;
                 start(): void;
                 update(): void;
                 add(obj: any): void;
                 get texture(): any;
                 dispose(): void;
             }

              enum EpsgCrsTypes {
                 Beijing54 = "Beijing54",
                 Xian80 = "Xian80",
                 CGCS2000 = "CGCS2000",
                 Wgs84 = "Wgs84",
                 Merc3857 = "Merc3857",
                 NewBeijing54 = "NewBeijing54"
             }

             /**
              * Whether is exactly NaN. Notice isNaN('a') returns true.
              */
              function eqNaN(value: any): boolean;

             /**
              * Equation base class.
              *
              * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
              */
              class Equation {
                 id: number;
                 /**
                  * Minimum (read: negative max) force to be applied by the constraint.
                  */
                 minForce: number;
                 /**
                  * Maximum (read: positive max) force to be applied by the constraint.
                  */
                 maxForce: number;
                 bi: Body_2;
                 bj: Body_2;
                 si: Shape;
                 sj: Shape;
                 /**
                  * SPOOK parameter
                  */
                 a: number;
                 /**
                  * SPOOK parameter
                  */
                 b: number;
                 /**
                  * SPOOK parameter
                  */
                 eps: number;
                 jacobianElementA: JacobianElement;
                 jacobianElementB: JacobianElement;
                 enabled: boolean;
                 /**
                  * A number, proportional to the force added to the bodies.
                  */
                 multiplier: number;
                 static idCounter: number;
                 constructor(bi: Body_2, bj: Body_2, minForce?: number, maxForce?: number);
                 /**
                  * Recalculates a, b, and eps.
                  *
                  * The Equation constructor sets typical SPOOK parameters as such:
                  * * `stiffness` = 1e7
                  * * `relaxation` = 4
                  * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
                  */
                 setSpookParams(stiffness: number, relaxation: number, timeStep: number): void;
                 /**
                  * Computes the right hand side of the SPOOK equation
                  */
                 computeB(a: number, b: number, h: number): number;
                 /**
                  * Computes G*q, where q are the generalized body coordinates
                  */
                 computeGq(): number;
                 /**
                  * Computes G*W, where W are the body velocities
                  */
                 computeGW(): number;
                 /**
                  * Computes G*Wlambda, where W are the body velocities
                  */
                 computeGWlambda(): number;
                 /**
                  * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
                  */
                 computeGiMf(): number;
                 /**
                  * Computes G*inv(M)*G'
                  */
                 computeGiMGt(): number;
                 /**
                  * Add constraint velocity to the bodies.
                  */
                 addToWlambda(deltalambda: number): void;
                 /**
                  * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
                  */
                 computeC(): number;
             }

             /**
              * Escape a string for use in a regular expression
              * @param str
              *
              * @category Text
              */
             export  function escapeRegExp(str: string): string;

              function estimateBytesUsed(geometry: BufferGeometry): number;

              function estimateMemoryInBytes(bvh: MeshBVH): number;

             export  class EulerGenerator implements RotationGenerator {
                 angleX: FunctionValueGenerator | ValueGenerator;
                 angleY: FunctionValueGenerator | ValueGenerator;
                 angleZ: FunctionValueGenerator | ValueGenerator;
                 type: 'rotation';
                 eular: Euler;
                 constructor(angleX: FunctionValueGenerator | ValueGenerator, angleY: FunctionValueGenerator | ValueGenerator, angleZ: FunctionValueGenerator | ValueGenerator, eulerOrder?: EulerOrder);
                 genValue(quat: Quaternion, t?: number): Quaternion;
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): EulerGenerator;
                 clone(): RotationGenerator;
             }

              class Evaluator {
                 attributes: String[];
                 useGroups: boolean;
                 consolidateMaterials: boolean;
                 debug: OperationDebugData;
                 evaluate(a: Brush, b: Brush, operation: CSGOperation, targetBrush?: Brush): Brush;
                 evaluate(a: Brush, b: Brush, operations: CSGOperation[], targetBrushes: Brush[]): Brush[];
                 evaluateHierarchy(root: Operation, target?: Brush): Brush;
             }

              type EventCallback<EvtParams = any[]> = EvtParams extends any[] ? (...args: EvtParams) => boolean | void : never;

             /**
              * 
              */
             export  class EventDispatcher {
                 private _events;
                 private _eventCount;
                 private readonly _dispatchingListeners;
                 /**
                  * 
                  * @param event 
                  * @returns 
                  */
                 hasEvent(event: string): boolean;
                 /**
                  * .
                  * @returns 
                  */
                 eventNames(): string[];
                 /**
                  * .
                  * @param event - Event name
                  * @returns The count of listeners
                  */
                 listenerCount(event: string): number;
                 /**
                  * .
                  * @param event - Event name
                  * @param data - Data
                  * @returns - Whether the dispatching is successful
                  */
                 dispatch(event: string, ...data: any): boolean;
                 /**
                  * 
                  * @param event - Event name
                  * @param fn - Function
                  * @returns This
                  */
                 on(event: string, fn: Function): EventDispatcher;
                 /**
                  * .
                  * @param event - Event name
                  * @param fn - Function
                  * @returns This
                  */
                 once(event: string, fn: Function): EventDispatcher;
                 /**
                  * .
                  * @param event - Event name
                  * @param fn - Function, If is undefined, delete all corresponding event listeners.
                  */
                 off(event: string, fn?: Function): EventDispatcher;
                 /**
                  * .
                  * @param event - Event name, delete all events if not passed
                  */
                 removeAllEventListeners(event?: string): void;
                 private _addEventListener;
                 private _clearEvent;
             }

             /**
              * Event dispatcher.
              *
              * Event can be defined in EvtDef to enable type check. For example:
              * ```ts
              * interface FooEvents {
              *     // key: event name, value: the first event param in `trigger` and `callback`.
              *     myevent: {
              *        aa: string;
              *        bb: number;
              *     };
              * }
              * class Foo extends Eventful<FooEvents> {
              *     fn() {
              *         // Type check of event name and the first event param is enabled here.
              *         this.trigger('myevent', {aa: 'xx', bb: 3});
              *     }
              * }
              * let foo = new Foo();
              * // Type check of event name and the first event param is enabled here.
              * foo.on('myevent', (eventParam) => { ... });
              * ```
              *
              * @param eventProcessor The object eventProcessor is the scope when
              *        `eventProcessor.xxx` called.
              * @param eventProcessor.normalizeQuery
              *        param: {string|Object} Raw query.
              *        return: {string|Object} Normalized query.
              * @param eventProcessor.filter Event will be dispatched only
              *        if it returns `true`.
              *        param: {string} eventType
              *        param: {string|Object} query
              *        return: {boolean}
              * @param eventProcessor.afterTrigger Called after all handlers called.
              *        param: {string} eventType
              */
              class Eventful<EvtDef extends DefaultEventDefinition = DefaultEventDefinition> {
                 private _$handlers;
                 protected _$eventProcessor: EventProcessor<EvtDef>;
                 constructor(eventProcessors?: EventProcessor<EvtDef>);
                 on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, handler: WithThisType<EvtDef[EvtNm], CbThis_2<Ctx, this>>, context?: Ctx): this;
                 on<Ctx, EvtNm extends keyof EvtDef>(event: EvtNm, query: EventQuery, handler: WithThisType<EvtDef[EvtNm], CbThis_2<Ctx, this>>, context?: Ctx): this;
                 /**
                  * Whether any handler has bound.
                  */
                 isSilent(eventName: keyof EvtDef): boolean;
                 /**
                  * Unbind a event.
                  *
                  * @param eventType The event name.
                  *        If no `event` input, "off" all listeners.
                  * @param handler The event handler.
                  *        If no `handler` input, "off" all listeners of the `event`.
                  */
                 off(eventType?: keyof EvtDef, handler?: Function): this;
                 /**
                  * Dispatch a event.
                  *
                  * @param {string} eventType The event name.
                  */
                 trigger<EvtNm extends keyof EvtDef>(eventType: EvtNm, ...args: Parameters<EvtDef[EvtNm]>): this;
                 /**
                  * Dispatch a event with context, which is specified at the last parameter.
                  *
                  * @param {string} type The event name.
                  */
                 triggerWithContext(type: keyof EvtDef, ...args: any[]): this;
             }

             /** code */
             export  function eventKeyCode(event?: any): number | undefined;

             /**
              * 
              */
             export  class EventModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 constructor(entity: Entity, options?: EventModuleOptions);
                 /**
                  * 
                  * @param options
                  * @returns id,removeEvent
                  */
                 addEvent(options: EventModuleOptions): number;
                 /**
                  * 
                  * @param options
                  * @returns
                  */
                 removeEvent(eventId?: number): void;
             }

             /**
              * 
              */
             export  interface EventModuleOptions {
                 onBeforeAdd?: (parent: Entity, self: Entity) => void;
                 onAdd?: (parent: Entity, self: Entity) => void;
                 onBeforeRemove?: (self: Entity) => void;
                 onRemove?: (self: Entity) => void;
                 onRayIntersect?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseMove?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseClick?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseDblClick?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseOver?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseOut?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseEnter?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseLeave?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onPointerDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onPointerMove?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onPointerUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onMouseWheel?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onKeyDown?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 onKeyUp?: (event: InteractiveEvent, object: InteractiveObject) => void;
                 /**  false*/
                 highlightUseBoxHelper?: boolean;
                 /**  */
                 clickSelect?: boolean;
                 /** (inherit)  none ; inherit  clickOtherPosition () clickOtherEntity  */
                 cancelSelectMode?: "none" | "inherit" | "clickOtherPosition" | "clickOtherEntity";
                 /**  */
                 clickHighlight?: boolean;
                 /** (inherit) none ; inherit ;  clickOtherPosition () clickOtherEntity  */
                 cancelHighlight?: "none" | "inherit" | "clickOtherPosition" | "clickOtherEntity";
                 /**  */
                 hoverSelect?: boolean;
                 /**  */
                 hoverHighlight?: boolean;
                 /**  */
                 highlightColor?: ColorRepresentation;
                 /**  */
                 highlightOpacity?: number;
                 /**   */
                 clickHtmlText?: string | ((ent: Entity) => Promise<string>);
                 /**  */
                 hoverHtmlText?: string | ((ent: Entity) => Promise<string>);
                 /** false */
                 enableWhenActiveTool?: boolean;
                 /**  */
                 popupOptions?: PopupOptions;
                 /**  'middle-top' - ) */
                 popupAnchor?: Anchor3d;
                 /** popuptrue */
                 popupAsEntityChild?: boolean;
                 /** popup  Object3D Object3dpopup */
                 popupCallback?: (entity: Entity, popup: Popup2D, isHover: boolean, object: InteractiveObject) => Object3D | Entity | undefined;
                 /**  */
                 clickCallback?: (entity: Entity, isClick: boolean, object: InteractiveObject) => void;
                 /**  */
                 hoverCallback?: (entity: Entity, isHover: boolean, object: InteractiveObject) => void;
             }

              interface EventProcessor<EvtDef = DefaultEventDefinition> {
                 normalizeQuery?: (query: EventQuery) => EventQuery;
                 filter?: (eventType: keyof EvtDef, query: EventQuery) => boolean;
                 afterTrigger?: (eventType: keyof EvtDef) => void;
             }

              type EventQuery = string | Object;

             /**
              * Base class for objects that dispatches events.
              */
              class EventTarget_2 {
                 private _listeners;
                 /**
                  * Add an event listener
                  * @return The self object, for chainability.
                  */
                 addEventListener(type: string, listener: Function): EventTarget_2;
                 /**
                  * Check if an event listener is added
                  */
                 hasEventListener(type: string, listener: Function): boolean;
                 /**
                  * Check if any event listener of the given type is added
                  */
                 hasAnyEventListener(type: string): boolean;
                 /**
                  * Remove an event listener
                  * @return The self object, for chainability.
                  */
                 removeEventListener(type: string, listener: Function): EventTarget_2;
                 /**
                  * Emit an event.
                  * @return The self object, for chainability.
                  */
                 dispatchEvent(event: any): EventTarget_2;
             }

             export  function eventXY(event?: any): Vector2;

             export  interface ExecutionContext {
                 inputs?: NodeValue[];
                 outputs?: NodeValue[];
                 particle?: IParticle;
                 [key: string]: any;
             }

             /**
              *  .
              * @param line 
              * @param lineWidth 
              */
             export  function expandLine(line: [number, number, number?][], lineWidth: number | [number, number][]): {
                 offsetPoints: any[];
                 leftPoints: any[];
                 rightPoints: any[];
                 expandPoints: any[];
             };

             /**  */
             export  const explodeGroup: (group: Object3D) => {
                 /**   */
                 explode: (opts?: {
                     /**  */
                     time?: number;
                     /**  */
                     distance?: number;
                     /**  */
                     enableRotation?: boolean;
                     /**  */
                     easing?: Easing;
                 }) => Promise<any>;
                 /**  */
                 reset: (opts?: {
                     /**  */
                     time?: number;
                     /**  */
                     enableRotation?: boolean;
                     /**  */
                     easing?: Easing;
                 }) => Promise<any>;
             };

             /**
              * Exports a render target to a blob. The type is automatically picked from exr to png based on the render target.
              * @param target - render target to export
              * @param mimeType - mime type to use.
              * If auto (default), then it will be picked based on the render target type.
              * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
              */
             export  function exportRenderTarget(renderer: WebGLRenderer, target: WebGLMultipleRenderTargets | WebGLRenderTarget, mimeType?: string, textureIndex?: number): Blob;

             /**
              * Given a destination object and optionally many source objects,
              * copy all properties from the source objects into the destination.
              * The last source object given overrides properties from previous
              * source objects.
              *
              * @param dest destination object
              * @param sources sources from which properties are pulled
              * @private
              */
             export  function extend(dest: Object, ...sources: Object[]): Object;

              function extend_2<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S): T & S;

              interface ExtendedCanvasRenderingContext2D extends CanvasRenderingContext2D {
                 dpr?: number;
             }

              class ExtendedTriangle extends Triangle {
                 needsUpdate: boolean;
                 intersectsTriangle(other: Triangle, target?: Line3): boolean;
                 intersectsSphere(sphere: Sphere): boolean;
                 closestPointToSegment(segment: Line3, target1?: Vector3, target2?: Vector3): number;
                 distanceToPoint(point: Vector3): number;
                 distanceToTriangle(tri: Triangle): number;
             }

             /**
              * Create a Path class from path string data
              * @param  str
              * @param  opts Other options
              */
              function extendFromString(str: string, defaultOpts?: SVGPathOption): typeof SVGPath;

              interface ExtremeInfo {
                 nodeCount: number;
                 leafNodeCount: number;
                 surfaceAreaScore: number;
                 depth: {
                     min: number;
                     max: number;
                 };
                 tris: {
                     min: number;
                     max: number;
                 };
                 splits: [number, number, number];
             }

             /**
              *
              * @param {Object} geojson
              * @param {Object} [opts]
              * @param {number} opts.depth
              * @param {number} [opts.bevelSize = 0]
              * @param {number} [opts.bevelSegments = 2]
              * @param {number} [opts.simplify = 0]
              * @param {boolean} [opts.smoothSide = 'auto']
              * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
              * @param {boolean} [opts.smoothBevel = false]
              * @param {boolean} [opts.excludeBottom = false]
              * @param {boolean} [opts.lineWidth = 1]
              * @param {boolean} [opts.miterLimit = 2]
              * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
              * @param {Array} [opts.translate]
              * @param {Array} [opts.scale]
              * @param {Object} [opts.boundingRect]
              * @return {Object} {polyline: {indices, position, uv, normal}, polygon: {indices, position, uv, normal}}
              */
             export  function extrudeGeoJSON(geojson: any, opts?: {
                 depth?: ((idx: number) => number) | number;
                 bevelSize?: number;
                 bevelSegments?: number;
                 simplify?: number;
                 smoothSide?: boolean;
                 smoothBevel?: boolean;
                 excludeBottom?: boolean;
                 /** default 0.9 */
                 smoothSideThreshold?: number;
                 /** default 1 */
                 lineWidth?: number;
                 /** default 2 */
                 miterLimit?: number;
                 fitRect?: {
                     x?: number;
                     y?: number;
                     width?: number;
                     height?: number;
                 };
                 translate?: ArrayLike<number>;
                 scale?: ArrayLike<number>;
                 isMapMode?: boolean;
                 boundingRect?: {
                     x: number;
                     y: number;
                     width: number;
                     height: number;
                 };
             }): {
                 polyline: {
                     position: Float32Array;
                     indices: Uint16Array | Uint32Array;
                     uv: Float32Array;
                     normal: Float32Array;
                     boundingRect: {
                         x: number;
                         y: number;
                         width: number;
                         height: number;
                     };
                     geometry: BufferGeometry<NormalBufferAttributes>;
                 };
                 polygon: {
                     position: Float32Array;
                     indices: Uint16Array | Uint32Array;
                     uv: Float32Array;
                     normal: Float32Array;
                     boundingRect: {
                         x: number;
                         y: number;
                         width: number;
                         height: number;
                     };
                     geometry: BufferGeometry<NormalBufferAttributes>;
                 };
             };

             /**
              * 
              *
              * @export
              * @class ExtrudeMesh
              * @extends {Mesh<BufferGeometry, Material>}
              */
             export  class ExtrudeMesh extends Mesh<BufferGeometry, Material> {
                 static temp1Vector2: Vector2;
                 static temp2Vector2: Vector2;
                 static temp3Vector2: Vector2;
                 static tempVector3: Vector3;
                 static temp1Vector3: Vector3;
                 static temp2Vector3: Vector3;
                 static temp3Vector3: Vector3;
                 static temp1Matrix4: Matrix4;
                 static temp2Matrix4: Matrix4;
                 static temp3Matrix4: Matrix4;
                 constructor(props: ExtrudeMeshProps, material?: Material);
                 pointerWidthRadius: Array<{
                     vector3: [number, number, number];
                     matrix: [
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number,
                     number
                     ];
                 }>;
                 computerMatrix(vector1: [number, number, number], vector2: [number, number, number], scale: [number, number, number]): Matrix4Tuple;
                 /**
                  * @ computerGradient([2,1,3], 0.3);
                  * @ values:number[]
                  * @ percentage:number
                  */
                 computerGradient(values: number[], percentage: number): number;
                 computerPointerWidthRadius(paths: Array<ExtrudePath>, closed: boolean): void;
                 computerPathLength(points: [number, number, number][]): number;
                 setExtrudeMesh(startP: [number, number, number], // 
                 startMatrix4: [
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number
                 ], // 
                 endP: [number, number, number], // 
                 endMatrix4: [
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number,
                 number
                 ], // 
                 uvx: number, // uv.x 
                 shapePath: Array<[number, number]>): {
                     geometryPoint: number[];
                     uvPoint: number[];
                 };
                 updateGeometry(props: ExtrudeMeshProps): void;
             }

             /**  */
             export  interface ExtrudeMeshProps {
                 /**  */
                 paths: Array<ExtrudePath>;
                 /**  */
                 shapePath: Array<[number, number]>;
                 /**  */
                 closed: boolean;
                 isMapMode?: boolean;
             }

             export  type ExtrudePath = {
                 vector3: [number, number, number];
                 /**  */
                 radius: number;
                 /**  */
                 segments: number;
                 /** shape */
                 scale: {
                     x: number;
                     y: number;
                 };
                 /**  */
                 name: string;
             };

             /**
              *
              * @param {Array} polygons Polygons array that match GeoJSON MultiPolygon geometry.
              * @param {Object} [opts]
              * @param {number|Function} [opts.depth]
              * @param {number} [opts.bevelSize = 0]
              * @param {number} [opts.bevelSegments = 2]
              * @param {number} [opts.simplify = 0]
              * @param {boolean} [opts.smoothSide = 'auto']
              * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
              * @param {boolean} [opts.smoothBevel = false]
              * @param {boolean} [opts.excludeBottom = false]
              * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
              * @param {Array} [opts.translate]
              * @param {Array} [opts.scale]
              *
              * @return {Object} {indices, position, uv, normal, boundingRect}
              */
             export  function extrudePolygon(polygons: any[], opts?: {
                 depth?: ((idx: number) => number) | number;
                 bevelSize?: number;
                 bevelSegments?: number;
                 simplify?: number;
                 smoothSide?: boolean;
                 smoothBevel?: boolean;
                 excludeBottom?: boolean;
                 fitRect?: {
                     x?: number;
                     y?: number;
                     width?: number;
                     height?: number;
                 };
                 translate?: ArrayLike<number>;
                 scale?: ArrayLike<number>;
                 removeIntersections?: boolean;
                 removeIntersectionsHole?: boolean;
                 isMapMode?: boolean;
                 boundingRect?: {
                     x: number;
                     y: number;
                     width: number;
                     height: number;
                 };
             }): {
                 position: Float32Array;
                 indices: Uint16Array | Uint32Array;
                 uv: Float32Array;
                 normal: Float32Array;
                 boundingRect: {
                     x: number;
                     y: number;
                     width: number;
                     height: number;
                 };
                 geometry: BufferGeometry<NormalBufferAttributes>;
             };

             /**
              *
              * @param {Array} polylines Polylines array that match GeoJSON MultiLineString geometry.
              * @param {Object} [opts]
              * @param {number} [opts.depth]
              * @param {number} [opts.bevelSize = 0]
              * @param {number} [opts.bevelSegments = 2]
              * @param {number} [opts.simplify = 0]
              * @param {boolean} [opts.smoothSide = 'auto']
              * @param {boolean} [opts.smoothSideThreshold = 0.9]    // Will not smooth sharp side.
              * @param {boolean} [opts.smoothBevel = false]
              * @param {boolean} [opts.excludeBottom = false]
              * @param {boolean} [opts.lineWidth = 1]
              * @param {boolean} [opts.miterLimit = 2]
              * @param {Object} [opts.fitRect] translate and scale will be ignored if fitRect is set
              * @param {Array} [opts.translate]
              * @param {Array} [opts.scale]
              * @param {Object} [opts.boundingRect]
              * @return {Object} {indices, position, uv, normal, boundingRect}
              */
             export  function extrudePolyline(polylines: any[], opts?: {
                 depth?: ((idx: number) => number) | number;
                 /** default 0 */
                 bevelSize?: number;
                 /** default 2 */
                 bevelSegments?: number;
                 /** default 0 */
                 simplify?: number;
                 /** default 'auto' */
                 smoothSide?: boolean;
                 /** default 0.9 */
                 smoothSideThreshold?: number;
                 /** default false */
                 smoothBevel?: boolean;
                 /** default false */
                 excludeBottom?: boolean;
                 /** default 1 */
                 lineWidth?: number;
                 /** default 2 */
                 miterLimit?: number;
                 fitRect?: {
                     x?: number;
                     y?: number;
                     width?: number;
                     height?: number;
                 };
                 translate?: ArrayLike<number>;
                 scale?: ArrayLike<number>;
                 removeIntersections?: boolean;
                 isMapMode?: boolean;
                 boundingRect?: {
                     x: number;
                     y: number;
                     width: number;
                     height: number;
                 };
             }): {
                 position: Float32Array;
                 indices: Uint16Array | Uint32Array;
                 uv: Float32Array;
                 normal: Float32Array;
                 boundingRect: {
                     x: number;
                     y: number;
                     width: number;
                     height: number;
                 };
                 geometry: BufferGeometry<NormalBufferAttributes>;
             };

             export  class FailingBehavior extends Behavior {
                 delayTicks: number;
                 static typeName: string;
                 constructor(delayTicks?: number);
                 tick(td: any): BehaviorStatus.Running | BehaviorStatus.Failed;
                 static INSTANCE: FailingBehavior;
             }

             /**
              * Map value to color. Faster than lerp methods because color is represented by rgba array.
              * @param normalizedValue A float between 0 and 1.
              * @param colors List of rgba color array
              * @param out Mapped gba color array
              * @return will be null/undefined if input illegal.
              */
              function fastLerp(normalizedValue: number, colors: number[][], out?: number[]): number[];

             /**
              * @deprecated
              */
              const fastMapToColor: typeof fastLerp;

             export  interface FBOConfig {
                 width: number;
                 height: number;
                 samples: number;
                 options: RenderTargetOptions;
             }

              type FBOSettings = {
                 /** Defines the count of MSAA samples. Can only be used with WebGL 2. Default: 0 */
                 samples?: number;
                 /** If set, the scene depth will be rendered into buffer.depthTexture. Default: false */
                 depth?: boolean;
             } & RenderTargetOptions;

             /**
              * Feature
              *
              * https://tools.ietf.org/html/rfc7946#section-3.2
              * A Feature object represents a spatially bounded thing.
              * Every Feature object is a GeoJSON object no matter where it occurs in a GeoJSON text.
              */
              interface Feature<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
                 type: "Feature";
                 geometry: G;
                 /**
                  * A value that uniquely identifies this feature in a
                  * https://tools.ietf.org/html/rfc7946#section-3.2.
                  */
                 id?: Id;
                 /**
                  * Properties associated with this feature.
                  */
                 properties: P;
             }

             /**
              * Feature Collection
              *
              * https://tools.ietf.org/html/rfc7946#section-3.3
              * A GeoJSON object with the type 'FeatureCollection' is a FeatureCollection object.
              * A FeatureCollection object has a member with the name 'features'.
              * The value of 'features' is a JSON array. Each element of the array is a Feature object as defined above.
              * It is possible for this array to be empty.
              */
              interface FeatureCollection<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
                 type: "FeatureCollection";
                 features: Array<Feature<G, P>>;
             }

             export  type FieldType = 'vec3' | 'value' | 'number' | 'range' | 'colorFunc' | 'valueFunc' | 'rotationFunc' | 'radian' | 'mesh' | 'particleSystem' | 'boolean' | 'geometry' | 'emitterMode';

             export  interface FillExtrusionItemData {
                 /** id */
                 id?: string;
                 /**  */
                 coordinates: [number, number][][] | [number, number][];
                 /**  */
                 color?: ColorRepresentation;
                 /** 2 color */
                 color2?: ColorRepresentation;
                 /** (0-1) */
                 opacity?: number;
                 /**  */
                 borderColor?: ColorRepresentation;
                 /** 2  */
                 borderColor2?: ColorRepresentation;
                 /**  */
                 showBorder?: boolean;
                 /**  */
                 extrude?: ExtrudeGeometryOptions;
                 /**  */
                 showVertex?: boolean;
                 /**  */
                 hidden?: boolean;
                 /**  */
                 baseHeight?: boolean;
                 /**  */
                 [key: string]: any;
             }

             /**
              * 
              */
             export  class FillExtrusionsEntity extends Entity {
                 constructor(options: FillExtrusionsEntityOptions);
                 /**
                  * 
                  */
                 getFillExtrusions: () => Mesh;
                 /**
                  * 
                  */
                 getBorderPolyline: () => LineSegments2_2;
                 /**
                  * 
                  */
                 updateStyle: (style: MeshBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 getVertexSymbol: () => SymbolEntity;
                 /**
                  * 
                  */
                 isShowVertex: () => boolean;
                 /**
                  * 
                  */
                 getVertexData: (isGetAll?: boolean) => SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex: (show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }) => void;
                 /**
                  * 
                  */
                 updateHightStyle: (style: MeshBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 setData: (data: FillExtrusionItemData[]) => void;
                 /**
                  * 
                  */
                 getData: () => FillExtrusionItemData[];
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
                     positionIndex: number;
                 } & FillExtrusionItemData;
                 /**
                  * 
                  */
                 refreshHighlight: () => void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight: (id: string) => boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight: () => void;
                 /**
                  * 
                  * @returns
                  */
                 setDepths: (data: {
                     index: number;
                     depth?: number;
                     color2?: ColorRepresentation;
                     opacity?: number;
                 }[]) => void;
                 /**
                  * 
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
             }

             export  type FillExtrusionsEntityOptions = EntityOptions & FillExtrusionsModuleOption;

             /**
              * ,
              */
             export  class FillExtrusionsModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 fillExtrusions: Mesh;
                 data: FillExtrusionItemData[];
                 style: MeshLambertMaterialParameters;
                 highlightFillExtrusions: Mesh;
                 highlightData: FillExtrusionItemData[];
                 highlightIndexMap: Map<string, number>;
                 highlightStyle: MeshLambertMaterialParameters;
                 facePosIndex: Map<number, {
                     polyIndex: number;
                     face: [number, number, number];
                 }>;
                 isXYPlane: boolean;
                 borderStyle: LineMaterialParameters_2;
                 showBorder: boolean;
                 useBvh: boolean;
                 borderPolyline: LineSegments2_2;
                 vertexEntity: SymbolEntity;
                 showVertex: boolean;
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
                 constructor(entity: Entity, options?: FillExtrusionsModuleOption);
                 setupUiConfig(): UiObjectConfig;
                 /**
                  * 
                  */
                 getFillExtrusions(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
                 /**
                  * 
                  */
                 getVertexSymbol(): SymbolEntity;
                 /**
                  * 
                  */
                 getBorderPolyline(): LineSegments2_2;
                 /**
                  * 
                  */
                 updateStyle(style: MeshLambertMaterialParameters): void;
                 /**
                  * 
                  */
                 updateHightStyle(style: MeshLambertMaterialParameters): void;
                 /**
                  * 
                  */
                 setData(data: FillExtrusionItemData[]): void;
                 /**
                  * 
                  */
                 getData(): FillExtrusionItemData[];
                 /**
                  * 
                  */
                 isShowVertex(): boolean;
                 /**
                  * 
                  */
                 getVertexData(isGetAll?: boolean): SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex(show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }): void;
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
                     data: FillExtrusionItemData;
                     face: [number, number, number];
                 } | {
                     face: number[];
                     /** id */
                     id?: string;
                     /**  */
                     coordinates: [number, number][] | [number, number][][];
                     /**  */
                     color?: ColorRepresentation;
                     /** 2 color */
                     color2?: ColorRepresentation;
                     /** (0-1) */
                     opacity?: number;
                     /**  */
                     borderColor?: ColorRepresentation;
                     /** 2  */
                     borderColor2?: ColorRepresentation;
                     /**  */
                     showBorder?: boolean;
                     /**  */
                     extrude?: ExtrudeGeometryOptions;
                     /**  */
                     showVertex?: boolean;
                     /**  */
                     hidden?: boolean;
                     /**  */
                     baseHeight?: boolean;
                     data?: undefined;
                 };
                 /**
                  * 
                  * @returns
                  */
                 setDepths(data: {
                     index: number;
                     depth?: number;
                     color2?: ColorRepresentation;
                     opacity?: number;
                 }[]): void;
                 /**
                  * 
                  * @returns
                  */
                 refreshHighlight(): void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight(id: string): boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight(): void;
             }

             export  interface FillExtrusionsModuleOption {
                 /**  */
                 data: FillExtrusionItemData[];
                 /**  */
                 style?: MeshLambertMaterialParameters;
                 /**  */
                 highlightStyle?: MeshLambertMaterialParameters;
                 /**  */
                 borderStyle?: LineMaterialParameters_2;
                 /**  */
                 showBorder?: boolean;
                 /** xyxz  */
                 isXYPlane?: boolean;
                 /** bvh */
                 useBvh?: boolean;
                 /** () */
                 showVertex?: boolean;
                 /**  */
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
             }

             /**
              * Array filtering.
              * @return Must be an array.
              */
              function filter<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index: number, arr: readonly T[]) => boolean, context?: Context): T[];

             export  class FilterBehavior extends SequenceBehavior {
                 constructor();
                 /**
                  *
                  * @param {Behavior[]} conditions
                  * @param {Behavior[]} actions
                  * @returns {FilterBehavior}
                  */
                 static from(conditions: Behavior[], actions?: Behavior[]): FilterBehavior;
                 addChild(child: Behavior): void;
                 /**
                  *
                  * @param {Behavior} condition
                  */
                 addCondition(condition: Behavior): void;
                 /**
                  *
                  * @param {Behavior} action
                  */
                 addAction(action: Behavior): void;
             }

             export  interface FilterColorOptions {
                 /**  */
                 inVerseColor?: boolean;
                 /** */
                 monochromeColor?: ColorRepresentation;
                 /**  1  < 1   1 */
                 bright?: number;
                 /**  1  < 1   1  */
                 contrast?: number;
                 /**  1  < 1   1 */
                 saturation?: number;
             }

             export  type FilteredType<T> = PickType<Partial<TransformedTypes<T>>, AllowedTypes>;

             /**
              * 
              */
              function find<T, Context>(arr: readonly T[], cb: (this: Context, value: T, index?: number, arr?: readonly T[]) => boolean, context?: Context): T;

             /**
              * 
              * @param startPoint 
              * @param endPoint 
              * @param lines 
              */
             export  function findShortestPath(startPoint: [number, number, number], endPoint: [number, number, number], lines: Array<{
                 points: [number, number, number][];
                 id?: string;
                 weight?: number;
             }>): {
                 startPoint: {
                     closestLength: number;
                     closestPoint: GeoPoint;
                     closestIndex: number;
                     closestPointIndex: number;
                     closestPrePointDist: number;
                 };
                 endPoint: {
                     closestLength: number;
                     closestPoint: GeoPoint;
                     closestIndex: number;
                     closestPointIndex: number;
                     closestPrePointDist: number;
                 };
                 route: any[][];
                 routeDetail: any[];
                 error?: undefined;
             } | {
                 error: any;
                 startPoint?: undefined;
                 endPoint?: undefined;
                 route?: undefined;
                 routeDetail?: undefined;
             };

             /**
              *
              * @param {SignalHandler[]} handlers
              * @param {function} f
              * @param thisArg
              * @returns {number} index of the handler, or -1 if not found
              */
             export  function findSignalHandlerIndexByHandle(handlers: any, f: any, thisArg?: any): number;

             /**
              *
              * @param {SignalHandler[]} handlers
              * @param {function} f
              * @param {*} ctx
              * @returns {number} index of the handler, or -1 if not found
              */
             export  function findSignalHandlerIndexByHandleAndContext(handlers: any, f: any, ctx: any): number;

              interface FitToOptions {
                 cover: boolean;
                 paddingLeft: number;
                 paddingRight: number;
                 paddingBottom: number;
                 paddingTop: number;
             }

             /**
              * 
              */
             export  class FixedSizeMeshMaterial extends ShaderMaterial {
                 constructor({ color, canvasSize, ...params }: {
                     color: ColorRepresentation;
                     canvasSize: Uniform_2<Vector2>;
                 } & MaterialParameters);
             }

             /**
              * 
              * @param model 
              * @param debugOutputModelName 
              * @returns
              */
             export  const flatModel: (model: Object3D | Entity, debugOutputModelName?: string) => Object3D[];

             export  const FlowMaterial: (new (parameters?: ShaderMaterialParameters & Partial<FlowMaterialProps>, uniforms?: Partial<FlowMaterialProps>) => ShaderMaterial & FlowMaterialProps) & {
                 key: string;
             };

             export  type FlowMaterialProps = {
                 /**  */
                 color?: Color;
                 /**  (0,0) */
                 uvBegin?: Vector2;
                 /**  (0,0) */
                 uvOffset?: Vector2;
                 /**   (1,1) */
                 uvScale?: Vector2;
                 /**  */
                 opacity?: number;
                 /**  */
                 time?: Vector4 | {
                     value: Vector4;
                 };
                 /** Material side, default: BackSide */
                 side?: Side;
                 /** Material depthWrite, default: false */
                 depthWrite?: boolean;
                 /**  */
                 map?: Texture;
                 [key: string]: any;
             };

             /**
              * .
              */
             export  class FluorescenceMarker extends AnimateMarkerBase {
                 constructor(features: FeatureCollection | {
                     position: [number, number, number?];
                     text?: string;
                 }, options?: AnimateMarkerLayerOption);
                 setMarkersWidth(width: number, index?: number): void;
                 setMarkersColors(colors: string[], index?: number): void;
                 _createMarker(): void;
                 private _setFluorescenceWidth;
                 private _setFluorescenceColor;
             }

             /**
              * FoF - Short for `Function of` - a generic type for function
              */
             export  type Fof<TReturn extends any = void, TArgs extends any[] = []> = (...args: TArgs) => TReturn;

             /**
              * Manages the creation of a Signed Distance Field (SDF) font atlas, and performs text layout to
              * generate attributes for rendering text using the atlas.
              */
             export  class FontManager extends EventDispatcher_2<{
                 atlasChange: object;
             }> {
                 options: FontManagerOptions;
                 private alphabet;
                 atlasData: AtlasData;
                 constructor(options?: FontManagerOptions);
                 update(newChars: string): void;
                 layout(text: string): LayoutInfo;
             }

             export  type FontManagerOptions = {
                 fontFamily?: string;
                 fontSize?: number;
             };

              type FontStyle = 'normal' | 'italic' | 'oblique';

              type FontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | number;

             /**
              * Apply a force to particles over their life.
              */
             export  class ForceOverLife implements Simulation {
                 x: FunctionValueGenerator | ValueGenerator;
                 y: FunctionValueGenerator | ValueGenerator;
                 z: FunctionValueGenerator | ValueGenerator;
                 type: string;
                 _temp: Vector3;
                 ps: IParticleSystem;
                 initialize(particle: Particle, particleSystem: ParticleSystem): void;
                 constructor(x: FunctionValueGenerator | ValueGenerator, y: FunctionValueGenerator | ValueGenerator, z: FunctionValueGenerator | ValueGenerator);
                 update(particle: Particle, delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any): Simulation;
                 _tempScale: Vector3;
                 _tempQ: Quaternion;
                 frameUpdate(delta: number): void;
                 clone(): Simulation;
                 reset(): void;
             }

             /**
              * apply tile number of particle texture by particles' life.
              */
             export  class FrameOverLife implements Simulation {
                 frame: FunctionValueGenerator;
                 type: string;
                 constructor(frame: FunctionValueGenerator);
                 initialize(particle: Particle): void;
                 update(particle: Particle, delta: number): void;
                 frameUpdate(delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any): Simulation;
                 clone(): Simulation;
                 reset(): void;
             }

             /**
              * Constrains the slipping in a contact along a tangent
              */
              class FrictionEquation extends Equation {
                 ri: Vec3;
                 rj: Vec3;
                 t: Vec3;
                 /**
                  * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
                  */
                 constructor(bodyA: Body_2, bodyB: Body_2, slipForce: number);
                 computeB(h: number): number;
             }

             /**
              * .
              * @param dist 
              * @param isMap2dHeightMeter false
              * @param app 
              * @param mapView
              */
             export  function fromDist(dist: number, isMap2dHeightMeter?: boolean, app?: App, mapView?: MapViewEntity): number;

             /**
              *  .
              */
             export  function fromWorld(vec3: [number, number, number?], app?: App, mapView?: MapViewEntity): [number, number, number];

             /**  */
             export  class FullscreenControl implements IControl {
                 _app: App;
                 _controlContainer: HTMLElement;
                 _fullscreen: boolean;
                 _fullscreenchange: string;
                 _fullscreenButton: HTMLElement;
                 _container: HTMLElement;
                 constructor(options?: FullscreenControlOptions);
                 onAdd(app: App): HTMLElement;
                 onRemove(): void;
                 _checkFullscreenSupport(): boolean;
                 _setupUI(): void;
                 _updateTitle(): void;
                 _getTitle(): "" | "";
                 _isFullscreen(): boolean;
                 _changeIcon(): void;
                 _onClickFullscreen(): void;
             }

             export  interface FullscreenControlOptions {
                 container?: HTMLElement;
             }

             export  class FullScreenQuad {
                 camera: OrthographicCamera;
                 geometry: PlaneGeometry;
                 mesh: Mesh;
                 constructor(material: any);
                 get material(): Material | Material[];
                 set material(value: Material | Material[]);
                 dispose(): void;
                 render(renderer: any): void;
             }

              interface FunctionBind {
                 <F extends BindFunc<Ctx>, Ctx>(func: F, ctx: Ctx): Bind1<F, Ctx>;
                 <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0]>(func: F, ctx: Ctx, a: T1): Bind2<F, Ctx, T1>;
                 <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1]>(func: F, ctx: Ctx, a: T1, b: T2): Bind3<F, Ctx, T1, T2>;
                 <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3): Bind4<F, Ctx, T1, T2, T3>;
                 <F extends BindFunc<Ctx>, Ctx, T1 extends Parameters<F>[0], T2 extends Parameters<F>[1], T3 extends Parameters<F>[2], T4 extends Parameters<F>[3]>(func: F, ctx: Ctx, a: T1, b: T2, c: T3, d: T4): Bind5<F, Ctx, T1, T2, T3, T4>;
             }

             export  interface FunctionColorGenerator {
                 type: 'function';
                 genColor(color: Vector4, t: number): Vector4;
                 toJSON(): FunctionJSON;
                 clone(): FunctionColorGenerator;
             }

             export  type FunctionJSON = {
                 [a: string]: any;
             };

             export  interface FunctionValueGenerator {
                 type: 'function';
                 genValue(t: number): number;
                 toJSON(): FunctionJSON;
                 clone(): FunctionValueGenerator;
             }

             

             export  const genDefaultForNodeValueType: (type: NodeValueType) => any;

              function generateRandomTriangleColors(geometry: BufferGeometry): void;

             /**
              * objectui
              * @param obj object
              * @param propItems 
              * @returns
              */
             export  function generateUiConfig(obj: any, propItems?: ({
                 prop?: string;
                 label?: string;
                 value?: any;
                 [key: string]: any;
             } | UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>)[]): UiObjectConfig[];

             export  function generateUiFolder(label: string, obj: any, params?: any, type?: string): UiObjectConfig;

             export  function generateUUID(): string;

             export  function GeneratorFromJSON(json: FunctionJSON): FunctionValueGenerator | ValueGenerator | RotationGenerator;

             /**
              * `GeoBounds` .
              */
             export  class GeoBounds {
                 min: GeoPoint;
                 max: GeoPoint;
                 constructor(min?: GeoPoint, max?: GeoPoint);
                 /**
                  *  `GeoBounds`.
                  *
                  * Example:
                  * ```typescript
                  * const b = GeoBounds.fromArray([left, bottom, right, top]);
                  * ```
                  */
                 static fromArray(input: [number, number, number, number]): GeoBounds;
                 /**
                  *  `GeoBounds`.
                  *
                  * Example:
                  * ```typescript
                  * const b = GeoBounds.fromString("[1,2,3,4]");
                  * ```
                  */
                 static fromString(input: string): GeoBounds;
                 /**
                  * bounds
                  * @param input
                  * @return {GeoBounds}
                  */
                 static fromDataExtent(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoBounds;
                 /**
                  * bounds
                  * @return {GeoBounds}
                  * @param center 
                  * @param width 
                  * @param height 
                  */
                 static fromCenterWH(center: GeoPointLike, width: number, height?: number): GeoBounds;
                 /**
                  * 
                  *
                  * @param min 
                  * @param max 
                  */
                 set(min: GeoPoint, max: GeoPoint): void;
                 /**
                  * 
                  * @return {GeoPoint}
                  */
                 center(): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  */
                 leftTop(): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  */
                 leftBottom(): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  */
                 rightTop(): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  */
                 rightBottom(): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  * @param xRatio x  0.6
                  * @param yRatio y  0.6
                  */
                 randomPoint(xRatio?: number, yRatio?: number): GeoPoint;
                 /**
                  * 
                  * @return {GeoPoint}
                  * @param xRatio x  0.6
                  * @param yRatio y  0.6
                  * @param minPointCount 
                  * @param maxPointCount 
                  */
                 randomPoints(minPointCount: number, maxPointCount: number, xRatio?: number, yRatio?: number): GeoPoint[];
                 /**
                  * geojson
                  * @return {GeoPoint}
                  * @param xRatio x  0.6
                  * @param yRatio y  0.6
                  * @param count 
                  * @param propertiesCb 
                  */
                 randomGeoJsonPointCollection(count: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object): GeoJsonGeomertry;
                 /**
                  * geojson
                  * @return {GeoPoint}
                  * @param xRatio x  0.6
                  * @param yRatio y  0.6
                  * @param maxLineCount 
                  * @param maxPointCount 
                  * @param propertiesCb 
                  * @param minLineCount 1)
                  * @param minPointCount 2)
                  */
                 randomGeoJsonLineCollection(maxLineCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minLineCount?: number, minPointCount?: number): GeoJsonGeomertry;
                 /**
                  * geojson
                  * @return {GeoPoint}
                  * @param xRatio x  0.6
                  * @param yRatio y  0.6
                  * @param maxPolygonCount 
                  * @param maxPointCount 
                  * @param propertiesCb 
                  * @param minPolygonCount (1)
                  * @param minPointCount (3)
                  */
                 randomGeoJsonPolygonCollection(maxPolygonCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minPolygonCount?: number, minPointCount?: number): GeoJsonGeomertry;
                 /**
                  * 
                  *
                  * @returns {Array} The coordinates represented as a array of the format `[minx, miny, maxx, maxy]'`.
                  *
                  */
                 toArray(): number[];
                 /**
                  * 
                  *
                  * @returns {Array} The coordinates represented as a array of the format `[[minx,maxy], [maxx,maxy], [maxx,miny], [minx,miny]]'`.
                  *
                  */
                 toPointArray(): Array<[number, number]>;
                 /**
                  * .
                  *
                  * @returns {string} The coordinates represented as a string of the format `minx, miny, maxx, maxy'`.
                  *
                  */
                 toString(fixed?: number): string;
                 /**
                  *  
                  *
                  */
                 clone(): GeoBounds;
                 /**
                  * 
                  * @param isMinValue 
                  * @return{GeoBounds}
                  */
                 square(isMinValue?: boolean): GeoBounds;
                 /**
                  *  
                  *
                  */
                 width(): number;
                 /**
                  *  
                  *
                  */
                 height(): number;
                 /**
                  *  / GeoBounds
                  * @param ratio 
                  * @param origin  bounds 
                  */
                 scale(ratio: number, origin?: GeoPoint | null): GeoBounds;
                 /**
                  *  XY/ GeoBounds
                  * @param ratioX X
                  * @param ratioY Y
                  * @param origin  bounds 
                  */
                 scaleXY(ratioX: number, ratioY: number, origin?: GeoPoint | null): GeoBounds;
                 /**
                  * 
                  * @param dx
                  * @param dy
                  */
                 translate(dx: number, dy: number): void;
                 /**
                  * 
                  * @param vertices
                  */
                 update(vertices: GeoPoint[]): void;
                 /**
                  * 
                  * @param bounds
                  */
                 updateByBounds(bounds: GeoBounds[] | GeoBounds): void;
                 /**
                  * 
                  * @param b
                  */
                 intersect(b: GeoBounds): GeoBounds | null;
                 /**
                  * 
                  * @param bound
                  */
                 union(bound: GeoBounds): GeoBounds;
                 /**
                  * 
                  * @param bound
                  */
                 isIntersect(bound: GeoBounds): boolean;
                 /**
                  * 
                  * @param bound
                  */
                 isContains(bound: GeoBounds): boolean;
                 /**
                  * 
                  * @param point
                  */
                 contains(point: GeoPoint): boolean;
                 /**
                  * Returns the value in the interval that is nearest to `targetValue`.
                  *
                  * @ignore
                  * @param interval        The interval to find the value within.
                  * @param targetValue     The value to get nearest to.
                  * @param includeInterior If false, the value will either be [[min]] or [[max]].
                  *                        If true, the value may be any number between [[min]] and [[max]].
                  */
                 private closestInterval;
                 /**
                  * .
                  * @param testPoint       .
                  * @param includeInterior truefalse.
                  */
                 closestPoint(testPoint: GeoPoint, includeInterior?: boolean): GeoPoint;
             }

             /**
              * newGeoBounds
              * @param min
              * @param max
              */
             export  function geoBounds(min?: GeoPoint, max?: GeoPoint): GeoBounds;

             /**
              * GeoJSON
              *
              * All GeoJSON objects
              */
              type GeoJsonGeomertry = Feature | FeatureCollection | Geometry | GeometryCollection;

             /**
              * GeoJSON Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3
              * The GeoJSON specification also allows [foreign members](https://tools.ietf.org/html/rfc7946#section-6.1)
              * Developers should use '&' type in TypeScript or extend the interface to add these foreign members.
              */
              interface GeoJSONObject {
                 /**
                  * Specifies the type of GeoJSON object.
                  */
                 type: string;
                 /**
                  * Bounding box of the coordinate range of the object's Geometries, Features, or Feature Collections.
                  * https://tools.ietf.org/html/rfc7946#section-5
                  */
                 bbox?: BBox;
             }

             /**
              * Geometry
              *
              * https://tools.ietf.org/html/rfc7946#section-3
              */
              interface Geometry extends GeoJSONObject {
                 coordinates: Position | Position[] | Position[][] | Position[][][];
             }

             /**
              * GeometryCollection
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.8
              *
              * A GeoJSON object with type 'GeometryCollection' is a Geometry object.
              * A GeometryCollection has a member with the name 'geometries'.
              * The value of 'geometries' is an array.  Each element of this array is a GeoJSON Geometry object.
              * It is possible for this array to be empty.
              */
              interface GeometryCollection extends GeometryObject {
                 type: "GeometryCollection";
                 geometries: Array<GeometryPoint | LineString | Polygon_2 | MultiPoint | MultiLineString | MultiPolygon>;
             }

             /**
              * Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3
              */
              interface GeometryObject extends GeoJSONObject {
                 type: GeometryTypes;
             }

             /**
              * Point Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.2
              */
              interface GeometryPoint extends GeometryObject {
                 type: "GeometryPoint";
                 coordinates: Position;
             }

             /**
              * GeometryTypes
              *
              * https://tools.ietf.org/html/rfc7946#section-1.4
              * The valid values for the 'type' property of GeoJSON geometry objects.
              */
              type GeometryTypes = "GeometryPoint" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";

             /**
              * `GeoPoint` .
              */
             export  class GeoPoint {
                 /**
                  *  {@link GeoPoint} .
                  *
                  * Example:
                  * ```typescript
                  * const p1 = GeoPoint.convert(new GeoPoint(x, y, z));
                  * const p2 = GeoPoint.convert([x, y]);
                  * const p3 = GeoPoint.convert([x, y, z]);
                  * const p4 = GeoPoint.convert(lng: -73.9749, lat: 40.7736});
                  * const p5 = GeoPoint.convert(lon: -73.9749, lat: 40.7736});
                  * ```
                  *
                  * @param input - Either [[GeoPointLike]], {@link GeoPointLike}
                  * or {@link GeoPointLike} object literal.
                  */
                 static convert(input: GeoPointLike): GeoPoint;
                 /**
                  *  `GeoPoint`.
                  *
                  * Example:
                  * ```typescript
                  * const b = GeoPoint.fromString("1,2");
                  * ```
                  */
                 static fromString(input: string): GeoPoint;
                 /** X. */
                 x: number;
                 /** y. */
                 y: number;
                 /** z(. */
                 z?: number;
                 /**
                  *  `GeoPoint` 
                  *
                  * @param x - x.
                  * @param y - y.
                  * @param z - z(.
                  */
                 constructor(x: number, y: number, z?: number);
                 /**
                  *  
                  *
                  */
                 clone(): GeoPoint;
                 private _add;
                 /**
                  * 
                  *
                  * @returns {Array<number>} The coordinates represeted as an array of x and y.
                  * ```typescript
                  * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
                  * ll.toArray(); // = [-73.9749, 40.7736]
                  * ```
                  */
                 toArray(): number[];
                 /**
                  * .
                  * @param fixed
                  * @returns {string} The coordinates represented as a string of the format `'x, y, z?'`.
                  * ```typescript
                  * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
                  * ll.toString(); // = "GeoPoint(-73.9749, 40.7736)"
                  * ```
                  */
                 toString(fixed?: number): string;
                 /**
                  * 
                  * @param fixed
                  * @return {GeoPoint}
                  */
                 round(fixed?: number): GeoPoint;
                 roundStr(fixed?: number): string;
                 /**
                  * .
                  *
                  * @param p - .
                  */
                 add(p: GeoPoint): GeoPoint;
                 private _sub;
                 /**
                  * .
                  *
                  * @param p - .
                  */
                 sub(p: GeoPoint): GeoPoint;
                 lengthSq(): number;
                 private _multByPoint;
                 /**
                  * .
                  *
                  * @param p - .
                  */
                 multByPoint(p: GeoPoint): GeoPoint;
                 private _divByPoint;
                 /**
                  * .
                  *
                  * @param p - .
                  */
                 divByPoint(p: GeoPoint): GeoPoint;
                 dot(p: GeoPoint): number;
                 lerp(v: GeoPoint, alpha: number): this;
                 private _mult;
                 /**
                  * .
                  *
                  * @param k - .
                  */
                 mult(k: number): GeoPoint;
                 private _div;
                 /**
                  * .
                  *
                  * @param k - .
                  */
                 div(k: number): GeoPoint;
                 private _rotate;
                 /**
                  * .
                  *
                  * @param angle - .
                  */
                 rotate(angle: number): GeoPoint;
                 private _rotateAround;
                 /**
                  * .
                  *
                  * @param angle - .
                  * @param p - .
                  */
                 roateAround(angle: number, p: GeoPoint): GeoPoint;
                 private _matMult;
                 /**
                  * .
                  *
                  * @param m - .
                  */
                 matMult(m: number[]): GeoPoint;
                 private _unit;
                 /**
                  * .
                  *
                  */
                 unit(): GeoPoint;
                 private _perp;
                 /**
                  *  [x,y] = [-y, x].
                  *
                  */
                 perp(): GeoPoint;
                 private _round;
                 /**
                  * .
                  *
                  */
                 roundInt(): GeoPoint;
                 /**
                  * .
                  *
                  */
                 mag(): number;
                 /**
                  * 
                  * @param other 
                  * @param dotErr 8
                  * @return {boolean}
                  */
                 equals(other: GeoPoint, dotErr?: number): boolean;
                 /**
                  * z).
                  *
                  */
                 equalsZ(other: GeoPoint): boolean;
                 /**
                  * .
                  *
                  */
                 distanceTo(p: GeoPoint): number;
                 /**
                  * .
                  *
                  */
                 distSqr(p: GeoPoint): number;
                 /**
                  * .
                  *
                  */
                 angle(): number;
                 /**
                  * 
                  *
                  */
                 angleTo(b: GeoPoint): number;
                 /**
                  * interiorAngle
                  *
                  */
                 angleWith(b: GeoPoint): number;
                 /**
                  * interiorAngle
                  *
                  */
                 angleWithSep(x: number, y: number): number;
                 /**
                  * .
                  * @param basePt 
                  * @param destPt 
                  * @param scale 1.0
                  * @param angle 0
                  * @return {GeoPoint}
                  *
                  */
                 transform(basePt: GeoPoint, destPt: GeoPoint, scale?: number, angle?: number): this;
             }

             /**
              * newGeoPoint
              * @param input
              * @return {GeoPoint}
              */
             export  function geoPoint(input: GeoPointLike): GeoPoint;

             export  type GeoPointLike = [number, number] | [number, number, number] | GeoPoint | {
                 x: number;
                 y: number;
                 z?: number;
             } | {
                 lng: number;
                 lat: number;
             } | {
                 lon: number;
                 lat: number;
             };

             /**
              * `GeoProjection` .
              *
              * Example:
              * ```typescript
              * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
              * const prj = new GeoProjection(mapExtent);
              * const pt = [30, 30];
              * const latlng = prj.toLngLat(pt);
              * const pt_geo = prj.fromLngLat(latlng);
              * const mkt = prj.toMercator(pt);
              * const pt_mkt = prj.fromMercator(mkt);
              * ```
              */
             export  class GeoProjection extends Projection {
                 /** . */
                 mapExtent: GeoBounds;
                 private _ratio_x;
                 private _ratio_y;
                 /**
                  *  `GeoBounds` 
                  *
                  * @extent extent - .
                  */
                 constructor(extent: GeoBounds);
                 /**
                  *  
                  *
                  * @extent extent - .
                  */
                 setExtent(extent: GeoBounds): void;
                 /**
                  * (epsg:3857)
                  * @param input 
                  * @return {[number, number]}
                  */
                 toMercator(input: GeoPointLike): [number, number];
                 /**
                  * (epsg:3857)
                  * @param input 
                  * @return {[number, number]}
                  */
                 fromMercator(input: GeoPointLike): [number, number];
                 /**
                  * 
                  * @param input 
                  * @return {[number, number]}
                  */
                 toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): [number, number];
                 /**
                  * 
                  * @param input 
                  * @return {GeoPoint}
                  */
                 fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
                 /**
                  * 
                  * @return {GeoBounds}
                  */
                 getMapExtent(): GeoBounds;
                 /**
                  * 
                  * @param dist
                  */
                 toMeter(dist: number): number;
                 /**
                  * 
                  * @param meter
                  */
                 fromMeter(meter: number): number;
             }

             /**
              * 3dtilesboundingVolumetransform
              * @param box 3dtilesboundingVolume.box[number,number,number]
              */
              function get3dTilesLngLatHeight(box: number[], matrix?: number[]): [number, number, number];

             export  const getAlignOfNodeValueType: (type: NodeValueType) => number;

             /**
              * 
              * @param object 
              * @param inLocalSpace 
              * @param app 
              * @param mapModeSceneSpace 
              */
             export  function getBoundingBox(object: Object3D, inLocalSpace?: boolean, app?: App, mapModeSceneSpace?: boolean): Box3;

              function getBVHExtremes(bvh: MeshBVH): Array<ExtremeInfo>;

             /**
              * Returns the current active effect scope if there is one.
              *
              */
              function getCurrentScope(): EffectScope;

              function getElementSSRData(el: Element_2): ElementSSRData;

             export  function getEmptyMeta(res?: any): {
                 geometries: any;
                 materials: any;
                 textures: any;
                 images: any;
                 shapes: any;
                 skeletons: any;
                 animations: any;
                 extras: any;
                 _context: {};
             };

             /**  */
             export  const getEntityParents: (ent: Entity) => Entity[];

             /** hdrenvmap */
             export  const getEnvmapFromHDRTexture: (renderer: WebGLRenderer, texture: Texture) => Texture;

             /**  envmap */
             export  const getEnvmapFromScene: (renderer: WebGLRenderer, scene: Scene) => Texture;

             /**
              * epsg
              * @param coordinate xx[x,y][lng,lat]
              * @param crs   
              * @param is3DegreeBelt  
              * @returns
              */
              function getEpsgCode(coordinate: number | [number, number], crs?: EpsgCrsTypes, is3DegreeBelt?: boolean): any[];

             /**
              * proj4
              * @param crs 
              * @param lon 54,8020008wgs843857
              * @returns {null | {epsg: string, proj: string}}
              */
              function getEpsgParam(crs: EpsgCrsTypes, lon?: number): {
                 epsg: string;
                 proj: string;
             };

             /**
              * Get the filename from a path, similar to PHP's basename()
              * @param url
              *
              * @category Text
              */
             export  function getFilenameFromPath(url: string): string;

             /**
              * 
              * @returns
              */
             export  function getFilterColorMatrix(filter: FilterColorOptions): Matrix4;

             export  function getFrustum(camera: any, offsetZ?: number): {
                 width: number;
                 height: number;
             };

             export  function getFrustumFromHeight(camera: any, height: any, offsetZ?: number): number;

             export  function getFullscreenTriangle(): BufferGeometry<NormalBufferAttributes>;

             /**
              * Get render2d instance by id
              */
              function getInstance(id: number): Render2D;

              function getJSONStructure(bvh: MeshBVH): TreeNode;

             /**
              * Find the key of an object with a given value.
              * @param object - object to search
              * @param value - value to search for
              *
              * @category JS Object
              */
             export  function getKeyByValue(object: Record<string, any>, value: any): string | undefined;

             /**
              * 
              * object 
              * anchor 
              * inLocalSpace 
              */
             export  function getObjectAnchorPoint(object: Object3D | Box3, anchor: Anchor3d, inLocalSpace?: boolean, app?: App): Vector3;

             /**
              * 
              * @param object 
              * @param isRootEntity false
              * @returns
              */
             export  const getObjectOwnerEntity: (object: Object3D, isRootEntity?: boolean) => Entity | undefined;

             export  const getObjectRefCount: (obj: any) => boolean;

             /**
              * Get value, but if it is a function, call it with args
              * @param s - value or function
              * @param args - arguments to pass to function
              *
              * @category JS Object
              */
             export  function getOrCall<T>(s: ValOrFunc<T | undefined>, ...args: any[]): T | undefined;

             /**  */
             export  function getOwerScene(ent: Entity | Object3D): Scene | undefined;

             export  function getPhysicsResolver(): PhysicsResolver;

             /**
              * Get property descriptor from object or its prototype chain
              * @param obj
              * @param prop
              *
              * @category JS Object
              */
             export  function getPropertyDescriptor<T>(obj: T, prop: keyof T): PropertyDescriptor | undefined;

             export  function getScreenSpaceBox(mesh: any, camera: any): Box2;

             /**
              * Given a THREE.Object3D instance, creates parameters for a CANNON shape.
              */
             export  const getShapeParameters: (object: Object3D, options?: ShapeOptions) => ShapeParameters | null;

             export  const getSizeOfNodeValueType: (type: NodeValueType) => number;

             export  function getSphericalCube(radius: any, segments: any): BoxGeometry;

              function getTriangleDefinitions(...triangles: Triangle[]): String[];

              function getTriangleHitPointInfo(point: Vector3, geometry: BufferGeometry, triangleIndex: number, target?: HitTriangleInfo): HitTriangleInfo;

             /**
              * Create a typed array from an ArrayBuffer by name
              * @param type - Name of the typed array constructor
              * @param buffer - ArrayBuffer to use
              * @category ArrayBuffer
              */
             export  function getTypedArray(type: keyof typeof TYPED_ARRAYS, buffer: ArrayBuffer): Float32Array | Uint8Array | Int8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float64Array;

             /**
              * Get URL query parameter. If not found, return default value. Similar to PHP's $_GET
              * @param p - parameter name to get
              * @param def - default value if parameter not found
              *
              * @category URL
              */
             export  function getUrlQueryParam(p: string, def?: any): any;

             export  function getValueFromEmitterMode(mode: EmitterMode, currentValue: number, spread: number, emissionState: EmissionState): number;

             

             

             export  interface GlLineItemData {
                 /** id */
                 id?: string;
                 /**  */
                 coordinates: [number, number, number][];
                 /**  */
                 color?: ColorRepresentation | ColorRepresentation[];
                 /**  */
                 showVertex?: boolean;
                 /**   */
                 [key: string]: any;
             }

             /**
              * (glline)
              */
             export  class GlLinesEntity extends Entity {
                 constructor(options: GlLinesEntityOptions);
                 /**
                  * 
                  */
                 getGlLines: () => Line_2;
                 /**
                  * 
                  */
                 updateStyle: (style: LineDashedMaterialParameters | LineBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 updateHightStyle: (style: LineDashedMaterialParameters | LineBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 setData: (data: GlLineItemData[]) => void;
                 /**
                  * 
                  */
                 getData: () => GlLineItemData[];
                 /**
                  * 
                  */
                 getVertexSymbol: () => SymbolEntity;
                 /**
                  * 
                  */
                 isShowVertex: () => boolean;
                 /**
                  * 
                  */
                 getVertexData: (isGetAll?: boolean) => SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex: (show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }) => void;
                 /**
                  * 
                  * @param index 
                  * @param isRefData ,false,
                  */
                 getItemDataByIndex: (index: number, isRefData?: boolean) => {
                     positionIndex: number;
                 } & GlLineItemData;
                 /**
                  * 
                  */
                 refreshHighlight: () => void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight: (id: string) => boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight: () => void;
                 /**
                  * 
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
             }

             export  type GlLinesEntityOptions = EntityOptions & GlLinesModuleOption;

             /**
              * webgl,()
              */
             export  class GlLinesModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 gllines: Line_2;
                 data: GlLineItemData[];
                 style: LineDashedMaterialParameters | LineBasicMaterialParameters;
                 highlightGlLines: Line_2;
                 highlightData: GlLineItemData[];
                 highlightStyle: LineDashedMaterialParameters | LineBasicMaterialParameters;
                 highlightIndexMap: Map<string, number>;
                 posIndex: Map<number, {
                     lineIndex: number;
                     positionIndex: number;
                 }>;
                 vertexEntity: SymbolEntity;
                 showVertex: boolean;
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
                 constructor(entity: Entity, options?: GlLinesModuleOption);
                 setupUiConfig(): UiObjectConfig;
                 /**
                  * 
                  */
                 getGlLines(): Line_2<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
                 /**
                  * 
                  */
                 getVertexSymbol(): SymbolEntity;
                 /**
                  * 
                  */
                 updateStyle(style: LineDashedMaterialParameters | LineBasicMaterialParameters): void;
                 /**
                  * 
                  */
                 updateHightStyle(style: LineDashedMaterialParameters | LineBasicMaterialParameters): void;
                 /**
                  * 
                  */
                 setData(data: GlLineItemData[]): void;
                 /**
                  * 
                  */
                 isShowVertex(): boolean;
                 /**
                  * 
                  */
                 getVertexData(isGetAll?: boolean): SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex(show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }): void;
                 /**
                  * 
                  */
                 getData(): GlLineItemData[];
                 /**
                  * Index
                  * @param index 
                  * @param isRefData ,false,
                  */
                 getItemDataByIndex(index: number, isRefData?: boolean): {
                     data: GlLineItemData;
                     positionIndex: number;
                 } | {
                     positionIndex: number;
                     /** id */
                     id?: string;
                     /**  */
                     coordinates: [number, number, number][];
                     /**  */
                     color?: ColorRepresentation | ColorRepresentation[];
                     /**  */
                     showVertex?: boolean;
                     data?: undefined;
                 };
                 /**
                  * 
                  * @returns
                  */
                 refreshHighlight(): void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight(id: string): boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight(): void;
             }

             export  interface GlLinesModuleOption {
                 /**  */
                 data: GlLineItemData[];
                 /**  */
                 style?: LineDashedMaterialParameters | LineBasicMaterialParameters;
                 /**  */
                 highlightStyle?: LineDashedMaterialParameters | LineBasicMaterialParameters;
                 /**  */
                 dashed?: boolean;
                 /**  () */
                 showVertex?: boolean;
                 /**  */
                 hidden?: boolean;
                 /**   */
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
             }

             /**
              * A template literal tag that does nothing. Useful for syntax highlighting of GLSL code.
              *
              * @example
              * ```js
              * const vertexShader = glsl`
              *    void main() {}
              * `
              * ```
              * @category Template Literals
              */
             export  const glsl: (strings: any, ...rest: any[]) => string;

             

             export  class Gradient implements FunctionColorGenerator {
                 type: 'function';
                 color: ContinuousLinearFunction<Vector3>;
                 alpha: ContinuousLinearFunction<number>;
                 constructor(color?: Array<[Vector3, number]>, alpha?: Array<[number, number]>);
                 genColor(color: Vector4, t: number): Vector4;
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): Gradient;
                 clone(): FunctionColorGenerator;
             }

              class Gradient_2 {
                 id?: number;
                 type: string;
                 colorStops: GradientColorStop[];
                 global: boolean;
                 constructor(colorStops: GradientColorStop[]);
                 addColorStop(offset: number, color: string): void;
             }

              interface GradientColorStop {
                 offset: number;
                 color: string;
             }

              interface GradientObject {
                 id?: number;
                 type: string;
                 colorStops: GradientColorStop[];
                 global?: boolean;
             }

             /**
              * 
              *
              * @example
              * var graph = Graph()
              * .addEdge("s", "t", 10)
              * .addEdge("s", "y", 5)
              * .addEdge("s", "y", 4)
              * .addEdge("t", "y", 2)
              * .addEdge("y", "t", 3)
              * .addEdge("t", "x", 1)
              * .addEdge("y", "x", 9)
              * .addEdge("y", "z", 2)
              * .addEdge("x", "z", 4)
              * .addEdge("z", "x", 6);
              * var res = graph.shortestPath("s", "z")
              */
             export  function Graph(serialized?: Serialized): {
                 addNode: (node: NodeId) => any;
                 removeNode: (node: NodeId) => any;
                 nodes: () => NodeId[];
                 adjacent: (node: NodeId) => NodeId[];
                 addEdge: (u: NodeId, v: NodeId, weight?: EdgeWeight) => any;
                 removeEdge: (u: NodeId, v: NodeId) => any;
                 hasEdge: (u: NodeId, v: NodeId) => boolean;
                 setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any;
                 getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight;
                 indegree: (node: NodeId) => number;
                 outdegree: (node: NodeId) => number;
                 depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
                 hasCycle: () => boolean;
                 lowestCommonAncestors: (node1: NodeId, node2: NodeId) => string[];
                 topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => string[];
                 shortestPath: (source: NodeId, destination: NodeId) => string[] & {
                     weight?: EdgeWeight;
                 };
                 serialize: () => Serialized;
                 deserialize: (serialized: Serialized) => any;
             };

             export  class GraphNodeType extends NodeDef {
                 nodeGraph: NodeGraph;
                 constructor(nodeGraph: NodeGraph);
             }

             /**
              * Apply a gravity force to particles.
              * the gravity force is calculated as:
              * F = G * m1 * m2 / r^2
              */
             export  class GravityForce implements Simulation {
                 center: Vector3;
                 magnitude: number;
                 type: string;
                 temp: Vector3;
                 constructor(center: Vector3, magnitude: number);
                 initialize(particle: Particle): void;
                 update(particle: Particle, delta: number): void;
                 frameUpdate(delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any): Simulation;
                 clone(): Simulation;
                 reset(): void;
             }

             export  const Grid: ({ args, cellColor, sectionColor, cellSize, sectionSize, followCamera, infiniteGrid, fadeDistance, fadeStrength, cellThickness, sectionThickness, axisThickness, side, depthWrite, }?: GridProps) => GridType;

             /**
              * Axis aligned uniform grid broadphase.
              * @todo Needs support for more than just planes and spheres.
              */
              class GridBroadphase extends Broadphase {
                 /**
                  * Number of boxes along x
                  */
                 nx: number;
                 /**
                  * Number of boxes along y
                  */
                 ny: number;
                 /**
                  * Number of boxes along z
                  */
                 nz: number;
                 /**
                  * aabbMin
                  */
                 aabbMin: Vec3;
                 /**
                  * aabbMax
                  */
                 aabbMax: Vec3;
                 /**
                  * bins
                  */
                 bins: Body_2[][];
                 /**
                  * binLengths
                  */
                 binLengths: number[];
                 /**
                  * @param nx Number of boxes along x.
                  * @param ny Number of boxes along y.
                  * @param nz Number of boxes along z.
                  */
                 constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number);
                 /**
                  * Get all the collision pairs in the physics world
                  */
                 collisionPairs(world: World, pairs1: Body_2[], pairs2: Body_2[]): void;
             }

             export  class GridEmitter implements EmitterShape {
                 type: string;
                 width: number;
                 height: number;
                 column: number;
                 row: number;
                 constructor(parameters?: GridEmitterParameters);
                 initialize(p: Particle): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any): GridEmitter;
                 clone(): EmitterShape;
                 update(system: ParticleSystem, delta: number): void;
             }

             /**
              * Interface representing the parameters for a grid emitter.
              */
             export  interface GridEmitterParameters {
                 /**
                  * The width of the grid.
                  */
                 width?: number;
                 /**
                  * The height of the grid.
                  */
                 height?: number;
                 /**
                  * The number of columns in the grid.
                  */
                 column?: number;
                 /**
                  * The number of rows in the grid.
                  */
                 row?: number;
             }

             export  class GridHelperModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 grid: GridType;
                 gridLineHelper: GridHelper;
                 constructor(entity: Entity, options?: GridHelperModuleOptions);
                 getVisible(isUseGridLine?: boolean): boolean;
                 setVisible(visible: boolean, isUseGridLine?: boolean): void;
                 onAppUpdate(time: Time): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface GridHelperModuleOptions extends GridProps {
                 polygonOffset?: boolean;
                 polygonOffsetFactor?: number;
                 polygonOffsetUnits?: number;
                 /**  */
                 drawGridLine?: boolean;
                 /**  */
                 gridLineSize?: number;
                 /**  */
                 gridLineDivisions?: number;
                 /**  */
                 gridLineColor1?: Color;
                 /**  */
                 gridLineColor2?: Color;
             }

              class GridMaterial extends MeshPhongMaterial {
                 enableGrid: boolean;
             }

             export  type GridProps = {
                 /** plane-geometry size, default: [100, 100] */
                 args?: Array<number>;
                 /** Cell size, default: 1 */
                 cellSize?: number;
                 /** Cell thickness, default: 0.8 */
                 cellThickness?: number;
                 /** Cell color, default: rgb(50,55,72) */
                 cellColor?: Color;
                 /** Section size, default: 10 */
                 sectionSize?: number;
                 /** Section thickness, default: 1 */
                 sectionThickness?: number;
                 /** axisThickness thickness, default: 1.8 */
                 axisThickness?: number;
                 /** Section color, default: rgb(73,79,105) */
                 sectionColor?: Color;
                 /** Follow camera, default: false */
                 followCamera?: boolean;
                 /** Display the grid infinitely, default: false */
                 infiniteGrid?: boolean;
                 /** Fade distance, default: 1000 */
                 fadeDistance?: number;
                 /** Fade strength, default: 1 */
                 fadeStrength?: number;
                 /** Material side, default: BackSide */
                 side?: Side;
                 /** Material depthWrite, default: false */
                 depthWrite?: boolean;
                 /** visible, default: true */
                 visible?: boolean;
             };

             export  type GridType = {
                 mesh: Mesh;
                 update: (camera: Camera) => void;
             };

              class Group extends Element_2<GroupProps> {
                 readonly isGroup = true;
                 private _children;
                 constructor(opts?: GroupProps);
                 /**
                  * Get children reference.
                  */
                 childrenRef(): Element_2<ElementProps>[];
                 /**
                  * Get children copy.
                  */
                 children(): Element_2<ElementProps>[];
                 /**
                  *  index 
                  */
                 childAt(idx: number): Element_2;
                 /**
                  * 
                  */
                 childOfName(name: string): Element_2;
                 childCount(): number;
                 /**
                  * 
                  */
                 add(child: Element_2): Group;
                 /**
                  *  nextSibling 
                  */
                 addBefore(child: Element_2, nextSibling: Element_2): this;
                 replace(oldChild: Element_2, newChild: Element_2): this;
                 replaceAt(child: Element_2, index: number): this;
                 _doAdd(child: Element_2): void;
                 /**
                  * Remove child
                  * @param child
                  */
                 remove(child: Element_2): this;
                 /**
                  * Remove all children
                  */
                 removeAll(): this;
                 /**
                  * 
                  */
                 eachChild<Context>(cb: (this: Context, el: Element_2, index?: number) => void, context?: Context): this;
                 /**
                  * Visit all descendants.
                  * Return false in callback to stop visit descendants of current node
                  */
                 traverse<T>(cb: (this: T, el: Element_2) => boolean | void, context?: T): this;
                 addSelfToZr(zr: Render2dType): void;
                 removeSelfFromZr(zr: Render2dType): void;
                 getBoundingRect(includeChildren?: Element_2[]): BoundingRect;
             }

              interface GroupLike extends Element_2 {
                 childrenRef(): Element_2[];
             }

              interface GroupProps extends ElementProps {
             }

             /**
              * Constraint equation Gauss-Seidel solver.
              * @todo The spook parameters should be specified for each constraint, not globally.
              * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
              */
              class GSSolver extends Solver {
                 /**
                  * The number of solver iterations determines quality of the constraints in the world.
                  * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
                  */
                 iterations: number;
                 /**
                  * When tolerance is reached, the system is assumed to be converged.
                  */
                 tolerance: number;
                 /**
                  * @todo remove useless constructor
                  */
                 constructor();
                 /**
                  * Solve
                  * @return number of iterations performed
                  */
                 solve(dt: number, world: World): number;
             }

             /**
              * Generate unique id
              */
              function guid(): number;

              class HalfEdgeHelper extends EdgesHelper {
                 constructor(geometry?: BufferGeometry, halfEdges?: HalfEdgeMap);
                 setHalfEdges(geometry: BufferGeometry, halfEdges: HalfEdgeMap): void;
             }

              class HalfEdgeMap {
                 constructor(geometry?: BufferGeometry);
                 getSiblingTriangleIndex(triIndex: number, edgeIndex: number): number;
                 getSiblingEdgeIndex(triIndex: number, edgeIndex: number): number;
                 updateFrom(geomtry: BufferGeometry): void;
             }

             /**
              * .
              */
             export  class HaloRingMarker extends AnimateMarkerBase {
                 constructor(features: FeatureCollection | {
                     position: [number, number, number?];
                     text?: string;
                 }, options?: AnimateMarkerLayerOption);
                 setMarkersWidth(width: number, index?: number): void;
                 setMarkersColors(colors: string[], index?: number): void;
                 _createMarker(): void;
                 private _createMakerElement;
             }

              class Handler extends Eventful {
                 storage: Storage_2;
                 painter: PainterBase;
                 painterRoot: HTMLElement;
                 proxy: HandlerProxyInterface;
                 private _hovered;
                 private _gestureMgr;
                 private _draggingMgr;
                 private _pointerSize;
                 _downEl: Element_2;
                 _upEl: Element_2;
                 _downPoint: [number, number];
                 constructor(storage: Storage_2, painter: PainterBase, proxy: HandlerProxyInterface, painterRoot: HTMLElement, pointerSize: number);
                 setHandlerProxy(proxy: HandlerProxyInterface): void;
                 mousemove(event: ZRRawEvent): void;
                 mouseout(event: ZRRawEvent): void;
                 /**
                  * Resize
                  */
                 resize(): void;
                 /**
                  * Dispatch event
                  */
                 dispatch(eventName: HandlerName, eventArgs?: any): void;
                 /**
                  * Dispose
                  */
                 dispose(): void;
                 /**
                  * cursor style
                  * @param cursorStyle  crosshair 'default'
                  */
                 setCursorStyle(cursorStyle: string): void;
                 /**
                  * 
                  *
                  * @private
                  * @param {Object} targetInfo {target, topTarget} 
                  * @param {string} eventName 
                  * @param {Object} event 
                  */
                 dispatchToElement(targetInfo: {
                     target?: Element_2;
                     topTarget?: Element_2;
                 }, eventName: ElementEventName, event: ZRRawEvent): void;
                 findHover(x: number, y: number, exclude?: Displayable): HoveredResult;
                 processGesture(event: ZRRawEvent, stage?: 'start' | 'end' | 'change'): void;
                 click: (event: ZRRawEvent) => void;
                 mousedown: (event: ZRRawEvent) => void;
                 mouseup: (event: ZRRawEvent) => void;
                 mousewheel: (event: ZRRawEvent) => void;
                 dblclick: (event: ZRRawEvent) => void;
                 contextmenu: (event: ZRRawEvent) => void;
             }

              type HandlerName = 'click' | 'dblclick' | 'mousewheel' | 'mouseout' | 'mouseup' | 'mousedown' | 'mousemove' | 'contextmenu';

              interface HandlerProxyInterface extends Eventful {
                 handler: Handler;
                 dispose: () => void;
                 setCursor: (cursorStyle?: string) => void;
             }

             /**
              * @constructor
              * @param {Object} obj
              */
              class HashMap<T, KEY extends string | number = string | number> {
                 data: MapInterface<T, KEY>;
                 constructor(obj?: HashMap<T, KEY> | {
                     [key in KEY]?: T;
                 } | KEY[]);
                 hasKey(key: KEY): boolean;
                 get(key: KEY): T;
                 set(key: KEY, value: T): T;
                 each<Context>(cb: (this: Context, value?: T, key?: KEY) => void, context?: Context): void;
                 keys(): KEY[];
                 removeKey(key: KEY): void;
             }

              function hasOwn(own: object, prop: string): boolean;

              class Heart extends Path<HeartProps> {
                 shape: HeartShape;
                 constructor(opts?: HeartProps);
                 getDefaultShape(): HeartShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: HeartShape): void;
             }

              interface HeartProps extends PathProps {
                 shape?: Partial<HeartShape>;
             }

              class HeartShape {
                 cx: number;
                 cy: number;
                 width: number;
                 height: number;
             }

             /**  */
             export  class Heatmap {
                 #private;
                 options: HeatmapOptions;
                 heatmap: any;
                 mesh: Mesh;
                 h337: any;
                 size: [number, number];
                 bounds: GeoBounds;
                 texture: Texture;
                 constructor(options: HeatmapOptions);
                 /**  */
                 create(): Promise<Mesh<PlaneGeometry, MeshBasicMaterial | ShaderMaterial, Object3DEventMap>>;
                 /**  */
                 setData(opts: {
                     /**  [[minx, minz],[maxx, maxz]]*/
                     bounds?: [number, number][];
                     boundScale?: number;
                     /**  */
                     data: {
                         /**  x,z*/
                         point: [number, number];
                         /**  */
                         value: number;
                     }[];
                     max?: number;
                     min?: number;
                     /**  */
                     clipPolygon?: [number, number][];
                 }): void;
                 /** uv */
                 getValueByUV(uv: [number, number]): any;
                 /**  */
                 getValueByCoord(pt: [number, number]): any;
             }

             /**  */
             export  interface HeatmapOptions {
                 /** 3d */
                 mode3D?: boolean;
                 /** 3d 10 */
                 heightRatio?: number;
                 /** 3d 50 */
                 segment?: number;
                 /**  [[minx, minz],[maxx, maxz]]*/
                 bounds?: [[number, number], [number, number]];
                 /**  */
                 clipPolygon?: [number, number][];
                 boundScale?: number;
                 /**  */
                 data: {
                     /**  x,z*/
                     point: [number, number];
                     /**  */
                     value: number;
                 }[];
                 max?: number;
                 min?: number;
                 /**  */
                 canvasSize?: number;
                 /**  */
                 style?: {
                     /**
                      * A background color string in form of hexcode, color name, or rgb(a)
                      */
                     backgroundColor?: string;
                     /**
                      * The blur factor that will be applied to all datapoints. The higher the
                      * blur factor is, the smoother the gradients will be
                      * Default value: 0.85
                      */
                     blur?: number;
                     /**
                      * An object that represents the gradient.
                      * Syntax: {[key: number in range [0,1]]: color}
                      * Default value: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"}
                      */
                     gradient?: {
                         [key: string]: string;
                     };
                     /**
                      * The maximal opacity the highest value in the heatmap will have. (will be
                      * overridden if opacity set)
                      * Default value: 0.6
                      */
                     maxOpacity?: number;
                     /**
                      * The minimum opacity the lowest value in the heatmap will have (will be
                      * overridden if opacity set)
                      */
                     minOpacity?: number;
                     /**
                      * A global opacity for the whole heatmap. This overrides maxOpacity and
                      * minOpacity if set
                      * Default value: 0.6
                      */
                     opacity?: number;
                     /**
                      * The radius each datapoint will have (if not specified on the datapoint
                      * itself)
                      * Default value: 40
                      */
                     radius?: number;
                     /**
                      * Scales the radius based on map zoom.
                      */
                     scaleRadius?: boolean;
                 };
             }

             /**
              * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
              * @todo Should be possible to use along all axes, not just y
              * @todo should be possible to scale along all axes
              * @todo Refactor elementSize to elementSizeX and elementSizeY
              *
              * @example
              *     // Generate some height data (y-values).
              *     const data = []
              *     for (let i = 0; i < 1000; i++) {
              *         const y = 0.5 * Math.cos(0.2 * i)
              *         data.push(y)
              *     }
              *
              *     // Create the heightfield shape
              *     const heightfieldShape = new CANNON.Heightfield(data, {
              *         elementSize: 1 // Distance between the data points in X and Y directions
              *     })
              *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })
              *     world.addBody(heightfieldBody)
              */
              class Heightfield extends Shape {
                 /**
                  * An array of numbers, or height values, that are spread out along the x axis.
                  */
                 data: number[][];
                 /**
                  * Max value of the data points in the data array.
                  */
                 maxValue: number | null;
                 /**
                  * Minimum value of the data points in the data array.
                  */
                 minValue: number | null;
                 /**
                  * World spacing between the data points in X and Y direction.
                  * @todo elementSizeX and Y
                  * @default 1
                  */
                 elementSize: number;
                 /**
                  * @default true
                  */
                 cacheEnabled: boolean;
                 pillarConvex: ConvexPolyhedron;
                 pillarOffset: Vec3;
                 private _cachedPillars;
                 /**
                  * @param data An array of numbers, or height values, that are spread out along the x axis.
                  */
                 constructor(data: number[][], options?: {
                     /**
                      * Max value of the data points in the data array.
                      * Will be computed automatically if not given.
                      */
                     maxValue?: number | null;
                     /**
                      * Minimum value of the data points in the data array.
                      * Will be computed automatically if not given.
                      */
                     minValue?: number | null;
                     /**
                      * World spacing between the data points in X direction.
                      */
                     elementSize?: number;
                 });
                 /**
                  * Call whenever you change the data array.
                  */
                 update(): void;
                 /**
                  * Update the `minValue` property
                  */
                 updateMinValue(): void;
                 /**
                  * Update the `maxValue` property
                  */
                 updateMaxValue(): void;
                 /**
                  * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
                  */
                 setHeightValueAtIndex(xi: number, yi: number, value: number): void;
                 /**
                  * Get max/min in a rectangle in the matrix data
                  * @param result An array to store the results in.
                  * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
                  */
                 getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result?: number[]): void;
                 /**
                  * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
                  * @param result Two-element array
                  * @param clamp If the position should be clamped to the heightfield edge.
                  */
                 getIndexOfPosition(x: number, y: number, result: number[], clamp: boolean): boolean;
                 getTriangleAt(x: number, y: number, edgeClamp: boolean, a: Vec3, b: Vec3, c: Vec3): boolean;
                 getNormalAt(x: number, y: number, edgeClamp: boolean, result: Vec3): void;
                 /**
                  * Get an AABB of a square in the heightfield
                  * @param xi
                  * @param yi
                  * @param result
                  */
                 getAabbAtIndex(xi: number, yi: number, { lowerBound, upperBound }: AABB): void;
                 /**
                  * Get the height in the heightfield at a given position
                  */
                 getHeightAt(x: number, y: number, edgeClamp: boolean): number;
                 getCacheConvexTrianglePillarKey(xi: number, yi: number, getUpperTriangle: boolean): string;
                 getCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): HeightfieldPillar;
                 setCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean, convex: ConvexPolyhedron, offset: Vec3): void;
                 clearCachedConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;
                 /**
                  * Get a triangle from the heightfield
                  */
                 getTriangle(xi: number, yi: number, upper: boolean, a: Vec3, b: Vec3, c: Vec3): void;
                 /**
                  * Get a triangle in the terrain in the form of a triangular convex shape.
                  */
                 getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;
                 calculateLocalInertia(mass: number, target?: Vec3): Vec3;
                 volume(): number;
                 calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
                 updateBoundingSphereRadius(): void;
                 /**
                  * Sets the height values from an image. Currently only supported in browser.
                  */
                 setHeightsFromImage(image: HTMLImageElement, scale: Vec3): void;
             }

              type HeightfieldOptions = ConstructorParameters<typeof Heightfield>[1];

              type HeightfieldPillar = {
                 convex: any;
                 offset: any;
             };

             export  class HemisphereEmitter implements EmitterShape {
                 type: string;
                 radius: number;
                 arc: number;
                 thickness: number;
                 mode: EmitterMode;
                 spread: number;
                 speed: ValueGenerator | FunctionValueGenerator;
                 constructor(parameters?: HemisphereEmitterParameters);
                 private currentValue;
                 update(system: ParticleSystem, delta: number): void;
                 initialize(p: Particle, emissionState: EmissionState): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any): HemisphereEmitter;
                 clone(): EmitterShape;
             }

             /**
              * Interface representing the parameters for a hemisphere emitter.
              */
             export  interface HemisphereEmitterParameters {
                 /**
                  * The radius of the hemisphere.
                  */
                 radius?: number;
                 /**
                  * The arc of the hemisphere.
                  */
                 arc?: number;
                 /**
                  * The thickness of the hemisphere. 1 is a full hemisphere, 0 is a thin shell.
                  */
                 thickness?: number;
                 /**
                  * The mode of the emitter.
                  * {@link EmitterMode}
                  */
                 mode?: EmitterMode;
                 /**
                  * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
                  * {@link EmitterMode}
                  */
                 spread?: number;
                 /**
                  * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
                  * {@link EmitterMode}
                  */
                 speed?: ValueGenerator | FunctionValueGenerator;
             }

             /**
              * 
              * @param props
              */
             export  const highlightMaterial: (opts: HighlightMaterialOption) => any;

             export  interface HighlightMaterialOption {
                 material: Material | Material[];
                 highlightOpacity?: IUniformN;
                 highlightColor: IUniformColor;
             }

             /**
              * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
              */
              class HingeConstraint extends PointToPointConstraint {
                 /**
                  * Rotation axis, defined locally in bodyA.
                  */
                 axisA: Vec3;
                 /**
                  * Rotation axis, defined locally in bodyB.
                  */
                 axisB: Vec3;
                 rotationalEquation1: RotationalEquation;
                 rotationalEquation2: RotationalEquation;
                 motorEquation: RotationalMotorEquation;
                 constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                     /**
                      * A point defined locally in bodyA. This defines the offset of axisA.
                      */
                     pivotA?: Vec3;
                     /**
                      * A point defined locally in bodyB. This defines the offset of axisB.
                      */
                     pivotB?: Vec3;
                     /**
                      * An axis that bodyA can rotate around, defined locally in bodyA.
                      */
                     axisA?: Vec3;
                     /**
                      * An axis that bodyB can rotate around, defined locally in bodyB.
                      */
                     axisB?: Vec3;
                     /**
                      * Wheter to collide the connected bodies or not.
                      * @default false
                      */
                     collideConnected?: boolean;
                     /**
                      * The maximum force that should be applied to constrain the bodies.
                      * @default 1e6
                      */
                     maxForce?: number;
                 });
                 /**
                  * enableMotor
                  */
                 enableMotor(): void;
                 /**
                  * disableMotor
                  */
                 disableMotor(): void;
                 /**
                  * setMotorSpeed
                  */
                 setMotorSpeed(speed: number): void;
                 /**
                  * setMotorMaxForce
                  */
                 setMotorMaxForce(maxForce: number): void;
                 /**
                  * update
                  */
                 update(): void;
             }

              type HingeConstraintOptions = ConstructorParameters<typeof HingeConstraint>[2];

              interface HitPointInfo {
                 point: Vector3;
                 distance: number;
                 faceIndex: number;
             }

              interface HitTriangleInfo {
                 face: {
                     a: number;
                     b: number;
                     c: number;
                     materialIndex: number;
                     normal: Vector3;
                 };
                 uv: Vector2;
             }

              const HOLLOW_INTERSECTION: CSGOperation;

              const HOLLOW_SUBTRACTION: CSGOperation;

             export  class HolographicMaterial extends ShaderMaterial {
                 /**
                  * Create a HolographicMaterial.
                  *
                  * @param {Object} parameters - The parameters to configure the material.
                  * @param {number} [parameters.time=0.0] - The time uniform representing animation time.
                  * @param {number} [parameters.fresnelOpacity=1.0] - The opacity for the fresnel effect.
                  * @param {number} [parameters.fresnelAmount=1.0] - The strength of the fresnel effect.
                  * @param {number} [parameters.scanlineSize=15.0] - The size of the scanline effect.
                  * @param {number} [parameters.hologramBrightness=1.0] - The brightness of the hologram.
                  * @param {number} [parameters.signalSpeed=1.0] - The speed of the signal effect.
                  * @param {Color} [parameters.hologramColor=new Color('#00d5ff')] - The color of the hologram.
                  * @param {boolean} [parameters.enableBlinking=true] - Enable/disable blinking effect.
                  * @param {boolean} [parameters.blinkFresnelOnly=false] - Enable blinking only on the fresnel effect.
                  * @param {number} [parameters.hologramOpacity=1.0] - The opacity of the hologram.
                  * @param {number} [parameters.blendMode=NormalBlending] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
                  * @param {number} [parameters.side=FrontSide] - The rendering side. Use `THREE.FrontSide`, `THREE.BackSide`, or `THREE.DoubleSide`.
                  * @param {Boolean} [parameters.depthTest=true] - Enable or disable depthTest.
                  */
                 constructor(app: App, parameters?: {
                     /** The time uniform representing animation time. default 0 */
                     time?: number;
                     /** The opacity for the fresnel effect. default 1 */
                     fresnelOpacity?: number;
                     /** The strength of the fresnel effect. default 1 */
                     fresnelAmount?: number;
                     /** The size of the scanline effect. default 15 */
                     scanlineSize?: number;
                     /** The brightness of the hologram. default 1 */
                     hologramBrightness?: number;
                     /** The speed of the signal effect. default 1 */
                     signalSpeed?: number;
                     /**  The color of the hologram. default new Color('#00d5ff') */
                     hologramColor?: ColorRepresentation;
                     /** Enable/disable blinking effect. default true */
                     enableBlinking?: boolean;
                     /** Enable blinking only on the fresnel effect.. default false */
                     blinkFresnelOnly?: boolean;
                     /** The opacity of the hologram. default 1 */
                     hologramOpacity?: number;
                     /** The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`. default NormalBlending */
                     blendMode?: Blending;
                     /** The rendering side. Use `THREE.FrontSide`, `THREE.BackSide`, or `THREE.DoubleSide`.. default FrontSide */
                     side?: Side;
                     /** Enable or disable depthTest.. default true */
                     depthTest?: boolean;
                 });
             }

              class HoveredResult {
                 x: number;
                 y: number;
                 target: Displayable;
                 topTarget: Displayable;
                 constructor(x?: number, y?: number);
             }

             /**
              * A template literal tag that does nothing. Useful for syntax highlighting of HTML code.
              *
              * @example
              * ```js
              * const vertexShader = html`
              *    <div class="my-class">
              *        <p>Some text</p>
              *    </div>
              * `
              * ```
              * @category Template Literals
              */
             export  const html: (strings: any, ...rest: any[]) => string;

             /**
              * Renders an HTML string to a canvas. This is done by first embedding HTML into a svg and then rendering the svg to a canvas.
              * @param html - HTML string
              * @param style - CSS string
              * @param options - options for rendering the canvas
              * @returns HTML canvas element
              *
              * @category HTML To Image
              */
             export  function htmlToCanvas(html: string | Node, style: string, options: ImageCanvasOptions): Promise<HTMLCanvasElement>;

             /**
              * Renders an HTML string to a png. This is done by first embedding HTML into a svg and then rendering the svg to a png.
              * @param html
              * @param style
              * @param options
              * @returns png as data url
              *
              * @category HTML To Image
              */
             export  function htmlToPng(html: string, style: string, options: ImageCanvasOptions): Promise<string>;

             /**
              * Embeds an HTML string into a svg tag and converts to svg string or svg as data url
              * @param html - HTML string
              * @param style - CSS string
              * @param width - width of the svg
              * @param height - height of the svg
              * @param toDataUrl - if true, returns a data url, otherwise returns the svg string
              * @returns svg string or svg as data url
              *
              * @category HTML To Image
              */
             export  function htmlToSvg(html: string, style: string, { width, height }: {
                 width: number;
                 height: number;
             }, toDataUrl?: boolean): string;

             export  const httpHelper: {
                 configure: (opts: Partial<Config>) => void;
                 event: {
                     READY_STATE_CHANGE: string;
                     LOAD_START: string;
                     PROGRESS: string;
                     ABORT: string;
                     ERROR: string;
                     LOAD: string;
                     TIMEOUT: string;
                     LOAD_END: string;
                 };
                 methods: Methods;
                 rqeust: (args: Partial<Config>) => Promise<any>;
                 get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
                 put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 del: (url: string, args?: Partial<Config>) => Promise<any>;
                 options: (url: string, args?: Partial<Config>) => Promise<any>;
             };

             export  class HyperbolicHelicoidGeometry extends ParametricGeometry {
                 constructor(slices?: number, stacks?: number);
             }

             export  interface IAppModuleBase extends IModuleBase {
                 onAppBeforeUpdate?: (time: Time) => any;
                 onAppUpdate?: (time: Time) => any;
                 onAppAfterUpdate?: (time: Time) => any;
                 onAppBeforeRender?: (time: Time) => any;
                 onAppRender?: (time: Time) => any;
                 onAppAfterRender?: (time: Time) => any;
                 onAppBeforeAddEntity?: (obj: Entity) => any;
                 onAppAddEntity?: (obj: Entity) => any;
                 onAppBeforeRemoveObject?: (obj: Object3D) => any;
                 onAppRemoveObject?: (obj: Object3D) => any;
                 onAppBeforeRemoveEntity?: (ent: Entity) => any;
                 onAppRemoveEntity?: (ent: Entity) => any;
             }

             export  interface ICameraModule {
                 /** */
                 viewHelperEnable: boolean;
                 /**
                  * 
                  * @param position 
                  * @param lookAt 
                  * @param options 
                  */
                 setCameraLookAt: (position: Vector3, lookAt: Vector3, options?: boolean | Record<string, any>) => void;
             }

             export  interface ICommand {
                 app: App;
                 /**  */
                 owerScene?: Scene;
                 /**  */
                 autoExecute?: boolean;
                 callbacks?: ICommandCallback;
                 execute(): void;
                 undo(): void;
                 redo(): void;
             }

             export  interface ICommandCallback {
                 onExecute(): void;
                 onUndo(): void;
                 onRedo(): void;
             }

             export  interface ICommandModule {
                 readonly commandHistory: CommandHistory;
                 /**  */
                 clearCommands: () => void;
                 /**  */
                 executeCommand: (cmd: ICommand) => void;
                 /**  */
                 executeAllCommands: (cmds: ICommand[]) => void;
                 /**  */
                 executeManyCommands: (...cmds: ICommand[]) => void;
                 /**  */
                 addCommand: (cmd: ICommand) => void;
                 /**  */
                 addAllCommands: (cmds: ICommand[]) => void;
                 /**  */
                 addManyCommands: (...cmds: ICommand[]) => void;
                 /**  */
                 undo: () => any;
                 /**  */
                 redo: () => any;
             }

             /**
              * 
              */
             export  interface IComposeNewMap {
                 /** ID. */
                 mapid: string;
                 /** (). */
                 version?: string;
                 /** [x1,y1,x2,y2]  */
                 clipbounds?: [number, number, number, number];
                 /** falsetrue */
                 selByCrossing?: boolean;
                 /** (x,y,)*/
                 fourParameter?: [number, number, number, number];
                 /** false*/
                 isInverseFourParamter?: boolean;
                 /**  */
                 layers?: string[];
                 /** null */
                 layerPrefix?: string;
                 /**  */
                 layerSuffix?: string;
                 /**  */
                 savefilename?: string;
                 /** dwg */
                 purge?: boolean;
                 /**  true */
                 isRenameBlockNameIfExist?: boolean;
                 /**  false () */
                 isZoomExtents?: boolean;
                 /** CAD*CAD */
                 cadVersion?: string | "*" | "cad2000" | "cad2004" | "cad2007" | "cad2010" | "cad2013" | "cad2018";
             }

             /**
              * 
              */
             export  interface IConditionQueryFeatures extends IQueryBaseFeatures {
                 /** . */
                 condition: string;
                 /** . */
                 bounds?: [number, number, number, number];
                 /** . */
                 beginpos?: number;
                 /** ,realgeomfalse1.1geojsonrealgeomtruegeojson */
                 includegeom?: boolean;
                 /** geojson. includegeomincludegeom*/
                 realgeom?: boolean;
                 /** , true,falsefalse. (bounds)*/
                 isContains?: boolean;
             }

             export  type IControl = {
                 onAdd(app: App): HTMLElement;
                 onRemove(app: App): void;
                 getDefaultPosition?: () => ControlPosition | string;
             };

             export  interface ICoordSystemModule {
                 /**
                  * 
                  * @param x
                  * @param y
                  * @param opts (undefined false , true)    (-1  1 )  (xz)      
                  */
                 unproject: (x: number | Vector2, y?: number, opts?: UnProjectOpts) => Vector3 | undefined;
                 /**
                  *  unproject 
                  * @param x  x
                  * @param y y
                  * @param opts (false , true) "depth"    (-1  1 )  (xz)     
                  * @param retIntersectObject object
                  */
                 unprojectAsync: (x: number, y: number, opts?: UnProjectOpts | "depth", retIntersectObject?: {}) => Promise<Vector3 | undefined>;
                 /**
                  * 
                  */
                 project: (x: number | Vector3, y?: number, z?: number) => Vector2;
                 /**
                  * NDC
                  */
                 screenToNdc: (x: number | Vector2, y?: number) => Vector2;
                 /**
                  * NDC
                  */
                 ndcToScreen: (x: number | Vector2, y?: number) => Vector2;
                 /**
                  * 
                  */
                 centerOrigin: Vector3 | undefined;
                 /**
                  * x,y,z1
                  */
                 scaleOrigin: number | undefined;
             }

             /**
              * 
              */
             export  interface ICreateEntitiesGeomData {
                 /** . */
                 filedoc: string;
                 /** . */
                 mapBounds?: [number, number, number, number];
                 /** 1, */
                 renderAccuracy?: number;
                 /** ( true) */
                 excludeAttribute?: boolean;
                 /** zip( true) */
                 useZip?: boolean;
             }

             export  interface iCSMInternals<T extends MaterialConstructor> {
                 patchMap: iCSMPatchMap;
                 fragmentShader: string;
                 vertexShader: string;
                 cacheKey: (() => string) | undefined;
                 baseMaterial: T | InstanceType<T>;
                 instanceID: string;
                 type: string;
                 isAlreadyExtended: boolean;
                 cacheHash: string;
                 silent?: boolean;
             }

             export  type iCSMParams<T extends MaterialConstructor> = {
                 baseMaterial: T | InstanceType<T>;
                 vertexShader?: string;
                 fragmentShader?: string;
                 cacheKey?: () => string;
                 patchMap?: iCSMPatchMap;
                 silent?: boolean;
                 uniforms?: {
                     [key: string]: IUniform<any>;
                 };
             } & (MaterialParams<T> extends undefined ? any : MaterialParams<T>);

             export  interface iCSMPatchMap {
                 [keyword: string]: {
                     [toReplace: string]: string;
                 };
             }

             export  interface iCSMShader {
                 defines: string;
                 header: string;
                 main: string;
             }

             export  type iCSMUpdateParams<T extends MaterialConstructor> = Partial<Omit<iCSMParams<T>, 'baseMaterial'>>;

             export  interface ICSS2DRendererModule {
                 /** */
                 readonly css2dRenderer: CSS2DRenderer;
                 /**marker2d */
                 getMarker2Ds: () => Marker2D[];
                 /**popup2d */
                 getPopup2Ds: () => Popup2D[];
                 /** popup */
                 readonly popup2d: Popup2D;
             }

             export  interface ICSS3DRendererModule {
                 /**css3d */
                 readonly css3dRenderer: CSS3DRenderer;
                 /**css3d */
                 readonly css3dOccludeRenderer: CSS3DRenderer;
                 /** 3d */
                 setCss3dObjectCanOcclude: (object: CSS3DObject, canOcclude?: boolean) => void;
             }

             /**
              * Id
              *
              * https://tools.ietf.org/html/rfc7946#section-3.2
              * If a Feature has a commonly used identifier, that identifier SHOULD be included as a member of
              * the Feature object with the name 'id', and the value of this member is either a JSON string or number.
              */
              type Id = string | number;

             /**
              * 
              */
             export  interface IDeleteCache {
                 /** ID(mapid). */
                 mapid?: string;
                 /** (, "*"). */
                 version?: string;
                 /** . */
                 key?: string;
             }

             /**
              * 
              */
             export  interface IDeleteStyle {
                 /** ID(mapid). */
                 mapid?: string;
                 /** (, "*"). */
                 version?: string;
                 /** ."*"  "a*","m*"; "s*"*/
                 styleid: string;
                 /** , false ; true . */
                 onlycleardata: boolean;
             }

             /**
              * 
              */
              function identity(out: MatrixArray): MatrixArray;

             /**
              * Disposable interface for objects that can be disposed. Has a single method `dispose`
              */
             export  interface IDisposable {
                 dispose(): void;
             }

              class Idle extends StateNode {
                 static id: string;
             }

              class Idle_2 extends StateNode {
                 static id: string;
                 onPointerDown: (info: TLEventHandler) => void;
                 onEnter: () => void;
             }

              class Idle_3 extends StateNode {
                 static id: string;
                 info: TransformEnterOptions;
                 onPointerDownUp: (info: TLEventHandler) => void;
                 onEnter: (info: TransformEnterOptions) => void;
                 onKeyUp: (info: TLEventHandler) => void;
             }

              class Idle_4 extends StateNode {
                 static id: string;
                 info: PickEnterOptions;
                 onPointerDownUp: (info: TLEventHandler) => void;
                 onEnter: (info: PickEnterOptions) => void;
                 onKeyUp: (info: TLEventHandler) => void;
             }

             export  interface IDrawEditEnterOptions {
                 /**  */
                 queryEntities?: Entity[];
                 /**  */
                 editEntity?: Entity;
                 /**  */
                 editIndex?: number;
                 /** false */
                 editShowVertex?: boolean;
                 /** TransformControl(false,shift) */
                 useTransformControl?: boolean;
                 /** TransformControl(false,shift) */
                 useVertTransformControl?: boolean;
                 /**  */
                 dblClickExitEdit?: boolean;
                 /**   draw */
                 drawLayerName?: string;
                 /** div)  */
                 autoFocus?: boolean;
                 /**  true*/
                 onBeforeSelectEntity?: (info: InteractiveObject) => boolean;
                 /**  */
                 onBeginEditEntity?: (entity: Entity, entIndex?: number, faceIndex?: number) => void;
                 /**  */
                 onUnEditEntity?: (entity: Entity, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
                 /** true */
                 onBeforeDeleteEntity?: (entity: Entity, data: any) => boolean;
                 /**  */
                 onDeleteEntity?: (entity: Entity, data: any, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
                 /** true */
                 onBeforeMoveEntity?: (entity: Entity, data: any, offset: {
                     dx: number;
                     dy: number;
                     dz: number;
                 }) => boolean;
                 /**  */
                 onMoveEntity?: (entity: Entity, data: any, offset: {
                     dx: number;
                     dy: number;
                     dz: number;
                 }, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
                 /** true */
                 onBeforeMoveVertex?: (entity: Entity, data: any, newPoint: Vector3, entIndex: number, ptIndex: number) => boolean;
                 /**  */
                 onMoveVertex?: (entity: Entity, data: any, newPoint: Vector3, entIndex: number, ptIndex: number, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
                 /**  */
                 onComplete?: (info: TLEventType, from: string) => void;
                 /**  */
                 onKeyUp?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
                 /**  */
                 onContextMenu?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                 }) => void;
             }

             export  interface IDrawLineEnterOptions {
                 /**  */
                 color?: ColorRepresentation;
                 /** (0-1) */
                 opacity?: number;
                 /**   */
                 showVertex?: boolean;
                 /**  */
                 dashed?: boolean;
                 /**  */
                 lineWidth?: number;
                 /**  */
                 dashOffset?: number;
                 /**  */
                 dashScale?: number;
                 /**  */
                 dashSize?: number;
                 /**  */
                 gapSize?: number;
                 /** false */
                 isAddToApp?: boolean;
                 /** , */
                 isSnap?: boolean;
                 /** , */
                 snapDrawLayerPoint?: boolean;
                 /** , */
                 snapDrawPoint?: boolean;
                 /**  */
                 snapData?: [number, number, number][];
                 /** 0,  */
                 snapStylePointOpacity?: number;
                 /** 5 */
                 snapStylePixelSize?: number;
                 /**  */
                 pointMaxCount?: number;
                 /**  */
                 isClosed?: boolean;
                 /** unproject (undefined false , true)    (-1  1 )          depth */
                 unprojectOpts?: UnProjectOpts | "depth";
                 /**   false*/
                 disableUnProjectMenu?: boolean;
                 /**   draw */
                 drawLayerName?: string;
                 /** div)  */
                 autoFocus?: boolean;
                 /**   */
                 enterKeyComplete?: boolean;
                 /** esc  */
                 escKeyCancel?: boolean;
                 /** false */
                 isExitToDefaultTool?: boolean;
                 /** delete  */
                 deleteKeyDelPoint?: boolean;
                 /**  */
                 onKeyUp?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
                     delPoint: () => void;
                     /**  */
                     data: PolylineItemData;
                     /**  */
                     polylines: PolylinesEntity;
                 }) => void;
                 /**  */
                 onContextMenu?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
                     delPoint: () => void;
                     /**  */
                     data: PolylineItemData;
                     /**  */
                     polylines: PolylinesEntity;
                 }) => void;
                 /**  */
                 beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
                 /**  */
                 updateCoordinate?: (point: Vector3, isMoveing: boolean, data: PolylineItemData, polylines?: PolylinesEntity) => void;
                 /**  */
                 onComplete?: (isCancel: boolean, data: PolylineItemData) => void;
             }

             export  interface IDrawPointEnterOptions {
                 /**  */
                 color?: ColorRepresentation;
                 /**  */
                 borderColor?: ColorRepresentation;
                 /**  */
                 size?: number;
                 /** false */
                 isAddToApp?: boolean;
                 /** , */
                 isSnap?: boolean;
                 /** , */
                 snapDrawLayerPoint?: boolean;
                 /** , */
                 snapDrawPoint?: boolean;
                 /**  */
                 snapData?: [number, number, number][];
                 /** 0,  */
                 snapStylePointOpacity?: number;
                 /** 5 */
                 snapStylePixelSize?: number;
                 /** unproject (undefined false , true)    (-1  1 )          depth */
                 unprojectOpts?: UnProjectOpts | "depth";
                 /**   false*/
                 disableUnProjectMenu?: boolean;
                 /**   draw */
                 drawLayerName?: string;
                 /** div)  */
                 autoFocus?: boolean;
                 /** esc  */
                 escKeyCancel?: boolean;
                 /** false */
                 isExitToDefaultTool?: boolean;
                 /**  */
                 onKeyUp?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
                     /**  */
                     data: SymbolItemData;
                     /**  */
                     symbol: SymbolEntity;
                 }) => void;
                 /**  */
                 onContextMenu?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => Promise<void>;
                     /**  */
                     data: SymbolItemData;
                     /**  */
                     symbol: SymbolEntity;
                 }) => void;
                 /**  */
                 beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
                 /**  */
                 updateCoordinate?: (point: Vector3, isMoveing: boolean, data: SymbolItemData, symbol?: SymbolEntity) => void;
                 /**  */
                 onComplete?: (isCancel: boolean, data: SymbolItemData) => void; /**  false*/
                 /** false, */
                 onAddData?: (data: SymbolItemData) => boolean;
             }

             export  interface IDrawPolygonEnterOptions {
                 /**  */
                 color?: ColorRepresentation;
                 /** (0-1) */
                 opacity?: number;
                 /**  */
                 borderColor?: ColorRepresentation;
                 /**   */
                 showVertex?: boolean;
                 /**  */
                 dashed?: boolean;
                 /** false */
                 isAddToApp?: boolean;
                 /** , */
                 isSnap?: boolean;
                 /** , */
                 snapDrawLayerPoint?: boolean;
                 /** , */
                 snapDrawPoint?: boolean;
                 /**  */
                 snapData?: [number, number, number][];
                 /** 0,  */
                 snapStylePointOpacity?: number;
                 /** 5 */
                 snapStylePixelSize?: number;
                 /**  */
                 pointMaxCount?: number;
                 /**  */
                 showEdge?: boolean;
                 /**  */
                 edgeStyle?: PolylineItemData;
                 /** unproject (undefined false , true)    (-1  1 )          depth */
                 unprojectOpts?: UnProjectOpts | "depth";
                 /**   false*/
                 disableUnProjectMenu?: boolean;
                 /**   draw */
                 drawLayerName?: string;
                 /** div)  */
                 autoFocus?: boolean;
                 /**   */
                 enterKeyComplete?: boolean;
                 /** esc  */
                 escKeyCancel?: boolean;
                 /** false */
                 isExitToDefaultTool?: boolean;
                 /** delete  */
                 deleteKeyDelPoint?: boolean;
                 /**  */
                 onKeyUp?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => void;
                     delPoint: () => void;
                     /**  */
                     data: PolygonItemData;
                     /**  */
                     polygon: PolygonsEntity;
                 }) => void;
                 /**  */
                 onContextMenu?: (info: TLEventHandler, context: {
                     /**   */
                     complete: () => void;
                     /**  */
                     cancel: () => void;
                     addPoint: (worldPos: Vector3, info?: TLEventHandler, isSnapPoint?: boolean, snapData?: SymbolItemData[]) => void;
                     delPoint: () => void;
                     /**  */
                     data: PolygonItemData;
                     /**  */
                     polygon: PolygonsEntity;
                 }) => void;
                 /**  */
                 beforeUpdateCoordinate?: (point: Vector3, isMoveing: boolean, info: TLEventHandler, isSnapPoint?: boolean) => Promise<Vector3 | undefined>;
                 /**  */
                 updateCoordinate?: (point: Vector3, isMoveing: boolean, data: PolygonItemData, polygon?: PolygonsEntity) => void;
                 /**  */
                 onComplete?: (isCancel: boolean, data: PolygonItemData) => void;
             }

             export  interface IEntityManagerModule {
                 getEntities: () => Entity[];
                 getRayQueryEntities: () => Entity[];
                 addSelectedEntity: (ent: Entity) => {};
                 removeSelectEntity: (ent: Entity) => {};
                 getSelectObjects: () => Object3D[];
                 getSelectObjectsRef: () => ShallowReactive<Object3D[]>;
                 addBloomEntity: (ent: Entity) => {};
                 removeBloomEntity: (ent: Entity) => {};
                 getBloomObjects: () => Object3D[];
                 getBloomObjectsRef: () => ShallowReactive<Object3D[]>;
                 addOutlineEntity: (ent: Entity) => {};
                 removeOutlineEntity: (ent: Entity) => {};
                 getOutlineObjects: () => Object3D[];
                 getOutlineObjectsRef: () => ShallowReactive<Object3D[]>;
                 setSelectBoomRefreshFlag: () => void;
             }

             export  interface IEntityModuleBase extends IAppModuleBase {
                 onBeforeAdd?: () => any;
                 onAdd?: () => any;
                 onBeforeRemove?: () => any;
                 onRemove?: () => any;
                 onRayIntersect?: (ray: Raycaster) => Intersection[];
                 onMouseUp?: (event: InteractiveEvent) => any;
                 onMouseMove?: (event: InteractiveEvent) => any;
                 onMouseDown?: (event: InteractiveEvent) => any;
                 onMouseClick?: (event: InteractiveEvent) => any;
                 onMouseDblClick?: (event: InteractiveEvent) => any;
                 onMouseOver?: (event: InteractiveEvent) => any;
                 onMouseOut?: (event: InteractiveEvent) => any;
                 onMouseEnter?: (event: InteractiveEvent) => any;
                 onMouseLeave?: (event: InteractiveEvent) => any;
                 onPointerDown?: (event: InteractiveEvent) => any;
                 onPointerMove?: (event: InteractiveEvent) => any;
                 onPointerUp?: (event: InteractiveEvent) => any;
                 /**  */
                 onPointerDownUp?: (event: InteractiveEvent) => any;
                 onPointerCancel?: (event: InteractiveEvent) => any;
                 onMouseWheel?: (event: InteractiveEvent) => any;
                 onKeyDown?: (event: InteractiveEvent) => any;
                 onKeyUp?: (event: InteractiveEvent) => any;
                 setupUiConfig?: () => UiObjectConfig;
             }

             export  interface IEntityQueryModule {
                 /**
                  * 
                  */
                 queryEntitiesByCamera: (option?: EntityQueryOption) => InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByRaycast: (ray: Ray, option?: EntityQueryOption) => InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByScreenPos: (x: number, y: number, option?: EntityQueryOption) => InteractiveObject;
                 /**
                  * 
                  */
                 queryEntitiesByBox: (startPoint: Vector3, endPoint: Vector3, option?: EntityQueryOption, deep?: number) => InteractiveObject[];
                 /**
                  * 
                  */
                 getRayByScreenPos: (x: number, y: number, camera?: Camera) => Ray;
                 /**
                  * 
                  */
                 getQueryRaycaster: () => Raycaster;
             }

             /**
              * A simple event interface with typed event types.
              */
             export  interface IEvent<T> {
                 type: T;
                 target?: any;
                 [attachment: string]: any;
             }

             /**
              * A simple event dispatcher interface with {@link IEvent} as event type.
              */
             export  interface IEventDispatcher<T> {
                 /**
                  * Adds a listener to an event type.
                  * @param type The type of event to listen to.
                  * @param listener The function that gets called when the event is fired.
                  */
                 addEventListener(type: T, listener: (event: IEvent<T>) => void): void;
                 /**
                  * Checks if listener is added to an event type.
                  * @param type The type of event to listen to.
                  * @param listener The function that gets called when the event is fired.
                  */
                 hasEventListener(type: T, listener: (event: IEvent<T>) => void): boolean;
                 /**
                  * Removes a listener from an event type.
                  * @param type The type of the listener that gets removed.
                  * @param listener The listener function that gets removed.
                  */
                 removeEventListener(type: T, listener: (event: IEvent<T>) => void): void;
                 /**
                  * Fire an event type.
                  * @param event.type The type of event that gets fired.
                  */
                 dispatchEvent(event: IEvent<T>): void;
             }

             /**
              * dwg
              */
             export  interface IExportLayout {
                 /** ID. */
                 mapid: string;
                 /** (). */
                 version?: string;
                 /** layoutIndexlayoutNamelayoutIndexdwg. */
                 layoutIndex?: string;
                 /** . layoutIndexlayoutNamelayoutIndexdwg. */
                 layoutName?: string;
             }

             /**
              * 
              */
             export  interface IExprQueryFeatures extends IQueryBaseFeatures {
                 /** . */
                 expr: string;
                 /** . */
                 beginpos?: number;
             }

              type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;

             export  class IgnoreFailureBehavior extends AbstractDecoratorBehavior {
                 IgnoreFailureBehavior(): void;
                 /**
                  *
                  * @param {Behavior} source
                  * @return {IgnoreFailureBehavior}
                  */
                 static from(source: Behavior): IgnoreFailureBehavior;
                 tick(timeDelta: number): BehaviorStatus.Initial | BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Suspended | BehaviorStatus.Invalid;
             }

             export  interface IHasDataEntity extends Entity {
                 setData(data: any): void;
                 getData(): any;
             }

             export  interface IHasUpdate {
                 update(): void;
             }

             export  interface IInputModule {
                 addPointerEventsObject: (entity: Entity) => {};
                 removePointerEventsObject: (entity: Entity) => {};
                 /**
                  *  `contextMenuPreOpen`, `contextMenuOpened`, `contextMenuNoContent`
                  * @param menu 
                  * @param key setMenukeykeykeynullContextMenu
                  */
                 setMenu: (menu?: (event: InteractiveEvent | any, object?: InteractiveObject) => ContextMenu | null, key?: string) => void;
                 Input: {
                     /**  exam: getKeyDown("KeyW") */
                     getKeyDown: (keyCode: string) => boolean;
                     /**   Space Enter ShiftLeft */
                     getKeyPressed: (keyCode: string) => boolean;
                     /**  */
                     getKeyUp: (keyCode: string) => boolean;
                     x: () => number;
                     y: () => number;
                     movementX: () => number;
                     movementY: () => number;
                     isMoving: () => boolean;
                     isDragging: () => boolean;
                     isLeftButtonDown: () => boolean;
                     isLeftButtonPressed: () => boolean;
                     isLeftButtonUp: () => boolean;
                     isRightButtonDown: () => boolean;
                     isRightButtonPressed: () => boolean;
                     isRightButtonUp: () => boolean;
                     isMidButtonDown: () => boolean;
                     isMidButtonPressed: () => boolean;
                     isMidButtonUp: () => boolean;
                     enabled: () => boolean;
                     setEnable: (b: boolean) => {};
                     /**  */
                     enabledRef: () => Ref<boolean>;
                     /**  */
                     closestObject: () => InteractiveObject | undefined | null;
                 };
             }

             /**
              * Interface for objects that can be serialized to JSON, with to and from JSON methods
              */
             export  interface IJSONSerializable<T = any, TM = any> {
                 toJSON(meta?: TM): T;
                 fromJSON(data: T, meta?: TM): this | null | Promise<this | null>;
             }

             /**
              * 
              */
             export  interface ILoadModelOption {
                 /**  */
                 fileType?: string;
                 /** () */
                 useCache?: boolean;
                 /**  */
                 position?: [number, number, number] | Vector3;
                 /**  */
                 anchor?: Anchor3d;
                 /**  */
                 modelCenter?: Vector3;
                 /**  */
                 offset?: [number, number, number] | Vector3;
                 /**  */
                 size?: number;
                 /** sizesize */
                 scale?: [number, number, number] | Vector3 | number;
                 /**  */
                 rotation?: [number, number, number] | Vector3;
                 /**  */
                 splitSubEntity?: boolean;
                 /** (groupmesh)mesh false) splitSubEntityfalse */
                 autoAsMeshEntity?: boolean;
                 /**  */
                 onLoad?: (data: any) => any;
                 /**  */
                 toEntity?: boolean;
                 /** x90 xyxz) */
                 isMapMode?: boolean;
                 /** toEntity truegroup */
                 asEntityGroup?: boolean;
             }

             /**
              * Convert an image {@link ImageBitmap} or {@link CanvasImageSource} to a base64 data url.
              * @param bitmap - image to convert
              * @param maxWidth - maximum width of the image (default: 8192). Images larger than this will be scaled down. This is because strings can get too long.
              * @param detachBitmap - detach the bitmap after conversion (default: false). This will free up bitmap memory if you don't need it anymore.
              *
              * See also {@link imageUrlToImageData}
              *
              * @category Images
              */
             export  function imageBitmapToBase64(bitmap: ImageBitmap | CanvasImageSource, maxWidth?: number, detachBitmap?: boolean): string;

             /**
              * Options for {@link imageToCanvas}.
              */
             export  interface ImageCanvasOptions {
                 width: number;
                 height: number;
                 backgroundColor?: string;
                 scale?: number;
             }

             /**
              * Converts an {@link ImageData} to a canvas. This creates a new canvas element and draws the image data on it.
              * Image Data can be created from image pixels like from gl.readPixels
              * This can be used to convert a WebGL texture/render target to a canvas/data url.
              * Note: if the output is flipped, use {@link canvasFlipY} after this, like `canvasFlipY(imageDataToCanvas(imageData))`
              * @param data - image data to convert
              */
             export  function imageDataToCanvas(data: ImageData): HTMLCanvasElement;

              type ImageLike = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;

              interface ImagePatternObject extends PatternObjectBase {
                 image: ImageLike | string;
                 repeat?: ImagePatternRepeat;
                 /**
                  * Width and height of image.
                  * `imageWidth` and `imageHeight` are only used in svg-ssr renderer.
                  * Because we can't get the size of image in svg-ssr renderer.
                  * They need to be give explictly.
                  */
                 imageWidth?: number;
                 imageHeight?: number;
             }

              type ImagePatternRepeat = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';

              interface ImageProps extends DisplayableProps {
                 style?: ImageStyleProps;
                 onload?: (image: ImageLike) => void;
             }

              type ImageState = Pick<ImageProps, DisplayableStatePropNames> & ElementCommonState;

              interface ImageStyleProps extends CommonStyleProps {
                 image?: string | ImageLike;
                 x?: number;
                 y?: number;
                 width?: number;
                 height?: number;
                 sx?: number;
                 sy?: number;
                 sWidth?: number;
                 sHeight?: number;
             }

             /**
              * Converts an HTML image to a canvas. This creates a new canvas element and draws the image on it.
              * @param image - image to convert
              * @param backgroundColor - background color of the canvas
              * @param scale - scale of the canvas
              * @param width - width of the canvas
              * @param height - height of the canvas
              * @returns a new canvas element
              *
              * @category Images
              */
             export  function imageToCanvas(image: HTMLImageElement, { backgroundColor, scale, width, height }: ImageCanvasOptions): HTMLCanvasElement;

             /**
              * Downloads/parse the image from an url/data url and draw to an {@link ImageData} object.
              * @param url - url or data url of the image
              * @returns ImageData object
              *
              * See also {@link imageBitmapToBase64}
              *
              * @category Images
              */
             export  function imageUrlToImageData(url: string): Promise<ImageData>;

             /**
              * 
              */
             export  interface IMapDiff {
                 /** ID. */
                 mapid1: string;
                 /** (). */
                 version1?: string;
                 /** . */
                 layer1?: string;
                 /** ID. */
                 mapid2: string;
                 /** (). */
                 version2?: string;
                 /** . */
                 layer2?: string;
                 /** . */
                 noCompareNew?: boolean;
                 /** . */
                 noCompareDelete?: boolean;
                 /** . */
                 size?: number;
                 /** . */
                 cellsize?: number;
                 /** . */
                 diffMinPixel?: number;
                 /** . */
                 diffMinAlpha?: number;
                 /** . */
                 diffMinColor?: number;
             }

             /**
              * 
              */
             export  interface IMapLayer {
                 /** . */
                 name: string;
                 /** . */
                 color: string;
                 /** . */
                 index: number;
                 /** . */
                 isFrozen: boolean;
                 /** . */
                 isLocked: boolean;
                 /** . */
                 isOff: boolean;
                 /** . */
                 lineWeight: number;
                 /** . */
                 linetype: number;
             }

             /**
              * 
              */
             export  interface IMapStyleParam {
                 /** . */
                 name?: string;
                 /** [0,1,3]. */
                 layeron?: string | number[];
                 /** [2,4]. layeronlayeroff*/
                 layeroff?: string | number[];
                 /** [x1,y1,x2,y2]. */
                 clipbounds?: [number, number, number, number] | number;
                 /** . */
                 backcolor?: number;
                 /** [11110].123455 */
                 lineweight?: string | number[];
                 /** . */
                 expression?: string;
             }

             /**
              * 
              */
             export  interface IMatchObject {
                 /** ID. */
                 mapid: string;
                 /** (). */
                 version?: string;
                 /** . */
                 layer?: string;
                 /** . */
                 mapBounds?: string;
                 /** objectid||. */
                 objectIds?: string;
                 /**  */
                 objectBounds: string;
                 /**  */
                 layeron?: string;
                 /** 10000 */
                 size?: number;
                 /** .  matchPattern */
                 method?: "matchTemplate" | "matchPattern";
                 /** .  200 */
                 maxCount?: number;
                 /**  (0 -1) 0.6 . */
                 score?: number;
                 /**  (64-2048).256 matchPattern*/
                 minReduceArea?: number;
                 /**  (false). */
                 canOverlap?: boolean;
                 /**  (0-0.8) 0.3. */
                 maxOverlap?: number;
                 /** (-180, 180)matchPattern. 180*/
                 toleranceAngle?: number;
                 /** ,false. matchPattern*/
                 useToleranceRange?: boolean;
                 /** 1. matchPattern*/
                 tolerance1?: number;
                 /** 1. matchPattern*/
                 tolerance2?: number;
                 /** 2. matchPattern*/
                 tolerance3?: number;
                 /** 2. matchPattern*/
                 tolerance4?: number;
             }

             export  const iMaterialUI: {
                 base: (material: any) => UiObjectConfig[];
                 blending: (material: any) => UiObjectConfig;
                 polygonOffset: (material: any) => UiObjectConfig;
                 aoLightMap: (material: any) => UiObjectConfig;
                 misc: (material: any) => UiObjectConfig[];
                 roughMetal: (material: any) => UiObjectConfig;
                 bumpNormal: (material: any) => UiObjectConfig;
                 emission: (material: any) => UiObjectConfig;
                 transmission: (material: any) => UiObjectConfig;
                 clearcoat: (material: any) => UiObjectConfig;
                 iridescence: (material: any) => UiObjectConfig;
                 sheen: (material: any) => UiObjectConfig;
             };

             export  interface IModuleBase {
                 onAwake?: (app?: any) => any;
                 onEnable?: () => any;
                 onDisable?: () => any;
                 onDestroy?: () => any;
                 [key: string]: any;
             }

             /**
              * Returns true if the array includes all the elements of the sub array
              * @param arr
              * @param subArr
              */
             export  function includesAll(arr: any[], subArr: IterableIterator<any>): boolean;

              class IncrementalDisplayable extends Displayable {
                 notClear: boolean;
                 incremental: boolean;
                 private _displayables;
                 private _temporaryDisplayables;
                 private _cursor;
                 traverse<T>(cb: (this: T, el: this) => void, context: T): void;
                 useStyle(): void;
                 getCursor(): number;
                 innerAfterBrush(): void;
                 clearDisplaybles(): void;
                 clearTemporalDisplayables(): void;
                 addDisplayable(displayable: Displayable, notPersistent?: boolean): void;
                 addDisplayables(displayables: Displayable[], notPersistent?: boolean): void;
                 getDisplayables(): Displayable[];
                 getTemporalDisplayables(): Displayable[];
                 eachPendingDisplayable(cb: (displayable: Displayable) => void): void;
                 update(): void;
                 getBoundingRect(): BoundingRect;
                 contain(x: number, y: number): boolean;
             }

             /**
              * index
              */
              function indexOf<T>(array: T[] | readonly T[] | ArrayLike_2<T>, value: T): number;

              interface IndividualDelay {
                 (index: number, count: number, fromPath: Path, toPath: Path): number;
             }

             export  function infinityToMaxNumber(value: number): number;

             /**
              * 
              *
              * @param clazz 
              * @param baseClazz 
              */
              function inherits(clazz: Function, baseClazz: Function): void;

             /**
              * Initializing a render2d instance
              *
              * @param dom Not necessary if using SSR painter like svg-ssr
              */
              function init(dom?: HTMLElement | null, opts?: Render2DInitOpt): Render2D;

              class InputImpl {
                 manager: InteractionManager;
                 constructor(manager?: InteractionManager);
                 getKeyDown(keyCode: any): boolean;
                 getKeyPressed(keyCode: any): boolean;
                 getKeyUp(keyCode: any): boolean;
                 x(): number;
                 y(): number;
                 movementX(): number;
                 movementY(): number;
                 isMoving(): boolean;
                 isDragging(): boolean;
                 isLeftButtonDown(): boolean;
                 isLeftButtonPressed(): boolean;
                 isLeftButtonUp(): boolean;
                 isRightButtonDown(): boolean;
                 isRightButtonPressed(): boolean;
                 isRightButtonUp(): boolean;
                 isMidButtonDown(): boolean;
                 isMidButtonPressed(): boolean;
                 isMidButtonUp(): boolean;
                 enabled(): boolean;
                 setEnable(b: any): any;
                 enabledRef(): Ref<boolean>;
                 closestObject(): InteractiveObject;
             }

             export  class InputModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: InputModuleOptions;
                 manager: InteractionManager;
                 constructor(app?: App, options?: InputModuleOptions);
                 setupUiConfig(): UiObjectConfig;
                 addPointerEventsObject(entity: Entity): void;
                 removePointerEventsObject(entity: Entity): void;
                 onAwake(): void;
                 get Input(): InputImpl;
                 onAppAfterRender(): void;
                 onAppAddEntity(ent: Entity): void;
                 onAppRemoveEntity(ent: Entity): void;
                 /**
                  *  `contextMenuPreOpen`, `contextMenuOpened`, `contextMenuNoContent`
                  * @param menu 
                  * @param key setMenukeykeykeynullContextMenu
                  */
                 setMenu(menu?: (event: InteractiveEvent, object?: InteractiveObject) => ContextMenu | null | undefined, key?: string): void;
             }

             export  interface InputModuleOptions {
                 /** Bodymousemove  false */
                 bindEventsOnBodyElement?: boolean;
                 clickTolerance?: number;
                 /**  */
                 interactiveMapObject?: any;
                 /** class  mapstopprop*/
                 stopPropagationClassList?: string[];
                 /** 3000ms0  */
                 longTouchMillSecond?: number;
             }

             /**
              * mesh
              */
             export  class InstancedMeshEntity extends Entity {
                 /**
                  * id
                  */
                 addInstance: (opts: {
                     id: string;
                     position?: Vector3;
                     rotation?: Vector3;
                     scale?: number | Vector3;
                     color?: Color;
                     computeBoundingSphere?: boolean;
                 }) => string;
                 /**
                  * idid
                  */
                 setInstance: (opts: {
                     id: string;
                     position?: Vector3 | null;
                     rotation?: Vector3 | null;
                     scale?: number | Vector3 | null;
                     color?: Color | null;
                     computeBoundingSphere?: boolean;
                 }) => string;
                 /**
                  * id
                  */
                 removeInstance: (id: string, computeBoundingSphere?: boolean) => void;
                 /**
                  * mesh
                  */
                 getInstancedMeshList: () => DynamicInstancedMesh[];
                 /**
                  * 
                  */
                 getGroup: () => Object3D;
                 /**
                  * id
                  */
                 getIdByIndex: (index: number) => string;
                 /**
                  * id
                  */
                 getIndexById: (id: string) => number;
                 /**
                  * 
                  * @param id id
                  * @param highlightColor null
                  * @returns
                  */
                 setInstanceHighlight: (id: string, highlightColor?: ColorRepresentation) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isInstanceHighlight: (id: string) => boolean;
                 /**
                  * 
                  * @param id id
                  */
                 clearInstanceHighlight: () => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 getInstanceAttr: (id: string, key: string) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 setInstanceAttr: (id: string, key: string, value: any) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 getInstanceBox3: (id: string) => Box3 | null;
                 /**
                  * 
                  */
                 setInstanceSelected: (id: string, isSelected?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  */
                 isInstanceSelected: (id: string) => boolean;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 clearInstanceSelected: () => void;
                 /**
                  * 
                  */
                 setInstanceBloom: (id: string, isSelected?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  */
                 isInstanceBloom: (id: string) => boolean;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 clearInstanceBloom: () => void;
                 /**
                  * 
                  */
                 setInstanceOutline: (id: string, isSelected?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  */
                 isInstanceOutline: (id: string) => boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearInstanceOutline: () => void;
                 constructor(options: InstancedMeshEntityOptions);
                 /**
                  * 
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
             }

             export  type InstancedMeshEntityOptions = EntityOptions & InstancedMeshModuleOption;

             /**
              * mesh
              */
             export  class InstancedMeshModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 meshList: Mesh[];
                 uuidList: string[];
                 matrixWorldList: Matrix4[];
                 instancedMeshList: DynamicInstancedMesh[];
                 instConfig: Record<string, {
                     position?: Vector3;
                     rotation?: Vector3;
                     scale?: number | Vector3;
                     color?: Color;
                     isSelected?: boolean;
                     isBloom?: boolean;
                     isHighlight?: boolean;
                     isOutline?: boolean;
                 }>;
                 idIndexMap: BidirectionalMap;
                 onInstanceTransformChangedSignal: Signal;
                 constructor(entity: Entity, options?: InstancedMeshModuleOption);
                 /**
                  * id
                  * @returns
                  */
                 addInstance(opts: {
                     id: string;
                     position?: Vector3;
                     rotation?: Vector3;
                     scale?: number | Vector3;
                     color?: Color;
                     computeBoundingSphere?: boolean;
                 }): any;
                 /**
                  * idid
                  * @returns
                  */
                 setInstance(opts: {
                     id: string;
                     position?: Vector3 | null;
                     rotation?: Vector3 | null;
                     scale?: number | Vector3 | null;
                     color?: Color | null;
                     computeBoundingSphere?: boolean;
                 }): any;
                 /**
                  * id
                  * @returns
                  */
                 removeInstance(id: string, computeBoundingSphere?: boolean): void;
                 /**
                  * mesh
                  * @returns
                  */
                 getInstancedMeshList(): DynamicInstancedMesh[];
                 /**
                  * 
                  * @returns
                  */
                 getGroup(): Group_2<Object3DEventMap>;
                 /**
                  * id
                  * @returns
                  */
                 getIdByIndex(index: number): string;
                 /**
                  * id
                  * @returns
                  */
                 getIndexById(id: string): number;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 setInstanceSelected(id: string, isSelected?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isInstanceSelected(id: string): any;
                 /**
                  * 
                  * @returns
                  */
                 clearInstanceSelected(): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 setInstanceBloom(id: string, isBloom?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 setInstanceOutline(id: string, isOutline?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 clearInstanceOutline(): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isInstanceBloom(id: string): any;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isInstanceOutline(id: string): any;
                 /**
                  * 
                  * @returns
                  */
                 clearInstanceBloom(): void;
                 /**
                  * 
                  * @param id id
                  * @param highlightColor null
                  * @returns
                  */
                 setInstanceHighlight(id: string, highlightColor?: ColorRepresentation): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isInstanceHighlight(id: string): any;
                 /**
                  * 
                  * @returns
                  */
                 clearInstanceHighlight(): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 getInstanceAttr(id: string, key: string): any;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 setInstanceAttr(id: string, key: string, value: any): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 getInstanceBox3(id: string): Box3;
             }

             export  interface InstancedMeshModuleOption {
                 mesh: Mesh | Group_2;
                 maxCapacity?: number;
                 instances: {
                     id?: string;
                     position?: Vector3;
                     rotation?: Vector3;
                     scale?: number | Vector3;
                     color?: Color;
                     [key: string]: any;
                 }[];
             }

              class InteractionManager {
                 #private;
                 renderer: Renderer;
                 camera: Camera;
                 domElement: HTMLElement;
                 cameraControl: CameraControls;
                 app: App;
                 interactiveMapObject: any;
                 bindEventsOnBodyElement: boolean;
                 autoAdd: boolean;
                 mouse: Vector2;
                 supportsPointerEvents: boolean;
                 allInteractiveObjects: InteractiveObject[];
                 interactiveObjects: InteractiveObject[];
                 closestObject: InteractiveObject | null;
                 raycaster: Raycaster;
                 treatTouchEventsAsMouseEvents: boolean;
                 upKeys: Record<string, boolean>;
                 downKeys: Record<string, boolean>;
                 pressedKeys: Record<string, boolean>;
                 constructor(app: App, renderer: Renderer, camera: Camera, domElement: HTMLElement, interactiveMapObject?: any, cameraControl?: CameraControls, options?: InteractionManagerOptions);
                 dispose: () => void;
                 add: (object: Entity) => void;
                 remove: (object: Entity) => void;
                 updateInteractiveObjects(): void;
                 _onRemoveScene(scene: any): void;
                 update: () => void;
                 onDocumentMouseMove: (mouseEvent: MouseEvent) => void;
                 onDocumentPointerMove: (pointerEvent: PointerEvent) => void;
                 onTouchMove: (touchEvent: TouchEvent) => void;
                 onMouseClick: (mouseEvent: MouseEvent) => void;
                 onMouseDblClick: (mouseEvent: MouseEvent) => void;
                 onMouseDown: (mouseEvent: MouseEvent) => void;
                 onContextMenu: (mouseEvent: MouseEvent) => void;
                 onPointerDown: (pointerEvent: PointerEvent) => void;
                 onPointerCancel: (pointerEvent: PointerEvent) => void;
                 onTouchStart: (touchEvent: TouchEvent) => void;
                 onMouseUp: (mouseEvent: MouseEvent) => void;
                 onMouseWheel: (mouseEvent: MouseEvent) => void;
                 onKeyDown: (keyboradEvent: KeyboardEvent) => void;
                 onKeyUp: (keyboradEvent: KeyboardEvent) => void;
                 onPointerUp: (pointerEvent: PointerEvent) => void;
                 onTouchEnd: (touchEvent: TouchEvent) => void;
                 dispatch: (object: InteractiveObject, event: InteractiveEvent) => void;
                 sendEvent(object: InteractiveObject, event: InteractiveEvent): void;
                 mapPositionToPoint: (point: Vector2, x: number, y: number) => void;
                 setMouseMovement(evt: any): void;
                 resetMouseMovement(): void;
                 get x(): number;
                 get y(): number;
                 get movementX(): number;
                 get movementY(): number;
                 get isMoving(): boolean;
                 get isDragging(): boolean;
                 get isLeftButtonDown(): boolean;
                 get isLeftButtonPressed(): boolean;
                 get isLeftButtonUp(): boolean;
                 get isRightButtonDown(): boolean;
                 get isRightButtonPressed(): boolean;
                 get isRightButtonUp(): boolean;
                 get isMidButtonDown(): boolean;
                 get isMidButtonPressed(): boolean;
                 get isMidButtonUp(): boolean;
                 get buttonDown(): any;
                 get buttonPressed(): boolean;
                 get buttonUp(): any;
                 get enabled(): boolean;
                 set enabled(value: boolean);
                 get enabledRef(): Ref<boolean>;
             }

              class InteractionManagerOptions {
                 bindEventsOnBodyElement: boolean;
                 clickTolerance?: number;
                 /** class  mapstopprop*/
                 stopPropagationClassList?: string[];
                 /** 3000ms0  */
                 longTouchMillSecond?: number;
                 constructor(options: {
                     bindEventsOnBodyElement?: boolean | undefined;
                     clickTolerance?: number;
                     stopPropagationClassList?: string[];
                 });
             }

             export  class InteractiveEvent {
                 type: string;
                 cancelBubble: boolean;
                 originalEvent: Event | null | MouseEvent;
                 /**  */
                 originMapEvent?: {
                     lngLat: {
                         lng: number;
                         lat: number;
                     };
                     originalEvent: Event | null;
                     point: {
                         x: number;
                         y: number;
                     };
                     target: any;
                     type: string;
                 };
                 coords: Vector2;
                 distance: number;
                 intersected: boolean;
                 entity: Entity;
                 intersection?: Intersection;
                 [key: string]: any;
                 constructor(type: string, originalEvent?: Event | null, originMapEvent?: any);
                 stopPropagation(): void;
             }

             export  class InteractiveObject {
                 target: Entity;
                 intersected?: boolean;
                 wasIntersected?: boolean;
                 distance?: number;
                 intersection?: Intersection;
                 constructor(target: Entity);
             }

              function interleaveAttributes(attributes: BufferAttribute[]): InterleavedBufferAttribute;

             /**
              * (0-1)
              * @param points 
              * @param ratio 
              * @param options 
              */
             export  function interpolatePointsByRatio(points: Array<[number, number, number]>, ratio: number, options?: {
                 nextPoint?: [number, number, number];
                 remainingPoints?: [number, number, number][];
                 curRetIndex?: number;
                 distance?: number;
                 segmentDist?: number[];
             }): [number, number, number][];

             /**  */
             export  class Interpolation {
                 options: InterpolationOptions;
                 variogram: any;
                 constructor(options: InterpolationOptions);
                 invDist(x: number, y: number, z: number): number;
                 /**  */
                 predict(x: number, y: number, z: number): number;
                 /**  */
                 predicts(data: {
                     x: number;
                     y: number;
                     z: number;
                 }[]): number[];
                 variance(x: number, y: number, z: number): number;
                 /**
                  * search array max value
                  * @param source
                  */
                 max(source: number[]): number;
                 /**
                  * search array min value
                  * @param source
                  */
                 min(source: number[]): number;
                 /**
                  * get mean value from array number
                  * @param source
                  */
                 mean(source: number[]): number;
                 /**
                  * fill array with number
                  * @param source
                  * @param n
                  */
                 rep(source: number, n: number): number[];
                 matrixDiag(c: number, n: number): number[];
                 matrixTranspose(X: any[], n: number, m: number): any[];
                 matrixAdd(X: number[], Y: number[], n: number, m: number): number[];
                 matrixMultiply(X: number[], Y: number[], n: number, m: number, p: number): number[];
                 matrixChol(X: number[], n: number): boolean;
                 matrixChol2inv(X: number[], n: number): void;
                 matrixSolve(X: number[], n: number): boolean;
                 variogramGaussian(h: number, nugget: number, range: number, sill: number, A: number): number;
                 variogramExponential(h: number, nugget: number, range: number, sill: number, A: number): number;
                 variogramSpherical(h: number, nugget: number, range: number, sill: number): number;
                 variogramCircle(h: number, nugget: number, range: number, sill: number): number;
                 variogramLinear(h: number, nugget: number, range: number, sill: number): number;
                 train(t: number[], x: number[], y: number[], z: number[], model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear", sigma2?: any, alpha?: number): {
                     t: number[];
                     x: number[];
                     y: number[];
                     z: number[];
                     nugget: number;
                     range: number;
                     sill: number;
                     A: number;
                     n: number;
                     model: (h: number, nugget: number, range: number, sill: number, A: number) => number;
                     K: any[];
                     M: any[];
                 };
                 _predict(x: number, y: number, z: number, variogram: {
                     n: number;
                     model: (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any) => void;
                     x: number[];
                     y: number[];
                     z: number[];
                     nugget: any;
                     range: any;
                     sill: any;
                     A: any;
                     M: number[];
                 }): number;
                 _variance(x: number, y: number, z: number, variogram: {
                     n: number;
                     model: {
                         (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any): void;
                         (arg0: number, arg1: any, arg2: any, arg3: any, arg4: any): number;
                     };
                     x: number[];
                     y: number[];
                     z: number[];
                     nugget: any;
                     range: any;
                     sill: any;
                     A: any;
                     K: number[];
                 }): any;
             }

             export  interface InterpolationOptions {
                 /**  */
                 t: number[];
                 /** x */
                 x: number[];
                 /** y */
                 y: number[];
                 /** z */
                 z: number[];
                 /**  */
                 useInvDistWeight?: boolean;
                 /**  2 */
                 power?: number;
                 /**  */
                 model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
                 /** sigma2z 0  */
                 sigma2?: number;
                 /** Alpha ,,100 */
                 alpha?: number;
             }

             export  class Interpreter extends BaseCompiler {
                 constructor();
                 private executeCompiledGraph;
                 run(graph: NodeGraph, context: ExecutionContext): void;
                 build(graph: NodeGraph, context: ExecutionContext): string;
             }

              const INTERSECTED: ShapecastIntersection;

              const INTERSECTION: CSGOperation;

             /**
              * 
              * @param p1
              * @param p2
              * @param p3
              * @param p4
              * @param epsilon
              * @returns
              */
             export  const intersectLine3D: (p1: any, p2: any, p3: any, p4: any, epsilon: any) => Vector3[];

             export  class IntervalValue implements ValueGenerator {
                 a: number;
                 b: number;
                 constructor(a: number, b: number);
                 genValue(): number;
                 type: 'value';
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): IntervalValue;
                 clone(): ValueGenerator;
             }

             /**
              * 
              */
              function invert(out: MatrixArray, a: MatrixArray): MatrixArray | null;

             /**
              * Inverts result of the source behavior, success becomes failure, failure becomes success
              */
             export  class InvertStatusBehavior extends AbstractDecoratorBehavior {
                 /**
                  *
                  * @param {Behavior} source
                  */
                 constructor(source: Behavior);
                 /**
                  *
                  * @param {Behavior} source
                  * @return {InvertStatusBehavior}
                  */
                 static from(source: Behavior): InvertStatusBehavior;
                 tick(timeDelta: number): BehaviorStatus;
             }

             /**
              * 
              */
             export  interface IOpenMapBaseParam {
                 /** ID. */
                 mapid: string;
                 /** (: GeomRender) . */
                 mapopenway?: MapOpenWay;
                 /** ID. IDfileid */
                 fileid?: string;
                 /** . */
                 filedoc?: string;
                 /** . */
                 filename?: string;
                 /** . */
                 uploadname?: string;
                 /** (). */
                 secretKey?: string;
                 /** keysecretKey. */
                 accessKey?: string;
                 /** . */
                 cbInputPassword?: (param: {
                     mapid: string;
                     isPasswordError: boolean;
                     tryPasswordCount: number;
                     result: any;
                 }) => Promise<string>;
                 /** . */
                 mapfrom?: string;
                 /** . */
                 mapdependencies?: string;
                 /** (mapfrom.mapfrom */
                 subfrom?: string;
                 /** (mapdependencies.mapdependencies  */
                 subdependencies?: string;
                 /** 1, */
                 renderAccuracy?: number;
                 /** . */
                 style?: IMapStyleParam;
                 /** . */
                 notUseDefaultTtfFont?: boolean;
                 /** . */
                 notUseDefaultShxFont?: boolean;
                 /** . */
                 notReplaceLineType?: boolean;
                 /** . openMapfindFontsfontReplaceRule: {"tssdeng.shx_1": "_default_.ttc"}*/
                 fontReplaceRule?: Record<string, string> | string;
                 /** x */
                 imageLeft?: number;
                 /** y */
                 imageTop?: number;
                 /**  ,   /  */
                 imageResolution?: number;
                 /**  5s  */
                 openFinishTryInterval?: number;
                 /**  120  */
                 openFinishMaxTryCount?: number;
                 /** fileDoc */
                 cadVersion?: string;
                 /** post (get)*/
                 httpUsePost?: boolean;
                 /** 3d ()*/
                 open3dview?: boolean;
                 /**  */
                 extData?: Record<string, any>;
             }

             /**
              * 
              */
             export  interface IOpenMapParam extends IOpenMapBaseParam {
                 /** (: "" ). */
                 version?: string;
                 /**  */
                 layer?: string;
                 /**  (1)0 */
                 layoutIndex?: number;
             }

             /**
              * 
              */
             export  interface IOpenMapResponse {
                 /** ID. */
                 mapid?: string;
                 /** (: "" ). */
                 version?: string;
                 /**  */
                 layer?: string;
                 /** (: GeomRender) . */
                 mapopenway?: MapOpenWay;
                 /** DbID. */
                 dbid?: string;
                 /** ID. */
                 fileid?: string;
                 /** . */
                 filename?: string;
                 /** (clipBoundsclipBounds). */
                 bounds?: GeoBounds;
                 /** (clipBounds,). */
                 mapBounds?: GeoBounds;
                 /** */
                 dbBounds?: GeoBounds;
                 /** cmdGetDrawBounds*/
                 drawBounds?: GeoBounds;
                 /** . */
                 styles?: any;
                 /** . */
                 layers?: any;
                 /** . cadimage */
                 maptype?: string;
                 /** . */
                 status?: string;
                 /** (). */
                 darkMode?: boolean;
                 /** . */
                 type?: string;
                 /** ucs. */
                 ucsorg?: string;
                 /** . */
                 uploadname?: string;
                 /** . */
                 description?: string;
                 /** . */
                 lineWidthDisplay?: boolean;
                 /** . */
                 layouts?: string[];
                 /** . */
                 mapfrom?: string;
                 /** . */
                 mapdependencies?: string;
                 /** (mapfrom.mapfrom */
                 subfrom?: string;
                 /** (mapdependencies.mapdependencies  */
                 subdependencies?: string;
                 /** 1, */
                 renderAccuracy?: number;
                 /** bounds * initViewScale = dbBounds */
                 initViewScale?: number;
                 /** . */
                 view?: {
                     /** . */
                     center?: [number, number];
                     /** . */
                     zoom?: number;
                     /** . */
                     bearing?: number;
                 };
                 /**  */
                 maxzoom?: number;
                 /**  */
                 imageWidth?: number;
                 /**  */
                 imageHeight?: number;
                 /** x */
                 imageLeft?: number;
                 /** y */
                 imageTop?: number;
                 /**     /  */
                 imageResolution?: number;
                 /** 3d */
                 isMap3d?: boolean;
                 /**  */
                 createTime?: string;
                 /**  */
                 geomRecordCount?: string;
             }

             export  interface IOrbitControlModule {
                 /**  */
                 readonly cameraControl: CameraControls;
                 /**  */
                 enableCameraControl: boolean;
                 /**  */
                 enableCameraControlRef: Ref<boolean>;
                 /**  */
                 enableWheelWhenCtrlDisabled: boolean;
             }

             export  interface IParticle {
                 /**
                  * Position of the particle.
                  * @type {Vector3}
                  */
                 position: Vector3;
                 /**
                  * Velocity of the particle.
                  * @type {Vector3}
                  */
                 velocity: Vector3;
                 /**
                  * Age of the particle.
                  * @type {number}
                  */
                 age: number;
                 /**
                  * Life duration of the particle.
                  * @type {number}
                  */
                 life: number;
                 /**
                  * Size of the particle.
                  * @type {number}
                  */
                 size: number;
                 /**
                  * Rotation of the particle.
                  * @type {number | Quaternion}
                  */
                 rotation?: number | Quaternion;
                 /**
                  * UV tile index.
                  * @type {number}
                  */
                 uvTile: number;
                 /**
                  * Color of the particle.
                  * @type {Vector4}
                  */
                 color: Vector4;
                 /**
                  * Indicates if the particle has died.
                  * @type {boolean}
                  */
                 get died(): boolean;
             }

             export  interface IParticleRenderModule {
                 readonly particleRenderer: BatchedRenderer;
                 /**
                  *  
                  * @param system   
                  * @param parent  parent nullundefinedparentparent
                  * @param disposeWhenEnd true
                  * @returns
                  */
                 addParticleSystem: (system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean) => void;
                 /**  */
                 addParticle: (opts: {
                     /**  */
                     system: ParticleSystemParameters;
                     /**   */
                     simulations?: Simulation | Simulation[];
                     /**   */
                     name?: string;
                     /**   */
                     position?: Vector3 | [number, number, number];
                     /**  */
                     rotation?: Vector3 | [number, number, number];
                     /**  */
                     scale?: Vector3 | [number, number, number] | number;
                     /** parent nullundefinedparentparent */
                     parent?: Object3D;
                     /** true */
                     disposeWhenEnd?: boolean;
                 }) => ParticleEmitter<Object3DEventMap>;
                 /**  */
                 loadParticle: (url: string, opts?: {
                     /**  */
                     system?: ParticleSystemParameters;
                     /**   */
                     simulations?: Simulation | Simulation[];
                     /**   */
                     name?: string;
                     /**   */
                     position?: Vector3 | [number, number, number];
                     /**  */
                     rotation?: Vector3 | [number, number, number];
                     /**  */
                     scale?: Vector3 | [number, number, number] | number;
                     /** parent nullundefinedparentparent */
                     parent?: Object3D;
                     /** json json */
                     onData?: (data: any) => any;
                     /**  */
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                     /** true */
                     disposeWhenEnd?: boolean;
                     crossOrigin?: string;
                     withCredentials?: boolean;
                     urlPath?: string;
                     resourcePath?: string;
                     requestHeader?: {
                         [header: string]: string;
                     };
                 }) => Promise<ParticleEmitter<Object3DEventMap>>;
                 /** JSON */
                 loadParticleFromJson: (json: string | JSON, opts?: {
                     /**  */
                     system?: ParticleSystemParameters;
                     /**   */
                     simulations?: Simulation | Simulation[];
                     /**  */
                     name?: string;
                     /**   */
                     position?: Vector3 | [number, number, number];
                     /**  */
                     rotation?: Vector3 | [number, number, number];
                     /**  */
                     scale?: Vector3 | [number, number, number] | number;
                     /** parent nullundefinedparentparent */
                     parent?: Object3D;
                     /** true */
                     disposeWhenEnd?: boolean;
                     /**  */
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                     /**  */
                     onData?: (data: any) => any;
                 }) => ParticleEmitter<Object3DEventMap>;
                 /**  */
                 loadParticleFromRes(obj: Object3D, opts?: {
                     /**  */
                     system?: ParticleSystemParameters;
                     /**   */
                     simulations?: Simulation | Simulation[];
                     /**   */
                     name?: string;
                     /**   */
                     position?: Vector3 | [number, number, number];
                     /**  */
                     rotation?: Vector3 | [number, number, number];
                     /**  */
                     scale?: Vector3 | [number, number, number] | number;
                     /** parent nullundefinedparentparent */
                     parent?: Object3D;
                     /** true */
                     disposeWhenEnd?: boolean;
                     /**  */
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                 }): ParticleEmitter<Object3DEventMap>;
                 removeParticle(obj: ParticleEmitter<Object3DEventMap>): any;
             }

             export  interface IParticleSystem {
                 /**
                  * Whether the system is in world space.
                  * @type {boolean}
                  */
                 worldSpace: boolean;
                 /**
                  * Number of particles.
                  * @type {number}
                  */
                 particleNum: number;
                 /**
                  * Duration of the system.
                  * @type {number}
                  */
                 duration: number;
                 /**
                  * Whether the system is looping.
                  * @type {boolean}
                  */
                 looping: boolean;
                 /**
                  * Array of particles.
                  * @type {Array<IParticle>}
                  */
                 particles: Array<IParticle>;
                 /**
                  * Emitter for the particles.
                  * @type {ParticleEmitter<any>}
                  */
                 emitter: ParticleEmitter<any>;
                 /**
                  * Optional renderer.
                  * @type {BatchedRenderer}
                  */
                 _renderer?: BatchedRenderer;
                 instancingGeometry: BufferGeometry;
                 rendererEmitterSettings: RendererEmitterSettings;
                 getRendererSettings(): VFXBatchSettings;
                 paused: boolean;
                 pause(): void;
                 play(): void;
                 restart(): void;
                 clone(): IParticleSystem;
                 toJSON(metaData: any, options: SerializationOptions): any;
                 signal: {
                     onRestart: Signal;
                     onPlay: Signal;
                     onPause: Signal;
                     onEnd: Signal;
                 };
                 dispose(): void;
             }

             export  interface IPhysicsManagerModule {
                 /**  */
                 physicsEnable: boolean;
                 /**  */
                 readonly physicsWorld: World;
                 /**  */
                 readonly physicsEngine: typeof CANNON;
                 /**  */
                 enablePhysicsEngine(): Promise<typeof CANNON>;
                 /**  */
                 addPhysicsBody(phyObject: MeshPhysicsObjectParams): MeshPhysicsObjectParams;
                 /**  */
                 removePhysicsObject(object: Object3D | Entity): any;
                 /**  */
                 addPhysicsGround(): CANNON.Plane;
                 /**  */
                 setPhysicsDebugger(enable: boolean): void;
             }

             export  interface IPickModule {
                 /**
                  * 
                  */
                 isFreeStatus: boolean;
                 /**
                  * 
                  */
                 isFreeStatusRef: Ref<boolean>;
                 /**
                  * 
                  */
                 pickPoint: (opts?: PickPointOptions) => Promise<{
                     cancel: boolean;
                     point?: Vector3;
                     reason?: string;
                     intersectObject?: any;
                     event?: InteractiveEvent;
                 }>;
                 /**
                  * 
                  */
                 pickEntity: (opts?: PickEntityOptions) => Promise<{
                     cancel: boolean;
                     entities: Entity[];
                     reason?: string;
                     clearHighlight: Function;
                 }>;
                 /**
                  * 
                  */
                 drawSelectBox: (style?: Record<string, any>) => Promise<{
                     cancel: boolean;
                     reason?: string;
                 } | [Vector2, Vector2]>;
                 /**
                  * 
                  */
                 actionDrawPoint: (opts?: IDrawPointEnterOptions) => Promise<{
                     isCancel?: boolean;
                     data: SymbolItemData;
                 }>;
                 /**
                  * 
                  */
                 actionDrawLineSting: (opts?: IDrawLineEnterOptions) => Promise<{
                     isCancel?: boolean;
                     data: PolylineItemData;
                 }>;
                 /**
                  * 
                  */
                 actionDrawPolygon: (opts?: IDrawPolygonEnterOptions) => Promise<{
                     isCancel?: boolean;
                     data: PolygonItemData;
                 }>;
                 actionDrawEdit: (opts?: IDrawEditEnterOptions) => Promise<{}>;
                 /**  */
                 actionPickSelect: (opts?: PickEnterOptions) => Promise<{
                     isCancel: boolean;
                     info?: TLEventHandler;
                     select?: InteractiveObject;
                 }>;
                 /**  */
                 getDrawLayer: (layerName?: string, noCreateStyle?: Record<string, any>) => {
                     symbol: () => SymbolEntity | undefined;
                     polylines: () => PolylinesEntity | undefined;
                     polygons: () => PolygonsEntity | undefined;
                     addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
                     addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
                     addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
                     updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
                     updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
                     updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
                     deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
                     deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
                     deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
                 };
             }

             /**
              * 
              */
             export  interface IPointQueryFeatures extends IQueryBaseFeatures {
                 /** X. */
                 x: number;
                 /** Y. */
                 y: number;
                 /** . */
                 pixelsize?: number;
                 /** . */
                 condition?: string;
                 /** . */
                 maxGeomBytesSize?: number;
                 /** zoom. */
                 pixelToGeoLength?: number;
             }

             export  interface IPostProcessModule {
                 /** */
                 readonly composer: EffectComposer;
                 /** */
                 isComposerEnable: () => boolean;
                 /**  */
                 setComposerEnable: (b: boolean) => void;
                 /**  */
                 addEffectRenderPass(pass: Pass, orderIndex?: number): any;
                 /**  */
                 removeEffectRenderPass(pass: Pass): any;
                 /**  foreceUpdate*/
                 refreshEffectRenderPass(foreceUpdate?: boolean): any;
                 /**  */
                 getDepth: (x: number, y: number) => Promise<number>;
                 /** OutlineEffect */
                 readonly outlineEffect: OutlineEffect;
                 /** bloomEffect */
                 readonly bloomEffect: BloomEffect;
                 /** selectedEffect */
                 readonly selectedEffect: OutlineEffect;
             }

             /**
              * 
              */
             export  interface IQueryBaseFeatures {
                 /** . */
                 zoom?: number;
                 /** ID(mapid). */
                 mapid?: string;
                 /** (). */
                 version?: string;
                 /** ). */
                 layer?: string;
                 /** . */
                 limit?: number;
                 /** ,,. "name,objectid" */
                 fields?: string;
                 /** . */
                 geom?: boolean;
                 /** GeoJSON10 map.pixelToGeoLength(1, 10) * vjmap.Projection.EQUATORIAL_SEMIPERIMETER * 2 / map.getGeoBounds(1.0).width() */
                 simplifyTolerance?: boolean;
                 /** cache(). */
                 useCache?: boolean;
                 /** cadcadtoMapCoordinatetrue. */
                 toMapCoordinate?: boolean;
             }

             export  interface IRectCollide {
                 getBoundingRect: () => {
                     /** x */
                     x1: number;
                     /** y */
                     y1: number;
                     /** x */
                     x2: number;
                     /** y */
                     y2: number;
                     /** x */
                     cx: number;
                     /** y */
                     cy: number;
                     /** (0-360) */
                     rotation: number;
                     /**  */
                     position: Vector3;
                     /** index() */
                     zIndex?: number;
                     /** id */
                     id?: string;
                     /**   */
                     groupName?: string;
                     /**   */
                     setVisible: (b: boolean) => any;
                 } | null;
             }

             export  interface IRectCollideModule {
                 /**  */
                 addCollideRectObject: (item: IRectCollide) => void;
                 /**  */
                 removeCollideRectObject: (item: IRectCollide) => void;
                 /**  */
                 updateCollideRect: () => void;
                 /**  */
                 setCollideRectDirty: () => void;
             }

             /**
              * 
              */
             export  interface IRectQueryFeatures extends IQueryBaseFeatures {
                 /** X1. (x1,y1,x2,y2 */
                 x1?: number;
                 /** Y1. */
                 y1?: number;
                 /** X2. */
                 x2?: number;
                 /** Y2. */
                 y2?: number;
                 /** . */
                 condition?: string;
                 /** . */
                 maxGeomBytesSize?: number;
             }

             export  interface IRequest {
                 get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
                 put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
                 del: (url: string, args?: Partial<Config>) => Promise<any>;
                 options: (url: string, args?: Partial<Config>) => Promise<any>;
             }

             export  function isAltKeyDown(event?: any): boolean;

              function isArray(value: any): value is any[];

             /**
              * Consider typed array.
              * @param data
              */
              function isArrayLike(data: any): data is ArrayLike_2<any>;

              function isBuiltInObject(value: any): boolean;

             export  interface ISceneModule {
                 /**  */
                 addScene: (scene?: Scene, camera?: CameraOptions) => Scene;
                 /**  */
                 activeScene: (_scene: Scene) => Promise<void>;
                 /**  */
                 setScene: (scene?: Scene, camera?: CameraOptions) => Promise<Scene>;
                 /**  */
                 removeScene: (_scene: Scene) => Promise<void>;
                 /**  */
                 initScene(scene: Scene): any;
                 /**  */
                 clearScenes(): any;
                 /**  */
                 readonly sceneEntity: Entity;
                 /**  */
                 addDefaultLights: (scene?: Scene) => {};
                 /**  */
                 getSceneStatData: () => {
                     /**  */
                     objects: number;
                     /**  */
                     vertices: number;
                     /**  */
                     triangles: number;
                 };
                 /**  */
                 readonly envConfig: EnvConfigOption & {
                     [key: string]: any;
                 };
                 /**  */
                 setEnvConfig: (key: keyof EnvConfigOption | string, value: any) => void;
                 /**  */
                 setBackgroundEnvironment: (options?: BackgroundEnvironmentOptions) => Promise<void>;
                 /**  */
                 setFocus: () => void;
                 /**  */
                 loadResources: (_resources: ResourceItem[], options?: loadResourcesOptions) => Promise<RosourceItemsReturnType>;
                 /** loadResources */
                 getLoadedResources: () => RosourceItemsReturnType;
             }

              function isCombineMorphing(path: Element_2): path is CombineMorphingPath;

             export  function isCtrlKeyDown(event?: any): boolean;

             export  function isDeleteKey(event?: any): boolean;

              function isDom(value: any): value is HTMLElement;

             export  function isEnterKey(event?: any): boolean;

             export  function isEscKey(event?: any): boolean;

              function isFunction(value: any): value is Function;

             /**
              * A {@link GeoPointLike} object, an array of two numbers representing longitude and latitude,
              * or an object with `lng` and `lat` or `lon` and `lat` properties.
              *
              * Example:
              * ```typescript
              * const center = { lat: 53.3, lng: 13.4 };
              * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
              * ```
              */
             export  function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike;

              function isGradientObject(value: any): value is GradientObject;

              function isImagePatternObject(value: any): value is ImagePatternObject;

             export  function isLeftButton(event?: any): boolean;

             /**
              * 
              */
             export  interface ISliceCacheZoom {
                 /** ID(mapid). */
                 mapid?: string;
                 /** (). */
                 version?: string;
                 /** ) */
                 layer?: string;
                 /**  */
                 ismvt: boolean;
             }

             /**
              * 
              */
             export  interface ISliceLayer {
                 /** ID(mapid). */
                 mapid?: string;
                 /** (). */
                 version?: string;
                 /** ). */
                 layer: string | string[];
                 /** , layer */
                 zoom: number | number[];
                 /** . layer */
                 ismvt: boolean | boolean[];
                 /** . */
                 iscancel?: boolean;
                 /** . */
                 isAllCancel?: boolean;
                 /** 10000. */
                 batchNum?: number;
                 /** 1ms. */
                 idleBatchSleepMs?: number;
                 /** 10000ms. */
                 busyBatchSleepMs?: number;
             }

             export  const isMapMode: (app?: App) => boolean;

             export  function isMiddleButton(event?: any): boolean;

              function isMorphing(el: Element_2): boolean;

              function isNumber(value: any): value is number;

              function isObject<T = unknown>(value: T): value is (object & T);

             /**
              * 
              */
             export  function isObjectBehindCamera(el: Object3D, camera: Camera, isMapMode?: boolean): boolean;

             /**
              * 
              */
             export  function isObjectOcclude(el: Object3D, camera: Camera, raycaster: Raycaster, occlude: Object3D[]): boolean;

              class Isogon extends Path<IsogonProps> {
                 shape: IsogonShape;
                 constructor(opts?: IsogonProps);
                 getDefaultShape(): IsogonShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: IsogonShape): void;
             }

              interface IsogonProps extends PathProps {
                 shape?: Partial<IsogonShape>;
             }

              class IsogonShape {
                 x: number;
                 y: number;
                 r: number;
                 n: number;
             }

             /**
              * 
              * @param pos 
              * @param polygon 
              * @return {boolean}
              */
             export  const isPointInPolygon: (pos: GeoPoint, polygon: GeoPoint[]) => boolean;

              function isPrimitive(obj: any): boolean;

             /**
              * Check if property is writable in object or its prototype chain
              * @param object - object to check
              * @param prop - property to check
              * @param allowWritable - allow writable properties without setter
              * @param allowAny - allow any property (even if it doesn't exist)
              *
              * @category JS Object
              */
             export  function isPropertyWritable<T>(object: T, prop: keyof T, allowWritable?: boolean, allowAny?: boolean): boolean;

             /**
              * Checks if an object is a proxy created by {@link reactive},
              * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.
              *
              * @param value - The value to check.
              */
              function isProxy(value: unknown): boolean;

             /**
              * Checks if an object is a proxy created by {@link reactive()} or
              * {@link shallowReactive()} (or {@link ref()} in some cases).
              *
              * @example
              * ```js
              * isReactive(reactive({}))            // => true
              * isReactive(readonly(reactive({})))  // => true
              * isReactive(ref({}).value)           // => true
              * isReactive(readonly(ref({})).value) // => true
              * isReactive(ref(true))               // => false
              * isReactive(shallowRef({}).value)    // => false
              * isReactive(shallowReactive({}))     // => true
              * ```
              *
              * @param value - The value to check.
              */
              function isReactive(value: unknown): boolean;

             /**
              * Checks whether the passed value is a readonly object. The properties of a
              * readonly object can change, but they can't be assigned directly via the
              * passed object.
              *
              * The proxies created by {@link readonly()} and {@link shallowReadonly()} are
              * both considered readonly, as is a computed ref without a set function.
              *
              * @param value - The value to check.
              */
              function isReadonly(value: unknown): boolean;

             /**
              * Checks if a value is a ref object.
              *
              * @param r - The value to inspect.
              */
              function isRef<T>(r: Ref<T> | unknown): r is Ref<T>;

              function isRegExp(value: unknown): value is RegExp;

             export  function isRightButton(event?: any): boolean;

              function isShallow(value: unknown): boolean;

             export  function isShiftKeyDown(event?: any): boolean;

              function isString(value: any): value is string;

              function isStringSafe(value: any): value is string;

             export  interface IStatModule {
                 /**  */
                 showStat: boolean;
             }

              function isTypedArray(value: any): boolean;

             /**
              * Check if the browser supports exporting to webp, with the canvas.toDataURL('image/webp') method.
              */
             export  function isWebpExportSupported(): boolean;

              type IterableCollections = Map<any, any> | Set<any>;

              const ITERATE_KEY: unique symbol;

             /**
              * 
              */
             export  interface ITileUrlParam {
                 /** ID. */
                 mapid?: string;
                 /** . */
                 version?: string;
                 /** . */
                 layer?: string;
                 /** ID. */
                 fileid?: string;
             }

             export  interface IToolStateModule {
                 readonly rootState: StateNode;
                 getStatePath: () => string;
                 stateIsIn: (path: string) => boolean;
                 stateInAny: (...paths: string[]) => boolean;
                 setCurrentTool: (id?: string, info?: Record<string, any>) => App;
                 getCurrentTool: () => StateNode;
                 getCurrentToolId: () => string;
                 getStateDescendant: <T extends StateNode>(path: string) => T | undefined;
                 addTool: (Tool: TLStateNodeConstructor) => void;
                 removeTool: (Tool: TLStateNodeConstructor) => void;
                 /**
                  * 
                  */
                 isInActiveTool: () => boolean;
                 /**
                  * 
                  */
                 isInteracting(): boolean;
                 /**
                  *  
                  */
                 transformObject: (options: TransformEnterOptions) => Promise<StateNode>;
             }

             export  interface IUiConfigContainer<TValue = any, TType extends string = string> {
                 uiConfig?: UiObjectConfig<TValue, TType>;
             }

             export  interface IUiModule {
                 /**
                  *  ( `control.onAdd(this)` ).
                  *
                  * @param control .
                  * @param {string} [position] . 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
                  */
                 addControl: (control: IControl, position?: ControlPosition) => App;
                 /**
                  * .
                  *
                  * @param {IControl} control .

                  */
                 removeControl: (control: IControl) => App;
                 /**
                  * .
                  *
                  * @param {IControl} control .
                  */
                 hasControl: (control: IControl) => void;
                 /**
                  * 
                  * @param cur 
                  */
                 setCursor: (cur: string) => void;
                 /**
                  * 
                  */
                 getConfigPane: (opts?: {
                     /**  */
                     isReset?: boolean;
                     /**  */
                     title?: string;
                     /**  */
                     style?: Partial<CSSStyleDeclaration>;
                 }) => Promise<{
                     configPane: any;
                     rootPane: any;
                     element: HTMLElement;
                     isInit: boolean;
                     setVisible: (b: boolean) => void;
                     isVisible: () => boolean;
                     reset: () => void;
                     appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
                     renderUiConfig: (uiConfig: UiObjectConfig) => void;
                     renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
                 }>;
                 /**
                  * 
                  * text
                  * type  "log"
                  * time  2500
                  */
                 logInfo: (text: string, type?: logInfoType | number, time?: number) => void;
             }

             export  interface IUniformB {
                 value: boolean;
             }

             export  interface IUniformColor {
                 value: Color;
             }

             export  interface IUniformN {
                 value: number;
             }

             export  interface IUniformNArray {
                 value: number[];
             }

             export  interface IUniformTexture {
                 value: Texture | null;
             }

             export  interface IUniformV2 {
                 value: Vector2;
             }

             export  interface IUniformV3 {
                 value: Vector3;
             }

             export  interface IUniformV3Array {
                 value: Vector3[];
             }

             /**
              * 
              */
             export  interface IUpdateMapParam extends IOpenMapBaseParam {
                 /** (: false ). */
                 deleteOldVersion?: boolean;
             }

             /**
              * 
              */
             export  interface IUpdateStyle {
                 /** ID(mapid). */
                 mapid?: string;
                 /** (). */
                 version?: string;
                 /** . */
                 name?: string;
                 /** [0,1,3]. */
                 layeron?: string | number[];
                 /** [2,4]. layeronlayeroff*/
                 layeroff?: string | number[];
                 /** [x1,y1,x2,y2]. */
                 clipbounds?: [number, number, number, number] | number;
                 /** . */
                 backcolor?: number;
                 /** [11110].123455 */
                 lineweight?: string | number[];
                 /** . */
                 expression?: string;
             }

             export  interface IWebGLRendererModule {
                 /**  */
                 readonly renderer: WebGLRenderer;
                 /**  */
                 getScreenshot: (params?: Screenshot) => Promise<Blob | null | undefined>;
                 /**  */
                 readonly isMapMode: boolean;
                 readonly commonUniforms: {
                     time: {
                         value: Vector4;
                     };
                     resolution: {
                         value: Vector2;
                     };
                 };
             }

             /**
              * wmsurl
              */
             export  interface IWmsTileUrl {
                 /** ID(mapid) . */
                 mapid?: string | string[];
                 /** (). */
                 version?: string | string[];
                 /** ). */
                 layers?: string | string[];
                 /** {bbox-epsg-3857}. (cadwmscad,srs,crs,mapbounds).*/
                 bbox?: string;
                 /** ,(EPSG:3857). */
                 srs?: string;
                 /** cad. proj4*/
                 crs?: string | string[];
                 /** ,srs */
                 mapbounds?: string;
                 /** . */
                 width?: number;
                 /** . */
                 height?: number;
                 /** . */
                 transparent?: boolean;
                 /** rgb(r,g,b)rgba(r,g,b,a),a255. */
                 backgroundColor?: string;
                 /** (x,y,)*/
                 fourParameter?: string | string[];
                 /** false*/
                 isInverseFourParamter?: boolean | boolean[];
                 /** . */
                 mvt?: boolean;
                 /** . */
                 useImageRotate?: boolean;
                 /** . 12,*/
                 imageProcessAlg?: number;
                 /**  WGS84(84osm), GCJ02() BD09LL() BD09MC()*/
                 webMapType?: "WGS84" | "GCJ02" | "BD09LL" | "BD09MC";
             }

             /**
              * 
              */
             export  interface IWorkspace {
                 /** (). */
                 name: string;
                 /** (). */
                 alias?: string;
                 /** . */
                 workDir?: string;
                 /** . */
                 isPublic?: boolean;
             }

             /**
              * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
              */
              class JacobianElement {
                 /**
                  * spatial
                  */
                 spatial: Vec3;
                 /**
                  * rotational
                  */
                 rotational: Vec3;
                 constructor();
                 /**
                  * Multiply with other JacobianElement
                  */
                 multiplyElement(element: JacobianElement): number;
                 /**
                  * Multiply with two vectors
                  */
                 multiplyVectors(spatial: Vec3, rotational: Vec3): number;
             }

             export  interface JsonMetaData {
                 textures: {
                     [uuid: string]: Texture;
                 };
                 geometries: {
                     [uuid: string]: BufferGeometry;
                 };
             }

             

             

              type Keyframe_2 = {
                 time: number;
                 value: unknown;
                 percent: number;
                 rawValue: unknown;
                 easing?: AnimationEasing;
                 easingFunc?: (percent: number) => number;
                 additiveValue?: unknown;
             };

              type KeyOfDistributive<T> = T extends unknown ? keyof T : never;

             /**
              * Get all object keys
              *
              * Will return an empty array if obj is null/undefined
              */
              function keys<T extends object>(obj: T): (KeyOfDistributive<T> & string)[];

             export  class Label extends Object3D {
                 #private;
                 labelPool: LabelPool;
                 text: string;
                 mesh: InstancedMesh;
                 geometry: InstancedBufferGeometry;
                 material: LabelMaterial;
                 pickingMaterial: LabelMaterial;
                 instanceAttrData: Float32Array;
                 instanceAttrBuffer: InstancedInterleavedBuffer;
                 instanceBoxPosition: InterleavedBufferAttribute;
                 instanceCharPosition: InterleavedBufferAttribute;
                 instanceUv: InterleavedBufferAttribute;
                 instanceBoxSize: InterleavedBufferAttribute;
                 instanceCharSize: InterleavedBufferAttribute;
                 lineHeight: number;
                 constructor(labelPool: LabelPool);
                 private _handleAtlasChange;
                 dispose(): void;
                 private reallocateAttributeBufferIfNeeded;
                 setText(text: string): void;
                 private _needsUpdateLayout;
                 private _updateLayoutIfNeeded;
                 /** Values should be in working (linear-srgb) color space */
                 setColor(r: number, g: number, b: number, a?: number): void;
                 /** Values should be in working (linear-srgb) color space */
                 setBackgroundColor(r: number, g: number, b: number, a?: number): void;
                 setBillboard(billboard: boolean): void;
                 /**
                  * Enable or disable size attenuation. Setting this to `false` also requires that billboarding is
                  * enabled.
                  */
                 setSizeAttenuation(sizeAttenuation: boolean): void;
                 setAnchorPoint(x: number, y: number): void;
                 setLineHeight(lineHeight: number): void;
             }

             export  class LabelMaterial extends RawShaderMaterial {
                 picking: boolean;
                 constructor(params: {
                     atlasTexture?: Texture;
                     picking?: boolean;
                 });
             }

             export  interface LabelOptions {
                 /**   */
                 position?: Vector3;
                 /**  */
                 text: string;
                 /**  */
                 color?: ColorRepresentation;
                 /**  */
                 backgroundColor?: ColorRepresentation;
                 /**  */
                 backgroundOpacity?: number;
                 /**  */
                 billboard?: boolean;
                 /**  */
                 anchorPoint?: [number, number];
                 /**  */
                 lineHeight?: number;
                 /**  */
                 sizeAttenuation?: boolean;
                 /**  */
                 transparent?: boolean;
                 /**  */
                 labelPool?: LabelPool;
             }

             export  class LabelPool extends EventDispatcher_2<{
                 scaleFactorChange: object;
                 atlasChange: object;
             }> {
                 atlasTexture: DataTexture;
                 private availableLabels;
                 private disposed;
                 static QUAD_POINTS: Vector3Tuple[];
                 static QUAD_POSITIONS: BufferAttribute;
                 static QUAD_UVS: BufferAttribute;
                 fontManager: FontManager;
                 scaleFactor: number;
                 setScaleFactor(scaleFactor: number): void;
                 constructor(options?: FontManagerOptions);
                 updateAtlas(text: string): void;
                 private _updateAtlasTexture;
                 acquire(): Label;
                 release(label: Label): void;
                 dispose(): void;
             }

             

              interface LayerConfig {
                 clearColor?: string | GradientObject | ImagePatternObject;
                 motionBlur?: boolean;
                 lastFrameAlpha?: number;
             }

             export  type LayoutInfo = {
                 width: number;
                 height: number;
                 chars: CharLayoutInfo[];
             };

             /**
              * 
              */
              function len(v: VectorArray): number;

              const length_2: typeof len;

              const lengthSquare: typeof lenSquare;

             /**
              * 
              */
              function lenSquare(v: VectorArray): number;

             /**  */
             export  function lerp(x: number, y: number, t: number): number;

             /**
              * 
              */
              function lerp_2<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, t: number): T;

             /**
              * @param normalizedValue A float between 0 and 1.
              * @param colors Color list.
              * @param fullOutput Default false.
              * @return Result color. If fullOutput,
              return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
              */
              function lerp_3(normalizedValue: number, colors: string[], fullOutput: boolean): LerpFullOutput;

              function lerp_3(normalizedValue: number, colors: string[]): string;

             export  function lerpCameras(camera1: any, camera2: any, alpha: any): void;

             /**
              * 
              * @param coordinates 
              * @param t 0-1
              * @returns
              */
             export  function lerpCoordinates(coordinates: Vector3[] | [number, number, number][], t: number): Vector3;

             /**  */
             export  function lerpEuler(e1: Euler, e2: Euler, t: number): Euler;

              type LerpFullOutput = {
                 color: string;
                 leftIndex: number;
                 rightIndex: number;
                 value: number;
             };

              function lift(color: string, level: number): string;

              function liftColor(color: GradientObject): GradientObject;

              function liftColor(color: string): string;

             /**
              * Limit the speed of particles over their life.
              */
             export  class LimitSpeedOverLife implements Simulation {
                 speed: FunctionValueGenerator;
                 dampen: number;
                 type: string;
                 initialize(particle: Particle): void;
                 constructor(speed: FunctionValueGenerator, dampen: number);
                 update(particle: Particle, delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any): Simulation;
                 frameUpdate(delta: number): void;
                 clone(): Simulation;
                 reset(): void;
             }

              class Line extends Path<LineProps> {
                 shape: LineShape;
                 constructor(opts?: LineProps);
                 getDefaultStyle(): {
                     stroke: string;
                     fill: string;
                 };
                 getDefaultShape(): LineShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: LineShape): void;
                 /**
                  * Get point at percent
                  */
                 pointAt(p: number): VectorArray;
             }

             export  class Line2 extends LineSegments2 {
                 constructor(geometry?: LineGeometry, material?: LineMaterial);
             }

             /**
              * 
              * @param line
              * @param splitLine
              * @param epsilon 1e-6
              */
             export  function line3dSplit(line: Vector3[], splitLine: Vector3[], epsilon?: number): Vector3[][];

             /**
              * x, y, x2, y2 are all percent from 0 to 1 when globalCoord is false
              */
              class LinearGradient extends Gradient_2 {
                 type: 'linear';
                 x: number;
                 y: number;
                 x2: number;
                 y2: number;
                 constructor(x: number, y: number, x2: number, y2: number, colorStops?: GradientColorStop[], globalCoord?: boolean);
             }

              interface LinearGradientObject extends GradientObject {
                 type: 'linear';
                 x: number;
                 y: number;
                 x2: number;
                 y2: number;
             }

             /**
              * Converts a single color channel from the linear color space to sRGB.
              * @param c - The color channel to be converted.
              * @category Color
              */
             export  function LinearToSRGB(c: number): number;

             export  function lineDistance(points: [number, number, number][] | Vector3[]): number;

             export  class LineGeometry extends LineSegmentsGeometry {
                 constructor();
                 setPositions(array: any): this;
                 setColors(array: any): this;
                 setLinewidths(array: number[]): this;
                 setLineOpacitys(array: number[]): this;
                 setDashArguments(array: number[]): this;
                 fromLine(line: any): this;
             }

             export  function lineIntersection(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, out?: number[], writeOffset?: number): number;

             export  class LineMaterial extends ShaderMaterial {
                 constructor(parameters: any);
                 get color(): any;
                 set color(value: any);
                 get worldUnits(): boolean;
                 set worldUnits(value: boolean);
                 get linewidth(): any;
                 set linewidth(value: any);
                 get dashed(): boolean;
                 set dashed(value: boolean);
                 get dashScale(): any;
                 set dashScale(value: any);
                 get dashSize(): any;
                 set dashSize(value: any);
                 get dashOffset(): any;
                 set dashOffset(value: any);
                 get gapSize(): any;
                 set gapSize(value: any);
                 get opacity(): any;
                 set opacity(value: any);
                 get resolution(): any;
                 set resolution(value: any);
                 get alphaToCoverage(): boolean;
                 set alphaToCoverage(value: boolean);
             }

             export  type LineMaterialParameters = {
                 worldUnits?: boolean;
                 color?: number;
                 linewidth?: number;
                 dashed?: boolean;
                 dashScale?: number;
                 dashSize?: number;
                 dashOffset?: number;
                 gapSize?: number;
                 resolution?: Vector2;
             } & ShaderMaterialParameters;

              interface LineProps extends PathProps {
                 shape?: Partial<LineShape>;
             }

             export  class LineSegments2 extends Mesh {
                 constructor(geometry?: LineSegmentsGeometry, material?: LineMaterial);
                 computeLineDistances(): this;
                 raycast(raycaster: any, intersects: any): void;
             }

             export  class LineSegmentsGeometry extends InstancedBufferGeometry {
                 constructor();
                 applyMatrix4(matrix: any): this;
                 setPositions(array: any): this;
                 setColors(array: any): this;
                 setLinewidths(linewidthArray: Float32Array | number[]): this;
                 setLineOpacitys(lineOpacityArray: Float32Array | number[]): this;
                 /**
                  * dash
                  * @param dashArgsArr
                  */
                 setDashArguments(dashArgsArr: Float32Array | number[]): this;
                 fromWireframeGeometry(geometry: any): this;
                 fromEdgesGeometry(geometry: any): this;
                 fromMesh(mesh: any): this;
                 fromLineSegments(lineSegments: any): this;
                 computeBoundingBox(): void;
                 computeBoundingSphere(): void;
                 toJSON(): void;
                 applyMatrix(matrix: any): this;
             }

              class LineShape {
                 x1: number;
                 y1: number;
                 x2: number;
                 y2: number;
                 percent: number;
             }

             /**
              * 
              * @param cs 
              * @param lineChunkLength 10
              */
             export  function lineSlice(cs: Array<[number, number, number]>, lineChunkLength?: number): any[];

             /**
              * 
              * @param line
              * @param splitLine
              * @param dotErr 6
              * @return {any[] | GeoPoint[][]}
              */
             export  function lineSplit(line: GeoPoint[], splitLine: GeoPoint[], dotErr?: number): GeoPoint[][];

             /**
              * LineString Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.4
              */
              interface LineString extends GeometryObject {
                 type: "LineString";
                 coordinates: Position[];
             }

              class LinkedList<T> {
                 length: number;
                 head: LinkedListNode<T> | null;
                 tail: LinkedListNode<T> | null;
                 constructor();
                 isEmpty(): boolean;
                 clear(): void;
                 front(): T | null;
                 back(): T | null;
                 /**
                  * remove at head in O(1)
                  */
                 dequeue(): T | undefined;
                 /**
                  * remove at tail in O(1)
                  */
                 pop(): T | undefined;
                 /**
                  * add at head in O(1)
                  */
                 queue(data: T): void;
                 /**
                  * add at tail in O(1)
                  */
                 push(data: T): void;
                 insertBefore(node: LinkedListNode<T>, data: T): void;
                 remove(data: T): void;
                 /**
                  * Returns an iterator over the values
                  */
                 values(): Generator<T, void, unknown>;
             }

              class LinkedListNode<T> {
                 data: T;
                 next: LinkedListNode<T> | null;
                 prev: LinkedListNode<T> | null;
                 constructor(data: T);
                 hasPrev(): boolean;
                 hasNext(): boolean;
             }

             export  interface LoadDetail {
                 url: string;
                 progress: number;
                 error: boolean;
                 message: string;
             }

             export  class LoaderManager {
                 private readonly resourceMap;
                 private loaderMap;
                 private readonly loadDetailMap;
                 private path;
                 loaderUrlPath: string;
                 signal: {
                     beforeLoad: Signal;
                     loading: Signal;
                     detailLoading: Signal;
                     detailLoaded: Signal;
                     loaded: Signal;
                 };
                 imageLoader: ImageLoader;
                 videoLoader: VideoLoader;
                 gltfLoader: GLTFLoader;
                 objLoader: OBJLoader;
                 mtlLoader: MTLLoader;
                 videlLoader: VideoLoader;
                 hdrLoader: RGBELoader;
                 fbxLoader: FBXLoader;
                 ddsLoader: DDSLoader;
                 dracoLoader: DRACOLoader;
                 ktx2Loader: KTX2Loader;
                 svgLoader: SVGLoader;
                 fileLoader: FileLoader;
                 particleLoader: ParticleLoader;
                 constructor(parameters?: LoaderManagerOptions);
                 /**
                  * 
                  * @param path
                  * @returns
                  */
                 setPath(path: string): this;
                 /**
                  * 
                  * @param headers
                  * @returns this
                  */
                 setRequestHeader(headers: Record<string, string>): this;
                 /**
                  * 
                  * @param responseType
                  * @returns this
                  */
                 setResponseType(responseType: string): this;
                 /**
                  * 
                  * @param ext 
                  * @returns
                  */
                 getLoader(ext: string): Loader | null;
                 /**
                  * 
                  * @param urls
                  * @param useCache 
                  * @returns this
                  */
                 load(urls: LoadUnit[] | LoadUnit, useCache: boolean, onLoad: (resource: any) => void, onProgress?: (event: ProgressEvent | ProgressEvent[]) => void, onError?: (event: ErrorEvent | string | string[] | ErrorEvent[]) => void, fileType?: string[] | string): this;
                 /**
                  * loader
                  * @param ext : jpg
                  * @param loader extend THREE.Loader
                  * @returns this
                  */
                 register(ext: string, loader: Loader): this;
                 hasLoaded(url: string): boolean;
                 /**
                  * url
                  * @param url
                  * @returns
                  */
                 getResource(url: string): any;
                 /**
                  * url
                  * @param url
                  * @returns
                  */
                 getResourceStatus(url: string): ResStatus;
                 /**
                  * 
                  * @returns
                  */
                 getLoadDetail(url: string): LoadDetail;
                 /**
                  * 
                  * @returns
                  */
                 getLoadDetailMap(): {
                     [key: string]: LoadDetail;
                 };
                 setLoaderPath(urlPath: string): void;
                 /**
                  * 
                  * @returns
                  */
                 dispose(): this;
                 /**
                  * loader
                  */
                 loadExtensionLoader(): Promise<void>;
                 /**
                  * IfcLoader
                  */
                 loadExtensionIfcLoader(options?: {
                     setupOptionalCategoriesOpts?: Record<string, any>;
                     applyWebIfcConfigOpts?: Record<string, any>;
                 }): Promise<void>;
             }

             export  interface LoaderManagerOptions {
                 /** */
                 loaderExtends: {
                     [key: string]: Loader;
                 };
             }

             /**
              * 
              */
             export  const loadImage: (src: string) => Promise<HTMLImageElement>;

             export  const LoadManager: LoaderManager;

             export  function loadParticlePlugin(plugin: ParticlePlugin): void;

             /**  */
             export  function loadPhysicsEngine(): Promise<typeof CANNON>;

             /** 3dtiles */
             export  const loadPlugin3dtiles: () => Promise<typeof vjmap3d_2.Tiles3dPluginType>;

             /** algorithm */
             export  const loadPluginAlgorithm: () => Promise<typeof vjmap3d_2.AlgorithmPluginType>;

             export  interface LoadPluginOpts {
                 /**  */
                 isAbsPath?: boolean;
                 /**  JavaScript `inject``eval` `href`. */
                 strategy?: "inject" | "eval" | `href`;
                 /**  `document.querySelector` */
                 injectLocation?: string;
                 /**  */
                 async?: boolean;
                 /** globalThisundefined */
                 globalThisUndefined?: boolean;
                 /** globalThisundefined */
                 globalThisReplace?: boolean;
                 /**  */
                 context?: any;
                 /**  */
                 reqConfig?: Partial<Config>;
             }

             export  interface loadResourcesOptions {
                 /** loading   true*/
                 showLoading?: boolean;
                 /**     true*/
                 showShadertoy?: boolean;
                 /** htmldiv  false */
                 showHtml?: boolean;
                 /**  */
                 shadertoyMaterial?: Partial<ShadertoyMaterialParameters> & {
                     hsbOffsetDelta?: [number, number, number];
                     hsbOffsetMax?: [number, number, number];
                 };
                 /**   */
                 ShadertoyProgressOpacity?: boolean;
                 /** webgl   false */
                 showGlLabel?: boolean;
                 /** div   true */
                 showDivLabel?: boolean;
                 /**   text loading... {{percentage}} */
                 labelOptions?: Partial<LabelOptions> & {
                     /**  */
                     position?: [number, number];
                     /**  */
                     height?: number;
                 };
                 /**  false */
                 enableCameraControl?: boolean;
                 /**  */
                 progressCb?: (percentage: number, error?: any) => void;
                 /** html div */
                 html?: {
                     /** div */
                     div: string;
                     /** css */
                     css?: string;
                     /** div  */
                     textDivClassName?: string;
                 };
                 /**  true */
                 autoHiddenSceneObjects?: boolean;
             }

             export  type LoadUnit = string | {
                 url: string;
                 ext: string;
             };

             /**
              * Lock constraint. Will remove all degrees of freedom between the bodies.
              */
              class LockConstraint extends PointToPointConstraint {
                 xA: Vec3;
                 xB: Vec3;
                 yA: Vec3;
                 yB: Vec3;
                 zA: Vec3;
                 zB: Vec3;
                 rotationalEquation1: RotationalEquation;
                 rotationalEquation2: RotationalEquation;
                 rotationalEquation3: RotationalEquation;
                 motorEquation?: RotationalMotorEquation;
                 constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                     /**
                      * The maximum force that should be applied to constrain the bodies.
                      * @default 1e6
                      */
                     maxForce?: number;
                 });
                 /**
                  * update
                  */
                 update(): void;
             }

              type LockConstraintOptions = ConstructorParameters<typeof LockConstraint>[2];

             /**
              * LOD control objects define how the map tiles are subsivided or simplified.
              */
             export  interface LODControl {
                 /**
                  * Update LOD of the MapView and Camera position on the world.
                  *
                  * @param view - Map view for wich the LOD will be updated.
                  * @param camera - Camera used to view the scene.
                  * @param renderer - Renderer object.
                  * @param scene - Scene that compose the mapview.
                  */
                 updateLOD(view: MapView, camera: Camera, renderer: WebGLRenderer, scene: Object3D): void;
             }

             /**
              * Use random raycasting to randomly pick n objects to be tested on screen space.
              *
              * Overall the fastest solution but does not include out of screen objects.
              */
             export  class LODRaycast implements LODControl {
                 /**
                  * Number of rays used to test nodes and subdivide the map.
                  *
                  * N rays are cast each frame dependeing on this value to check distance to the visible map nodes. A single ray should be enough for must scenarios.
                  */
                 subdivisionRays: number;
                 /**
                  * Threshold to subdivide the map tiles.
                  *
                  * Lower value will subdivide earlier (less zoom required to subdivide).
                  */
                 thresholdUp: number;
                 /**
                  * Threshold to simplify the map tiles.
                  *
                  * Higher value will simplify earlier.
                  */
                 thresholdDown: number;
                 /**
                  * Raycaster object used to cast rays into the world and check for hits.
                  */
                 raycaster: Raycaster;
                 /**
                  * Normalized mouse coordinates.
                  */
                 mouse: Vector2;
                 /**
                  * Consider the distance powered to level of the node.
                  */
                 powerDistance: boolean;
                 /**
                  * Consider the scale of the node when calculating the distance.
                  *
                  * If distance is not considered threshold values should be absolute distances.
                  */
                 scaleDistance: boolean;
                 updateLOD(view: MapView, camera: Camera, renderer: WebGLRenderer, scene: Object3D): void;
             }

              function logError(...args: any[]): void;

             export  const Logger: {
                 debug: (message?: any, ...optionalParams: any[]) => void;
                 info: (message?: any, ...optionalParams: any[]) => void;
                 warn: (message?: any, ...optionalParams: any[]) => void;
                 error: (message?: any, ...optionalParams: any[]) => void;
                 isEnabled: boolean;
                 /** Turn on log */
                 enable(): void;
                 /** Turn off log */
                 disable(): void;
             };

             export  type logInfoType = "log" | "warn" | "error" | "info" | "success";

             /**
              * Prints given message into the console
              */
             export  class LogMessageBehavior extends Behavior {
                 message: string;
                 constructor(message?: string);
                 /**
                  *
                  * @param {String} message
                  * @return {LogMessageBehavior}
                  */
                 static from(message: string): LogMessageBehavior;
                 tick(timeDelta: number): BehaviorStatus;
             }

              function logTriangleDefinitions(...triangles: Triangle[]): void;

             /**
              * Find the longest common prefix in an array of strings
              * https://stackoverflow.com/questions/68702774/longest-common-prefix-in-javascript
              * @param words
              */
             export  function longestCommonPrefix(words: string[]): string;

             /**
              * Calculate luminance. It will include alpha.
              */
              function lum(color: string, backgroundLum: number): number;

             export  function makeBasicMaterialUiConfig(mat: MeshBasicMaterial): UiObjectConfig;

             export  function makeCameraUiConfig(camera: Camera): UiObjectConfig;

             /**
              * Returns a data url for a 16x16 svg rectangle with the given color.
              * @param c - color
              *
              * @category SVGs
              */
             export  const makeColorSvg: (c: string) => string;

             /**
              * Returns a data url for a 16x16 svg circle with the given color.
              * @param c - color
              *
              * @category SVGs
              */
             export  const makeColorSvgCircle: (c: string) => string;

             export  function makeGeomertyUiConfig(geom: BufferGeometry): UiObjectConfig;

             export  function makeLightUiConfig(light: Light): UiObjectConfig | undefined;

             export  function makeMaterialUiConfig(mat: Material, object?: Object3D): UiObjectConfig;

             export  function makeObject3DUiConfig(obj: Object3D, isMesh?: boolean): UiObjectConfig;

             export  function makePhongMaterialUiConfig(mat: MeshPhongMaterial): UiObjectConfig;

             export  function makePhysicalMaterialUiConfig(mat: MeshPhysicalMaterial): UiObjectConfig;

             export  function makeSamplerUi(mat: any, map: any): UiObjectConfig<any, string, any>;

             /**
              * Returns a data url for a svg with the given text.
              * @param text
              *
              * @category SVGs
              */
             export  const makeTextSvg: (text: string) => string;

             /**
              * Array mapping.
              * @typeparam T Type in Array
              * @typeparam R Type Returned
              * @return Must be an array.
              */
              function map<T, R, Context>(arr: readonly T[], cb: (this: Context, val: T, index?: number, arr?: readonly T[]) => R, context?: Context): R[];

             export  class map2dUtils {
                 static WorldResolution: number;
                 static makePerspectiveMatrix(fovy: any, aspect: any, near: any, far: any): Matrix4;
                 static makeOrthographicMatrix(left: any, right: any, top: any, bottom: any, near: any, far: any): Matrix4;
                 /** 2d3d */
                 static projectToWorld(coords: [number, number, number?]): Vector3;
                 /**  */
                 static projectedUnitsPerMeter(latitude: any): number;
                 /** z */
                 static mercatorZfromAltitude(altitude: any, lat: any): number;
                 /** 3d2d */
                 static unprojectFromWorld(world: {
                     x: number;
                     y: number;
                     z: number;
                 } | Vector3): number[];
                 /**
                  * 
                  */
                 static fitToObject(map: any, object: Sphere | Object3D, opts?: Record<string, any>): void;
                 /**  */
                 static scene2World(pt: Vector3, app?: App): Vector3;
                 /**  */
                 static world2Scene(pt: Vector3, app?: App): Vector3;
             }

             /**
              * Represents a height map tile node that can be subdivided into other height nodes.
              *
              * Its important to update match the height of the tile with the neighbors nodes edge heights to ensure proper continuity of the surface.
              *
              * The height node is designed to use MapBox elevation tile encoded data as described in https://www.mapbox.com/help/access-elevation-data/
              */
             export  class MapHeightNode extends MapNode {
                 /**
                  * Flag indicating if the tile height data was loaded.
                  */
                 heightLoaded: boolean;
                 /**
                  * Flag indicating if the tile texture was loaded.
                  */
                 textureLoaded: boolean;
                 /**
                  * Original tile size of the images retrieved from the height provider.
                  */
                 static tileSize: number;
                 /**
                  * Size of the grid of the geometry displayed on the scene for each tile.
                  */
                 geometrySize: number;
                 /**
                  * If true the tiles will compute their normals.
                  */
                 geometryNormals: boolean;
                 /**
                  * Map node plane geometry.
                  */
                 static geometry: BufferGeometry;
                 /**
                  * Base geometry shared across all the nodes.
                  */
                 static baseGeometry: BufferGeometry;
                 /**
                  * Map height node constructor.
                  *
                  * @param parentNode - The parent node of this node.
                  * @param mapView - Map view object where this node is placed.
                  * @param location - Position in the node tree relative to the parent.
                  * @param level - Zoom level in the tile tree of the node.
                  * @param x - X position of the node in the tile tree.
                  * @param y - Y position of the node in the tile tree.
                  * @param material - Material used to render this height node.
                  * @param geometry - Geometry used to render this height node.
                  */
                 constructor(parentNode?: MapHeightNode, mapView?: MapView, location?: number, level?: number, x?: number, y?: number, geometry?: BufferGeometry, material?: Material);
                 initialize(): Promise<void>;
                 /**
                  * Load tile texture from the server.
                  *
                  * Aditionally in this height node it loads elevation data from the height provider and generate the appropiate maps.
                  */
                 loadData(): Promise<void>;
                 /**
                  * Load height texture from the server and create a geometry to match it.
                  *
                  * @returns Returns a promise indicating when the geometry generation has finished.
                  */
                 loadHeightGeometry(): Promise<any>;
                 createChildNodes(): void;
                 /**
                  * Overrides normal raycasting, to avoid raycasting when isMesh is set to false.
                  */
                 raycast(raycaster: Raycaster, intersects: Intersection[]): void;
             }

              interface MapInterface<T, KEY extends string | number = string | number> {
                 delete(key: KEY): boolean;
                 has(key: KEY): boolean;
                 get(key: KEY): T | undefined;
                 set(key: KEY, value: T): this;
                 keys(): KEY[];
                 forEach(callback: (value: T, key: KEY) => void): void;
             }

             /**
              * Represents a map tile node inside of the tiles quad-tree
              *
              * Each map node can be subdivided into other nodes.
              *
              * It is intended to be used as a base class for other map node implementations.
              */
             export  abstract class MapNode extends Mesh {
                 /**
                  * Default texture used when texture fails to load.
                  */
                 static defaultTexture: Texture;
                 static defaultTransparentTexture: Texture;
                 /**
                  * The map view object where the node is placed.
                  */
                 mapView: MapView;
                 /**
                  * Parent node (from an upper tile level).
                  */
                 parentNode: MapNode;
                 /**
                  * Index of the map node in the quad-tree parent node.
                  *
                  * Position in the tree parent, can be topLeft, topRight, bottomLeft or bottomRight.
                  */
                 location: number;
                 /**
                  * Tile level of this node.
                  */
                 level: number;
                 /**
                  * Tile x position.
                  */
                 x: number;
                 /**
                  * Tile y position.
                  */
                 y: number;
                 /**
                  * Variable to check if the node is subdivided.
                  *
                  * To avoid bad visibility changes on node load.
                  */
                 subdivided: boolean;
                 /**
                  * Flag to indicate if the map node was disposed.
                  *
                  * When a map node is disposed its resources are dealocated to save memory.
                  */
                 disposed: boolean;
                 /**
                  * Indicates how many children nodes are loaded.
                  *
                  * The child on become visible once all of them are loaded.
                  */
                 nodesLoaded: number;
                 /**
                  * Cache with the children objects created from subdivision.
                  *
                  * Used to avoid recreate object after simplification and subdivision.
                  *
                  * The default value is null. Only used if "cacheTiles" is set to true.
                  */
                 childrenCache: Object3D[];
                 /**
                  * Base geometry is attached to the map viewer object.
                  *
                  * It should have the full size of the world so that operations over the MapView bounding box/sphere work correctly.
                  */
                 static baseGeometry: BufferGeometry;
                 /**
                  * How many children each branch of the tree has.
                  *
                  * For a quad-tree this value is 4.
                  */
                 static childrens: number;
                 /**
                  * Flag to check if the node is a mesh by the renderer.
                  *
                  * Used to toggle the visibility of the node. The renderer skips the node rendering if this is set false.
                  */
                 isMesh: true;
                 constructor(parentNode?: MapNode, mapView?: MapView, location?: number, level?: number, x?: number, y?: number, geometry?: BufferGeometry, material?: Material);
                 /**
                  * Initialize resources that require access to data from the MapView.
                  *
                  * Called automatically by the constructor for child nodes and MapView when a root node is attached to it.
                  */
                 initialize(): Promise<void>;
                 /**
                  * Create the child nodes to represent the next tree level.
                  *
                  * These nodes should be added to the object, and their transformations matrix should be updated.
                  */
                 createChildNodes(): void;
                 /**
                  * Subdivide node,check the maximum depth allowed for the tile provider.
                  *
                  * Uses the createChildNodes() method to actually create the child nodes that represent the next tree level.
                  */
                 subdivide(): void;
                 /**
                  * Simplify node, remove all children from node, store them in cache.
                  *
                  * Reset the subdivided flag and restore the visibility.
                  *
                  * This base method assumes that the node implementation is based off Mesh and that the isMesh property is used to toggle visibility.
                  */
                 simplify(): void;
                 /**
                  * Load tile texture from the server.
                  *
                  * This base method assumes the existence of a material attribute with a map texture.
                  */
                 loadData(): Promise<void>;
                 /**
                  * Increment the child loaded counter.
                  *
                  * Should be called after a map node is ready for display.
                  */
                 nodeReady(): void;
                 /**
                  * Dispose the map node and its resources.
                  *
                  * Should cancel all pending processing for the node.
                  */
                 dispose(): void;
             }

             /**
              * Map node geometry is a geometry used to represent the map nodes.
              *
              * Consists of a XZ plane with normals facing +Y.
              *
              * The geometry points start in XZ plane that can be manipulated for example for height adjustment.
              *
              * Geometry can also include skirts to mask off missalignments between tiles.
              */
             export  class MapNodeGeometry extends BufferGeometry {
                 /**
                  * Map node geometry constructor.
                  *
                  * @param width - Width of the node.
                  * @param height - Height of the node.
                  * @param widthSegments - Number of subdivisions along the width.
                  * @param heightSegments - Number of subdivisions along the height.
                  * @param skirt - Skirt around the plane to mask gaps between tiles.
                  */
                 constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number, skirt?: boolean, skirtDepth?: number);
                 static buildPlane(width: number, height: number, widthSegments: number, heightSegments: number, indices: number[], vertices: number[], normals: number[], uvs: number[]): void;
                 static buildSkirt(width: number, height: number, widthSegments: number, heightSegments: number, skirtDepth: number, indices: number[], vertices: number[], normals: number[], uvs: number[]): void;
             }

             export  class MapNodeHeightGeometry extends BufferGeometry {
                 /**
                  * Map node geometry constructor.
                  *
                  * @param width - Width of the node.
                  * @param height - Height of the node.
                  * @param widthSegments - Number of subdivisions along the width.
                  * @param heightSegments - Number of subdivisions along the height.
                  * @param skirt - Skirt around the plane to mask gaps between tiles.
                  */
                 constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number, skirt?: boolean, skirtDepth?: number, imageData?: ImageData, calculateNormals?: boolean, heightScale?: number);
                 /**
                  * Compute normals for the height geometry.
                  *
                  * Only computes normals for the surface of the map geometry. Skirts are not considered.
                  *
                  * @param widthSegments - Number of segments in width.
                  * @param heightSegments - Number of segments in height.
                  */
                 computeNormals(widthSegments: number, heightSegments: number): void;
             }

             export  enum MapOpenWay {
                 /** . */
                 Memory = "Memory",
                 /**  */
                 GeomRender = "GeomRender"
             }

             /**
              * Represents a basic plane tile node.
              */
             export  class MapPlaneNode extends MapNode {
                 constructor(parentNode?: any, mapView?: any, location?: number, level?: number, x?: number, y?: number);
                 /**
                  * Map node plane geometry.
                  */
                 static geometry: BufferGeometry;
                 static baseGeometry: BufferGeometry;
                 initialize(): Promise<void>;
                 createChildNodes(): void;
                 /**
                  * Overrides normal raycasting, to avoid raycasting when isMesh is set to false.
                  */
                 raycast(raycaster: Raycaster, intersects: Intersection[]): void;
             }

             /**
              * A map provider is a object that handles the access to map tiles of a specific service.
              *
              * They contain the access configuration and are responsible for handling the map theme size etc.
              *
              * MapProvider should be used as a base for all the providers.
              */
             export  class MapProvider {
                 /**
                  * Name of the map provider
                  */
                 mapView: MapView;
                 /**
                  * Name of the map provider
                  */
                 name: string;
                 /**
                  * Minimum tile level.
                  */
                 minZoom: number;
                 /**
                  * Maximum tile level.
                  */
                 maxZoom: number;
                 /**
                  * Map bounds.
                  */
                 bounds?: Box2;
                 layers: MapProviderLayer[];
                 options?: MapProviderParameters;
                 constructor(layers: MapProviderLayer | MapProviderLayer[], options?: MapProviderParameters);
                 /**
                  * Get a tile for the x, y, zoom based on the provider configuration.
                  *
                  * The tile should be returned as a image object, compatible with canvas context 2D drawImage() and with webgl texImage2D() method.
                  *
                  * @param zoom - Zoom level.
                  * @param x - Tile x.
                  * @param y - Tile y.
                  * @returns Promise with the image obtained for the tile ready to use.
                  */
                 fetchTile(zoom: number, x: number, y: number): {
                     promise: Promise<any>;
                     layers: MapProviderLayer[];
                 };
             }

              interface MapProviderLayer {
                 /**
                  * Name of the map provider
                  */
                 name?: string;
                 /**
                  * Minimum tile level.
                  */
                 minZoom?: number;
                 /**
                  * Maximum tile level.
                  */
                 maxZoom?: number;
                 /**
                  * Map bounds.
                  */
                 bounds?: [number, number, number, number];
                 opacity?: number;
                 url?: string;
                 tileUrl?: string;
                 fetchTile?: (zoom: number, x: number, y: number) => Promise<any>;
             }

              interface MapProviderParameters extends MeshBasicMaterialParameters {
                 /** [], [0, 0, 0] */
                 rootTile?: [number, number, number];
                 /**  */
                 backColor?: ColorRepresentation;
                 /**  */
                 texture?: {
                     magFilter?: MagnificationTextureFilter;
                     minFilter?: MinificationTextureFilter;
                     [key: string]: any;
                 };
                 /**  */
                 colorFilter?: FilterColorOptions;
             }

              type MapSources<T, Immediate> = {
                 [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : T[K] extends object ? Immediate extends true ? T[K] | undefined : T[K] : never;
             };

             export  class MapThreeLayer {
                 #private;
                 map: any;
                 options: MapThreeLayerOptions;
                 app: App;
                 world: any;
                 worldEntity: Entity;
                 cameraSync: any;
                 scene: Scene;
                 constructor(map: any, options?: MapThreeLayerOptions);
                 init(map: any, options: any): void;
                 update(): void;
                 repaint(): void;
                 onRemove(map: any, gl: any): void;
             }

             export  interface MapThreeLayerOptions extends AppOptions {
                 passiveRendering?: boolean;
             }

             /**
              * @deprecated
              */
              const mapToColor: typeof lerp_3;

              type MapToType<T extends Dictionary<any>, S> = {
                 [P in keyof T]: T[P] extends Dictionary<any> ? MapToType<T[P], S> : S;
             };

             export  class MapUtils {
                 /** The equatorial semi perimeter in meters. */
                 static EQUATORIAL_SEMIPERIMETER: number;
                 /** The equatorial semi perimeter in meters. */
                 static EARTH_BOUNDS: [number, number, number, number];
                 /**
                  *  .
                  * @param pt 
                  * @param isMercatorNormalize 0-1
                  */
                 static lngLatToMercator(pt: [number, number], isMercatorNormalize?: boolean): [number, number];
                 /**
                  *  .
                  * @param pt 
                  * @param isMercatorNormalize 
                  */
                 static mercatorToLngLat(pt: [number, number], isMercatorNormalize?: boolean): [number, number];
                 /**
                  * 
                  * @param pt 
                  * @param mapBounds 
                  */
                 static toNormalize(pt: [number, number], mapBounds?: [number, number, number, number]): [number, number];
                 /**
                  *  .
                  * @param pt 
                  * @param mapBounds 
                  */
                 static fromNormalize(pt: [number, number], mapBounds?: [number, number, number, number]): [number, number];
                 /**
                  * (epsg:3857)
                  * @param pt 
                  * @param mapBounds  [minx, miny,maxx, maxy]
                  *  @param isMercatorNormalize 0-1
                  * @return {[number, number]}
                  */
                 static toMercator(pt: [number, number], mapBounds: [number, number, number, number], isMercatorNormalize?: boolean): [number, number];
                 /**
                  * (epsg:3857)
                  * @param pt 
                  * @param mapBounds  [minx, miny,maxx, maxy]
                  * @param isMercatorNormalize 
                  * @return {[number, number]}
                  */
                 static fromMercator(pt: [number, number], mapBounds: [number, number, number, number], isMercatorNormalize?: boolean): [number, number];
                 /**
                  * 
                  */
                 static WebMapCoordType: {
                     unknown: number;
                     LngLat: number;
                     Mercator: number;
                     NormalizeMercator: number;
                 };
                 /**
                  *  0-1
                  */
                 static getLikeCoordType(pt: [number, number] | [number, number][]): number;
                 /**
                  * getTileBBox
                  *
                  * @param    {Number}  x  Tile coordinate x
                  * @param    {Number}  y  Tile coordinate y
                  * @param    {Number}  z  Tile zoom
                  * @returns  {String}  String of the bounding box
                  */
                 static getTileBBox(x: any, y: any, z: any): string;
                 /**
                  * 
                  *
                  * @param    {Number}  x  Tile coordinate x
                  * @param    {Number}  y  Tile coordinate y
                  * @param    {Number}  z  Tile zoom
                  * @returns  {String}  String of the bounding box
                  */
                 static getTileMercator(x: any, y: any, z: any): [number, number, number, number];
                 /**
                  * getMercCoords
                  *
                  * @param    {Number}  x  Pixel coordinate x
                  * @param    {Number}  y  Pixel coordinate y
                  * @param    {Number}  z  Tile zoom
                  * @returns  {Array}   [x, y]
                  */
                 static getMercCoords(x: any, y: any, z: any): number[];
                 static fetchDebugTile(zoom: number, x: number, y: number, startColor?: ColorRepresentation, endColor?: ColorRepresentation, borderColor?: ColorRepresentation, resolution?: number): Promise<any>;
             }

             /**
              * Map viewer is used to read and display map tiles from a server.
              *
              * It was designed to work with a OpenMapTiles but can also be used with another map tiles.
              *
              * The map is drawn in plane map nodes using a quad tree that is subdivided as necessary to guaratee good map quality.
              */
             export  class MapView extends Mesh {
                 #private;
                 /**
                  * Planar map projection.
                  */
                 static PLANAR: number;
                 /**
                  * Spherical map projection.
                  */
                 /**
                  * Planar map projection with height deformation.
                  */
                 static HEIGHT: number;
                 /**
                  * Planar map projection with height deformation using the GPU for height generation.
                  */
                 static HEIGHT_SHADER: number;
                 /**
                  * RTIN map mode.
                  */
                 static MARTINI: number;
                 /**
                  * Map of the map node types available.
                  */
                 static mapModes: Map<number, any>;
                 /**
                  * LOD control object used to defined how tiles are loaded in and out of memory.
                  */
                 lod: LODControl;
                 /**
                  * Map tile color layer provider.
                  */
                 provider: MapProvider;
                 /**
                  * Map height (terrain elevation) layer provider.
                  *
                  * Only used for HEIGHT, HEIGHT_SHADER and MARTINI map modes.
                  */
                 heightProvider: MapProvider;
                 /**
                  * Define the type of map node in use, defined how the map is presented.
                  *
                  * Should only be set on creation.
                  */
                 root: MapNode;
                 /**
                  * Indicate if the nodes should cache its children when it is simplified. Nodes that are no longer in use should be kept in memory.
                  *
                  * Usefull for fast moving scenarios to prevent reparsing data in fast moving scenes.
                  *
                  * Should only be used if the child generation process is time consuming. Should be kept off unless required.
                  */
                 cacheTiles: boolean;
                 scheduler: Scheduler;
                 useScheduler: boolean;
                 isClip?: boolean;
                 options: MapViewOption;
                 /**
                  * Constructor for the map view objects.
                  *
                  * @param root - Map view node modes can be HEIGHT or PLANAR. PLANAR is used by default. Can also be a custom MapNode instance.
                  * @param provider - Map color tile provider by default a OSM maps provider is used if none specified.
                  * @param heightProvider - Map height tile provider, by default no height provider is used.
                  */
                 constructor(options: MapViewOption);
                 /**
                  * Ajust node configuration depending on the camera distance.
                  *
                  * Called everytime automatically before render by the renderer.
                  */
                 onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group_2) => void;
                 /**
                  * 
                  */
                 mapToLocal(point: [number, number]): Vector3;
                 /**
                  * 
                  */
                 localToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 mapToWorld(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 worldToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 lngLatToLocal(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 localToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 lngLatToWorld(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 worldToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * , []rootTile0-1
                  */
                 lngLatToNormalize(lngLat: [number, number]): [number, number];
                 getMapBounds(): [number, number, number, number];
                 worldResolution(): number;
                 /**
                  *  (mapBoundscadmapBounds)
                  */
                 isWebBaseMap(): boolean;
                 clip(): void;
                 /**
                  * Set the root of the map view.
                  *
                  * Is set by the constructor by default, can be changed in runtime.
                  *
                  * @param root - Map node to be used as root.
                  */
                 setRoot(root: (MapNode | number)): void;
                 /**
                  * Pre-subdivide map tree to create nodes of levels not available in the provider.
                  *
                  * Checks for the minimum zoom level in the providers attached to the map view.
                  */
                 preSubdivide(): void;
                 /**
                  * Change the map provider of this map view.
                  *
                  * Will discard all the tiles already loaded using the old provider.
                  */
                 setProvider(provider: MapProvider): void;
                 /**
                  * Change the map height provider of this map view.
                  *
                  * Will discard all the tiles already loaded using the old provider.
                  */
                 setHeightProvider(heightProvider: MapProvider): void;
                 /**
                  * Clears all tiles from memory and reloads data. Used when changing the provider.
                  *
                  * Should be called manually if any changed to the provider are made without setting the provider.
                  */
                 clear(): any;
                 /**
                  * Get the minimum zoom level available in the providers attached to the map view.
                  *
                  * @returns Minimum zoom level available.
                  */
                 minZoom(): number;
                 /**
                  * Get the maximum zoom level available in the providers attached to the map view.
                  *
                  * @returns Maximum zoom level available.
                  */
                 maxZoom(): number;
                 raycast(raycaster: Raycaster, intersects: any[]): boolean;
             }

             /**
              * 
              */
             export  class MapViewEntity extends MeshEntity {
                 map: MapView;
                 constructor(mapOptions: MapViewOption, meshOptions?: MapViewEntityOptions);
                 /**
                  * 
                  */
                 mapToLocal(point: [number, number]): Vector3;
                 /**
                  * 
                  */
                 localToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 mapToWorld(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 worldToMap(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 lngLatToLocal(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 localToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * 
                  */
                 lngLatToWorld(lngLat: [number, number]): Vector3;
                 /**
                  * 
                  */
                 worldToLngLat(world: [number, number] | [number, number, number] | Vector3): [number, number];
                 /**
                  * , []rootTile0-1
                  */
                 lngLatToNormalize(lngLat: [number, number]): [number, number];
                 getMapBounds(): [number, number, number, number];
                 worldResolution(): number;
                 /**
                  *  (mapBoundscadmapBounds)
                  */
                 isWebBaseMap(): boolean;
                 clip(): void;
                 /**
                  * Set the root of the map view.
                  *
                  * Is set by the constructor by default, can be changed in runtime.
                  *
                  * @param root - Map node to be used as root.
                  */
                 setRoot(root: (MapNode | number)): void;
                 /**
                  * Pre-subdivide map tree to create nodes of levels not available in the provider.
                  *
                  * Checks for the minimum zoom level in the providers attached to the map view.
                  */
                 preSubdivide(): void;
                 /**
                  * Change the map provider of this map view.
                  *
                  * Will discard all the tiles already loaded using the old provider.
                  */
                 setProvider(provider: MapProvider): void;
                 /**
                  * Change the map height provider of this map view.
                  *
                  * Will discard all the tiles already loaded using the old provider.
                  */
                 setHeightProvider(heightProvider: MapProvider): void;
                 /**
                  * Clears all tiles from memory and reloads data. Used when changing the provider.
                  *
                  * Should be called manually if any changed to the provider are made without setting the provider.
                  */
                 clear(): any;
                 /**
                  * Get the minimum zoom level available in the providers attached to the map view.
                  *
                  * @returns Minimum zoom level available.
                  */
                 minZoom(): number;
                 /**
                  * Get the maximum zoom level available in the providers attached to the map view.
                  *
                  * @returns Maximum zoom level available.
                  */
                 maxZoom(): number;
             }

              interface MapViewEntityOptions extends MeshEntityOptions {
                 /**  true*/
                 autoSetAppCurrentMapView?: boolean;
                 /**  true*/
                 disableRayQuery?: boolean;
             }

              interface MapViewOption {
                 root?: number | MapNode;
                 provider: MapProvider;
                 heightProvider?: MapProvider;
                 heightScale?: number;
                 skirtDepthScale?: number;
                 baseScale?: number;
                 mapBounds?: [number, number, number, number];
                 clipPolygon?: [number, number][] | Shape_2;
                 isUseClipOuter?: boolean;
                 isAfterRenderClearStencil?: boolean;
                 lod?: {
                     subdivisionRays?: number;
                     /**
                      * Threshold to subdivide the map tiles.  0.6
                      *
                      * Lower value will subdivide earlier (less zoom required to subdivide).
                      */
                     thresholdUp?: number;
                     /**
                      * Threshold to simplify the map tiles.  0.15
                      *
                      * Higher value will simplify earlier.
                      */
                     thresholdDown?: number;
                     /**
                      * Consider the distance powered to level of the node. false
                      */
                     powerDistance?: boolean;
                     /**
                      * Consider the scale of the node when calculating the distance.. false
                      *
                      * If distance is not considered threshold values should be absolute distances.
                      */
                     scaleDistance?: boolean;
                 };
                 useScheduler?: boolean;
                 polygonOffset?: boolean;
                 polygonOffsetFactor?: number;
                 polygonOffsetUnits?: number;
             }

             /**
              * 2dhtml
              */
             export  class Marker2D extends CSS2DObject {
                 #private;
                 app: App;
                 _anchor: Anchor;
                 _offset: [number, number];
                 _element: HTMLElement;
                 _color?: string;
                 _scale: number;
                 _defaultMarker: boolean;
                 _draggable: boolean;
                 _rotation: number;
                 _clickTolerance: number;
                 _isDragging: boolean;
                 _state: 'inactive' | 'pending' | 'active';
                 _pointerdownPos?: Vector2;
                 _unProjectOpts: UnProjectOpts;
                 _allowOverlap: boolean;
                 _options: Marker2dOptions;
                 _opacity: string;
                 _occlusion: boolean;
                 _popup?: Popup2D;
                 _originalTabIndex?: string;
                 signal: {
                     dragstart: Signal;
                     drag: Signal;
                     dragend: Signal;
                     click: Signal;
                     occlusion: Signal;
                     elementSizeReady: Signal;
                     onAdd: Signal;
                     onRemove: Signal;
                 };
                 isMarker2D: boolean;
                 constructor(options?: Marker2dOptions);
                 isShow(): boolean;
                 show(): void;
                 hide(): void;
                 /**
                  * 
                  *
                  */
                 getPosition(): Vector3;
                 /**
                  * 
                  *
                  */
                 setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): void;
                 _onKeyPress(e: KeyboardEvent): void;
                 togglePopup(): this;
                 setPopup(popup?: Popup2D): this;
                 /**
                  * 
                  *
                  */
                 addTo(app: App | Entity | Object3D, curApp?: App): this;
                 /**
                  * 
                  *
                  */
                 getElement(): Element;
                 /**
                  * 
                  *
                  */
                 getOpacity(): number;
                 /**
                  * 
                  *
                  */
                 setOpacity(opacity: string | number): void;
                 _onMapClick(e: InteractiveEvent): void;
                 _onMove(e: InteractiveEvent): void;
                 _onUp(): void;
                 _addDragHandler(e: InteractiveEvent): void;
                 /**
                  * 
                  */
                 setAllowOverlap(allowOverlap: boolean): void;
                 getBoundingRect(): {
                     x1: number;
                     y1: number;
                     x2: number;
                     y2: number;
                     cx: number;
                     cy: number;
                     rotation: number;
                     position: Vector3;
                     zIndex: number;
                     id: string;
                     groupName: string;
                     setVisible: (visible: any) => void;
                 };
                 /**
                  * 
                  */
                 isAllowOverlap(): boolean;
                 /**
                  * 
                  *
                  */
                 setDraggable(shouldBeDraggable: boolean): this;
                 /**
                  * 
                  *
                  */
                 isDraggable(): boolean;
                 /**
                  * 
                  *
                  */
                 remove(...object: Object3D<Object3DEventMap>[]): this;
                 /**
                  * 
                  * @param animationType
                  * MAP_ANIMATION_NONE 
                  * MAP_ANIMATION_BOUNCE 
                  * MAP_ANIMATION_DROP 
                  */
                 setAnimation(animationType: "MAP_ANIMATION_NONE" | "MAP_ANIMATION_BOUNCE" | "MAP_ANIMATION_DROP" | ""): void;
                 /**
                  * 
                  * @param cur 
                  */
                 setCursor(cur: string): void;
             }

             export  interface Marker2dOptions {
                 /** html */
                 element?: HTMLElement;
                 /**  element*/
                 image?: {
                     /** svg */
                     src: string;
                     /**  */
                     width?: number;
                     /**  */
                     height?: number;
                 };
                 /**  */
                 offset?: [number, number];
                 /**   */
                 position?: [number, number, number] | Vector3;
                 /**  */
                 anchor?: Anchor;
                 /**  */
                 color?: string;
                 /**  */
                 scale?: number;
                 /**  xzxy), shift ctrl */
                 draggable?: boolean;
                 /** (0-360) */
                 rotation?: number;
                 /**  */
                 clickTolerance?: number;
                 /**   */
                 allowOverlap?: boolean;
                 /** zindex */
                 collideZIndex?: number;
                 /** id */
                 collideId?: string;
                 /**   */
                 collideGroupName?: string;
                 /**   */
                 collideIncludePopup?: boolean;
                 /**  */
                 dragUnProjectOpts?: UnProjectOpts;
                 /**  */
                 fadeDistance?: number;
                 /**  */
                 occlusionOpacity?: number;
                 /**  0.1 */
                 disableOpacity?: number;
                 /** )  */
                 dragAsCommand?: boolean;
                 /**  */
                 isHide?: boolean;
             }

             /**
              * 3dhtml
              */
             export  class Marker3D extends Object3D {
                 #private;
                 private _defaultMarker;
                 pixelWidth: number;
                 pixelHeight: number;
                 _options: Marker3dOptions;
                 app: App;
                 css3dObject: CSS3DObject | CSS3DSprite;
                 maskMesh: Mesh | Sprite;
                 _popup?: Popup2D;
                 _originalTabIndex?: string;
                 _opacity: string;
                 _occlusion: boolean;
                 signal: {
                     click: Signal;
                     occlusion: Signal;
                     elementSizeReady: Signal;
                     onAdd: Signal;
                     onRemove: Signal;
                 };
                 isMarker3D: boolean;
                 constructor(options?: Marker3dOptions);
                 isShow(): boolean;
                 show(): void;
                 hide(): void;
                 getElement(): HTMLElement;
                 updateSize(w?: number, h?: number): void;
                 /**
                  * 
                  *
                  */
                 getPosition(): Vector3;
                 /**
                  * 
                  *
                  */
                 setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): void;
                 /**
                  * 
                  *
                  */
                 updatePopupPosition(): void;
                 /**
                  * 
                  *
                  */
                 addTo(app: App | Entity | Object3D, curApp?: App): void;
                 isCss3dSprite(): boolean;
                 togglePopup(): this;
                 /**
                  * 
                  *
                  */
                 getOpacity(): number;
                 /**
                  * 
                  *
                  */
                 setOpacity(opacity: string | number): void;
                 _onMapClick(e: InteractiveEvent): void;
                 _onKeyPress(e: KeyboardEvent): void;
                 setPopup(popup?: Popup2D): this;
                 /**
                  * 
                  *
                  */
                 remove(...object: Object3D<Object3DEventMap>[]): this;
                 /**
                  * 
                  * @param animationType
                  * MAP_ANIMATION_NONE 
                  * MAP_ANIMATION_BOUNCE 
                  * MAP_ANIMATION_DROP 
                  */
                 setAnimation(animationType: "MAP_ANIMATION_NONE" | "MAP_ANIMATION_BOUNCE" | "MAP_ANIMATION_DROP" | ""): void;
                 /**
                  * 
                  * @param cur 
                  */
                 setCursor(cur: string): void;
             }

             export  interface Marker3dOptions {
                 element?: HTMLElement;
                 /**  element*/
                 image?: {
                     /** svg */
                     src: string;
                     /**  */
                     width?: number;
                     /**  */
                     height?: number;
                 };
                 color?: string;
                 width?: number;
                 height?: number;
                 pixelWidth?: number;
                 pixelHeight?: number;
                 asSprite?: boolean;
                 anchor?: Anchor;
                 popupAnchor?: Anchor;
                 popupOffset?: PopopOffset;
                 rotation?: [number, number, number];
                 occlude?: boolean;
                 occludeMaterial?: Record<string, any>;
                 createMaskObject?: boolean;
                 disableOpacity?: number;
                 fadeDistance?: number;
                 occlusionOpacity?: number;
                 /**  */
                 isHide?: boolean;
             }

             /**
              * Marks an object so that it will never be converted to a proxy. Returns the
              * object itself.
              *
              * @example
              * ```js
              * const foo = markRaw({})
              * console.log(isReactive(reactive(foo))) // false
              *
              * // also works when nested inside other reactive objects
              * const bar = reactive({ foo })
              * console.log(isReactive(bar.foo)) // false
              * ```
              *
              * **Warning:** `markRaw()` together with the shallow APIs such as
              * {@link shallowReactive()} allow you to selectively opt-out of the default
              * deep reactive/readonly conversion and embed raw, non-proxied objects in your
              * state graph.
              *
              * @param value - The object to be marked as "raw".
              */
              function markRaw<T extends object>(value: T): Raw<T>;

             /**
              * A 3x3 matrix.
              * Authored by {@link http://github.com/schteppe/ schteppe}
              */
              class Mat3 {
                 /**
                  * A vector of length 9, containing all matrix elements.
                  */
                 elements: number[];
                 /**
                  * @param elements A vector of length 9, containing all matrix elements.
                  */
                 constructor(elements?: number[]);
                 /**
                  * Sets the matrix to identity
                  * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
                  * @todo Create another function that immediately creates an identity matrix eg. `eye()`
                  */
                 identity(): void;
                 /**
                  * Set all elements to zero
                  */
                 setZero(): void;
                 /**
                  * Sets the matrix diagonal elements from a Vec3
                  */
                 setTrace(vector: Vec3): void;
                 /**
                  * Gets the matrix diagonal elements
                  */
                 getTrace(target?: Vec3): Vec3;
                 /**
                  * Matrix-Vector multiplication
                  * @param v The vector to multiply with
                  * @param target Optional, target to save the result in.
                  */
                 vmult(v: Vec3, target?: Vec3): Vec3;
                 /**
                  * Matrix-scalar multiplication
                  */
                 smult(s: number): void;
                 /**
                  * Matrix multiplication
                  * @param matrix Matrix to multiply with from left side.
                  */
                 mmult(matrix: Mat3, target?: Mat3): Mat3;
                 /**
                  * Scale each column of the matrix
                  */
                 scale(vector: Vec3, target?: Mat3): Mat3;
                 /**
                  * Solve Ax=b
                  * @param b The right hand side
                  * @param target Optional. Target vector to save in.
                  * @return The solution x
                  * @todo should reuse arrays
                  */
                 solve(b: Vec3, target?: Vec3): Vec3;
                 /**
                  * Get an element in the matrix by index. Index starts at 0, not 1!!!
                  * @param value If provided, the matrix element will be set to this value.
                  */
                 e(row: number, column: number): number;
                 e(row: number, column: number, value: number): void;
                 /**
                  * Copy another matrix into this matrix object.
                  */
                 copy(matrix: Mat3): Mat3;
                 /**
                  * Returns a string representation of the matrix.
                  */
                 toString(): string;
                 /**
                  * reverse the matrix
                  * @param target Target matrix to save in.
                  * @return The solution x
                  */
                 reverse(target?: Mat3): Mat3;
                 /**
                  * Set the matrix from a quaterion
                  */
                 setRotationFromQuaternion(q: Quaternion_2): Mat3;
                 /**
                  * Transpose the matrix
                  * @param target Optional. Where to store the result.
                  * @return The target Mat3, or a new Mat3 if target was omitted.
                  */
                 transpose(target?: Mat3): Mat3;
             }

             /**
              * Defines a physics material.
              */
              class Material_2 {
                 /**
                  * Material name.
                  * If options is a string, name will be set to that string.
                  * @todo Deprecate this
                  */
                 name: string;
                 /** Material id. */
                 id: number;
                 /**
                  * Friction for this material.
                  * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
                  */
                 friction: number;
                 /**
                  * Restitution for this material.
                  * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
                  */
                 restitution: number;
                 static idCounter: number;
                 constructor(options?: {
                     /**
                      * Friction for this material.
                      * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
                      */
                     friction?: number;
                     /**
                      * Restitution for this material.
                      * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
                      */
                     restitution?: number;
                 } | string);
             }

             export  type MaterialConstructor = new (opts: {
                 [key: string]: any;
             }) => Material;

              type MaterialOptions = ConstructorParameters<typeof Material_2>[0];

              type MaterialParams<T extends MaterialConstructor> = ConstructorParameters<T>[0];

              namespace matrix {
                 export {
                     create,
                     identity,
                     copy,
                     mul,
                     translate,
                     rotate,
                     scale,
                     invert,
                     clone,
                     MatrixArray
                 }
             }

              type MatrixArray = number[];

             /**
              * 
              */
              function max<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

             /**
              *
              * Returns highest value out of 2 supplied
              * @param {number} a
              * @param {number} b
              * @returns {number}
              */
             export  function max2(a: any, b: any): any;

             /**
              * Returns highest value out of 3 supplied
              * @param {number} a
              * @param {number} b
              * @param {number} c
              * @returns {number}
              */
             export  function max3(a: any, b: any, c: any): any;

             export  function maxNumberToInfinity(value: number): number;

             /**  */
             export  function maxValue(arr: number[]): number;

              type MaybeRef<T = any> = T | Ref<T>;

              type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T);

             /**
              * 
              * @param element 
              * @param maxSize 20000
              * @returns
              */
              const measureBoundingRect: (element: Element_2 | Element_2[], maxSize?: number) => BoundingRect;

             export  interface MeasureRulerOptions {
                 /**  */
                 startPoint: Vector3 | [number, number, number];
                 /**  */
                 endPoint: Vector3 | [number, number, number];
                 /** (0,0,0) */
                 planePoint?: Vector3 | [number, number, number];
                 /**  */
                 rulerLineStyle?: LineMaterialParameters_2;
                 /** */
                 sideLineStyle?: LineMaterialParameters_2;
                 /** ,  */
                 sideLineLength?: number;
                 /**  */
                 arrowStyle?: {
                     /**  */
                     color?: ColorRepresentation;
                     /** (0-1) */
                     opacity?: number;
                 };
                 /** ,  */
                 arrowLineLength?: number;
                 /** ,  */
                 arrowLineHeight?: number;
                 /**  */
                 textStyle?: LabelOptions;
                 /** 2 */
                 fractionDigits?: number;
                 /**   1/ 15*/
                 distRatio?: number;
                 /**  true */
                 autoFromWorld?: boolean;
                 /**  */
                 showTextCb?: (ptStart: Vector3, ptEnd: Vector3, dist: number, fractionDigits: number) => string;
                 /**  */
                 textAngleCb?: (ptStart: Vector3, ptEnd: Vector3, quat: Quaternion) => [
                     {
                     axis: Vector3 | "x" | "y" | "z";
                     angle: number;
                 }
                 ] | undefined;
             }

             export  interface MemorizedFunctionColorGenerator {
                 type: 'memorizedFunction';
                 startGen(memory: any): void;
                 genColor(color: Vector4, t: number, memory: any): Vector4;
                 toJSON(): FunctionJSON;
                 clone(): MemorizedFunctionColorGenerator;
             }

              function merge<T extends Dictionary<any>, S extends Dictionary<any>>(target: T, source: S, overwrite?: boolean): T & S;

              function merge<T extends any, S extends any>(target: T, source: S, overwrite?: boolean): T | S;

             /**
              * @param targetAndSources The first item is target, and the rests are source.
              * @param overwrite
              * @return Merged result
              */
              function mergeAll(targetAndSources: any[], overwrite?: boolean): any;

              function mergeAttributes(attributes: BufferAttribute[]): BufferAttribute;

              function mergeGeometries(geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry;

              function mergeGroups(geometry: BufferGeometry): BufferGeometry;

             /**
              * Merge multiple paths
              */
              function mergePath(pathEls: Path[], opts: PathProps): Path<PathProps>;

              function mergeVertices(geometry: BufferGeometry, tolerance?: number): BufferGeometry;

              class MeshBVH {
                 readonly geometry: BufferGeometry;
                 static serialize(bvh: MeshBVH, options?: MeshBVHSerializeOptions): SerializedBVH;
                 static deserialize(data: SerializedBVH, geometry: BufferGeometry, options?: MeshBVHDeserializeOptions): MeshBVH;
                 constructor(geometry: BufferGeometry, options?: MeshBVHOptions);
                 raycast(ray: Ray, materialOrSide: Side | Array<Material> | Material): Array<Intersection>;
                 raycastFirst(ray: Ray, materialOrSide: Side | Array<Material> | Material): Intersection;
                 intersectsSphere(sphere: Sphere): boolean;
                 intersectsBox(box: Box3, boxToMesh: Matrix4): boolean;
                 intersectsGeometry(geometry: BufferGeometry, geometryToBvh: Matrix4): boolean;
                 closestPointToPoint(point: Vector3, target?: HitPointInfo, minThreshold?: number, maxThreshold?: number): HitPointInfo | null;
                 closestPointToGeometry(geometry: BufferGeometry, geometryToBvh: Matrix4, target1?: HitPointInfo, target2?: HitPointInfo, minThreshold?: number, maxThreshold?: number): HitPointInfo | null;
                 shapecast(callbacks: {
                     intersectsBounds: (box: Box3, isLeaf: boolean, score: number | undefined, depth: number, nodeIndex: number) => ShapecastIntersection | boolean;
                     boundsTraverseOrder?: (box: Box3) => number;
                 } & ({
                     intersectsRange: (triangleOffset: number, triangleCount: number, contained: boolean, depth: number, nodeIndex: number, box: Box3) => boolean;
                 } | {
                     intersectsTriangle: (triangle: ExtendedTriangle, triangleIndex: number, contained: boolean, depth: number) => boolean | void;
                 })): boolean;
                 bvhcast(otherBVH: MeshBVH, matrixToLocal: Matrix4, callbacks: ({
                     intersectsRanges: (offset1: number, count1: number, offset2: number, count2: number, depth1: number, index1: number, depth2: number, index2: number) => boolean;
                 } | {
                     intersectsTriangles: (triangle1: ExtendedTriangle, triangle2: ExtendedTriangle, i1: number, i2: number, depth1: number, index1: number, depth2: number, index2: number) => boolean;
                 })): boolean;
                 traverse(callback: (depth: number, isLeaf: boolean, boundingData: ArrayBuffer, offsetOrSplit: number, count: number) => void, rootIndex?: number): void;
                 refit(nodeIndices?: Array<number> | Set<number>): void;
                 getBoundingBox(target: Box3): Box3;
             }

              interface MeshBVHDeserializeOptions {
                 setIndex?: boolean;
             }

              class MeshBVHHelper extends Group_2 {
                 opacity: number;
                 depth: number;
                 displayParents: boolean;
                 displayEdges: boolean;
                 edgeMaterial: LineBasicMaterial;
                 meshMaterial: MeshBasicMaterial;
                 constructor(mesh: Mesh, depth?: number);
                 update(): void;
                 get color(): Color;
             }

              interface MeshBVHOptions {
                 strategy?: SplitStrategy;
                 maxDepth?: number;
                 maxLeafTris?: number;
                 setBoundingBox?: boolean;
                 useSharedArrayBuffer?: boolean;
                 verbose?: boolean;
                 onProgress?: (progress: number) => void;
             }

              interface MeshBVHSerializeOptions {
                 cloneBuffers?: boolean;
             }

              class MeshBVHUniformStruct {
                 updateFrom(bvh: MeshBVH): void;
                 dispose(): void;
             }

             /**
              * mesh
              */
             export  class MeshEntity extends Entity {
                 /**
                  * mesh
                  */
                 mesh: Mesh;
                 /**
                  * 
                  */
                 nativeMaterial: () => Material | Material[];
                 /**
                  * 
                  */
                 useMaterial: () => Material | Material[];
                 /**
                  * 
                  */
                 readonly material: Material | Material[];
                 /**
                  * 
                  * @param option
                  * @param isHideMesh meshfalse)
                  */
                 addEdges: (option?: LineBasicMaterialParameters, isHideMesh?: boolean) => void;
                 /**
                  * 
                  */
                 clearEdges: () => void;
                 /**
                  * 
                  */
                 getEdges: () => any;
                 /**
                  * 
                  */
                 replaceMaterial: (material: Material | Material[]) => void;
                 /**
                  * 
                  */
                 resetMaterial: () => void;
                 /**  */
                 setHeatmapDataMaterial: (options: {
                     /**  */
                     data: {
                         x: number;
                         y: number;
                         z: number;
                         /**  */
                         value: number;
                     }[];
                     /** x 20 */
                     segmentX?: number;
                     /** y 20 */
                     segmentY?: number;
                     /** z 20 */
                     segmentZ?: number;
                     /**  */
                     dataMax?: number;
                     /**  */
                     dataMin?: number;
                     /** [(0-1),] [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]] */
                     colorMap?: [number, number][];
                     /**  100 */
                     colorCount?: number;
                     /**  */
                     interpolation?: {
                         /**  */
                         useInvDistWeight?: boolean;
                         /**  2 */
                         power?: number;
                         /**   exponential*/
                         model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
                         /** sigma2z 0  */
                         sigma2?: number;
                         /** Alpha ,,100 */
                         alpha?: number;
                     };
                 }) => Promise<{
                     lut: Lut;
                     material: ShaderMaterial;
                     reset: () => void;
                 }>;
                 /**
                  * 
                  */
                 isHighlight: () => boolean;
                 /**
                  * 
                  */
                 setHighlight: (color: ColorRepresentation, opacity: number) => {};
                 /**
                  * 
                  */
                 clearHighlight: () => void;
                 /**
                  * 
                  */
                 highlightMaterial: () => Material | Material[];
                 /**
                  * 
                  * @param opacity  0()-1()
                  * @param isAccOpacity (turefalse)
                  */
                 setOpacity: (opacity: number, isAccOpacity?: boolean) => void;
                 /**
                  * 
                  */
                 opacityMaterial: () => Material | Material[];
                 constructor(mesh: Mesh, options?: MeshEntityOptions);
             }

             export  interface MeshEntityOptions extends EntityOptions {
                 selected?: boolean;
                 bloom?: boolean;
                 outline?: boolean;
             }

             export  class MeshLine extends Mesh<MeshLineGeometry, MeshLineMaterial> {
                 readonly isMeshLine = true;
                 readonly type = "MeshLine";
                 raycast(raycaster: Raycaster, intersects: Intersection[]): void;
             }

             export  class MeshLineGeometry extends BufferGeometry {
                 #private;
                 readonly isMeshLineGeometry = true;
                 readonly type = "MeshLineGeometry";
                 /**
                  * A callback to be called for each point to determine the width of the line
                  * at that point. Although `setPoints` accepts this function as an argument,
                  * this has to be a public property so it can be used as a prop in
                  * react-three-fiber.
                  */
                 widthCallback: ((point: number, index: number) => number) | null;
                 smooth?: boolean;
                 curvePointNum?: number;
                 curvePointPosRatio?: number;
                 attributes: Partial<{
                     position: Float32BufferAttribute;
                     previous: Float32BufferAttribute;
                     next: Float32BufferAttribute;
                     side: Float32BufferAttribute;
                     width: Float32BufferAttribute;
                     uv: Float32BufferAttribute;
                     counters: Float32BufferAttribute;
                     index: Uint16BufferAttribute;
                 }>;
                 /**
                  * As an alternative to meshLine.setPoints(points), we can set
                  * meshLine.points = points. This was added for and is public for use as a
                  * prop in react-three-fiber.
                  */
                 get points(): Vector3[] | WritableArrayLike<number>;
                 set points(value: Vector3[] | WritableArrayLike<number>);
                 setPoints(points: Array<Vector3> | WritableArrayLike<number>, widthCallback?: ((point: number, index: number) => number) | null, smooth?: boolean, updateBounds?: boolean): void;
                 /**
                  * Fast method to advance the line by one position.  The oldest position is removed.
                  */
                 advance(position: Vector3): void;
             }

             export  class MeshLineMaterial extends ShaderMaterial {
                 readonly isMeshLineMaterial = true;
                 readonly type = "MeshLineMaterial";
                 uniforms: (typeof UniformsLib)['fog'] & {
                     lineWidth: IUniform<number>;
                     map: IUniform<Texture | null>;
                     useMap: IUniform<boolean>;
                     alphaMap: IUniform<Texture | null>;
                     useAlphaMap: IUniform<boolean>;
                     color: IUniform<Color>;
                     opacity: IUniform<number>;
                     resolution: IUniform<Vector2>;
                     sizeAttenuation: IUniform<boolean>;
                     dashArray: IUniform<number>;
                     dashOffset: IUniform<number>;
                     dashRatio: IUniform<number>;
                     useDash: IUniform<boolean>;
                     visibility: IUniform<number>;
                     alphaTest: IUniform<number>;
                     repeat: IUniform<Vector2>;
                     offset: IUniform<Vector2>;
                     time: IUniform<Vector4>;
                     speed: IUniform<Vector2>;
                 };
                 constructor(parameters: ShaderMaterialParameters & MeshLineMaterial);
                 copy(source: MeshLineMaterial): this;
             }

             export  interface MeshLineMaterial {
                 fogColor: Color;
                 fogDensity: number;
                 fogNear: number;
                 fogFar: number;
                 lineWidth: number;
                 map: Texture;
                 useMap: boolean;
                 alphaMap: Texture;
                 useAlphaMap: boolean;
                 color: Color;
                 opacity: number;
                 resolution?: Vector2 | {
                     value: Vector2;
                 };
                 sizeAttenuation: boolean;
                 dashArray: number;
                 dashOffset: number;
                 dashRatio: number;
                 useDash: boolean;
                 visibility: number;
                 alphaTest: number;
                 repeat: Vector2;
                 offset: Vector2;
                 time?: Vector4 | {
                     value: Vector4;
                 };
                 speed: Vector2;
             }

             /**
              * mesh
              */
             export  class MeshModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 constructor(entity: Entity, options?: MeshModuleOption);
                 /**
                  * mesh
                  */
                 get mesh(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
                 /**
                  * 
                  */
                 rawMaterial(): any;
                 /**
                  * 
                  */
                 useMaterial(): any;
                 /**
                  * 
                  */
                 get material(): any;
                 /**
                  * 
                  * @param option
                  * @param isHideMesh meshfalse)
                  */
                 addEdges(option?: LineBasicMaterialParameters, isHideMesh?: boolean): void;
                 /**
                  * 
                  */
                 clearEdges(): void;
                 /**
                  * 
                  */
                 getEdges(): any;
                 /**
                  * 
                  */
                 replaceMaterial(material: Material | Material[]): void;
                 /**
                  * 
                  */
                 resetMaterial(): void;
                 /**  */
                 setHeatmapDataMaterial(options: {
                     /**  */
                     data: {
                         x: number;
                         y: number;
                         z: number;
                         /**  */
                         value: number;
                     }[];
                     /** x 10 */
                     segmentX?: number;
                     /** y 10 */
                     segmentY?: number;
                     /** z 10 */
                     segmentZ?: number;
                     /**  */
                     dataMax?: number;
                     /**  */
                     dataMin?: number;
                     /** [(0-1),] [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]] */
                     colorMap?: [number, number][];
                     /**  100 */
                     colorCount?: number;
                     /**  */
                     interpolation?: {
                         /**  */
                         useInvDistWeight?: boolean;
                         /**  2 */
                         power?: number;
                         /**   exponential*/
                         model?: "gaussian" | "exponential" | "spherical" | "circle" | "linear";
                         /** sigma2z 0  */
                         sigma2?: number;
                         /** Alpha ,,100 */
                         alpha?: number;
                     };
                     /**  */
                     MaterialParameters?: ShaderMaterialParameters;
                 }): Promise<{
                     lut: Lut;
                     material: ShaderMaterial;
                     reset: () => void;
                 }>;
                 /**
                  * 
                  */
                 isHighlight(): boolean;
                 /**
                  * 
                  */
                 setHighlight(color?: ColorRepresentation, opacity?: number): void;
                 /**
                  * 
                  */
                 clearHighlight(): void;
                 /**
                  * 
                  */
                 highlightMaterial(): any;
                 /**
                  * 
                  * @param opacity  0()-1()
                  * @param isAccOpacity (turefalse)
                  */
                 setOpacity(opacity: number, isAccOpacity?: boolean): void;
                 /**
                  * 
                  */
                 opacityMaterial(): any;
                 onDestroy(): void;
                 toJSON(): {
                     mesh: {
                         uuid: string;
                     };
                 };
                 fromJSON(data: Record<string, any>, objects: Map<string, Object3D>): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface MeshModuleOption {
                 mesh: Mesh;
             }

             export  interface MeshPhysicsObject {
                 body?: CANNON.Body | PhysicsBodyOption;
                 type?: ShapeType2;
                 copyPosition?: boolean;
                 copyQuaternion?: boolean;
             }

             export  interface MeshPhysicsObjectParams extends MeshPhysicsObject {
                 mesh: Object3D | Entity;
             }

             /**
              * A material for reflection, which has blur support.
              */
             export  class MeshReflectorMaterial {
                 app: App;
                 parent: Mesh;
                 material: MeshReflectorMaterialImpl;
                 virtualCamera: PerspectiveCamera;
                 fbo1: WebGLRenderTarget;
                 fbo2: WebGLRenderTarget;
                 blurpass: BlurPass;
                 hasBlur: boolean;
                 ignoreObjects: Object3D[];
                 beforeRender: () => void;
                 constructor(app: App, parent: Mesh, config?: Partial<MeshReflectorMaterialConfig & MeshStandardMaterialParameters>);
                 update(): void;
             }

             export  interface MeshReflectorMaterialConfig {
                 resolution: number;
                 mixBlur: number;
                 mixStrength: number;
                 blur: [number, number] | number;
                 mirror: number;
                 ignoreObjects: Object3D[];
             }

              class MeshReflectorMaterialImpl extends MeshStandardMaterial {
                 _tDepth: UninitializedUniform<Texture>;
                 _distortionMap: UninitializedUniform<Texture>;
                 _tDiffuse: UninitializedUniform<Texture>;
                 _tDiffuseBlur: UninitializedUniform<Texture>;
                 _textureMatrix: UninitializedUniform<Matrix4>;
                 _hasBlur: {
                     value: boolean;
                 };
                 _mirror: {
                     value: number;
                 };
                 _mixBlur: {
                     value: number;
                 };
                 _blurStrength: {
                     value: number;
                 };
                 _minDepthThreshold: {
                     value: number;
                 };
                 _maxDepthThreshold: {
                     value: number;
                 };
                 _depthScale: {
                     value: number;
                 };
                 _depthToBlurRatioBias: {
                     value: number;
                 };
                 _distortion: {
                     value: number;
                 };
                 _mixContrast: {
                     value: number;
                 };
                 constructor(parameters?: {});
                 onBeforeCompile(shader: any): void;
                 get tDiffuse(): Texture | null;
                 set tDiffuse(v: Texture | null);
                 get tDepth(): Texture | null;
                 set tDepth(v: Texture | null);
                 get distortionMap(): Texture | null;
                 set distortionMap(v: Texture | null);
                 get tDiffuseBlur(): Texture | null;
                 set tDiffuseBlur(v: Texture | null);
                 get textureMatrix(): Matrix4 | null;
                 set textureMatrix(v: Matrix4 | null);
                 get hasBlur(): boolean;
                 set hasBlur(v: boolean);
                 get mirror(): number;
                 set mirror(v: number);
                 get mixBlur(): number;
                 set mixBlur(v: number);
                 get mixStrength(): number;
                 set mixStrength(v: number);
                 get minDepthThreshold(): number;
                 set minDepthThreshold(v: number);
                 get maxDepthThreshold(): number;
                 set maxDepthThreshold(v: number);
                 get depthScale(): number;
                 set depthScale(v: number);
                 get depthToBlurRatioBias(): number;
                 set depthToBlurRatioBias(v: number);
                 get distortion(): number;
                 set distortion(v: number);
                 get mixContrast(): number;
                 set mixContrast(v: number);
             }

             export  interface MeshSettings {
                 /**
                  * Rotation axis.
                  * @type {Vector3}
                  */
                 rotationAxis?: Vector3;
                 /**
                  * Initial rotation around the X-axis.
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startRotationX: ValueGenerator | FunctionValueGenerator;
                 /**
                  * Initial rotation around the Y-axis.
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startRotationY: ValueGenerator | FunctionValueGenerator;
                 /**
                  * Initial rotation around the Z-axis.
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startRotationZ: ValueGenerator | FunctionValueGenerator;
             }

             /**
              * A particle emitter that emits particles from the surface of a mesh uniformly.
              */
             export  class MeshSurfaceEmitter implements EmitterShape {
                 type: string;
                 private _triangleIndexToArea;
                 private _geometry?;
                 get geometry(): BufferGeometry | undefined;
                 set geometry(geometry: BufferGeometry | undefined);
                 constructor(geometry?: BufferGeometry);
                 private _tempA;
                 private _tempB;
                 private _tempC;
                 initialize(p: Particle): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any, meta: JsonMetaData): MeshSurfaceEmitter;
                 clone(): EmitterShape;
                 update(system: ParticleSystem, delta: number): void;
             }

             /**
              * Reference: https://blog.maximeheckel.com/posts/refraction-dispersion-and-other-shader-light-effects/
              */
             export  class MeshTransmissionMaterial {
                 fbo: WebGLRenderTarget;
                 fboBack: WebGLRenderTarget;
                 material: ShaderMaterial;
                 parent: Mesh;
                 backside: boolean;
                 background: Texture | Color | null;
                 oldBg: Texture | Color | null;
                 app: App;
                 constructor(app: App, parent: Mesh, config?: Partial<MeshTransmissionMaterialConfig>);
                 update(): void;
             }

             export  interface MeshTransmissionMaterialConfig {
                 backside: boolean;
                 samples: number;
                 background: Texture | Color | null;
                 chromaticAberration: number;
                 refraction: number;
                 saturation: number;
                 lightPosition: Vector3;
                 diffuse: number;
                 specular: number;
                 fresnel: number;
                 fresnelColor: Color;
             }

             /**
              * Interface representing metadata used in Threejs object toJSON method.
              */
             export  interface MetaData {
                 geometries: {
                     [key: string]: any;
                 };
                 materials: {
                     [key: string]: any;
                 };
                 textures: {
                     [key: string]: any;
                 };
                 images: {
                     [key: string]: any;
                 };
                 shapes: {
                     [key: string]: any;
                 };
                 skeletons: {
                     [key: string]: any;
                 };
                 animations: {
                     [key: string]: any;
                 };
                 nodes: {
                     [key: string]: any;
                 };
             }

              interface Methods {
                 GET: "GET";
                 POST: "POST";
                 PUT: "PUT";
                 DELETE: "DELETE";
                 PATCH: "PATCH";
                 OPTIONS: "OPTIONS";
                 HEAD: "HEAD";
             }

             /**
              * 
              */
              function min<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

             /**
              * Returns lowest value out of 2 supplied
              * @param {number} a
              * @param {number} b
              * @returns {number}
              */
             export  function min2(a: any, b: any): any;

             /**
              * Returns lowest value out of 3 supplied
              * @param {number} a
              * @param {number} b
              * @param {number} c
              * @returns {number}
              */
             export  function min3(a: any, b: any, c: any): any;

             /**  */
             export  class MiniMapControl {
                 private container;
                 private panel;
                 private app;
                 private readonly style;
                 options: MiniMapControlOption;
                 private _miniMapRenderer;
                 private mapRotateZ;
                 private _miniMapDomEl;
                 private _miniMapCamera;
                 private mapSyncRotateZ;
                 private followTarget;
                 constructor(options?: MiniMapControlOption);
                 setFollowTarget(followTarget: Object3D): void;
                 insertControl(): void;
                 updateCamera(): void;
                 onAdd(app: App): HTMLElement;
                 onUpdate(): void;
                 onRemove(): void;
                 getDefaultPosition(): string;
             }

             export  interface MiniMapControlOption {
                 /**  */
                 bkDivStyle?: {
                     border: string;
                     backgroundColor: string;
                 };
                 /**  */
                 mapDivStyle?: Partial<CSSStyleDeclaration>;
                 /**  ms*/
                 throttleTime?: number;
                 /**   */
                 scene?: Scene;
                 /**  3D */
                 followTarget?: Object3D;
                 /**  10*/
                 followTargetCameraHeight?: number;
                 /** 10 */
                 mapSize?: number;
                 /** 2D200 */
                 mapRenderSize?: number;
                 /** Z0 */
                 mapRotateZ?: number;
                 /** Ztargetfalse */
                 mapSyncRotateZ?: boolean;
                 /**  */
                 rendererParameters?: WebGLRendererParameters;
                 /**  */
                 shadowMapEnabled?: boolean;
                 /**  */
                 cameraOption?: CameraOptions;
                 /**  true */
                 cameraUpdate?: (camera: Camera, target?: Object3D, context?: any) => boolean;
             }

             /**  */
             export  function minValue(arr: number[]): number;

              function mixin<T, S>(target: T | Function, source: S | Function, override?: boolean): void;

             /**
              * Check if the browser is running on a mobile or tablet device.
              */
             export  function mobileAndTabletCheck(): boolean;

             /**
              * 
              */
             export  class ModelModule extends EntityModuleBase implements IEntityModuleBase {
                 static moduleName: string;
                 modelEntity: Entity;
                 signal: {
                     onLoad: Signal;
                     onError: Signal;
                 };
                 constructor(entity: Entity, options?: ModelModuleOptions);
                 /** Mesh */
                 getMeshEntities(): any[];
             }

             /**
              * 
              */
             export  interface ModelModuleOptions extends ILoadModelOption {
                 url: string;
             }

             /**
              * @param color
              * @param alpha 0 ~ 1
              * @return Color string in rgba format.
              * @memberOf module:render2d/util/color
              */
              function modifyAlpha(color: string, alpha?: number): string;

             /**
              * @param color
              * @param h 0 ~ 360, ignore when null.
              * @param s 0 ~ 1, ignore when null.
              * @param l 0 ~ 1, ignore when null.
              * @return Color string in rgba format.
              * @memberOf module:render2d/util/color
              */
              function modifyHSL(color: string, h?: number, s?: number, l?: number): string;

             export  class ModuleBase extends AppObject {
                 private _awoken;
                 private _phasedActive;
                 private _enabled;
                 appRenderIndex: number;
                 static moduleName: string;
                 /**
                  * Indicates whether the component is enabled.
                  */
                 get enabled(): boolean;
                 set enabled(value: boolean);
             }

             /**
              * 
              */
             export  class ModuleManager {
                 modules: Map<string, ModuleBase[]>;
                 private readonly _isApp;
                 private readonly _orderDirty;
                 constructor(isApp?: boolean);
                 addModule(module: ModuleBase): void;
                 getModules(methodName: string): ModuleBase[];
                 callModules(methodName: string, ...args: any): void;
                 removeModule(module: ModuleBase): void;
             }

             /**
              * Morphing from old path to new path.
              */
              function morphPath(fromPath: Path, toPath: Path, animationOpts: ElementAnimateConfig): Path;

              namespace morphPathTool {
                 export {
                     alignBezierCurves,
                     centroid,
                     isCombineMorphing,
                     isMorphing,
                     morphPath,
                     combineMorph,
                     separateMorph,
                     CombineMorphingPath,
                     DividePathParams,
                     DividePath,
                     IndividualDelay,
                     CombineConfig,
                     SeparateConfig,
                     split as defaultDividePath
                 }
             }

             export  type Motion<T> = {
                 [key in keyof FilteredType<T>]: FilteredType<T>[key];
             };

             /**
              * Interface for configuring motion animations in a Tween.
              * You can specify easing, callback functions, and progress tracking functions.
              * @template T - The type of the target object being tweened.
              */
             export  interface MotionConfig<T = any> {
                 /** The easing function to control the animation's progression. */
                 easing?: Easing;
                 /**
                  * A callback function to execute when the animation completes.
                  * @param target - The target object that was tweened.
                  * @param isEnd 
                  * @param isStop 
                  */
                 onComplete?: (target: T, isEnd: boolean, isStop: boolean) => void;
                 /**
                  * A callback function to execute when the animation starts.
                  * @param target - The target object that is being tweened.
                  */
                 onStart?: (target: T) => void;
                 /**
                  * A callback function to be executed after each property has been updated.
                  * @param target - The target object that is being tweened.
                  */
                 onUpdate?: (target: T) => void;
                 /**
                  * A callback function to be executed before each property is updated.
                  * @param target - The target object that is being tweened.
                  * @param key - The key or property being animated.
                  * @param start - The initial value of the animated property.
                  * @param end - The final value of the animated property.
                  * @param alpha - The current animation progress as a normalized value (0 to 1).
                  * @param reversed - 
                  * @returns If `false`, will not assign a new value to the property.
                  */
                 onProgress?: (target: T, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
             }

              const MOUSE_BUTTON: {
                 readonly LEFT: 1;
                 readonly RIGHT: 2;
                 readonly MIDDLE: 4;
             };

              type MOUSE_BUTTON = typeof MOUSE_BUTTON[keyof typeof MOUSE_BUTTON];

              type mouseButtonAction = typeof ACTION.ROTATE | typeof ACTION.TRUCK | typeof ACTION.OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

              interface MouseButtons {
                 left: mouseButtonAction;
                 middle: mouseButtonAction;
                 right: mouseButtonAction;
                 wheel: mouseWheelAction;
             }

             /**  */
             export  class MousePositionControl {
                 #private;
                 private readonly digits;
                 private readonly trackCenter;
                 private readonly labelFormat;
                 private container;
                 private panel;
                 private app;
                 private readonly style;
                 private unProjectModes?;
                 constructor(options?: MousePositionControlOption);
                 insertControl(): void;
                 defaultLabelFormat(x: number, y: number, z: number): string;
                 onMouseMove(evt?: any): Promise<void>;
                 onAdd(app: App): HTMLElement;
                 onRemove(): void;
                 getDefaultPosition(): string;
             }

             export  interface MousePositionControlOption {
                 digits?: number;
                 trackCenter?: boolean;
                 labelFormat?: (x: number, y: number, z: number, context: MousePositionControl, retIntersectObject?: any) => string;
                 style?: {
                     border: string;
                     backgroundColor: string;
                 };
                 UnProjectModes?: (UnProjectOpts | "depth")[];
             }

              type mouseWheelAction = typeof ACTION.ROTATE | typeof ACTION.TRUCK | typeof ACTION.OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

             /**
              * 
              */
              function mul(out: MatrixArray, m1: MatrixArray, m2: MatrixArray): MatrixArray;

             /**
              * 
              */
              function mul_2<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

             export  class MultiCmdsCommand extends BaseCommand {
                 private commands;
                 constructor(commands: ICommand[]);
                 execute(): void;
                 undo(): void;
                 redo(): void;
                 addCommand(cmd: ICommand | ICommand[]): void;
                 execCommand(cmd: ICommand | ICommand[]): void;
                 getCommands(): ICommand[];
             }

             /**
              * ,
              * @param lines
              * @param epsilon  1e-6
              */
             export  function multiLine3dSplit(lines: Vector3[][], epsilon?: number): {
                 status: boolean;
                 error: string;
                 lines?: undefined;
                 indexs?: undefined;
             } | {
                 status: boolean;
                 lines: Vector3[][];
                 indexs: any[];
                 error?: undefined;
             };

             /**
              * ,
              * @param lines
              * @param dotErr 6
              */
             export  function multiLineSplit(lines: GeoPoint[][], dotErr?: number): GeoPoint[][];

             /**
              * MultiLineString Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.5
              */
              interface MultiLineString extends GeometryObject {
                 type: "MultiLineString";
                 coordinates: Position[][];
             }

             /**
              * MultiPoint Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.3
              */
              interface MultiPoint extends GeometryObject {
                 type: "MultiPoint";
                 coordinates: Position[];
             }

             /**
              * MultiPolygon Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.7
              */
              interface MultiPolygon extends GeometryObject {
                 type: "MultiPolygon";
                 coordinates: Position[][][];
             }

              type multiTouchAction = typeof ACTION.TOUCH_DOLLY_ROTATE | typeof ACTION.TOUCH_DOLLY_TRUCK | typeof ACTION.TOUCH_DOLLY_OFFSET | typeof ACTION.TOUCH_ZOOM_ROTATE | typeof ACTION.TOUCH_ZOOM_TRUCK | typeof ACTION.TOUCH_ZOOM_OFFSET | typeof ACTION.TOUCH_DOLLY | typeof ACTION.TOUCH_ZOOM | typeof ACTION.TOUCH_ROTATE | typeof ACTION.TOUCH_TRUCK | typeof ACTION.TOUCH_OFFSET | typeof ACTION.NONE;

              type MultiWatchSources = Array<WatchSource<unknown> | object>;

             /**
              * Naive broadphase implementation, used in lack of better ones.
              *
              * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
              */
              class NaiveBroadphase extends Broadphase {
                 /**
                  * @todo Remove useless constructor
                  */
                 constructor();
                 /**
                  * Get all the collision pairs in the physics world
                  */
                 collisionPairs(world: World, pairs1: Body_2[], pairs2: Body_2[]): void;
                 /**
                  * Returns all the bodies within an AABB.
                  * @param result An array to store resulting bodies in.
                  */
                 aabbQuery(world: World, aabb: AABB, result?: Body_2[]): Body_2[];
             }

             /**
              * Helper class for the World. Generates ContactEquations.
              * @todo Sphere-ConvexPolyhedron contacts
              * @todo Contact reduction
              * @todo should move methods to prototype
              */
              class Narrowphase {
                 /**
                  * Internal storage of pooled contact points.
                  */
                 contactPointPool: ContactEquation[];
                 frictionEquationPool: FrictionEquation[];
                 result: ContactEquation[];
                 frictionResult: FrictionEquation[];
                 /**
                  * Pooled vectors.
                  */
                 v3pool: Vec3Pool;
                 world: World;
                 currentContactMaterial: ContactMaterial;
                 enableFrictionReduction: boolean;
                 get [COLLISION_TYPES.sphereSphere](): (si: Sphere_2, sj: Sphere_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => boolean | void;
                 get [COLLISION_TYPES.spherePlane](): (si: Sphere_2, sj: Plane_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.boxBox](): (si: Box, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.sphereBox](): (si: Sphere_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.planeBox](): (si: Plane_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.convexConvex](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
                 get [COLLISION_TYPES.sphereConvex](): (si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.planeConvex](): (planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.boxConvex](): (si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.sphereHeightfield](): (sphereShape: Sphere_2, hfShape: Heightfield, spherePos: Vec3, hfPos: Vec3, sphereQuat: Quaternion_2, hfQuat: Quaternion_2, sphereBody: Body_2, hfBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.boxHeightfield](): (si: Box, sj: Heightfield, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.convexHeightfield](): (convexShape: ConvexPolyhedron, hfShape: Heightfield, convexPos: Vec3, hfPos: Vec3, convexQuat: Quaternion_2, hfQuat: Quaternion_2, convexBody: Body_2, hfBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.sphereParticle](): (sj: Sphere_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.planeParticle](): (sj: Plane_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.boxParticle](): (si: Box, sj: Particle2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.convexParticle](): (sj: ConvexPolyhedron, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.cylinderCylinder](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
                 get [COLLISION_TYPES.sphereCylinder](): (si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.planeCylinder](): (planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.boxCylinder](): (si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.convexCylinder](): (si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean, faceListA?: number[], faceListB?: number[]) => true | void;
                 get [COLLISION_TYPES.heightfieldCylinder](): (hfShape: Heightfield, convexShape: Cylinder, hfPos: Vec3, convexPos: Vec3, hfQuat: Quaternion_2, convexQuat: Quaternion_2, hfBody: Body_2, convexBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.particleCylinder](): (si: Particle2, sj: Cylinder, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.sphereTrimesh](): (sphereShape: Sphere_2, trimeshShape: Trimesh, spherePos: Vec3, trimeshPos: Vec3, sphereQuat: Quaternion_2, trimeshQuat: Quaternion_2, sphereBody: Body_2, trimeshBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 get [COLLISION_TYPES.planeTrimesh](): (planeShape: Plane_2, trimeshShape: Trimesh, planePos: Vec3, trimeshPos: Vec3, planeQuat: Quaternion_2, trimeshQuat: Quaternion_2, planeBody: Body_2, trimeshBody: Body_2, rsi?: Shape, rsj?: Shape, justTest?: boolean) => true | void;
                 constructor(world: World);
                 /**
                  * Make a contact object, by using the internal pool or creating a new one.
                  */
                 createContactEquation(bi: Body_2, bj: Body_2, si: Shape, sj: Shape, overrideShapeA?: Shape | null, overrideShapeB?: Shape | null): ContactEquation;
                 createFrictionEquationsFromContact(contactEquation: ContactEquation, outArray: FrictionEquation[]): boolean;
                 /**
                  * Take the average N latest contact point on the plane.
                  */
                 createFrictionFromAverage(numContacts: number): void;
                 /**
                  * Generate all contacts between a list of body pairs
                  * @param p1 Array of body indices
                  * @param p2 Array of body indices
                  * @param result Array to store generated contacts
                  * @param oldcontacts Optional. Array of reusable contact objects
                  */
                 getContacts(p1: Body_2[], p2: Body_2[], world: World, result: ContactEquation[], oldcontacts: ContactEquation[], frictionResult: FrictionEquation[], frictionPool: FrictionEquation[]): void;
                 sphereSphere(si: Sphere_2, sj: Sphere_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): boolean | void;
                 spherePlane(si: Sphere_2, sj: Plane_2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 boxBox(si: Box, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 sphereBox(si: Sphere_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 planeBox(si: Plane_2, sj: Box, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 convexConvex(si: ConvexPolyhedron, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean, faceListA?: number[] | null, faceListB?: number[] | null): true | void;
                 sphereConvex(si: Sphere_2, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 planeConvex(planeShape: Plane_2, convexShape: ConvexPolyhedron, planePosition: Vec3, convexPosition: Vec3, planeQuat: Quaternion_2, convexQuat: Quaternion_2, planeBody: Body_2, convexBody: Body_2, si?: Shape, sj?: Shape, justTest?: boolean): true | void;
                 boxConvex(si: Box, sj: ConvexPolyhedron, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 sphereHeightfield(sphereShape: Sphere_2, hfShape: Heightfield, spherePos: Vec3, hfPos: Vec3, sphereQuat: Quaternion_2, hfQuat: Quaternion_2, sphereBody: Body_2, hfBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 boxHeightfield(si: Box, sj: Heightfield, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 convexHeightfield(convexShape: ConvexPolyhedron, hfShape: Heightfield, convexPos: Vec3, hfPos: Vec3, convexQuat: Quaternion_2, hfQuat: Quaternion_2, convexBody: Body_2, hfBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 sphereParticle(sj: Sphere_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 planeParticle(sj: Plane_2, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 boxParticle(si: Box, sj: Particle2, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 convexParticle(sj: ConvexPolyhedron, si: Particle2, xj: Vec3, xi: Vec3, qj: Quaternion_2, qi: Quaternion_2, bj: Body_2, bi: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 heightfieldCylinder(hfShape: Heightfield, convexShape: Cylinder, hfPos: Vec3, convexPos: Vec3, hfQuat: Quaternion_2, convexQuat: Quaternion_2, hfBody: Body_2, convexBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 particleCylinder(si: Particle2, sj: Cylinder, xi: Vec3, xj: Vec3, qi: Quaternion_2, qj: Quaternion_2, bi: Body_2, bj: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 sphereTrimesh(sphereShape: Sphere_2, trimeshShape: Trimesh, spherePos: Vec3, trimeshPos: Vec3, sphereQuat: Quaternion_2, trimeshQuat: Quaternion_2, sphereBody: Body_2, trimeshBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
                 planeTrimesh(planeShape: Plane_2, trimeshShape: Trimesh, planePos: Vec3, trimeshPos: Vec3, planeQuat: Quaternion_2, trimeshQuat: Quaternion_2, planeBody: Body_2, trimeshBody: Body_2, rsi?: Shape | null, rsj?: Shape | null, justTest?: boolean): true | void;
             }

              const nativeSlice: (start?: number, end?: number) => any[];

             /**
              * 
              */
              function negate<T extends VectorArray>(out: T, v: VectorArray): T;

              class Node_2 {
                 id: string;
                 inputs: (Wire | ConstInput | Adapter | undefined)[];
                 outputs: Wire[][];
                 definition: NodeDef;
                 signatureIndex: number;
                 data: NodeData;
                 position: Vector2;
                 outputValues: any[];
                 constructor(definition: NodeDef, signatureIndex?: number, data?: NodeData);
                 get inputTypes(): NodeValueType[];
                 get outputTypes(): NodeValueType[];
                 func(context: ExecutionContext, inputs: any[], outputs: any[]): void;
             }
             export { Node_2 as Node }

             export  type NodeData = {
                 [key: string]: any;
             };

             export  class NodeDef {
                 name: string;
                 type: NodeType;
                 nodeTypeSignatures: NodeTypeSignature[];
                 constructor(name: string, type: NodeType);
                 addSignature(inputTypes: NodeValueType[], outputTypes: NodeValueType[], func: NodeExecFunction): void;
             }

              type NodeExecFunction = (context: ExecutionContext, data: NodeData, inputs: NodeValue[], outputs: NodeValue[]) => void;

             export  class NodeGraph {
                 uuid: string;
                 name: string;
                 version: string;
                 revision: number;
                 inputNodes: Node_2[];
                 outputNodes: Node_2[];
                 allNodes: Map<string, Node_2>;
                 wires: Wire[];
                 compiled: boolean;
                 nodesInOrder: Array<Node_2>;
                 constructor(name: string);
                 addWire(wire: Wire): void;
                 addNode(node: Node_2): void;
                 getNode(id: string): Node_2 | undefined;
                 deleteNode(node: Node_2): void;
                 deleteWire(wire: Wire): void;
                 toJSON(): any;
                 clone(): NodeGraph;
             }

              type NodeId = string;

             /**
              * Particle implementation for node-based particle systems.
              */
             export  class NodeParticle implements IParticle {
                 /**
                  * Position of the particle.
                  * @type {Vector3}
                  */
                 position: Vector3;
                 /**
                  * Velocity of the particle.
                  * @type {Vector3}
                  */
                 velocity: Vector3;
                 /**
                  * Age of the particle.
                  * @type {number}
                  */
                 age: number;
                 /**
                  * Life duration of the particle.
                  * @type {number}
                  */
                 life: number;
                 /**
                  * Size of the particle.
                  * @type {number}
                  */
                 size: number;
                 /**
                  * Angular velocity of the particle.
                  * @type {number | Quaternion}
                  */
                 angularVelocity?: number | Quaternion;
                 /**
                  * Rotation of the particle.
                  * @type {number | Quaternion}
                  */
                 rotation: number | Quaternion;
                 /**
                  * Color of the particle.
                  * @type {Vector4}
                  */
                 color: Vector4;
                 /**
                  * UV tile index.
                  * @type {number}
                  */
                 uvTile: number;
                 /**
                  * Indicates if the particle has died.
                  * @type {boolean}
                  */
                 get died(): boolean;
                 /**
                  * Resets the particle properties to initial values.
                  */
                 reset(): void;
             }

             export  enum NodeType {
                 Variable = 0,
                 Expression = 1,
                 Storage = 2,
                 Function = 3
             }

             export  const NodeTypes: {
                 [key: string]: NodeDef;
             };

             export  interface NodeTypeSignature {
                 inputTypes: NodeValueType[];
                 outputTypes: NodeValueType[];
                 func: NodeExecFunction;
             }

              type NodeValue = number | boolean | Vector2 | Vector3 | Vector4 | Array<any>;

             export  enum NodeValueType {
                 Number = 0,
                 Vec2 = 1,
                 Vec3 = 2,
                 Vec4 = 3,
                 Boolean = 4,
                 AnyType = 5,
                 NullableAnyType = 6,
                 EventStream = 7
             }

             /**
              * NodeVFX represents a node graph based visual effect
              *
              * @class
              */
             export  class NodeVFX implements IParticleSystem {
                 signal: {
                     onRestart: Signal;
                     onPlay: Signal;
                     onPause: Signal;
                     onEnd: Signal;
                 };
                 emissionGraph: NodeGraph;
                 updateGraph: NodeGraph;
                 interpreter: Interpreter;
                 /**
                  * Determines whether the ParticleSystem should be automatically disposed when it finishes emitting particles.
                  *
                  * @type {boolean}
                  */
                 autoDestroy: boolean;
                 /**
                  * Determines whether a looping ParticleSystem should prewarm, i.e., the Particle System looks like it has already simulated for one loop when first becoming visible.
                  *
                  * @type {boolean}
                  */
                 prewarm: boolean;
                 /**
                  * Determines whether the ParticleSystem should loop, i.e., restart emitting particles after the duration of the particle system is expired.
                  *
                  * @type {boolean}
                  */
                 looping: boolean;
                 /**
                  * The duration of the ParticleSystem in seconds.
                  *
                  * @type {number}
                  */
                 duration: number;
                 /**
                  * The number of particles in the ParticleSystem.
                  *
                  * @type {number}
                  */
                 particleNum: number;
                 /**
                  * Determines whether the ParticleSystem is paused.
                  *
                  * @type {boolean}
                  */
                 paused: boolean;
                 /**
                  * All the particles in the ParticleSystem.
                  *
                  * @type {Array<Particle>}
                  */
                 particles: Array<IParticle>;
                 /**
                  * the emitter object that should be added in the scene.
                  *
                  * @type {ParticleEmitter<Object3DEventMap>}
                  */
                 emitter: ParticleEmitter<Object3DEventMap>;
                 /**
                  * the VFX renderer settings for the batch renderer
                  *
                  * @type {VFXBatchSettings}
                  */
                 rendererSettings: VFXBatchSettings;
                 /**
                  * whether needs to update renderer settings for the batch renderer
                  *
                  * @type {boolean}
                  */
                 neededToUpdateRender: boolean;
                 rendererEmitterSettings: {};
                 worldSpace: boolean;
                 private prewarmed;
                 private emissionState;
                 private emitEnded;
                 private markForDestroy;
                 private previousWorldPos?;
                 private temp;
                 private travelDistance;
                 private normalMatrix;
                 set time(time: number);
                 get time(): number;
                 get layers(): Layers;
                 get texture(): Texture;
                 set texture(texture: Texture);
                 get material(): Material;
                 set material(material: Material);
                 get instancingGeometry(): BufferGeometry;
                 set instancingGeometry(geometry: BufferGeometry);
                 get renderMode(): RenderMode;
                 set renderMode(renderMode: RenderMode);
                 get renderOrder(): number;
                 set renderOrder(renderOrder: number);
                 get blending(): Blending;
                 set blending(blending: Blending);
                 constructor(parameters: VFXParameters);
                 pause(): void;
                 play(): void;
                 private spawn;
                 endEmit(): void;
                 dispose(): void;
                 restart(): void;
                 private update;
                 emit(delta: number, emissionState: EmissionState_2, emitterMatrix: Matrix4): void;
                 toJSON(meta: any, options?: SerializationOptions): any;
                 getRendererSettings(): VFXBatchSettings;
                 clone(): IParticleSystem;
                 speedFactor: number;
             }

             /**
              * Apply noise to particles.
              */
             export  class Noise implements Simulation {
                 frequency: FunctionValueGenerator | ValueGenerator;
                 power: FunctionValueGenerator | ValueGenerator;
                 positionAmount: FunctionValueGenerator | ValueGenerator;
                 rotationAmount: FunctionValueGenerator | ValueGenerator;
                 type: string;
                 duration: number;
                 constructor(frequency: FunctionValueGenerator | ValueGenerator, power: FunctionValueGenerator | ValueGenerator, positionAmount?: FunctionValueGenerator | ValueGenerator, rotationAmount?: FunctionValueGenerator | ValueGenerator);
                 initialize(particle: Particle): void;
                 update(particle: Particle, _: number): void;
                 toJSON(): any;
                 frameUpdate(delta: number): void;
                 static fromJSON(json: any): Simulation;
                 clone(): Simulation;
                 reset(): void;
             }

              function noop(): void;

             /**
              * 
              */
              function normalize<T extends VectorArray>(out: T, v: VectorArray): T;

             /**
              * Normalize css liked array configuration
              * e.g.
              *  3 => [3, 3, 3, 3]
              *  [4, 2] => [4, 2, 4, 2]
              *  [4, 3, 2] => [4, 3, 2, 3]
              */
              function normalizeCssArray(val: number | number[]): number[];

             

              const NOT_INTERSECTED: ShapecastIntersection;

             /**
              * Returns the current time in milliseconds. If performance.now() is available, it is used, otherwise Date.now() is used.
              *
              * @category Time
              */
             export  function now(): number;

             /**
              * object3d
              * @param object object3d
              * @param splitSubEntity 
              * @param autoAsMeshEntity mesh false) splitSubEntityfalse
              */
             export  function object2Entity(object: Object3D, splitSubEntity?: boolean, autoAsMeshEntity?: boolean): Entity;

             /**
              * Records what objects are colliding with each other
              */
              class ObjectCollisionMatrix {
                 /**
                  * The matrix storage.
                  */
                 matrix: Record<string, boolean>;
                 /**
                  * @todo Remove useless constructor
                  */
                 constructor();
                 /**
                  * get
                  */
                 get(bi: Body_2, bj: Body_2): boolean;
                 /**
                  * set
                  */
                 set(bi: Body_2, bj: Body_2, value: boolean): void;
                 /**
                  * Empty the matrix
                  */
                 reset(): void;
                 /**
                  * Set max number of objects
                  */
                 setNumObjects(n: number): void;
             }

             /**
              * Check if an object has a property.
              * @param o
              * @param v
              */
             export  function objectHasOwn(o: object, v: PropertyKey): boolean;

             /**
              * 
              */
             export  interface ObjectTransform {
                 position?: Vector3;
                 rotation?: Vector3;
                 scale?: number | Vector3;
             }

             /**
              * 
              */
             export  function objectTransformToMatrix(tf: ObjectTransform): Matrix4;

              interface ObjectValueType<T> {
                 copy(value: T): ObjectValueType<T>;
                 lerp(value: T, pos: number): ObjectValueType<T>;
                 clone(): ObjectValueType<T>;
             }

             /**
              * Octree
              */
              class Octree extends OctreeNode {
                 /**
                  * Maximum subdivision depth
                  * @default 8
                  */
                 maxDepth: number;
                 /**
                  * @param aabb The total AABB of the tree
                  */
                 constructor(aabb?: AABB, options?: {
                     /**
                      * Maximum subdivision depth
                      * @default 8
                      */
                     maxDepth?: number;
                 });
             }

             /**
              * OctreeNode
              */
              class OctreeNode {
                 /** The root node */
                 root: OctreeNode | null;
                 /** Boundary of this node */
                 aabb: AABB;
                 /** Contained data at the current node level */
                 data: number[];
                 /** Children to this node */
                 children: OctreeNode[];
                 constructor(options?: {
                     /** The root node */
                     root?: Octree | null;
                     /** Boundary of this node */
                     aabb?: AABB;
                 });
                 /**
                  * reset
                  */
                 reset(): void;
                 /**
                  * Insert data into this node
                  * @return True if successful, otherwise false
                  */
                 insert(aabb: AABB, elementData: number, level?: number): boolean;
                 /**
                  * Create 8 equally sized children nodes and put them in the `children` array.
                  */
                 subdivide(): void;
                 /**
                  * Get all data, potentially within an AABB
                  * @return The "result" object
                  */
                 aabbQuery(aabb: AABB, result: number[]): number[];
                 /**
                  * Get all data, potentially intersected by a ray.
                  * @return The "result" object
                  */
                 rayQuery(ray: Ray_2, treeTransform: Transform, result: number[]): number[];
                 /**
                  * removeEmptyNodes
                  */
                 removeEmptyNodes(): void;
             }

             /** 
              * @param paths 
              * @param offset 
              */
             export  function offsetCoords(paths: [number, number, number?][], offset: number): [number, number, number?][];

             export  function offsetPolygon(vertices: number[], holes?: number[], offset?: number, miterLimit?: number, close?: boolean, removeIntersections?: boolean, removeIntersectionsHole?: boolean): any[] | Float32Array;

             export  type Omitype<T, U> = {
                 [P in keyof T as T[P] extends U ? never : P]: T[P];
             };

             /**
              * Decorator that redefines a property with getter and setter, and calls a function when the property is changed.
              * Parameters passed to the function are the property key and the new value.
              * @note - Does not work with "target": "esnext" in tsconfig.json
              * @note - Requires "experimentalDecorators": true in tsconfig.json
              * @todo add example.
              * @param fnKey - use: `<MyClass>.prototype.<myFunction>` or define an arrow function: `(key, value, oldValue) => {}`.
              * @param paramType -
              * if param, the function is called with 3 parameters: `key, value, oldValue`, default for {@link onChange}
              * if object, the function is called with an object parameter: `{key, value, oldValue}`, default for {@link onChange3}
              * if void then no params are passed. {@link onChange2}
              * Default: false.
              *
              * @category Decorators
              */
             export  function onChange(fnKey: string | ((key: string, value: any, oldValue: any) => void), paramType?: "param" | "object" | "void"): PropertyDecorator;

             /**
              * Similar to {@link onChange}, but accepts any function and paramType defaults to 'void'. The function is called with no parameters. if 'void'
              * @param fnKey
              * @param paramType
              */
             export  function onChange2(fnKey: string | AnyFunction, paramType?: "param" | "object" | "void"): PropertyDecorator;

             /**
              * Similar to {@link onChange}, but accepts any function and paramType defaults to 'object'. The function is called with an object parameter: `{key, value, oldValue}`.
              * @param fnKey
              * @param paramType
              */
             export  function onChange3(fnKey: string | ((obj: {
                 key: string;
                 value: any;
                 oldValue: any;
             }) => void), paramType?: "object" | "void"): PropertyDecorator;

              type OnCleanup = (cleanupFn: () => void) => void;

              type ondestroyCallback = () => void;

              type OnframeCallback = (percent: number) => void;

              type OnframeCallback_2<T> = (target: T, percent: number) => void;

              type onrestartCallback = () => void;

             /**
              * Registers a dispose callback on the current active effect scope. The
              * callback will be invoked when the associated effect scope is stopped.
              *
              * @param fn - The callback function to attach to the scope's cleanup.
              */
              function onScopeDispose(fn: () => void): void;

             /**
              *  {backcolor: 0}
              */
             export  function openMapDarkStyle(): IMapStyleParam;

             /**
              *  {backcolor: 0xFFFFFF}
              */
             export  function openMapLightStyle(): IMapStyleParam;

              class Operation extends Brush {
                 isOperation: boolean;
                 markUpdated(): void;
                 isDirty(): boolean;
                 insertBefore(brush: Brush): void;
                 insertAfter(brush: Brush): void;
             }

              class OperationDebugData {
                 intersectionEdges: Line3[];
                 enabled: boolean;
                 addIntersectingTriangles(ia: number, triA: Triangle, ib: number, triB: Triangle): void;
                 addEdge(edge: Line3): void;
                 reset(): void;
             }

              class OperationGroup extends Group_2 {
                 isOperatioinGroup: boolean;
                 markUpdated(): void;
                 isDirty(): boolean;
             }

             /**  */
             export  const optimizeModelRender: (renderer: WebGLRenderer) => void;

              interface Opts {
                 style?: {
                     backgroundColor?: string;
                     color?: string;
                 };
                 autoHideDelay?: number;
             }

             export  class OrbitControlModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: OrbitControlModuleOptions;
                 constructor(app?: App, options?: OrbitControlModuleOptions);
                 get cameraControl(): CameraControls;
                 get enableCameraControlRef(): Ref<boolean>;
                 get enableCameraControl(): boolean;
                 set enableCameraControl(v: boolean);
                 get enableWheelWhenCtrlDisabled(): any;
                 set enableWheelWhenCtrlDisabled(v: any);
                 onAwake(): void;
                 onAppRender(time: Time): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface OrbitControlModuleOptions {
                 /**
                  * target
                  */
                 target?: [number, number, number] | Vector3;
                 /**
                  * Minimum vertical angle in radians.
                  * The angle has to be between `0` and `.maxPolarAngle` inclusive.
                  * The default value is `0`.
                  *
                  * e.g.
                  * ```
                  * cameraControl.maxPolarAngle = 0;
                  * ```
                  */
                 minPolarAngle?: number;
                 /**
                  * Maximum vertical angle in radians.
                  * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
                  * The default value is `Math.PI`.
                  *
                  * e.g.
                  * ```
                  * cameraControl.maxPolarAngle = Math.PI;
                  * ```
                  */
                 maxPolarAngle?: number;
                 /**
                  * Minimum horizontal angle in radians.
                  * The angle has to be less than `.maxAzimuthAngle`.
                  * The default value is `- Infinity`.
                  *
                  * e.g.
                  * ```
                  * cameraControl.minAzimuthAngle = - Infinity;
                  * ```
                  */
                 minAzimuthAngle?: number;
                 /**
                  * Maximum horizontal angle in radians.
                  * The angle has to be greater than `.minAzimuthAngle`.
                  * The default value is `Infinity`.
                  *
                  * e.g.
                  * ```
                  * cameraControl.maxAzimuthAngle = Infinity;
                  * ```
                  */
                 maxAzimuthAngle?: number;
                 /**
                  * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.
                  * PerspectiveCamera only.
                  */
                 minDistance?: number;
                 /**
                  * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.
                  * PerspectiveCamera only.
                  */
                 maxDistance?: number;
                 /**
                  * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`
                  * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.
                  */
                 infinityDolly?: boolean;
                 /**
                  * Minimum camera zoom. Default is `0.01`.
                  */
                 minZoom?: number;
                 /**
                  * Maximum camera zoom.Default is `Infinity`.
                  */
                 maxZoom?: number;
                 /**
                  * Approximate time in seconds to reach the target. A smaller value will reach the target faster.Default is `0.25`.
                  */
                 smoothTime?: number;
                 /**
                  * the smoothTime while draggingDefault is `0.125`.
                  */
                 draggingSmoothTime?: number;
                 /**
                  * Max transition speed in unit-per-seconds. Default is `Infinity`.
                  */
                 maxSpeed?: number;
                 /**
                  * Speed of azimuth (horizontal) rotation. Default is `1.0`.
                  */
                 azimuthRotateSpeed?: number;
                 /**
                  * Speed of polar (vertical) rotation.  Default is `1.0`.
                  */
                 polarRotateSpeed?: number;
                 /**
                  * Speed of mouse-wheel dollying.  Default is `1.0`.
                  */
                 dollySpeed?: number;
                 /**
                  * `true` to invert direction when dollying or zooming via drag  Default is `false`.
                  */
                 dollyDragInverted?: boolean;
                 /**
                  * Speed of drag for pan and pedestal. Default is `2.0`.
                  */
                 truckSpeed?: number;
                 /**
                  * `true` to enable Dolly-in to the mouse cursor coords. Default is `false`.
                  */
                 dollyToCursor?: boolean;
                 /**
                  * Properties Default is `false`.
                  */
                 dragToOffset?: boolean;
                 /**
                  *  if true, pan in screen-space default true
                  */
                 verticalDragToForward?: boolean;
                 /**
                  * Friction ratio of the boundary..Default is `0.0`.
                  */
                 boundaryFriction?: number;
                 /**
                  * Controls how soon the `rest` event fires as the camera slows. .Default is `0.01`.
                  */
                 restThreshold?: number;
                 /**
                  * An array of Meshes to collide with camera.
                  * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
                  */
                 colliderMeshes?: Object3D;
                 /**
                  * User's mouse input config.
                  *
                  * | button to assign      | behavior |
                  * | --------------------- | -------- |
                  * | `mouseButtons.left`   | `CameraControls.ACTION.ROTATE`* \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
                  * | `mouseButtons.right`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK`* \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
                  * | `mouseButtons.wheel`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY` \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
                  * | `mouseButtons.middle`  | `CameraControls.ACTION.ROTATE` \| `CameraControls.ACTION.TRUCK` \| `CameraControls.ACTION.OFFSET` \| `CameraControls.ACTION.DOLLY`* \| `CameraControls.ACTION.ZOOM` \| `CameraControls.ACTION.NONE` |
                  *
                  * 1. Mouse wheel event for scroll "up/down" on mac "up/down/left/right"
                  * 2. Mouse click on wheel event "button"
                  * - \* is the default.
                  * - The default of `mouseButtons.wheel` is:
                  *   - `DOLLY` for Perspective camera.
                  *   - `ZOOM` for Orthographic camera, and can't set `DOLLY`.
                  */
                 mouseButtons?: MouseButtons;
                 /**
                  * User's touch input config.
                  *
                  * | fingers to assign     | behavior |
                  * | --------------------- | -------- |
                  * | `touches.one` | `CameraControls.ACTION.TOUCH_ROTATE`* \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.DOLLY` | `CameraControls.ACTION.ZOOM` | `CameraControls.ACTION.NONE` |
                  * | `touches.two` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `ACTION.TOUCH_DOLLY` \| `ACTION.TOUCH_ZOOM` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
                  * | `touches.three` | `ACTION.TOUCH_DOLLY_TRUCK` \| `ACTION.TOUCH_DOLLY_OFFSET` \| `ACTION.TOUCH_DOLLY_ROTATE` \| `ACTION.TOUCH_ZOOM_TRUCK` \| `ACTION.TOUCH_ZOOM_OFFSET` \| `ACTION.TOUCH_ZOOM_ROTATE` \| `CameraControls.ACTION.TOUCH_ROTATE` \| `CameraControls.ACTION.TOUCH_TRUCK` \| `CameraControls.ACTION.TOUCH_OFFSET` \| `CameraControls.ACTION.NONE` |
                  *
                  * - \* is the default.
                  * - The default of `touches.two` and `touches.three` is:
                  *   - `TOUCH_DOLLY_TRUCK` for Perspective camera.
                  *   - `TOUCH_ZOOM_TRUCK` for Orthographic camera, and can't set `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY`.
                  * @category Properties
                  */
                 touches?: Touches;
                 /**  */
                 dblClickSetToCenter?: boolean;
                 /**  */
                 unProjectUseDepth?: boolean;
                 /** Markerfalse */
                 dblClickAddDebugMarker?: boolean;
                 /**  */
                 enable?: boolean;
                 /**  */
                 disableUpdate?: boolean;
                 /**  */
                 eventFromInputModule?: boolean;
                 /**  ()*/
                 leftButtonPan?: boolean;
                 /** () */
                 rotateShowTargetMarker?: boolean;
                 /** () */
                 zoomShowTargetMarker?: boolean;
                 /**  */
                 targetMarkerImage?: string;
                 /**  #d4237a */
                 targetMarkerColor?: string;
                 /**  */
                 targetMarkerSize?: number;
                 /** (0-1) */
                 targetMarkerOpacity?: number;
                 /**  */
                 initState?: CameraState & {
                     enableTransition?: boolean;
                 };
             }

             /**
              * Orbit particles around an axis over their life.
              */
             export  class OrbitOverLife implements Simulation {
                 orbitSpeed: FunctionValueGenerator | ValueGenerator;
                 axis: Vector3;
                 type: string;
                 rotation: Quaternion;
                 line: Line3;
                 temp: Vector3;
                 constructor(orbitSpeed: FunctionValueGenerator | ValueGenerator, axis?: Vector3);
                 initialize(particle: Particle): void;
                 update(particle: Particle, delta: number): void;
                 frameUpdate(delta: number): void;
                 toJSON(): any;
                 static fromJSON(json: any): Simulation;
                 clone(): Simulation;
                 reset(): void;
             }

             export  enum OrderIndex {
                 StartMost = -1000000,
                 Start = -1000,
                 Normal = 0,
                 End = 1000,
                 EndMost = 1000000
             }

              class OrientedBoundingRect {
                 private _corners;
                 private _axes;
                 private _origin;
                 constructor(rect?: BoundingRect, transform?: MatrixArray);
                 fromBoundingRect(rect: BoundingRect, transform?: MatrixArray): void;
                 /**
                  * If intersect with another OBB
                  * @param other Bounding rect to be intersected with
                  * @param mtv Calculated .
                  *  If it's not overlapped. it means needs to move given rect with Maximum Translation Vector to be overlapped.
                  *  Else it means needs to move given rect with Minimum Translation Vector to be not overlapped.
                  */
                 intersect(other: OrientedBoundingRect, mtv?: PointLike): boolean;
                 private _intersectCheckOneSide;
                 private _getProjMinMaxOnAxis;
             }

              class OrientedBox {
                 min: Vector3;
                 max: Vector3;
                 matrix: Matrix4;
                 needsUpdate: boolean;
                 constructor(min: Vector3, max: Vector3);
                 set(min: Vector3, max: Vector3, matrix: Matrix4): OrientedBox;
                 intersectsBox(box: Box3): boolean;
                 intersectsTriangle(tri: Triangle): boolean;
                 closestPointToPoint(point: Vector3, target?: Vector3): number;
                 distanceToPoint(point: Vector3): number;
                 distanceToBox(box: Box3, threshold?: number, target1?: Vector3, target2?: Vector3): number;
             }

             

             /**
              * 
              */
             export  class OutlineModule extends EntityModuleBase implements IEntityModuleBase {
                 static moduleName: string;
                 options: OutlinesProps;
                 outlines: OutlinesType[];
                 constructor(entity: Entity, options?: OutlinesProps);
                 onAppUpdate(time: Time): void;
             }

             export  function Outlines({ color, opacity, transparent, thickness, angle, }?: Partial<OutlinesProps>): OutlinesType;

             export  type OutlinesProps = {
                 /** Outline color, default: black */
                 color?: Color;
                 /** Outline opacity, default: 1 */
                 opacity?: number;
                 /** Outline transparency, default: false */
                 transparent?: boolean;
                 /** Outline thickness, default 0.05 */
                 thickness?: number;
                 /** Geometry crease angle (0 === no crease), default: Math.PI */
                 angle?: number;
                 pulsePeriod?: number;
             };

             export  type OutlinesType = {
                 group: Group_2;
                 updateProps: (props: Partial<OutlinesProps>) => void;
                 /**
                  * **Note**: Call this method to generate the outline mesh
                  */
                 generate: () => void;
                 dispose: () => void;
             };

             export  const OutputNodeTypeNames: Set<string>;

              class OverlapKeeper {
                 current: number[];
                 previous: number[];
                 /**
                  * @todo Remove useless constructor
                  */
                 constructor();
                 /**
                  * getKey
                  */
                 getKey(i: number, j: number): number;
                 /**
                  * set
                  */
                 set(i: number, j: number): void;
                 /**
                  * tick
                  */
                 tick(): void;
                 /**
                  * getDiff
                  */
                 getDiff(additions: number[], removals: number[]): void;
             }

             

             export  class PackedMipMapGenerator {
                 _swapTarget: any;
                 _copyQuad: any;
                 _mipQuad: any;
                 _mipMaterials: any;
                 constructor(mipmapLogic?: string);
                 update(texture: any, target: any, renderer: any, forcePowerOfTwo?: boolean): number;
                 dispose(): void;
             }

             export  interface PackOptions {
                 maxChartSize?: number;
                 padding?: number;
                 bilinear?: boolean;
                 createImage?: boolean;
                 rotateCharts?: boolean;
                 rotateChartsToAxis?: boolean;
                 blockAlign?: boolean;
                 resolution?: number;
                 bruteForce?: boolean;
                 texelsPerUnit?: number;
             }

              interface PainterBase {
                 type: string;
                 root?: HTMLElement;
                 ssrOnly?: boolean;
                 resize(width?: number | string, height?: number | string): void;
                 refresh(): void;
                 clear(): void;
                 renderToString?(): string;
                 getType: () => string;
                 getWidth(): number;
                 getHeight(): number;
                 dispose(): void;
                 getViewportRoot: () => HTMLElement;
                 getViewportRootOffset: () => {
                     offsetLeft: number;
                     offsetTop: number;
                 };
                 refreshHover(): void;
                 configLayer(zlevel: number, config: Dictionary<any>): void;
                 setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;
             }

              type PainterBaseCtor = {
                 new (dom: HTMLElement, storage: Storage_2, ...args: any[]): PainterBase;
             };

             /**
              * Executes all contained behaviors in parallel
              */
             export  class ParallelBehavior extends CompositeBehavior {
                 successPolicy: ParallelBehaviorPolicy;
                 failurePolicy: ParallelBehaviorPolicy;
                 activeSet: any;
                 successCount: number;
                 failureCount: number;
                 /**
                  *
                  * @param {ParallelBehaviorPolicy} successPolicy
                  * @param {ParallelBehaviorPolicy} failurePolicy
                  */
                 constructor(successPolicy: any, failurePolicy: any);
                 /**
                  *
                  * @return {ParallelBehaviorPolicy}
                  */
                 getSuccessPolicy(): ParallelBehaviorPolicy;
                 /**
                  *
                  * @param policy
                  */
                 setSuccessPolicy(policy: ParallelBehaviorPolicy): void;
                 /**
                  *
                  * @return {ParallelBehaviorPolicy}
                  */
                 getFailurePolicy(): ParallelBehaviorPolicy;
                 /**
                  *
                  * @param  policy
                  */
                 setFailurePolicy(policy: ParallelBehaviorPolicy): void;
                 /**
                  *
                  * @param {number} timeDelta
                  * @returns {BehaviorStatus|number}
                  */
                 tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
                 initialize(context: any): void;
                 /**
                  *
                  * @private
                  */
                 __finalizeActiveChildren(): void;
                 finalize(): void;
                 /**
                  *
                  * @param {Behavior[]} elements
                  * @param {ParallelBehaviorPolicy} success how should successful completion be determined?
                  * @param {ParallelBehaviorPolicy} failure how should failing completion be determined
                  * @returns {ParallelBehavior}
                  */
                 static from(elements: Behavior[], success?: ParallelBehaviorPolicy, failure?: ParallelBehaviorPolicy): ParallelBehavior;
             }

             /**
              *
              * @enum {number}
              */
             export  enum ParallelBehaviorPolicy {
                 RequireOne = 0,
                 RequireAll = 1
             }

             export  type ParameterPair = [string, ParameterType];

             export  type ParameterType = FieldType | 'self';

              function parse(colorStr: string, rgbaArr?: number[]): number[];

             /**
              * Parse a file extension from a path
              * @param path - The path to parse
              * @returns file extension without the dot (e.g. 'png')
              *
              * @category Text
              */
             export  function parseFileExtension(path: string): string;

              function parseSVG(xml: string | Document | SVGElement, opt: SVGParserOption): SVGParserResult;

             /**
              * Partial pick type with all keys optional
              */
             export  type PartialPick<T, K extends keyof T> = Partial<T> & Pick<T, K>;

             /**
              * Partial record type with all keys optional
              * @example
              * ```ts
              * type T = PartialRecord<'a' | 'b', number>
              * // T = {a?: number, b?: number}
              * ```
              */
             export  type PartialRecord<K extends keyof any, T> = {
                 [P in K]?: T;
             };

             export  interface Particle extends IParticle {
                 /**
                  * Speed modifier of the particle.
                  * @type {number}
                  */
                 speedModifier: number;
                 /**
                  * Emission state of the particle.
                  * @type {EmissionState}
                  */
                 emissionState?: EmissionState;
                 /**
                  * Parent matrix for transformation.
                  * @type {Matrix4}
                  */
                 parentMatrix?: Matrix4;
                 /**
                  * Initial speed of the particle.
                  * @type {number}
                  */
                 startSpeed: number;
                 /**
                  * Initial color of the particle.
                  * @type {Vector4}
                  */
                 startColor: Vector4;
                 /**
                  * Initial size of the particle.
                  * @type {number}
                  */
                 startSize: number;
             }

             /**
              * Particle2 shape.
              * @example
              *     const particleShape = new CANNON.Particle2()
              *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })
              *     world.addBody(particleBody)
              */
              class Particle2 extends Shape {
                 constructor();
                 /**
                  * calculateLocalInertia
                  */
                 calculateLocalInertia(mass: number, target?: Vec3): Vec3;
                 volume(): number;
                 updateBoundingSphereRadius(): void;
                 calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
             }

             /**
              * Class representing a three.Particle particle emitter. particle emitter is a node in the three.js scene graph
              * every particle emitter only associates with a particle system.
              * particle system
              * @extends Object3D
              * @template E - Type of the event map.
              */
             export  class ParticleEmitter<E extends Object3DEventMap = Object3DEventMap> extends Object3D<E> {
                 type: string;
                 system: IParticleSystem;
                 /**
                  * Creates an instance of ParticleEmitter.
                  * @param {IParticleSystem} system - The particle system to be used.
                  */
                 constructor(system: IParticleSystem);
                 /**
                  * Clones the particle emitter.
                  * @returns {ParticleEmitter} A new instance of ParticleEmitter.
                  */
                 clone(): any;
                 /**
                  * Disposes the particle emitter.
                  */
                 dispose(): void;
                 /**
                  * Extracts data from the cache.
                  * @param {any} cache - The cache to extract data from.
                  * @returns {any[]} An array of extracted data without metadata.
                  */
                 extractFromCache(cache: any): any[];
                 /**
                  * Converts the particle emitter to JSON.
                  * @param {MetaData} [meta] - Optional metadata.
                  * @param {SerializationOptions} [options={}] - Optional serialization options.
                  * @returns {any} The JSON representation of the particle emitter.
                  */
                 toJSON(meta?: MetaData, options?: SerializationOptions): any;
             }

             /**
              * Loader for Particle particle system.
              */
             export  class ParticleLoader extends ObjectLoader {
                 onData?: (data: any) => any;
                 constructor(opts?: {
                     manager?: LoadingManager;
                     onData?: (data: any) => any;
                 });
                 /**
                  * Links the references of the particle system.
                  * It's used to link the references of sub particle systems.
                  * @param object the target object to link the references.
                  */
                 linkReference(object: Object3D): void;
                 /**
                  * Parses the json data to create a Particle particle system.
                  * @param json the json data to parse.
                  * @param onLoad the callback function to be called after the object is loaded.
                  */
                 parse<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void): T;
                 parseObject(data: any, geometries: {
                     [uuid: string]: BufferGeometry;
                 }, materials: {
                     [uuid: string]: Material;
                 }, textures: {
                     [uuid: string]: Texture;
                 }, animations: AnimationClip[]): Object3D;
             }

             /**
              * 
              */
             export  class ParticleModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 constructor(entity: Entity, options?: ParticleModuleOption | ParticleModuleOption[]);
                 /**
                  * 
                  * @param particle
                  */
                 getParticles(name?: string): ParticleEmitter<Object3DEventMap>[];
                 /**
                  * 
                  * @param particle
                  */
                 addParticle(particle: ParticleModuleOption): void;
                 /**
                  * 
                  * @param particle
                  */
                 removeParticle(name?: string): void;
             }

             export  interface ParticleModuleOption {
                 /**  */
                 system?: ParticleSystemParameters;
                 /**   */
                 simulations?: Simulation | Simulation[];
                 /**  */
                 name?: string;
                 /**   */
                 position?: Vector3 | [number, number, number];
                 /**  */
                 rotation?: Vector3 | [number, number, number];
                 /**  */
                 scale?: Vector3 | [number, number, number] | number;
                 /**  */
                 resource?: Object3D;
                 /**   */
                 isCloneRes?: boolean;
                 /** true */
                 disposeWhenEnd?: boolean;
                 /**  */
                 onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
             }

             export  interface ParticlePlugin {
                 id: string;
                 initialize: () => void;
                 emitterShapes: Array<EmitterShapeParticlePlugin>;
                 simulations: Array<SimulationParticlePlugin>;
             }

             export  const ParticlePlugins: Array<ParticlePlugin>;

             /**
              * 
              */
             export  class ParticleRenderModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: ParticleRenderModuleOptions;
                 enable?: boolean;
                 batchRendererSet: Map<string, BatchedRenderer>;
                 constructor(app?: App, options?: ParticleRenderModuleOptions);
                 get batchRenderer(): BatchedRenderer;
                 get particleRenderer(): BatchedRenderer;
                 onAwake(): void;
                 onAppRender(time: Time): void;
                 addParticleSystem(system: IParticleSystem, parent?: Object3D, disposeWhenEnd?: boolean): void;
                 addParticle(opts: {
                     system: ParticleSystemParameters;
                     simulations?: Simulation | Simulation[];
                     name?: string;
                     position?: Vector3 | [number, number, number];
                     rotation?: Vector3 | [number, number, number];
                     scale?: Vector3 | [number, number, number] | number;
                     parent?: Object3D;
                     disposeWhenEnd?: boolean;
                 }): ParticleEmitter<Object3DEventMap>;
                 removeParticle(obj: ParticleEmitter<Object3DEventMap>): void;
                 loadParticle(url: string, opts?: {
                     system?: ParticleSystemParameters;
                     simulations?: Simulation | Simulation[];
                     name?: string;
                     position?: Vector3 | [number, number, number];
                     rotation?: Vector3 | [number, number, number];
                     scale?: Vector3 | [number, number, number] | number;
                     parent?: Object3D;
                     disposeWhenEnd?: boolean;
                     onData?: (data: any) => any;
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                     crossOrigin?: string;
                     withCredentials?: boolean;
                     urlPath?: string;
                     resourcePath?: string;
                     requestHeader?: {
                         [header: string]: string;
                     };
                 }): Promise<unknown>;
                 loadParticleFromJson(json: string | JSON, opts?: {
                     system?: ParticleSystemParameters;
                     simulations?: Simulation | Simulation[];
                     name?: string;
                     position?: Vector3 | [number, number, number];
                     rotation?: Vector3 | [number, number, number];
                     scale?: Vector3 | [number, number, number] | number;
                     parent?: Object3D;
                     disposeWhenEnd?: boolean;
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                     onData?: (data: any) => any;
                 }): Object3D<Object3DEventMap>;
                 loadParticleFromRes(obj: Object3D, opts?: {
                     system?: ParticleSystemParameters;
                     simulations?: Simulation | Simulation[];
                     name?: string;
                     position?: Vector3 | [number, number, number];
                     rotation?: Vector3 | [number, number, number];
                     scale?: Vector3 | [number, number, number] | number;
                     parent?: Object3D;
                     disposeWhenEnd?: boolean;
                     onAddSystem?: (object: Object3D, system: IParticleSystem) => any;
                 }): Object3D<Object3DEventMap>;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface ParticleRenderModuleOptions {
                 /** true */
                 enable?: boolean;
             }

             /**
              * ParticleSystem represents a system that generates and controls particles with similar attributes.
              *
              * @class
              */
             export  class ParticleSystem implements IParticleSystem {
                 signal: {
                     onRestart: Signal;
                     onPlay: Signal;
                     onPause: Signal;
                     onEnd: Signal;
                 };
                 /**
                  * Determines whether the ParticleSystem should be automatically disposed when it finishes emitting particles.
                  *
                  * @type {boolean}
                  */
                 autoDestroy: boolean;
                 /**
                  * Determines whether a looping ParticleSystem should prewarm, i.e., the Particle System looks like it has already simulated for one loop when first becoming visible.
                  *
                  * @type {boolean}
                  */
                 prewarm: boolean;
                 /**
                  * Determines whether the ParticleSystem should loop, i.e., restart emitting particles after the duration of the particle system is expired.
                  *
                  * @type {boolean}
                  */
                 looping: boolean;
                 /**
                  * The duration of the ParticleSystem in seconds.
                  *
                  * @type {number}
                  */
                 duration: number;
                 /**
                  * The value generator or function value generator for the starting life of particles.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startLife: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The value generator or function value generator for the starting speed of particles.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startSpeed: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The value generator or function value generator or rotation generator for the starting rotation of particles.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator | RotationGenerator}
                  */
                 startRotation: ValueGenerator | FunctionValueGenerator | RotationGenerator;
                 /**
                  * The value generator or function value generator for the starting size of particles.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 startSize: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The color generator or function color generator for the starting color of particles.
                  *
                  * @type {ColorGenerator | FunctionColorGenerator}
                  */
                 startColor: ColorGenerator | FunctionColorGenerator | MemorizedFunctionColorGenerator;
                 /**
                  * The value generator for the starting tile index of particles.
                  *
                  * @type {ValueGenerator}
                  */
                 startTileIndex: ValueGenerator;
                 /**
                  * The renderer emitter settings for the ParticleSystem.
                  *
                  * @type {TrailSettings | MeshSettings | BillBoardSettings | StretchedBillBoardSettings}
                  */
                 rendererEmitterSettings: RendererEmitterSettings;
                 /**
                  * The value generator or function value generator for the emission rate of particles over time.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 emissionOverTime: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The value generator or function value generator for the emission rate of particles over distance.
                  *
                  * @type {ValueGenerator | FunctionValueGenerator}
                  */
                 emissionOverDistance: ValueGenerator | FunctionValueGenerator;
                 /**
                  * An array of burst parameters for the ParticleSystem.
                  *
                  * @type {Array<BurstParameters>}
                  */
                 emissionBursts: Array<BurstParameters>;
                 /**
                  * Determines whether the ParticleSystem is only used by other ParticleSystems.
                  *
                  * @type {boolean}
                  */
                 onlyUsedByOther: boolean;
                 /**
                  * Determines whether the ParticleSystem is in world space or local space.
                  *
                  * @type {boolean}
                  */
                 worldSpace: boolean;
                 /**
                  * The number of particles in the ParticleSystem.
                  *
                  * @type {number}
                  */
                 particleNum: number;
                 /**
                  * Determines whether the ParticleSystem is paused.
                  *
                  * @type {boolean}
                  */
                 paused: boolean;
                 /**
                  * All the particles in the ParticleSystem.
                  *
                  * @type {Array<Particle>}
                  */
                 particles: Array<Particle>;
                 /**
                  * the shape of the emitter.
                  *
                  * @type {EmitterShape}
                  */
                 emitterShape: EmitterShape;
                 /**
                  * the emitter object that should be added in the scene.
                  *
                  * @type {ParticleEmitter<Object3DEventMap>}
                  */
                 emitter: ParticleEmitter<Object3DEventMap>;
                 /**
                  * the VFX renderer settings for the batch renderer
                  *
                  * @type {VFXBatchSettings}
                  */
                 rendererSettings: VFXBatchSettings;
                 /**
                  * whether needs to update renderer settings for the batch renderer
                  *
                  * @type {boolean}
                  */
                 neededToUpdateRender: boolean;
                 /**
                  * a list of particle simulations in the particle system
                  *
                  * @type {Array<Simulation>}
                  */
                 simulations: Array<Simulation>;
                 emissionState: EmissionState;
                 private prewarmed;
                 private emitEnded;
                 private markForDestroy;
                 private previousWorldPos?;
                 private temp;
                 private travelDistance;
                 private normalMatrix;
                 /**
                  * set the time of the playback of the particle system
                  * @param time
                  */
                 set time(time: number);
                 /**
                  * get the current time of the playback of the particle system
                  */
                 get time(): number;
                 /**
                  * layers control visibility of the object.
                  * currently if you change the layers setting, you need manually set this.neededToUpdateRender = true;
                  * @type {Layers}
                  * @see {@link https://threejs.org/docs/index.html#api/en/core/Layers | Official Documentation}
                  * @see {@link https://github.com/mrdoob/three.js/blob/master/src/core/Layers.js | Source}
                  */
                 get layers(): Layers;
                 /**
                  * get the texture of the particle system
                  */
                 get texture(): Texture | null;
                 /**
                  * Set the texture of the particle system
                  * It will rebuild the material
                  */
                 set texture(texture: Texture | null);
                 /**
                  * Get the material of the particle system
                  */
                 get material(): Material;
                 /**
                  * Set the material of the particle system
                  * It will rebuild the material
                  */
                 set material(material: Material);
                 /**
                  * Get the number of horizontal tiles in the texture.
                  */
                 get uTileCount(): number;
                 /**
                  * Set the number of horizontal tiles in the texture.
                  * @param u
                  */
                 set uTileCount(u: number);
                 /**
                  * Get the number of vertical tiles in the texture.
                  */
                 get vTileCount(): number;
                 /**
                  * Set the number of vertical tiles in the texture.
                  * @param v
                  */
                 set vTileCount(v: number);
                 /**
                  * get whether the particle texture blends tile transitions
                  */
                 get blendTiles(): boolean;
                 /**
                  * Set whether the particle texture blends tile transitions
                  * @param v
                  */
                 set blendTiles(v: boolean);
                 /**
                  * Get whether the particle system uses soft particles.
                  * Soft particles are particles that fade out when they are close to geometry.
                  */
                 get softParticles(): boolean;
                 /**
                  * Set whether the particle system uses soft particles.
                  * Soft particles are particles that fade out when they are close to geometry.
                  * @param v
                  */
                 set softParticles(v: boolean);
                 get softNearFade(): number;
                 set softNearFade(v: number);
                 get softFarFade(): number;
                 set softFarFade(v: number);
                 /**
                  * Get the instancing geometry of the particle system.
                  * @param geometry
                  */
                 get instancingGeometry(): BufferGeometry;
                 /**
                  * Set the instancing geometry of the particle system.
                  * @param geometry
                  */
                 set instancingGeometry(geometry: BufferGeometry);
                 /**
                  * Get the render mode of the particle system.
                  * {@link RenderMode}
                  */
                 get renderMode(): RenderMode;
                 /**
                  * Set the render mode of the particle system.
                  * {@link RenderMode}
                  */
                 set renderMode(renderMode: RenderMode);
                 /**
                  * get the render order of the particle system in render pipeline.
                  * the higher the value, the later the particle system is rendered.
                  */
                 get renderOrder(): number;
                 /**
                  * set the render order of the particle system in render pipeline.
                  * the higher the value, the later the particle system is rendered.
                  */
                 set renderOrder(renderOrder: number);
                 /**
                  * get which blending to use.
                  * @default THREE.NormalBlending
                  */
                 get blending(): Blending;
                 /**
                  * Set which blending to use.
                  * @default THREE.NormalBlending
                  */
                 set blending(blending: Blending);
                 constructor(parameters: ParticleSystemParameters);
                 pause(): void;
                 play(): void;
                 private spawn;
                 /**
                  * Stops emitting particles
                  */
                 endEmit(): void;
                 /**
                  * remove the particle system's emitter from the scene
                  */
                 dispose(): void;
                 restart(): void;
                 private firstTimeUpdate;
                 /**
                  * Update the particle system per frame
                  * @param delta
                  * @private
                  */
                 private update;
                 /**
                  * Emit particles
                  * @param delta the duration of the frame
                  * @param emissionState the state of the emission
                  * @param emitterMatrix the matrix of the emitter
                  */
                 emit(delta: number, emissionState: EmissionState, emitterMatrix: Matrix4): void;
                 /**
                  * output the particle system to JSON
                  * @param meta serialization meta data
                  * @param options serialization options
                  */
                 toJSON(meta: MetaData, options?: SerializationOptions): ParticleSystemJSONParameters;
                 /**
                  * Create a ParticleSystem from JSON
                  * @param json the JSON data
                  * @param meta serialization meta data
                  * @param dependencies the dependencies of the particle system
                  */
                 static fromJSON(json: ParticleSystemJSONParameters, meta: {
                     textures: {
                         [uuid: string]: Texture;
                     };
                     materials: {
                         [uuoid: string]: Material;
                     };
                     geometries: {
                         [uuid: string]: BufferGeometry;
                     };
                 }, dependencies: {
                     [uuid: string]: Simulation;
                 }): ParticleSystem;
                 /**
                  * Add a simulation to the particle system
                  * @param simulation
                  */
                 addSimulation(simulation: Simulation): void;
                 /**
                  * Remove a simulation from the particle system
                  */
                 getRendererSettings(): VFXBatchSettings;
                 /**
                  * Clone the particle system
                  */
                 clone(): ParticleSystem;
             }

             export  interface ParticleSystemJSONParameters {
                 version: string;
                 autoDestroy: boolean;
                 looping: boolean;
                 prewarm: boolean;
                 duration: number;
                 shape: ShapeJSON;
                 startLife: FunctionJSON;
                 startSpeed: FunctionJSON;
                 startRotation: FunctionJSON;
                 startSize: FunctionJSON;
                 startColor: FunctionJSON;
                 emissionOverTime: FunctionJSON;
                 emissionOverDistance: FunctionJSON;
                 emissionBursts?: Array<BurstParametersJSON>;
                 onlyUsedByOther: boolean;
                 rendererEmitterSettings: RendererEmitterSettings;
                 instancingGeometry?: any;
                 renderMode: number;
                 renderOrder?: number;
                 speedFactor?: number;
                 texture?: string;
                 material: string;
                 layers?: number;
                 startTileIndex: FunctionJSON | number;
                 uTileCount: number;
                 vTileCount: number;
                 blendTiles?: boolean;
                 softParticles?: boolean;
                 softFarFade?: number;
                 softNearFade?: number;
                 blending?: Blending;
                 transparent?: boolean;
                 simulations: Array<any>;
                 worldSpace: boolean;
             }

             /**
              * Interface representing the parameters for a particle system.
              */
             export  interface ParticleSystemParameters {
                 /**
                  * Whether the particle system auto-destroys.
                  */
                 autoDestroy?: boolean;
                 /**
                  * Whether the particle system loops.
                  */
                 looping?: boolean;
                 /**
                  * Whether the particle system prewarms.
                  */
                 prewarm?: boolean;
                 /**
                  * The duration of the particle system.
                  */
                 duration?: number;
                 /**
                  * The shape of the emitter.
                  */
                 shape?: EmitterShape;
                 /**
                  * The initial life of particles.
                  */
                 startLife?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The initial speed of particles.
                  */
                 startSpeed?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The initial rotation of particles.
                  */
                 startRotation?: ValueGenerator | FunctionValueGenerator | RotationGenerator;
                 /**
                  * The initial size of particles.
                  */
                 startSize?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The initial length of particles.
                  */
                 startLength?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The initial color of particles.
                  */
                 startColor?: ColorGenerator | FunctionColorGenerator | MemorizedFunctionColorGenerator;
                 /**
                  * The emission rate over time.
                  */
                 emissionOverTime?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The emission rate over distance.
                  */
                 emissionOverDistance?: ValueGenerator | FunctionValueGenerator;
                 /**
                  * The burst parameters for emission.
                  */
                 emissionBursts?: Array<BurstParameters>;
                 /**
                  * Whether the particle system is only used by others.
                  */
                 onlyUsedByOther?: boolean;
                 /**
                  * The simulations of the particle system.
                  */
                 simulations?: Array<Simulation>;
                 /**
                  * The instancing geometry of the particle system.
                  */
                 instancingGeometry?: BufferGeometry;
                 /**
                  * The render mode of the particle system.
                  */
                 renderMode?: RenderMode;
                 /**
                  * The renderer emitter settings.
                  */
                 rendererEmitterSettings?: RendererEmitterSettings;
                 /**
                  * The speed factor of the particle system.
                  */
                 speedFactor?: number;
                 /**
                  * The material of the particle system.
                  */
                 material: Material;
                 /**
                  * The layers of the particle system.
                  */
                 layers?: Layers;
                 /**
                  * The initial tile index for particles.
                  */
                 startTileIndex?: ValueGenerator;
                 /**
                  * The number of tiles in the u direction.
                  */
                 uTileCount?: number;
                 /**
                  * The number of tiles in the v direction.
                  */
                 vTileCount?: number;
                 /**
                  * Whether to blend tiles.
                  */
                 blendTiles?: boolean;
                 /**
                  * Whether to use soft particles.
                  */
                 softParticles?: boolean;
                 /**
                  * The far fade distance for soft particles.
                  */
                 softFarFade?: number;
                 /**
                  * The near fade distance for soft particles.
                  */
                 softNearFade?: number;
                 /**
                  * The render order of the particle system.
                  */
                 renderOrder?: number;
                 /**
                  * Whether the particle system uses world space.
                  */
                 worldSpace?: boolean;
             }

             

              interface Path<Props extends PathProps = PathProps> {
                 animate(key?: '', loop?: boolean): Animator_2<this>;
                 animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
                 animate(key: 'shape', loop?: boolean): Animator_2<this['shape']>;
                 getState(stateName: string): PathState;
                 ensureState(stateName: string): PathState;
                 states: Dictionary<PathState>;
                 stateProxy: (stateName: string) => PathState;
             }

              class Path<Props extends PathProps = PathProps> extends Displayable<Props> {
                 path: PathProxy;
                 strokeContainThreshold: number;
                 segmentIgnoreThreshold: number;
                 subPixelOptimize: boolean;
                 style: PathStyleProps;
                 /**
                  * If element can be batched automatically
                  */
                 autoBatch: boolean;
                 private _rectStroke;
                 protected _normalState: PathState;
                 protected _decalEl: Path;
                 shape: Dictionary<any>;
                 constructor(opts?: Props);
                 update(): void;
                 getDecalElement(): Path<PathProps>;
                 protected _init(props?: Props): void;
                 protected getDefaultStyle(): Props['style'];
                 protected getDefaultShape(): {};
                 protected canBeInsideText(): boolean;
                 protected getInsideTextFill(): "#333" | "#ccc" | "#eee";
                 protected getInsideTextStroke(textFill?: string): string;
                 buildPath(ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBatch?: boolean): void;
                 pathUpdated(): void;
                 getUpdatedPathProxy(inBatch?: boolean): PathProxy;
                 createPathProxy(): void;
                 hasStroke(): boolean;
                 hasFill(): boolean;
                 getBoundingRect(): BoundingRect;
                 contain(x: number, y: number): boolean;
                 /**
                  * Shape changed
                  */
                 dirtyShape(): void;
                 dirty(): void;
                 /**
                  * Alias for animate('shape')
                  * @param {boolean} loop
                  */
                 animateShape(loop: boolean): Animator_2<this["shape"]>;
                 updateDuringAnimation(targetKey: string): void;
                 attrKV(key: PathKey, value: PathPropertyType): void;
                 setShape(obj: Props['shape']): this;
                 setShape<T extends keyof Props['shape']>(obj: T, value: Props['shape'][T]): this;
                 /**
                  * If shape changed. used with dirtyShape
                  */
                 shapeChanged(): boolean;
                 /**
                  * Create a path style object with default values in it's prototype.
                  * @override
                  */
                 createStyle(obj?: Props['style']): Props["style"];
                 protected _innerSaveToNormal(toState: PathState): void;
                 protected _applyStateObj(stateName: string, state: PathState, normalState: PathState, keepCurrentStates: boolean, transition: boolean, animationCfg: ElementAnimateConfig): void;
                 protected _mergeStates(states: PathState[]): PathState;
                 getAnimationStyleProps(): MapToType<PathProps, boolean>;
                 /**
                  * If path shape is zero area
                  */
                 isZeroArea(): boolean;
                 /**
                  *  Path element, 
                  * Extend a path element
                  * @DEPRECATED Use class extends
                  * @param props
                  * @param props.type Path type
                  * @param props.init Initialize
                  * @param props.buildPath Overwrite buildPath method
                  * @param props.style Extended default style config
                  * @param props.shape Extended default shape config
                  */
                 static extend<Shape extends Dictionary<any>>(defaultProps: {
                     type?: string;
                     shape?: Shape;
                     style?: PathStyleProps;
                     beforeBrush?: Displayable['beforeBrush'];
                     afterBrush?: Displayable['afterBrush'];
                     getBoundingRect?: Displayable['getBoundingRect'];
                     calculateTextPosition?: Element_2['calculateTextPosition'];
                     buildPath(this: Path, ctx: CanvasRenderingContext2D | PathProxy, shape: Shape, inBatch?: boolean): void;
                     init?(this: Path, opts: PathProps): void;
                 }): {
                     new (opts?: PathProps & {
                         shape: Shape;
                     }): Path;
                 };
                 protected static initDefaultProps: void;
             }

             /**
              * 
              */
             export  class PathAnimateModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 options: PathAnimateModuleOptions;
                 tween: Tween;
                 constructor(entity: Entity, options?: PathAnimateModuleOptions);
                 /**  */
                 start(options?: PathAnimateModuleOptions): Promise<{
                     target: any;
                     isEnd: boolean;
                     isStop: boolean;
                     error: boolean;
                 }>;
                 lookAt(point: Vector3, pointNext: Vector3, model?: Object3D, opts?: {
                     tPosition?: number;
                     tQuat?: number;
                     euler?: Euler;
                     offsetAngle?: number;
                     followDist?: number;
                     followAngle?: number;
                     cameraFollow?: boolean;
                 }): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface PathAnimateModuleOptions {
                 /**  */
                 paths: Vector3[] | [number, number, number][];
                 /**   300 */
                 discretePointsNum?: number;
                 /**  0-1 1 */
                 quatLerpT?: number;
                 /**  0 */
                 offsetAngle?: number;
                 /**  offsetAngle  */
                 euler?: Euler;
                 /**  */
                 cameraFollow?: boolean;
                 /**  5 */
                 followDist?: number;
                 /**   35*/
                 followAngle?: number;
                 /**  */
                 target?: Object3D;
                 /**  true */
                 isAutoChangeDir?: boolean;
                 /**  false */
                 autoCompleteWhenExit?: boolean;
                 /**  0*/
                 animatorIndex?: number;
                 /**   */
                 stopAimatorClipName?: string;
                 /**   */
                 startAimatorClipName?: string;
                 /**  */
                 animation?: {
                     /** id */
                     id?: string;
                     /**  */
                     tag?: string;
                     /**  5000 */
                     duration: number;
                     /** easing  linear */
                     easing?: Easing;
                     /**  */
                     yoyoForever?: boolean;
                     /**  */
                     yoyoTimes?: number;
                     /**  */
                     repeatForever?: boolean;
                     /**  */
                     repeatTimes?: number;
                     /**  */
                     delay?: number;
                     /**  */
                     autoPlay?: boolean;
                     /**
                      * .
                      * @param target .
                      * @param isEnd 
                      * @param isStop 
                      */
                     onComplete?: (target: any, isEnd: boolean, isStop: boolean) => void;
                     onStart?: (target: any) => void;
                     onUpdate?: (target: any) => void;
                     onProgress?: (target: any, key: string, start: AllowedTypes, end: AllowedTypes, alpha: number, reversed: boolean) => boolean | void;
                 };
             }

             export  class PathEmitter implements EmitterShape {
                 type: string;
                 mode: EmitterMode;
                 spread: number;
                 speed: ValueGenerator | FunctionValueGenerator;
                 paths: [number, number, number][];
                 constructor(parameters: PathEmitterParameters);
                 update(system: ParticleSystem, delta: number): void;
                 initialize(p: Particle): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any): PathEmitter;
                 clone(): EmitterShape;
             }

             export  interface PathEmitterParameters {
                 paths?: [number, number, number][];
                 mode?: EmitterMode;
                 spread?: number;
                 speed?: ValueGenerator | FunctionValueGenerator;
             }

             /**
              * PathGeometry
              */
             export  class PathGeometry extends BufferGeometry {
                 /**
                  * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
                  * @param {Boolean} [generateUv2=false]
                  */
                 constructor(initData?: {
                     pathPointList: PathPointList;
                     options: Record<string, any>;
                     usage: Usage;
                 } | Number, generateUv2?: Boolean);
                 _initByMaxVertex(maxVertex: any, generateUv2: any): void;
                 _initByData(pathPointList: any, options: {}, usage: any, generateUv2: any): void;
                 /**
                  * Update geometry by PathPointList instance
                  * @param {PathPointList} pathPointList
                  * @param {Object} options
                  * @param {Number} [options.width=0.1]
                  * @param {Number} [options.progress=1]
                  * @param {Boolean} [options.arrow=true]
                  * @param {String} [options.side='both'] - "left"/"right"/"both"
                  */
                 update(pathPointList: PathPointList, options?: {
                     width?: number;
                     progress?: number;
                     arrow?: Boolean;
                     side?: "left" | "right" | "both";
                 }): void;
                 _resizeAttribute(name: any, len: any): void;
                 _resizeIndex(len: any): void;
                 _updateAttributes(position: any, normal: any, uv: any, uv2: any, indices: any): void;
             }

             /**
              * Join path parts with separator. Similar to PHP's pathJoin
              * @param parts - path parts
              * @param separator - separator, default '/'
              */
             export  function pathJoin(parts: string[], separator?: string): string;

              type PathKey = keyof PathProps;

             /**
              * PathPointList
              * input points to generate a PathPoint list
              */
             export  class PathPointList {
                 array: any[];
                 count: number;
                 constructor();
                 /**
                  * Set points
                  * @param {Vector3[]} points key points array
                  * @param {number} cornerRadius? the corner radius. set 0 to disable round corner. default is 0.1
                  * @param {number} cornerSplit? the corner split. default is 10.
                  * @param {number} up? force up. default is auto up (calculate by tangent).
                  * @param {boolean} close? close path. default is false.
                  */
                 set(points: any, cornerRadius?: number, cornerSplit?: number, up?: any, close?: boolean): void;
                 /**
                  * Get distance of this path
                  * @return {number}
                  */
                 distance(): any;
                 _getByIndex(index: any): any;
                 _start(current: any, next: any, up: any): void;
                 _end(current: any): void;
                 _corner(current: any, next: any, cornerRadius: any, cornerSplit: any, up: any): void;
                 _sharpCorner(current: any, next: any, up: any, dirType?: number, sharp?: boolean): void;
             }

              type PathPropertyType = PropType<PathProps, PathKey>;

              interface PathProps extends DisplayableProps {
                 strokeContainThreshold?: number;
                 segmentIgnoreThreshold?: number;
                 subPixelOptimize?: boolean;
                 style?: PathStyleProps;
                 shape?: Dictionary<any>;
                 autoBatch?: boolean;
                 __value?: (string | number)[] | (string | number);
                 buildPath?: (ctx: PathProxy | CanvasRenderingContext2D, shapeCfg: Dictionary<any>, inBatch?: boolean) => void;
             }

              class PathProxy {
                 dpr: number;
                 data: number[] | Float32Array;
                 /**
                  * Version is for tracking if the path has been changed.
                  */
                 private _version;
                 /**
                  * If save path data.
                  */
                 private _saveData;
                 /**
                  * If the line segment is too small to draw. It will be added to the pending pt.
                  * It will be added if the subpath needs to be finished before stroke, fill, or starting a new subpath.
                  */
                 private _pendingPtX;
                 private _pendingPtY;
                 private _pendingPtDist;
                 private _ctx;
                 private _xi;
                 private _yi;
                 private _x0;
                 private _y0;
                 private _len;
                 private _pathSegLen;
                 private _pathLen;
                 private _ux;
                 private _uy;
                 static CMD: {
                     M: number;
                     L: number;
                     C: number;
                     Q: number;
                     A: number;
                     Z: number;
                     R: number;
                 };
                 constructor(notSaveData?: boolean);
                 increaseVersion(): void;
                 /**
                  * Version can be used outside for compare if the path is changed.
                  * For example to determine if need to update svg d str in svg renderer.
                  */
                 getVersion(): number;
                 /**
                  * @readOnly
                  */
                 setScale(sx: number, sy: number, segmentIgnoreThreshold?: number): void;
                 setDPR(dpr: number): void;
                 setContext(ctx: ExtendedCanvasRenderingContext2D): void;
                 getContext(): ExtendedCanvasRenderingContext2D;
                 beginPath(): this;
                 /**
                  * Reset path data.
                  */
                 reset(): void;
                 moveTo(x: number, y: number): this;
                 lineTo(x: number, y: number): this;
                 bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): this;
                 quadraticCurveTo(x1: number, y1: number, x2: number, y2: number): this;
                 arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise?: boolean): this;
                 arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;
                 rect(x: number, y: number, w: number, h: number): this;
                 closePath(): this;
                 fill(ctx: CanvasRenderingContext2D): void;
                 stroke(ctx: CanvasRenderingContext2D): void;
                 len(): number;
                 setData(data: Float32Array | number[]): void;
                 appendPath(path: PathProxy | PathProxy[]): void;
                 /**
                  *  Path 
                  * 
                  */
                 addData(cmd: number, a?: number, b?: number, c?: number, d?: number, e?: number, f?: number, g?: number, h?: number): void;
                 private _drawPendingPt;
                 private _expandData;
                 /**
                  * Convert dynamic array to static Float32Array
                  *
                  * It will still use a normal array if command buffer length is less than 10
                  * Because Float32Array itself may take more memory than a normal array.
                  *
                  * 10 length will make sure at least one M command and one A(arc) command.
                  */
                 toStatic(): void;
                 getBoundingRect(): BoundingRect;
                 private _calculateLength;
                 /**
                  * Rebuild path from current data
                  * Rebuild path will not consider javascript implemented line dash.
                  * @param {CanvasRenderingContext2D} ctx
                  */
                 rebuildPath(ctx: PathRebuilder, percent: number): void;
                 clone(): PathProxy;
                 private static initDefaultProps;
             }

              interface PathRebuilder {
                 moveTo(x: number, y: number): void;
                 lineTo(x: number, y: number): void;
                 bezierCurveTo(x: number, y: number, x2: number, y2: number, x3: number, y3: number): void;
                 quadraticCurveTo(x: number, y: number, x2: number, y2: number): void;
                 arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, anticlockwise: boolean): void;
                 ellipse(cx: number, cy: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: boolean): void;
                 rect(x: number, y: number, width: number, height: number): void;
                 closePath(): void;
             }

              type PathState = Pick<PathProps, PathStatePropNames> & {
                 hoverLayer?: boolean;
             };

              type PathStatePropNames = DisplayableStatePropNames | 'shape';

              interface PathStyleProps extends CommonStyleProps {
                 fill?: string | PatternObject | LinearGradientObject | RadialGradientObject;
                 stroke?: string | PatternObject | LinearGradientObject | RadialGradientObject;
                 decal?: PatternObject;
                 /**
                  * Still experimental, not works weel on arc with edge cases(large angle).
                  */
                 strokePercent?: number;
                 strokeNoScale?: boolean;
                 fillOpacity?: number;
                 strokeOpacity?: number;
                 /**
                  * `true` is not supported.
                  * `false`/`null`/`undefined` are the same.
                  * `false` is used to remove lineDash in some
                  * case that `null`/`undefined` can not be set.
                  * (e.g., emphasis.lineStyle in )
                  */
                 lineDash?: false | number[] | 'solid' | 'dashed' | 'dotted';
                 lineDashOffset?: number;
                 lineWidth?: number;
                 lineCap?: CanvasLineCap;
                 lineJoin?: CanvasLineJoin;
                 miterLimit?: number;
                 /**
                  * Paint order, if do stroke first. Similar to SVG paint-order
                  * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order
                  */
                 strokeFirst?: boolean;
             }

              namespace pathTool {
                 export {
                     createFromString,
                     extendFromString,
                     mergePath,
                     clonePath
                 }
             }

             /**  */
             export  class PathTubeEntities {
                 #private;
                 options: PathTubeEntitiesOptions;
                 entity: Entity;
                 /**  */
                 topo: {
                     /**  */
                     tubes: {
                         /** ID */
                         tubeIndex: number;
                         /**  */
                         data: Record<string, any>;
                         /** ID */
                         startNodeId: string;
                         /** ID */
                         endNodeId: string;
                     }[];
                     /**  <ID > */
                     nodes: Map<string, number[]>;
                 };
                 /**  */
                 data: {
                     sect: PathTubeGeometryOptions;
                     pathPointList: PathPointList;
                     mesh: Mesh;
                     box3d: Box3;
                     /**  */
                     [key: string]: any;
                 }[];
                 inputData: {
                     [key: string]: any;
                     /**  */
                     paths: [number, number, number][];
                     /**  false */
                     disableMergeNode?: boolean;
                 }[];
                 geometries: PathTubeGeometry[];
                 constructor(options: PathTubeEntitiesOptions);
                 coordHash(pt: [number, number, number]): string;
                 /**  */
                 update(): void;
                 addTo(target?: App | Entity): void;
                 /**
                  * 
                  * @param point 
                  * @param index  ()
                  * @returns
                  */
                 getSectPoints(point: [number, number, number], index?: number): {
                     points: Vector3[];
                     posBase: Vector3;
                     posLeft: Vector3;
                     posRight: Vector3;
                     posTop: Vector3;
                     posLeftTop: Vector3;
                     posRightTop: Vector3;
                     data: any;
                 };
                 /**
                  * 
                  */
                 showEdgeLine(opts: {
                     /**  true */
                     bottom?: boolean;
                     /**  true */
                     top?: boolean;
                     /**   false */
                     center?: boolean;
                     /**  */
                     color?: ColorRepresentation;
                     /**  true */
                     disableRayQuery?: boolean;
                 }, app?: App): {
                     lineEntity: GlLinesEntity;
                     coordinates: [number, number, number][][];
                 };
                 /**
                  * 
                  */
                 removeEdgeLine(): void;
                 /**
                  * 
                  */
                 getEdgeLines(opts: {
                     /**  true */
                     bottom?: boolean;
                     /**  true */
                     top?: boolean;
                     /**   false */
                     center?: boolean;
                 }): [number, number, number][][];
                 remove(): void;
             }

             export  interface PathTubeEntitiesOptions {
                 /**  */
                 data: {
                     /**  */
                     paths: [number, number, number][];
                     /**  false */
                     disableMergeNode?: boolean;
                     /**  */
                     [key: string]: any;
                 }[];
                 /**  */
                 sect?: PathTubeGeometryOptions;
                 /**   0.3 */
                 nodeRadius?: number;
                 /**  */
                 outerMaterial?: Material;
                 /**  */
                 innerSideMaterial?: Material;
                 /**  outerMaterial   */
                 nodeOuterMaterial?: Material;
                 /**  innerSideMaterial   */
                 nodeInnerSideMaterial?: Material;
                 /** 6 */
                 decimalPrecision?: number;
                 /**  */
                 isMapMode?: boolean;
                 /**  true */
                 asEntity?: boolean;
                 /**  */
                 usage?: Usage;
                 /** y 1 */
                 nodeWidthScaleY?: number;
                 /** 10 */
                 cornerSplit?: number;
                 /** .  [1, 2, ...] ()  [15, 4, 25, 3, 50, 1]*/
                 drawRules?: number[];
                 /** 0.5 */
                 maxNodeRadiusRatio?: number;
                 /**   {shape:  "circle"} */
                 verticalShape?: PathTubeGeometryOptions | {
                     clipRadius?: number;
                 };
                 /**   false */
                 disableMergeNode?: boolean;
                 /** nodeIntersect nodeIntersect nodeEqual  */
                 topoStrategy?: "nodeIntersect" | "nodeEqual";
             }

             /**
              * PathTubeGeometry
              */
             export  class PathTubeGeometry extends PathGeometry {
                 options: any;
                 /**
                  * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.
                  * @param {Boolean} [generateUv2=false]
                  */
                 constructor(initData?: {
                     pathPointList: PathPointList;
                     options: PathTubeGeometryOptions;
                     usage: Usage;
                 } | Number, generateUv2?: boolean);
                 _initByData(pathPointList: any, options: {}, usage: any, generateUv2: any): void;
                 /**
                  * Update geometry by PathPointList instance
                  * @param {PathPointList} pathPointList
                  * @param {Object} options
                  * @param {Number} [options.radius=0.1]
                  * @param {Number} [options.progress=1]
                  * @param {Boolean} [options.radialSegments=8]
                  * @param {Boolean} [options.circleSegments=16]
                  * @param {String} [options.startRad=0]
                  */
                 update(pathPointList: PathPointList, options?: PathTubeGeometryOptions): void;
                 sectDataParam(): any;
             }

              interface PathTubeGeometryOptions {
                 /** 0.5 */
                 radius?: number;
                 /**  1  */
                 progress?: number;
                 /** 8 */
                 radialSegments?: number;
                 /** 16 */
                 circleSegments?: number;
                 /** 0 */
                 startRad?: number;
                 /**  */
                 shape?: "rect" | "arch" | "custom" | "circle" | "rectNoTop";
                 /** 1 */
                 rectWidth?: number;
                 /** 0.5 */
                 rectHeight?: number;
                 /**  xyy */
                 shapePoints?: [number, number][];
             }

              class Pattern {
                 type: 'pattern';
                 image: ImageLike | string;
                 /**
                  * svg element can only be used in svg renderer currently.
                  *
                  * Will be string if using SSR rendering.
                  */
                 svgElement: SVGElement | string;
                 repeat: ImagePatternRepeat;
                 x: number;
                 y: number;
                 rotation: number;
                 scaleX: number;
                 scaleY: number;
                 constructor(image: ImageLike | string, repeat: ImagePatternRepeat);
             }

              type PatternObject = ImagePatternObject | SVGPatternObject;

              interface PatternObjectBase {
                 id?: number;
                 type?: 'pattern';
                 x?: number;
                 y?: number;
                 rotation?: number;
                 scaleX?: number;
                 scaleY?: number;
             }

             /**
              * Temporarily pauses tracking.
              */
              function pauseTracking(): void;

             export  interface PhysicsBodyOption {
                 /**
                  * The collision group the body belongs to.
                  * @default 1
                  */
                 collisionFilterGroup?: number;
                 /**
                  * The collision group the body can collide with.
                  * @default -1
                  */
                 collisionFilterMask?: number;
                 /**
                  * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
                  */
                 collisionResponse?: boolean;
                 /**
                  * World space position of the body.
                  */
                 position?: Vec3;
                 /**
                  * World space velocity of the body.
                  */
                 velocity?: Vec3;
                 /**
                  * The mass of the body.
                  * @default 0
                  */
                 mass?: number;
                 /**
                  * The physics material of the body. It defines the body interaction with other bodies.
                  */
                 material?: Material_2;
                 /**
                  * How much to damp the body velocity each step. It can go from 0 to 1.
                  * @default 0.01
                  */
                 linearDamping?: number;
                 /**
                  * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
                  */
                 type?: BodyType;
                 /**
                  * If true, the body will automatically fall to sleep.
                  * @default true
                  */
                 allowSleep?: boolean;
                 /**
                  * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
                  * @default 0.1
                  */
                 sleepSpeedLimit?: number;
                 /**
                  * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
                  * @default 1
                  */
                 sleepTimeLimit?: number;
                 /**
                  * World space orientation of the body.
                  */
                 quaternion?: Quaternion;
                 /**
                  * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
                  */
                 angularVelocity?: Vec3;
                 /**
                  * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
                  * @default false
                  */
                 fixedRotation?: boolean;
                 /**
                  * How much to damp the body angular velocity each step. It can go from 0 to 1.
                  * @default 0.01
                  */
                 angularDamping?: number;
                 /**
                  * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
                  */
                 linearFactor?: Vec3;
                 /**
                  * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
                  */
                 angularFactor?: Vec3;
                 /**
                  * Add a Shape to the body.
                  */
                 shape?: Shape;
                 /**
                  * When true the body behaves like a trigger. It does not collide
                  * with other bodies but collision events are still triggered.
                  * @default false
                  */
                 isTrigger?: boolean;
             }

             export  class PhysicsManagerModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: PhysicsManagerModuleOptions;
                 world: World;
                 CANNON: typeof CANNON;
                 bodies: MeshPhysicsObjectParams[];
                 constructor(app?: App, options?: PhysicsManagerModuleOptions);
                 get physicsEnable(): boolean;
                 set physicsEnable(enable: boolean);
                 /**  */
                 get physicsWorld(): CANNON.World;
                 /**  */
                 get physicsEngine(): typeof CANNON;
                 /**  */
                 enablePhysicsEngine(): Promise<typeof CANNON>;
                 /**  */
                 addPhysicsBody(phyObject: MeshPhysicsObjectParams): MeshPhysicsObjectParams;
                 removePhysicsObject(object: Object3D | Entity): void;
                 addPhysicsGround(): CANNON.Plane;
                 setPhysicsDebugger(enable: boolean): void;
                 onAwake(): void;
                 onAppAfterUpdate(time: Time): void;
             }

             export  interface PhysicsManagerModuleOptions {
                 /**
                  * The gravity of the world.
                  */
                 gravity?: Vec3;
                 /**
                  * Gravity to use when approximating the friction max force (mu*mass*gravity).
                  * If undefined, global gravity will be used.
                  */
                 frictionGravity?: Vec3;
                 /**
                  * Makes bodies go to sleep when they've been inactive.
                  * @default false
                  */
                 allowSleep?: boolean;
                 /**
                  * The broadphase algorithm to use.
                  * @default NaiveBroadphase
                  */
                 broadphase?: Broadphase;
                 /**
                  * The solver algorithm to use.
                  * @default GSSolver
                  */
                 solver?: Solver;
                 /**
                  * Set to true to use fast quaternion normalization. It is often enough accurate to use.
                  * If bodies tend to explode, set to false.
                  * @default false
                  */
                 quatNormalizeFast?: boolean;
                 /**
                  * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
                  * @default 0
                  */
                 quatNormalizeSkip?: number;
                 maxSubSteps?: number;
             }

             /**
              * 
              */
             export  class PhysicsModule extends EntityModuleBase implements IEntityModuleBase {
                 static moduleName: string;
                 physics: MeshPhysicsObjectParams;
                 constructor(entity: Entity, options?: MeshPhysicsObject);
                 /**  */
                 getBody(): CANNON.Body;
                 /**  */
                 removePhysics(): void;
             }

              interface PhysicsResolver {
                 resolve(pos: Vector3, normal: Vector3): boolean;
             }

             /**
              * Pick `props` from `object.
              *
              * Runtime version of `Pick<T,K>`.
              */
             export  function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K>;

             /**  */
             export  interface PickEnterOptions extends TLEventType {
                 /**  false*/
                 highlightUseBoxHelper?: boolean;
                 /**   "#ff0000" */
                 highlightColor?: ColorRepresentation;
                 /**  0.5 */
                 highlightOpacity?: number;
                 /**  */
                 target?: InteractiveObject;
                 /**  */
                 queryOptions?: EntityQueryOption;
                 /**  true */
                 clickNoEntityExit?: boolean;
                 /**  false */
                 clickNoSelfEntityExit?: boolean;
                 /**  */
                 clickIsEqualObject?: Object3D | Function;
                 /**  true */
                 clickEntitySelected?: boolean;
                 /**  false */
                 rightClickConfirmExit?: boolean;
                 /** esc  true */
                 enterEscConfirmExit?: boolean;
                 /**  */
                 pickCallBack?: (cb: {
                     oldPick: InteractiveObject | undefined | null;
                     curPick: InteractiveObject | undefined | null;
                 }) => void;
                 /**  */
                 onPointerMove?: (info: TLEventHandler, context: {
                     /**   */
                     complete: (info?: TLEventHandler) => void;
                 }, oldHover?: InteractiveObject, newHover?: InteractiveObject) => void;
                 /**  */
                 onKeyUp?: (info: TLEventHandler, context: {
                     /**   */
                     complete: (info?: TLEventHandler) => void;
                 }) => void;
                 /**  */
                 onContextMenu?: (info: TLEventHandler, context: {
                     /**   */
                     complete: (info?: TLEventHandler) => void;
                 }) => void;
                 /**  */
                 onComplete?: (isCancel: boolean, info?: TLEventHandler, select?: InteractiveObject) => void;
             }

             export  interface PickEntityOptions {
                 /**  false*/
                 highlightUseBoxHelper?: boolean;
                 /**   "#ff0000" */
                 highlightColor?: ColorRepresentation;
                 /**  0.5 */
                 highlightOpacity?: number;
                 /** unproject (undefined false , true)    (-1  1 )          depth */
                 unprojectOpts?: UnProjectOpts | "depth";
                 /**  */
                 maxSelectedCount?: number;
                 /** ESC  */
                 escCancel?: boolean;
                 /**   */
                 enterKeyConfirm?: boolean;
                 /**  */
                 dblClickConfirm?: boolean;
                 /**  */
                 rightClickConfirm?: boolean;
                 /**  */
                 exitAutoClearHighlight?: boolean;
                 /** ) 100ms 0 */
                 exitAutoClearDelay?: number;
                 /**  shift) */
                 canSelectBox?: boolean;
                 /** shift  */
                 shiftSelectBox?: boolean;
                 /**  */
                 selectBoxStyle?: Record<string, any>;
                 /**  */
                 onlyUseSelectBox?: boolean;
                 /** Ctrlctrl) */
                 ctrlKeyCencelSelect?: boolean;
                 /** div)  */
                 autoFocus?: boolean;
                 /**  true */
                 filterEntityCb?: (ent: Entity) => boolean;
                 /**   */
                 rightClickCb?: (e: any, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /** enter enterKeyConfirm false) */
                 enterKeyCb?: (e: any, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  */
                 keydownCb?: (e: any, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  */
                 updateCoordinate?: (e: any, context: {
                     worldPos?: Vector3;
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  */
                 onSelectBoxEnd?: (pointLeftTop: Vector2, pointBottomRight: Vector2, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  false */
                 onSelect?: (currentEntity: Entity, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<boolean> | any;
                 /**  true */
                 beforeConfirm?: (e: any, context: {
                     entity?: Entity[];
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  */
                 onResult?: (entity?: Entity[]) => Promise<any> | any;
             }

             /**
              * 
              */
             export  class PickModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 constructor(app?: App);
                 get isFreeStatus(): boolean;
                 set isFreeStatus(v: boolean);
                 get isFreeStatusRef(): Ref<boolean>;
                 onAwake(): void;
                 /**
                  * 
                  */
                 pickPoint(opts?: PickPointOptions): Promise<unknown>;
                 /**
                  * 
                  */
                 pickEntity(opts?: PickEntityOptions): Promise<unknown>;
                 drawSelectBox(style?: Record<string, any>, shiftSelectBox?: boolean): Promise<unknown>;
                 actionDrawPoint(opts?: IDrawPointEnterOptions): Promise<unknown>;
                 actionDrawLineSting(opts?: IDrawLineEnterOptions): Promise<unknown>;
                 actionDrawPolygon(opts?: IDrawPolygonEnterOptions): Promise<unknown>;
                 actionDrawEdit(opts?: IDrawEditEnterOptions): Promise<unknown>;
                 actionPickSelect(opts?: PickEnterOptions): Promise<unknown>;
                 getDrawLayer(layerName?: string, noCreateStyle?: Record<string, any>): {
                     symbol: () => SymbolEntity | undefined;
                     polylines: () => PolylinesEntity | undefined;
                     polygons: () => PolygonsEntity | undefined;
                     addPointData: (data: SymbolItemData, addToCommand?: boolean) => SymbolEntity;
                     addPolylineData: (data: PolylineItemData, addToCommand?: boolean) => PolylinesEntity;
                     addPolygonData: (data: PolygonItemData, addToCommand?: boolean) => PolygonsEntity;
                     updatePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
                     updatePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
                     updatePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
                     deletePointData: (data: SymbolItemData, addToCommand?: boolean) => boolean;
                     deletePolylineData: (data: PolylineItemData, addToCommand?: boolean) => boolean;
                     deletePolygonData: (data: PolygonItemData, addToCommand?: boolean) => boolean;
                 };
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface PickPointOptions {
                 /** unproject (undefined false , true)    (-1  1 )          depth */
                 unprojectOpts?: UnProjectOpts | "depth";
                 /** ESC  */
                 escCancel?: boolean;
                 /**  */
                 rightClickCancel?: boolean;
                 /**  */
                 callUpdateWhenAwake?: boolean;
                 /** div)  */
                 autoFocus?: boolean;
                 /**  */
                 rightClickCb?: (e: any, context: {
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any>;
                 /** enter) */
                 enterKeyCb?: (e: any, context: {
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any>;
                 /**  */
                 keydownCb?: (e: any, context: {
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any>;
                 /**  */
                 updateCoordinate?: (e: any, context: {
                     worldPos?: Vector3;
                     intersectObject?: any;
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
                 /**  true */
                 beforeConfirm?: (e: any, context: {
                     worldPos?: Vector3;
                     intersectObject?: any;
                     resolve: (value: unknown) => void;
                     reject: (reason?: any) => void;
                 }) => Promise<any> | any;
             }

             /**  */
             export  class PickTool extends StateNode {
                 static id: string;
                 static initial: string;
                 static children: () => (typeof Idle_4)[];
             }

             export  type PickType<T, U> = {
                 [P in keyof T as T[P] extends U ? P : never]: T[P];
             };

             export  class PiecewiseBezier extends PiecewiseFunction<Bezier> implements FunctionValueGenerator {
                 constructor(curves?: Array<[Bezier, number]>);
                 genValue(t?: number): number;
                 toSVG(length: number, segments: number): string;
                 type: "function";
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): PiecewiseBezier;
                 clone(): FunctionValueGenerator;
             }

             export  abstract class PiecewiseFunction<T> {
                 functions: Array<[T, number]>;
                 protected constructor();
                 findFunction(t: number): number;
                 getStartX(index: number): number;
                 setStartX(index: number, x: number): void;
                 getEndX(index: number): number;
                 setEndX(index: number, x: number): void;
                 insertFunction(t: number, func: T): void;
                 removeFunction(index: number): T;
                 getFunction(index: number): T;
                 setFunction(index: number, func: T): void;
                 get numOfFunctions(): number;
             }

             

             /**
              * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
              * @example
              *     const planeShape = new CANNON.Plane()
              *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })
              *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
              *     world.addBody(planeBody)
              */
              class Plane_2 extends Shape {
                 /** worldNormal */
                 worldNormal: Vec3;
                 /** worldNormalNeedsUpdate */
                 worldNormalNeedsUpdate: boolean;
                 boundingSphereRadius: number;
                 constructor();
                 /** computeWorldNormal */
                 computeWorldNormal(quat: Quaternion_2): void;
                 calculateLocalInertia(mass: number, target?: Vec3): Vec3;
                 volume(): number;
                 calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
                 updateBoundingSphereRadius(): void;
             }

             export  interface PlaneConfig {
                 vertexShader: string;
                 fragmentShader: string;
                 uniforms: {
                     [uniform: string]: IUniform<any>;
                 };
                 /**  */
                 opacityColor?: ColorRepresentation;
                 /**  */
                 opacity?: number;
                 /**  */
                 depthTest?: boolean;
                 /**  false*/
                 depthWrite?: boolean;
                 /**  */
                 map?: Texture;
                 /**  */
                 materialParam?: ShaderMaterialParameters;
                 /**  */
                 material?: Material;
                 /**  [0-1] */
                 mouseInputPos?: [number, number];
                 /**  */
                 renderOrder?: number;
                 /**  true */
                 frustumCulled?: boolean;
             }

              interface Platform {
                 createCanvas(): HTMLCanvasElement;
                 measureText(text: string, font?: string): {
                     width: number;
                 };
                 loadImage(src: string, onload: () => void | HTMLImageElement['onload'], onerror: () => void | HTMLImageElement['onerror']): HTMLImageElement;
             }

             /**  */
             export  class PluginManager {
                 #private;
                 cacheResult: Map<string, any>;
                 private loaderUrlPath;
                 /**
                  * 
                  * @param path 
                  * @param opts
                  */
                 loadPlugin(path: string, opts?: LoadPluginOpts): Promise<any>;
                 /**
                  * 
                  * @param path 
                  * @param opts
                  */
                 loadLibrary(path: string, opts?: LoadPluginOpts): Promise<any>;
                 setLoaderPath(urlPath: string, dirs?: Array<string>): void;
             }

             export  let Plugins: vjmap3d_2.PluginManager;

              class Point {
                 x: number;
                 y: number;
                 constructor(x?: number, y?: number);
                 /**
                  * Copy from another point
                  */
                 copy(other: PointLike): this;
                 /**
                  * Clone a point
                  */
                 clone(): Point;
                 /**
                  * Set x and y
                  */
                 set(x: number, y: number): this;
                 /**
                  * If equal to another point
                  */
                 equal(other: PointLike): boolean;
                 /**
                  * Add another point
                  */
                 add(other: PointLike): this;
                 scale(scalar: number): void;
                 scaleAndAdd(other: PointLike, scalar: number): void;
                 /**
                  * Sub another point
                  */
                 sub(other: PointLike): this;
                 /**
                  * Dot product with other point
                  */
                 dot(other: PointLike): number;
                 /**
                  * Get length of point
                  */
                 len(): number;
                 /**
                  * Get squared length
                  */
                 lenSquare(): number;
                 /**
                  * Normalize
                  */
                 normalize(): this;
                 /**
                  * Distance to another point
                  */
                 distance(other: PointLike): number;
                 /**
                  * Square distance to another point
                  */
                 distanceSquare(other: Point): number;
                 /**
                  * Negate
                  */
                 negate(): this;
                 /**
                  * Apply a transform matrix array.
                  */
                 transform(m: MatrixArray): this;
                 toArray(out: number[]): number[];
                 fromArray(input: number[]): void;
                 static set(p: PointLike, x: number, y: number): void;
                 static copy(p: PointLike, p2: PointLike): void;
                 static len(p: PointLike): number;
                 static lenSquare(p: PointLike): number;
                 static dot(p0: PointLike, p1: PointLike): number;
                 static add(out: PointLike, p0: PointLike, p1: PointLike): void;
                 static sub(out: PointLike, p0: PointLike, p1: PointLike): void;
                 static scale(out: PointLike, p0: PointLike, scalar: number): void;
                 static scaleAndAdd(out: PointLike, p0: PointLike, p1: PointLike, scalar: number): void;
                 static lerp(out: PointLike, p0: PointLike, p1: PointLike, t: number): void;
             }

             export  function pointDistance(a: [number, number, number], b: [number, number, number]): number;

             /**
              * A point emitter emits particles from a single point.
              */
             export  class PointEmitter implements EmitterShape {
                 type: string;
                 constructor();
                 update(system: ParticleSystem, delta: number): void;
                 initialize(p: Particle): void;
                 toJSON(): ShapeJSON;
                 static fromJSON(json: any): PointEmitter;
                 clone(): EmitterShape;
             }

             /**
              * A helper class to handle pointer events and dispatch drag events: `drag`, `dragStart` and `dragEnd` with NDC coordinates and time.
              *
              * To use, create an object of the class, set `element` with the HTML element(like canvas) and add event listeners to drag events.
              *
              * @example
              * ```ts
              * const pointerDragHelper = new PointerDragHelper()
              * pointerDragHelper.element = canvas
              * pointerDragHelper.addEventListener('dragStart', (e) => {
              *    console.log('dragStart', e.pointer)
              *    // {x: -0.5, y: 0.5, time: 123456789}
              *    // x and y are NDC coordinates, time is the time when the event is fired.
              *    // x and y are in the range of [-1, 1].
              *    // x is left to right, y is bottom to top.
              *    // time is in milliseconds.
              * })
              * pointerDragHelper.addEventListener('drag', (e) => {
              *   console.log('drag', e.pointer)
              *   // {x: -0.5, y: 0.5, time: 123456789}
              * })
              * pointerDragHelper.addEventListener('dragEnd', (e) => {
              *  console.log('dragEnd', e.pointer)
              *  // {x: -0.5, y: 0.5, time: 123456789}
              * })
              * ```
              */
             export  class PointerDragHelper extends SimpleEventDispatcher<"dragStart" | "drag" | "dragEnd"> implements IDisposable {
                 private _pointerDown?;
                 private _pointer?;
                 private _pointerUp?;
                 get element(): HTMLElement | undefined;
                 set element(value: HTMLElement | undefined);
                 private _element?;
                 private _removeElement;
                 private _addElement;
                 private readonly _onPointerDown;
                 private readonly _onPointerMove;
                 private readonly _onPointerUp;
                 dispose(): void;
             }

              interface PointerInput {
                 pointerId: number;
                 clientX: number;
                 clientY: number;
                 deltaX: number;
                 deltaY: number;
                 mouseButton: MOUSE_BUTTON | null;
             }

              interface PointLike {
                 x: number;
                 y: number;
             }

              class PointsHelper extends InstancedMesh {
                 constructor(count?: number, points?: Vector3[]);
                 setPoints(points: Vector3): void;
             }

             /**
              * Connects two bodies at given offset points.
              * @example
              *     const bodyA = new Body({ mass: 1 })
              *     const bodyB = new Body({ mass: 1 })
              *     bodyA.position.set(-1, 0, 0)
              *     bodyB.position.set(1, 0, 0)
              *     bodyA.addShape(shapeA)
              *     bodyB.addShape(shapeB)
              *     world.addBody(bodyA)
              *     world.addBody(bodyB)
              *     const localPivotA = new Vec3(1, 0, 0)
              *     const localPivotB = new Vec3(-1, 0, 0)
              *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB)
              *     world.addConstraint(constraint)
              */
              class PointToPointConstraint extends Constraint {
                 /**
                  * Pivot, defined locally in bodyA.
                  */
                 pivotA: Vec3;
                 /**
                  * Pivot, defined locally in bodyB.
                  */
                 pivotB: Vec3;
                 equationX: ContactEquation;
                 equationY: ContactEquation;
                 equationZ: ContactEquation;
                 /**
                  * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
                  * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
                  * @param pivotB The point relative to the center of mass of bodyB which bodyB is constrained to.
                  * @param maxForce The maximum force that should be applied to constrain the bodies.
                  */
                 constructor(bodyA: Body_2, pivotA: Vec3, bodyB: Body_2, pivotB?: Vec3, maxForce?: number);
                 update(): void;
             }

             /**
              * 
              * @param p
              * @param p1
              * @param p2
              * @return {number}
              */
             export  function pointToSegmentDistance(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): number;

              class Polygon extends Path<PolygonProps> {
                 shape: PolygonShape;
                 constructor(opts?: PolygonProps);
                 getDefaultShape(): PolygonShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: PolygonShape): void;
             }

             /**
              * Polygon Geometry Object
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.6
              */
              interface Polygon_2 extends GeometryObject {
                 type: "Polygon";
                 coordinates: Position[][];
             }

             export  interface PolygonItemData {
                 /** id */
                 id?: string;
                 /**  */
                 coordinates: [number, number, number][][] | [number, number, number][];
                 /**  */
                 color?: ColorRepresentation | ColorRepresentation[];
                 /** (0-1) */
                 opacity?: number;
                 /**  */
                 borderColor?: ColorRepresentation;
                 /**   */
                 showVertex?: boolean;
                 /**  */
                 disableEdit?: boolean;
                 /**  */
                 hidden?: boolean;
                 /**  true */
                 autoAntiClockwise?: boolean;
                 /**  */
                 [key: string]: any;
             }

              interface PolygonProps extends PathProps {
                 shape?: Partial<PolygonShape>;
             }

             /**
              * 
              */
             export  class PolygonsEntity extends Entity {
                 constructor(options: PolygonsEntityOptions);
                 /**
                  * 
                  */
                 getPolygons: () => Mesh;
                 /**
                  * 
                  */
                 getVertexSymbol: () => SymbolEntity;
                 /**
                  * 
                  */
                 isShowVertex: () => boolean;
                 /**
                  * 
                  */
                 setShowVertex: (show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }) => void;
                 /**
                  * 
                  */
                 getVertexData: (isGetAll?: boolean) => SymbolItemData[];
                 /**
                  * 
                  */
                 getBorderPolyline: () => LineSegments2_2;
                 /**
                  * 
                  */
                 updateStyle: (style: MeshBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 updateHightStyle: (style: MeshBasicMaterialParameters) => void;
                 /**
                  * 
                  */
                 setData: (data: PolygonItemData[]) => void;
                 /**
                  * 
                  */
                 getData: () => PolygonItemData[];
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
                     positionIndex: number;
                 } & PolygonItemData;
                 /**
                  * 
                  */
                 refreshHighlight: () => void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight: (id: string) => boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight: () => void;
                 /**
                  * 
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
             }

             export  type PolygonsEntityOptions = EntityOptions & PolygonsModuleOption;

              class PolygonShape {
                 points: VectorArray[];
                 smooth?: number;
                 smoothConstraint?: VectorArray[];
             }

             /**
              * ,
              */
             export  class PolygonsModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 polygons: Mesh;
                 data: PolygonItemData[];
                 style: MeshBasicMaterialParameters;
                 highlightPolygons: Mesh;
                 highlightData: PolygonItemData[];
                 highlightIndexMap: Map<string, number>;
                 highlightStyle: MeshBasicMaterialParameters;
                 facePosIndex: Map<number, {
                     polyIndex: number;
                     face: [number, number, number];
                 }>;
                 isXYPlane: boolean;
                 borderStyle: LineMaterialParameters_2;
                 showBorder: boolean;
                 useBvh: boolean;
                 borderPolyline: LineSegments2_2;
                 vertexEntity: SymbolEntity;
                 showVertex: boolean;
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
                 constructor(entity: Entity, options?: PolygonsModuleOption);
                 setupUiConfig(): UiObjectConfig;
                 /**
                  * 
                  */
                 getPolygons(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
                 /**
                  * 
                  */
                 getVertexSymbol(): SymbolEntity;
                 /**
                  * 
                  */
                 getBorderPolyline(): LineSegments2_2;
                 /**
                  * 
                  */
                 updateStyle(style: MeshBasicMaterialParameters): void;
                 /**
                  * 
                  */
                 updateHightStyle(style: MeshBasicMaterialParameters): void;
                 /**
                  * 
                  */
                 isShowVertex(): boolean;
                 /**
                  * 
                  */
                 getVertexData(isGetAll?: boolean): SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex(show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }): void;
                 /**
                  * 
                  */
                 setData(data: PolygonItemData[]): void;
                 /**
                  * 
                  */
                 getData(): PolygonItemData[];
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
                     data: PolygonItemData;
                     face: [number, number, number];
                 } | {
                     face: number[];
                     /** id */
                     id?: string;
                     /**  */
                     coordinates: [number, number, number][] | [number, number, number][][];
                     /**  */
                     color?: ColorRepresentation | ColorRepresentation[];
                     /** (0-1) */
                     opacity?: number;
                     /**  */
                     borderColor?: ColorRepresentation;
                     /**   */
                     showVertex?: boolean;
                     /**  */
                     disableEdit?: boolean;
                     /**  */
                     hidden?: boolean;
                     /**  true */
                     autoAntiClockwise?: boolean;
                     data?: undefined;
                 };
                 /**
                  * 
                  * @returns
                  */
                 refreshHighlight(): void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight(id: string): boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight(): void;
             }

             export  interface PolygonsModuleOption {
                 /**  */
                 data: PolygonItemData[];
                 /**  */
                 style?: MeshBasicMaterialParameters;
                 /**  */
                 highlightStyle?: MeshBasicMaterialParameters;
                 /**  */
                 borderStyle?: LineMaterialParameters_2;
                 /**  */
                 showBorder?: boolean;
                 /** xyxz  */
                 isXYPlane?: boolean;
                 /** bvh */
                 useBvh?: boolean;
                 /** () */
                 showVertex?: boolean;
                 /** y0.1z-fighting */
                 yOffsetDelta?: number;
                 /**  */
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
             }

              class Polyline extends Path<PolylineProps> {
                 shape: PolylineShape;
                 constructor(opts?: PolylineProps);
                 getDefaultStyle(): {
                     stroke: string;
                     fill: string;
                 };
                 getDefaultShape(): PolylineShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: PolylineShape): void;
             }

             export  interface PolylineItemData {
                 /** id */
                 id?: string;
                 /**  */
                 coordinates: [number, number, number][];
                 /**  */
                 color?: ColorRepresentation | ColorRepresentation[];
                 /**  */
                 lineWidth?: number;
                 /**  */
                 opacity?: number;
                 /**  */
                 dashed?: boolean;
                 /**  */
                 dashOffset?: number;
                 /**  */
                 dashScale?: number;
                 /**  */
                 dashSize?: number;
                 /**  */
                 gapSize?: number;
                 /**  */
                 showVertex?: boolean;
                 /**  */
                 disableEdit?: boolean;
                 /**  */
                 hidden?: boolean;
                 /**  */
                 [key: string]: any;
             }

              interface PolylineProps extends PathProps {
                 shape?: Partial<PolylineShape>;
             }

             /**
              * 
              */
             export  class PolylinesEntity extends Entity {
                 constructor(options: PolylinesEntityOptions);
                 /**
                  * 
                  */
                 getPolylines: () => LineSegments2_2;
                 /**
                  * 
                  */
                 getVertexSymbol: () => SymbolEntity;
                 /**
                  * 
                  */
                 isShowVertex: () => boolean;
                 /**
                  * 
                  */
                 getVertexData: (isGetAll?: boolean) => SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex: (show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }) => void;
                 /**
                  * 
                  */
                 updateStyle: (style: LineMaterialParameters_2) => void;
                 /**
                  * 
                  */
                 updateHightStyle: (style: LineMaterialParameters_2) => void;
                 /**
                  * 
                  */
                 setData: (data: PolylineItemData[]) => void;
                 /**
                  * 
                  */
                 getData: () => PolylineItemData[];
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex: (faceIndex: number, isRefData?: boolean) => {
                     positionIndex: number;
                 } & PolylineItemData;
                 /**
                  * 
                  */
                 refreshHighlight: () => void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight: (id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean) => void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight: (id: string) => boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight: () => void;
                 /**
                  * 
                  */
                 isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
             }

             export  type PolylinesEntityOptions = EntityOptions & PolylinesModuleOption;

              class PolylineShape {
                 points: VectorArray[];
                 percent?: number;
                 smooth?: number;
                 smoothConstraint?: VectorArray[];
             }

             /**
              * ,
              */
             export  class PolylinesModule extends EntityModuleBase implements IEntityModuleBase {
                 #private;
                 static moduleName: string;
                 polylines: LineSegments2;
                 data: PolylineItemData[];
                 style: LineMaterialParameters;
                 highlightPolylines: LineSegments2;
                 highlightData: PolylineItemData[];
                 highlightStyle: LineMaterialParameters;
                 highlightIndexMap: Map<string, number>;
                 facePosIndex: Map<number, {
                     lineIndex: number;
                     positionIndex: number;
                 }>;
                 vertexEntity: SymbolEntity;
                 showVertex: boolean;
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
                 constructor(entity: Entity, options?: PolylinesModuleOption);
                 setupUiConfig(): UiObjectConfig;
                 /**
                  * 
                  */
                 getPolylines(): LineSegments2;
                 /**
                  * 
                  */
                 getVertexSymbol(): SymbolEntity;
                 /**
                  * 
                  */
                 updateStyle(style: LineMaterialParameters): void;
                 /**
                  * 
                  */
                 updateHightStyle(style: LineMaterialParameters): void;
                 /**
                  * 
                  */
                 setData(data: PolylineItemData[]): void;
                 /**
                  * 
                  */
                 isShowVertex(): boolean;
                 /**
                  * 
                  */
                 getVertexData(isGetAll?: boolean): SymbolItemData[];
                 /**
                  * 
                  */
                 setShowVertex(show: boolean, symbolStyleOptions?: {
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }): void;
                 /**
                  * 
                  */
                 getData(): PolylineItemData[];
                 /**
                  * faceIndex
                  * @param faceIndex 
                  * @param isRefData ,false,
                  */
                 getItemDataByFaceIndex(faceIndex: number, isRefData?: boolean): {
                     data: PolylineItemData;
                     positionIndex: number;
                 } | {
                     positionIndex: number;
                     /** id */
                     id?: string;
                     /**  */
                     coordinates: [number, number, number][];
                     /**  */
                     color?: ColorRepresentation | ColorRepresentation[];
                     /**  */
                     lineWidth?: number;
                     /**  */
                     opacity?: number;
                     /**  */
                     dashed?: boolean;
                     /**  */
                     dashOffset?: number;
                     /**  */
                     dashScale?: number;
                     /**  */
                     dashSize?: number;
                     /**  */
                     gapSize?: number;
                     /**  */
                     showVertex?: boolean;
                     /**  */
                     disableEdit?: boolean;
                     /**  */
                     hidden?: boolean;
                     data?: undefined;
                 };
                 /**
                  * 
                  * @returns
                  */
                 refreshHighlight(): void;
                 /**
                  * 
                  * @param id id
                  * @param ishighlight 
                  * @param disableAutoRefreshData   refreshHighlight 
                  * @returns
                  */
                 setItemHighlight(id: string, ishighlight?: boolean, disableAutoRefreshData?: boolean): void;
                 /**
                  * 
                  * @param id id
                  * @returns
                  */
                 isItemHighlight(id: string): boolean;
                 /**
                  * 
                  * @returns
                  */
                 clearHighlight(): void;
             }

             export  interface PolylinesModuleOption {
                 /**  */
                 data: PolylineItemData[];
                 /**  */
                 style?: LineMaterialParameters;
                 /** () */
                 highlightStyle?: LineMaterialParameters;
                 /** () */
                 showVertex?: boolean;
                 /**  */
                 vertexStyle?: SymbolMaterialProps & {
                     pointColor?: ColorRepresentation;
                     pointBorderColor?: ColorRepresentation;
                     pointSize?: number;
                 };
             }

             /**
              * For pooling objects that can be reused.
              */
              class Pool {
                 /**
                  * The objects array.
                  */
                 objects: any[];
                 /**
                  * The type of the objects.
                  */
                 type: any;
                 /**
                  * Release an object after use
                  */
                 release(...args: any[]): Pool;
                 /**
                  * Get an object
                  */
                 get(): any;
                 /**
                  * Construct an object. Should be implemented in each subclass.
                  */
                 constructObject(): void;
                 /**
                  * @return Self, for chaining
                  */
                 resize(size: number): Pool;
             }

             export  type PopopOffset = [number, number] | number | {
                 'center'?: [number, number];
                 'top'?: [number, number];
                 'bottom'?: [number, number];
                 'left'?: [number, number];
                 'right'?: [number, number];
                 'top-left'?: [number, number];
                 'top-right'?: [number, number];
                 'bottom-left'?: [number, number];
                 'bottom-right'?: [number, number];
             };

             /**
              * 2dhtml
              */
             export  class Popup2D extends CSS2DObject {
                 #private;
                 app: App;
                 options: PopupOptions;
                 _content: HTMLElement;
                 _container: HTMLElement;
                 _closeButton: HTMLElement;
                 _tip: HTMLElement;
                 _pos?: [number, number];
                 _anchor: Anchor;
                 _classList: Set<string>;
                 isPopup2D: boolean;
                 signal: {
                     open: Signal;
                     close: Signal;
                     elementSizeReady: Signal;
                 };
                 constructor(options?: PopupOptions);
                 /**
                  * .
                  *
                  * @param {App} app add the popup to.
                  */
                 addTo(app: App | Entity | Object3D, curApp?: App): this;
                 /**
                  * .
                  *
                  * @returns {boolean} `true` , `false` 
                  * @example
                  * const isPopupOpen = popup.isOpen();
                  */
                 isOpen(): boolean;
                 /**
                  * .
                  *
                  * @example
                  * const popup = new vjvjmap3d.Popup().addTo(app);
                  * popup.remove();
                  * @returns {Popup} Returns itself to allow for method chaining.
                  */
                 remove(): this;
                 /**
                  * .
                  */
                 getPosition(): Vector3;
                 /**
                  *.
                  */
                 setPosition(pos: Vector3 | [number, number, number] | number, y?: number, z?: number): this;
                 /**
                  * .
                  *
                  * @example
                  * // Change the `Popup` element's font size
                  * const popup = new vjvjmap3d.Popup()
                  *     .setLngLat([-96, 37.8])
                  *     .setHTML("<p>Hello World!</p>")
                  *     .addTo(app);
                  * const popupElem = popup.getElement();
                  * popupElem.style.fontSize = "25px";
                  * @returns {HTMLElement} Returns container element.
                  */
                 getElement(): HTMLElement;
                 isShow(): boolean;
                 show(): void;
                 hide(): void;
                 /**
                  * .
                  *
                  * This function creates a Text node in the DOM,
                  * so it cannot insert raw HTML. Use this method for security against XSS
                  * if the popup content is user-provided.
                  *
                  * @param {string} text Textual content for the popup.
                  * @returns {Popup} Returns itself to allow for method chaining.
                  * @example
                  * popup.setText('Hello, world!')
                  */
                 setText(text: string): this;
                 /**
                  * html.
                  *
                  * @param {string} html A string representing HTML content for the popup.
                  * @returns {Popup} Returns itself to allow for method chaining.
                  * @example
                  * popup.setHTML("<h1>Hello World!</h1>")
                  */
                 setHTML(html: string): this;
                 /**
                  * .
                  *
                  * @returns {string} The maximum width of the popup.
                  * @example
                  * const maxWidth = popup.getMaxWidth();
                  */
                 getMaxWidth(): string;
                 /**
                  * . CSS  `max-width`.
                  *
                  * @param {string} maxWidth A string representing the value for the maximum width.
                  * @returns {Popup} Returns itself to allow for method chaining.
                  * @example
                  * popup.setMaxWidth('50');
                  */
                 setMaxWidth(maxWidth: string): this;
                 /**
                  * DOM.
                  *
                  * @param {Element} htmlNode A DOM node to be used as content for the popup.
                  * @returns {Popup} Returns itself to allow for method chaining.
                  * @example
                  * // create an element with the popup content
                  * const div = window.document.createElement('div');
                  * div.innerHTML = 'Hello, world!';
                  * popup.setDOMContent(div)
                  */
                 setDOMContent(htmlNode: Node): this;
                 /**
                  * CSS
                  *
                  * @param {string} className Non-empty string with CSS class name to add to popup container.
                  * @returns {Popup} Returns itself to allow for method chaining.
                  *
                  * @example
                  * const popup = new vjvjmap3d.Popup();
                  * popup.addClassName('some-class');
                  */
                 addClassName(className: string): this;
                 /**
                  * CSS
                  *
                  * @param {string} className Non-empty string with CSS class name to remove from popup container.
                  *
                  * @returns {Popup} Returns itself to allow for method chaining.
                  * @example
                  * const popup = new vjvjmap3d.Popup({className: 'some classes'});
                  * popup.removeClassName('some');
                  */
                 removeClassName(className: string): this;
                 /**
                  * 
                  *
                  * @param {number | PointLike | Object} offset Sets the popup's offset. The `Object` is of the following structure
                  * @returns {Popup} `this`.
                  * @example
                  * popup.setOffset(10);
                  */
                 setOffset(offset?: PopopOffset): this;
                 /**
                  * CSS
                  *
                  * @param {string} className Non-empty string with CSS class name to add/remove.
                  *
                  * @returns {boolean} If the class was removed return `false`. If the class was added, then return `true`.
                  *
                  * @example
                  * const popup = new vjvjmap3d.Popup();
                  * popup.toggleClassName('highlighted');
                  */
                 toggleClassName(className: string): boolean;
                 _createCloseButton(): void;
                 _onMouseUp(event: InteractiveEvent): void;
                 _onMouseMove(event: InteractiveEvent): void;
                 _onDrag(event: InteractiveEvent): void;
                 _getAnchor(offset: any): Anchor;
                 updateClassList(): void;
                 /**
                  * 
                  * @param bkColor 
                  * @param closeBtnColor 
                  */
                 setColor(bkColor?: string, closeBtnColor?: string): void;
                 update(cursor?: [number, number]): void;
                 _focusFirstElement(): void;
                 _onClose(): void;
                 setOpacity(opacity: string | number): void;
                 static normalizeOffset(offset?: PopopOffset): {
                     center: number[];
                     top: number[];
                     'top-left': number[];
                     'top-right': number[];
                     bottom: number[];
                     'bottom-left': number[];
                     'bottom-right': number[];
                     left: number[];
                     right: number[];
                 };
             }

             export  type PopupOptions = {
                 closeButton?: boolean;
                 closeOnClick?: boolean;
                 closeOnMove?: boolean;
                 focusAfterOpen?: boolean;
                 anchor?: Anchor;
                 offset?: PopopOffset;
                 className?: string;
                 maxWidth?: string;
                 backgroundColor?: string;
                 buttonColor?: string;
                 showArrow?: boolean;
                 /**  */
                 isHide?: boolean;
             };

             /**
              * Position
              *
              * https://tools.ietf.org/html/rfc7946#section-3.1.1
              * Array should contain between two and three elements.
              * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
              * but the current specification only allows X, Y, and (optionally) Z to be defined.
              */
              type Position = [number, number] | [number, number, number];

             export  class PostProcessModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: PostProcessModuleOptions;
                 _isFirstRender: boolean;
                 depthPickingPass: DepthPickingPass;
                 _composer: EffectComposer;
                 _passes: Pass[];
                 signal: {
                     beforeAddComposer: Signal;
                     afterAddComposer: Signal;
                     beforeAddRenderPass: Signal;
                     afterAddRenderPass: Signal;
                     beforeRemoveComposer: Signal;
                     afterRemoveComposer: Signal;
                     beforeRemoveRenderPass: Signal;
                     afterRemoveRenderPass: Signal;
                     beforRenderComposer: Signal;
                     afterRenderComposer: Signal;
                     beforRebuild: Signal;
                     afterRebuild: Signal;
                 };
                 constructor(app?: App, options?: PostProcessModuleOptions);
                 get composer(): EffectComposer;
                 addEffectRenderPass(pass: Pass, orderIndex?: number): void;
                 setEffectRenderPassOrder(pass: Pass, orderIndex: number): void;
                 removeEffectRenderPass(pass: Pass): void;
                 setEffectRenderPassEnable(pass: Pass, enable: boolean): void;
                 isComposerEnable(): boolean;
                 setComposerEnable(b: boolean): void;
                 onAwake(): void;
                 get outlineEffect(): OutlineEffect;
                 get bloomEffect(): SelectiveBloomEffect;
                 get selectedEffect(): OutlineEffect;
                 getDepth(x: number, y: number): Promise<number>;
                 refreshEffectRenderPass(foreceUpdate?: boolean): void;
                 onAppRender(time: Time): void;
                 addKawaseBlurPass(): void;
                 addToneMappingEffect(): void;
                 addColorDepthEffect(): void;
                 addDepthOfFieldEffect(): void;
                 addGlitchEffect(): void;
                 addPixelationEffect(): void;
                 addSSAOEffect(): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface PostProcessModuleOptions {
                 enable?: boolean;
                 renderTargetOptions?: {
                     depthBuffer?: boolean;
                     stencilBuffer?: boolean;
                     alpha?: boolean;
                     /** 4 */
                     multisampling?: number;
                     frameBufferType?: number;
                 };
                 /**  */
                 autoAddRenderPass?: boolean;
                 /** Selected Outline */
                 autoAddSelectedPass?: boolean;
                 /**  */
                 autoAddBloomPass?: boolean;
                 /** Outline */
                 autoAddOutlinePass?: boolean;
                 /** copypass */
                 autoAddCopyPass?: boolean;
                 /** selectedtrue*/
                 disableSelectedPassWhenIdle?: boolean;
                 /** bloomtrue*/
                 disableBloomPassWhenIdle?: boolean;
                 /** bloomtrue*/
                 disableOutlinePassWhenIdle?: boolean;
                 /**  */
                 renderUpdate?: boolean;
                 /**  */
                 autoClear?: boolean;
                 /** smaa */
                 useSMAA?: boolean;
                 /** fxaa */
                 useFXAA?: boolean;
                 /** ,false */
                 disableWhenIdle?: boolean;
                 depthPickingPass?: boolean;
                 /** ,,03*/
                 disableDepthPickTime?: number;
                 /** 0 */
                 depthPickMinZ?: number;
                 /** logarithmicDepthBuffertruefalse */
                 disableDepthPickWhenlogDepthBuffer?: boolean;
                 /** workaroundEnabled */
                 workaroundEnabled?: boolean;
                 /**   false */
                 disableMergeEffect?: boolean;
                 /**   false */
                 disableCacheEffectPass?: boolean;
                 bloomPass?: {
                     blendFunction?: BlendFunction;
                     luminanceThreshold?: number;
                     luminanceSmoothing?: number;
                     mipmapBlur?: boolean;
                     intensity?: number;
                     radius?: number;
                     levels?: number;
                     kernelSize?: KernelSize;
                     resolutionScale?: number;
                     width?: number;
                     height?: number;
                     resolutionX?: number;
                     resolutionY?: number;
                     luminancePassEnabled?: boolean;
                     ignoreBackground?: boolean;
                     inverted?: boolean;
                     /**   true */
                     disableMergeEffect?: boolean;
                 };
                 outlinePass?: {
                     blendFunction?: BlendFunction;
                     patternTexture?: Texture;
                     patternScale?: number;
                     edgeStrength?: number;
                     pulseSpeed?: number;
                     visibleEdgeColor?: number;
                     hiddenEdgeColor?: number;
                     multisampling?: number;
                     resolutionScale?: number;
                     resolutionX?: number;
                     resolutionY?: number;
                     width?: number;
                     height?: number;
                     blur?: boolean;
                     xRay?: boolean;
                     blurriness?: number;
                     /**   false */
                     disableMergeEffect?: boolean;
                 };
                 selectedPass?: {
                     blendFunction?: BlendFunction;
                     patternTexture?: Texture;
                     patternScale?: number;
                     edgeStrength?: number;
                     pulseSpeed?: number;
                     visibleEdgeColor?: number;
                     hiddenEdgeColor?: number;
                     multisampling?: number;
                     resolutionScale?: number;
                     resolutionX?: number;
                     resolutionY?: number;
                     width?: number;
                     height?: number;
                     blur?: boolean;
                     xRay?: boolean;
                     blurriness?: number;
                     /**   false */
                     disableMergeEffect?: boolean;
                 };
             }

             

             /**
              * Styles the default scrollbar to be more pretty and less intrusive (especially on dark backgrounds), (similar to MacOS)
              */
             export  function prettyScrollbar(root?: Element | undefined): HTMLStyleElement;

             export  function preventDefaultEvent(event?: any): void;

              const PRIMARY_STATES_KEYS: ["x" | "y" | "originX" | "originY" | "anchorX" | "anchorY" | "rotation" | "scaleX" | "scaleY" | "skewX" | "skewY", "ignore"];

              type Primitive = string | number | boolean | bigint | symbol | undefined | null;

             /**
              * `GeoPoint` .
              */
             export  abstract class Projection {
                 /** The equatorial semi perimeter in meters. */
                 static EQUATORIAL_SEMIPERIMETER: number;
                 /** The equatorial semi perimeter in meters. */
                 static EARTH_BOUNDS: [number, number, number, number];
                 /**
                  *  .
                  */
                 static lngLat2Mercator(input: GeoPointLike): [number, number];
                 /**
                  *  .
                  */
                 static mercator2LngLat(input: GeoPointLike): [number, number];
                 /**
                  * (epsg:3857)
                  * @param input 
                  * @return {[number, number]}
                  */
                 abstract toMercator(input: GeoPointLike): [number, number];
                 /**
                  * (epsg:3857)
                  * @param input 
                  * @return {[number, number]}
                  */
                 abstract fromMercator(input: GeoPointLike): [number, number];
                 /**
                  * 
                  * @param input 
                  * @return {[number, number]}
                  */
                 abstract toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): [number, number];
                 /**
                  * 
                  * @param input 
                  * @return {GeoPoint}
                  */
                 abstract fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
                 /**
                  * 
                  * @return {GeoBounds}
                  */
                 abstract getMapExtent(): GeoBounds;
                 /**
                  * 
                  * @param dist
                  */
                 abstract toMeter(dist: number): number;
                 /**
                  * 
                  * @param meter
                  */
                 abstract fromMeter(meter: number): number;
             }

              class ProjectionGenerator {
                 [key: string]: any;
             }

             export  class PromiseBehavior extends Behavior {
                 __factory: any;
                 __promise: any;
                 __promise_state: BehaviorStatus;
                 /**
                  *
                  * @param {()=>Promise} factory
                  */
                 constructor(factory: Promise<any>);
                 initialize(context: BehaviorContext): void;
                 tick(timeDelta: number): BehaviorStatus;
             }

             /**
              * Properties
              *
              * https://tools.ietf.org/html/rfc7946#section-3.2
              * A Feature object has a member with the name 'properties'.
              * The value of the properties member is an object (any JSON object or a JSON null value).
              */
              type Properties = {
                 [name: string]: any;
             } | null;

              type PropType<TObj, TProp extends keyof TObj> = TObj[TProp];

             /**
              * Returns a reactive proxy for the given object.
              *
              * If the object already is reactive, it's returned as-is. If not, a new
              * reactive proxy is created. Direct child properties that are refs are properly
              * handled, as well.
              *
              * @param objectWithRefs - Either an already-reactive object or a simple object
              * that contains refs.
              */
              function proxyRefs<T extends object>(objectWithRefs: T): ShallowUnwrapRef<T>;

             /**
              * 
              */
             export  function pushObjectStatus(obj: Record<string, any>, attr: Record<string, any>): {
                 push: () => void;
                 pop: () => void;
             };

             export  class PushValueCommand<T> extends BaseCommand {
                 private container;
                 private object;
                 constructor(container: T[], object: T);
                 execute(): void;
                 undo(): void;
                 redo(): void;
             }

             /**
              * Constants to store quad-tree positions.
              */
             export  class QuadTreePosition {
                 /**
                  * Root node has no location.
                  */
                 static root: number;
                 /**
                  * Index of top left quad-tree branch node.
                  *
                  * Can be used to navigate the children array looking for neighbors.
                  */
                 static topLeft: number;
                 /**
                  * Index of top left quad-tree branch node.
                  *
                  * Can be used to navigate the children array looking for neighbors.
                  */
                 static topRight: number;
                 /**
                  * Index of top left quad-tree branch node.
                  *
                  * Can be used to navigate the children array looking for neighbors.
                  */
                 static bottomLeft: number;
                 /**
                  * Index of top left quad-tree branch node.
                  *
                  * Can be used to navigate the children array looking for neighbors.
                  */
                 static bottomRight: number;
             }

             /**
              * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
              * @param x Multiplier of the imaginary basis vector i.
              * @param y Multiplier of the imaginary basis vector j.
              * @param z Multiplier of the imaginary basis vector k.
              * @param w Multiplier of the real part.
              * @see http://en.wikipedia.org/wiki/Quaternion
              */
              class Quaternion_2 {
                 x: number;
                 y: number;
                 z: number;
                 w: number;
                 constructor(x?: number, y?: number, z?: number, w?: number);
                 /**
                  * Set the value of the quaternion.
                  */
                 set(x: number, y: number, z: number, w: number): Quaternion_2;
                 /**
                  * Convert to a readable format
                  * @return "x,y,z,w"
                  */
                 toString(): string;
                 /**
                  * Convert to an Array
                  * @return [x, y, z, w]
                  */
                 toArray(): [number, number, number, number];
                 /**
                  * Set the quaternion components given an axis and an angle in radians.
                  */
                 setFromAxisAngle(vector: Vec3, angle: number): Quaternion_2;
                 /**
                  * Converts the quaternion to [ axis, angle ] representation.
                  * @param targetAxis A vector object to reuse for storing the axis.
                  * @return An array, first element is the axis and the second is the angle in radians.
                  */
                 toAxisAngle(targetAxis?: Vec3): [Vec3, number];
                 /**
                  * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
                  */
                 setFromVectors(u: Vec3, v: Vec3): Quaternion_2;
                 /**
                  * Multiply the quaternion with an other quaternion.
                  */
                 mult(quat: Quaternion_2, target?: Quaternion_2): Quaternion_2;
                 /**
                  * Get the inverse quaternion rotation.
                  */
                 inverse(target?: Quaternion_2): Quaternion_2;
                 /**
                  * Get the quaternion conjugate
                  */
                 conjugate(target?: Quaternion_2): Quaternion_2;
                 /**
                  * Normalize the quaternion. Note that this changes the values of the quaternion.
                  */
                 normalize(): Quaternion_2;
                 /**
                  * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
                  * @author unphased, https://github.com/unphased
                  */
                 normalizeFast(): Quaternion_2;
                 /**
                  * Multiply the quaternion by a vector
                  */
                 vmult(v: Vec3, target?: Vec3): Vec3;
                 /**
                  * Copies value of source to this quaternion.
                  * @return this
                  */
                 copy(quat: Quaternion_2): Quaternion_2;
                 /**
                  * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
                  * @param order Three-character string, defaults to "YZX"
                  */
                 toEuler(target: Vec3, order?: string): void;
                 /**
                  * Set the quaternion components given Euler angle representation.
                  *
                  * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
                  *
                  * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
                  */
                 setFromEuler(x: number, y: number, z: number, order?: string): Quaternion_2;
                 clone(): Quaternion_2;
                 /**
                  * Performs a spherical linear interpolation between two quat
                  *
                  * @param toQuat second operand
                  * @param t interpolation amount between the self quaternion and toQuat
                  * @param target A quaternion to store the result in. If not provided, a new one will be created.
                  * @returns {Quaternion} The "target" object
                  */
                 slerp(toQuat: Quaternion_2, t: number, target?: Quaternion_2): Quaternion_2;
                 /**
                  * Rotate an absolute orientation quaternion given an angular velocity and a time step.
                  */
                 integrate(angularVelocity: Vec3, dt: number, angularFactor: Vec3, target?: Quaternion_2): Quaternion_2;
             }

             export  const RAD2DEG: number;

             export  const RadarMaterial: (new (parameters?: ShaderMaterialParameters & Partial<RadarMaterialProps>, uniforms?: Partial<RadarMaterialProps>) => ShaderMaterial & RadarMaterialProps) & {
                 key: string;
             };

             export  type RadarMaterialProps = {
                 /**  */
                 uRadius?: number;
                 /**  */
                 uColor?: Color;
                 /**  */
                 uSpeed?: number;
                 /**  */
                 uSectorAngle?: number;
                 /**  */
                 uEdge?: number;
                 /**  */
                 uTime?: number | {
                     value: number;
                 };
                 [key: string]: any;
             };

             /**
              * x, y, r are all percent from 0 to 1 when globalCoord is false
              */
              class RadialGradient extends Gradient_2 {
                 type: 'radial';
                 x: number;
                 y: number;
                 r: number;
                 constructor(x: number, y: number, r: number, colorStops?: GradientColorStop[], globalCoord?: boolean);
             }

              interface RadialGradientObject extends GradientObject {
                 type: 'radial';
                 x: number;
                 y: number;
                 r: number;
             }

              const RADIAN_TO_DEGREE: number;

             export  function radToDeg(radians: number): number;

             export  const randColor: () => Color;

             export  const randHtmlColor: () => string;

             /**
              * 
              * @param n
              * @param m
              * @return {number}
              */
             export  function randInt(n: number, m: number): number;

             /**
              * Generate a random color
              */
              function random(): string;

             export  class RandomColor implements ColorGenerator {
                 a: Vector4;
                 b: Vector4;
                 constructor(a: Vector4, b: Vector4);
                 genColor(color: Vector4): Vector4;
                 type: "value";
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): RandomColor;
                 clone(): ColorGenerator;
             }

             export  class RandomColorBetweenGradient implements MemorizedFunctionColorGenerator {
                 gradient1: Gradient;
                 gradient2: Gradient;
                 constructor(gradient1: Gradient, gradient2: Gradient);
                 startGen(memory: any): void;
                 genColor(color: Vector4, t: number, memory?: any): Vector4;
                 type: 'memorizedFunction';
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): RandomColorBetweenGradient;
                 clone(): RandomColorBetweenGradient;
             }

             /**
              * A random() function, must return a numer in the interval [0,1), just like Math.random().
              */
              type RandomFn = () => number;

             export  class RandomQuatGenerator implements RotationGenerator {
                 type: "rotation";
                 constructor();
                 genValue(quat: Quaternion, t: number): Quaternion;
                 toJSON(): FunctionJSON;
                 static fromJSON(json: FunctionJSON): RotationGenerator;
                 clone(): RotationGenerator;
             }

             export  const randPoint2D: (opts?: {
                 maxX?: number;
                 maxY?: number;
                 minX?: number;
                 minY?: number;
             }) => number[];

             export  const randPoint3D: (opts?: {
                 maxX?: number;
                 maxY?: number;
                 maxZ?: number;
                 minX?: number;
                 minY?: number;
                 minZ?: number;
             }) => number[];

              type Raw<T> = T & {
                 [RawSymbol]?: true;
             };

              const RawSymbol: unique symbol;

             /**
              * A line in 3D space that intersects bodies and return points.
              */
              class Ray_2 {
                 /**
                  * from
                  */
                 from: Vec3;
                 /**
                  * to
                  */
                 to: Vec3;
                 /**
                  * direction
                  */
                 direction: Vec3;
                 /**
                  * The precision of the ray. Used when checking parallelity etc.
                  * @default 0.0001
                  */
                 precision: number;
                 /**
                  * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
                  * @default true
                  */
                 checkCollisionResponse: boolean;
                 /**
                  * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
                  * @default false
                  */
                 skipBackfaces: boolean;
                 /**
                  * collisionFilterMask
                  * @default -1
                  */
                 collisionFilterMask: number;
                 /**
                  * collisionFilterGroup
                  * @default -1
                  */
                 collisionFilterGroup: number;
                 /**
                  * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
                  * @default RAY.ANY
                  */
                 mode: number;
                 /**
                  * Current result object.
                  */
                 result: RaycastResult;
                 /**
                  * Will be set to `true` during intersectWorld() if the ray hit anything.
                  */
                 hasHit: boolean;
                 /**
                  * User-provided result callback. Will be used if mode is Ray.ALL.
                  */
                 callback: RaycastCallback;
                 /**
                  * CLOSEST
                  */
                 static CLOSEST: 1;
                 /**
                  * ANY
                  */
                 static ANY: 2;
                 /**
                  * ALL
                  */
                 static ALL: 4;
                 get [Shape.types.SPHERE](): (sphere: Sphere_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
                 get [Shape.types.PLANE](): (shape: Plane_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
                 get [Shape.types.BOX](): (box: Box, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
                 get [Shape.types.CYLINDER](): (shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
                     faceList: number[];
                 }) => void;
                 get [Shape.types.CONVEXPOLYHEDRON](): (shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
                     faceList: number[];
                 }) => void;
                 get [Shape.types.HEIGHTFIELD](): (shape: Heightfield, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape) => void;
                 get [Shape.types.TRIMESH](): (mesh: Trimesh, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
                     faceList?: any[];
                 }) => void;
                 constructor(from?: Vec3, to?: Vec3);
                 /**
                  * Do itersection against all bodies in the given World.
                  * @return True if the ray hit anything, otherwise false.
                  */
                 intersectWorld(world: World, options: RayOptions): boolean;
                 /**
                  * Shoot a ray at a body, get back information about the hit.
                  * @deprecated @param result set the result property of the Ray instead.
                  */
                 intersectBody(body: Body_2, result?: RaycastResult): void;
                 /**
                  * Shoot a ray at an array bodies, get back information about the hit.
                  * @param bodies An array of Body objects.
                  * @deprecated @param result set the result property of the Ray instead.
                  *
                  */
                 intersectBodies(bodies: Body_2[], result?: RaycastResult): void;
                 /**
                  * Updates the direction vector.
                  */
                 private updateDirection;
                 private intersectShape;
                 _intersectBox(box: Box, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
                 _intersectPlane(shape: Plane_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
                 /**
                  * Get the world AABB of the ray.
                  */
                 getAABB(aabb: AABB): void;
                 _intersectHeightfield(shape: Heightfield, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
                 _intersectSphere(sphere: Sphere_2, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape): void;
                 _intersectConvex(shape: ConvexPolyhedron, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
                     faceList: number[];
                 }): void;
                 /**
                  * @todo Optimize by transforming the world to local space first.
                  * @todo Use Octree lookup
                  */
                 _intersectTrimesh(mesh: Trimesh, quat: Quaternion_2, position: Vec3, body: Body_2, reportedShape: Shape, options?: {
                     faceList?: any[];
                 }): void;
                 /**
                  * @return True if the intersections should continue
                  */
                 private reportIntersection;
                 /**
                  * As per "Barycentric Technique" as named
                  * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
                  */
                 static pointInTriangle(p: Vec3, a: Vec3, b: Vec3, c: Vec3): boolean;
             }

             /**
              * RAY_MODES
              */
              const RAY_MODES: {
                 /** CLOSEST */
                 readonly CLOSEST: 1;
                 /** ANY */
                 readonly ANY: 2;
                 /** ALL */
                 readonly ALL: 4;
             };

              type RaycastCallback = (result: RaycastResult) => void;

             /**
              * Storage for Ray casting data
              */
              class RaycastResult {
                 /**
                  * rayFromWorld
                  */
                 rayFromWorld: Vec3;
                 /**
                  * rayToWorld
                  */
                 rayToWorld: Vec3;
                 /**
                  * hitNormalWorld
                  */
                 hitNormalWorld: Vec3;
                 /**
                  * hitPointWorld
                  */
                 hitPointWorld: Vec3;
                 /**
                  * hasHit
                  */
                 hasHit: boolean;
                 /**
                  * shape
                  */
                 shape: Shape | null;
                 /**
                  * body
                  */
                 body: Body_2 | null;
                 /**
                  * The index of the hit triangle, if the hit shape was a trimesh
                  */
                 hitFaceIndex: number;
                 /**
                  * Distance to the hit. Will be set to -1 if there was no hit
                  */
                 distance: number;
                 /**
                  * If the ray should stop traversing the bodies
                  */
                 shouldStop: boolean;
                 constructor();
                 /**
                  * Reset all result data.
                  */
                 reset(): void;
                 /**
                  * abort
                  */
                 abort(): void;
                 /**
                  * Set result data.
                  */
                 set(rayFromWorld: Vec3, rayToWorld: Vec3, hitNormalWorld: Vec3, hitPointWorld: Vec3, shape: Shape, body: Body_2, distance: number): void;
             }

             /**
              * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
              */
              class RaycastVehicle {
                 /** The car chassis body. */
                 chassisBody: Body_2;
                 /** The wheels. */
                 wheelInfos: WheelInfo[];
                 /** Will be set to true if the car is sliding. */
                 sliding: boolean;
                 world: World | null;
                 /** Index of the right axis. x=0, y=1, z=2 */
                 indexRightAxis: number;
                 /** Index of the forward axis. x=0, y=1, z=2 */
                 indexForwardAxis: number;
                 /** Index of the up axis. x=0, y=1, z=2 */
                 indexUpAxis: number;
                 /** The constraints. */
                 constraints: Constraint[];
                 /** Optional pre-step callback. */
                 preStepCallback: () => void;
                 currentVehicleSpeedKmHour: number;
                 /** Number of wheels on the ground. */
                 numWheelsOnGround: number;
                 constructor(options: {
                     /** The car chassis body. */
                     chassisBody: Body_2;
                     /** Index of the right axis. x=0, y=1, z=2 */
                     indexRightAxis?: number;
                     /** Index of the forward axis. x=0, y=1, z=2 */
                     indexForwardAxis?: number;
                     /** Index of the up axis. x=0, y=1, z=2 */
                     indexUpAxis?: number;
                 });
                 /**
                  * Add a wheel. For information about the options, see `WheelInfo`.
                  */
                 addWheel(options?: WheelInfoOptions): number;
                 /**
                  * Set the steering value of a wheel.
                  */
                 setSteeringValue(value: number, wheelIndex: number): void;
                 /**
                  * Set the wheel force to apply on one of the wheels each time step
                  */
                 applyEngineForce(value: number, wheelIndex: number): void;
                 /**
                  * Set the braking force of a wheel
                  */
                 setBrake(brake: number, wheelIndex: number): void;
                 /**
                  * Add the vehicle including its constraints to the world.
                  */
                 addToWorld(world: World): void;
                 /**
                  * Get one of the wheel axles, world-oriented.
                  */
                 private getVehicleAxisWorld;
                 updateVehicle(timeStep: number): void;
                 updateSuspension(deltaTime: number): void;
                 /**
                  * Remove the vehicle including its constraints from the world.
                  */
                 removeFromWorld(world: World): void;
                 castRay(wheel: WheelInfo): number;
                 updateWheelTransformWorld(wheel: WheelInfo): void;
                 /**
                  * Update one of the wheel transform.
                  * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
                  * @param wheelIndex The wheel index to update.
                  */
                 updateWheelTransform(wheelIndex: number): void;
                 /**
                  * Get the world transform of one of the wheels
                  */
                 getWheelTransformWorld(wheelIndex: number): Transform;
                 updateFriction(timeStep: number): void;
             }

              type RaycastVehicleOptions = ConstructorParameters<typeof RaycastVehicle>[0];

             /**
              * RayMode
              */
              type RayMode = typeof RAY_MODES[keyof typeof RAY_MODES];

             /**
              * RayOptions
              */
              type RayOptions = {
                 /**
                  * from
                  */
                 from?: Vec3;
                 /**
                  * to
                  */
                 to?: Vec3;
                 /**
                  * mode
                  */
                 mode?: RayMode;
                 /**
                  * result
                  */
                 result?: RaycastResult;
                 /**
                  * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
                  * @default false
                  */
                 skipBackfaces?: boolean;
                 /**
                  * collisionFilterMask
                  * @default -1
                  */
                 collisionFilterMask?: number;
                 /**
                  * collisionFilterGroup
                  * @default -1
                  */
                 collisionFilterGroup?: number;
                 /**
                  * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
                  * @default true
                  */
                 checkCollisionResponse?: boolean;
                 /**
                  * callback
                  */
                 callback?: RaycastCallback;
             };

             /**  */
             export  enum RayQueryType {
                 /**  */
                 Disable = 0,
                 /**  */
                 Allow = 1,
                 /**  */
                 AllowOnlyChilds = 2
             }

             /**
              * Returns a reactive proxy of the object.
              *
              * The reactive conversion is "deep": it affects all nested properties. A
              * reactive object also deeply unwraps any properties that are refs while
              * maintaining reactivity.
              *
              * @example
              * ```js
              * const obj = reactive({ count: 0 })
              * ```
              *
              * @param target - The source object.
              */
              function reactive<T extends object>(target: T): UnwrapNestedRefs<T>;

              class ReactiveEffect<T = any> {
                 fn: () => T;
                 scheduler: EffectScheduler | null;
                 active: boolean;
                 deps: Dep[];
                 parent: ReactiveEffect | undefined;
                 onStop?: () => void;
                 constructor(fn: () => T, scheduler?: EffectScheduler | null, scope?: EffectScope);
                 run(): T;
                 stop(): void;
             }

              interface ReactiveEffectOptions {
                 lazy?: boolean;
                 scheduler?: EffectScheduler;
                 scope?: EffectScope;
                 allowRecurse?: boolean;
                 onStop?: () => void;
             }

              interface ReactiveEffectRunner<T = any> {
                 (): T;
                 effect: ReactiveEffect;
             }

              const enum ReactiveFlags {
                 SKIP = "__v_skip",
                 IS_REACTIVE = "__v_isReactive",
                 IS_READONLY = "__v_isReadonly",
                 IS_SHALLOW = "__v_isShallow",
                 RAW = "__v_raw"
             }

              namespace reactivity {
                 export {
                     ref,
                     shallowRef,
                     isRef,
                     toRef,
                     toValue,
                     toRefs,
                     unref,
                     proxyRefs,
                     customRef,
                     triggerRef,
                     Ref,
                     MaybeRef,
                     MaybeRefOrGetter,
                     ToRef,
                     ToRefs,
                     UnwrapRef,
                     ShallowRef,
                     ShallowUnwrapRef,
                     RefUnwrapBailTypes,
                     CustomRefFactory,
                     reactive,
                     readonly,
                     isReactive,
                     isReadonly,
                     isShallow,
                     isProxy,
                     shallowReactive,
                     shallowReadonly,
                     markRaw,
                     toRaw,
                     ReactiveFlags,
                     Raw,
                     DeepReadonly,
                     ShallowReactive,
                     UnwrapNestedRefs,
                     computed,
                     ComputedRef,
                     WritableComputedRef,
                     WritableComputedOptions,
                     ComputedGetter,
                     ComputedSetter,
                     deferredComputed,
                     effect,
                     stop_2 as stop,
                     trigger,
                     track,
                     enableTracking,
                     pauseTracking,
                     resetTracking,
                     ITERATE_KEY,
                     ReactiveEffect,
                     ReactiveEffectRunner,
                     ReactiveEffectOptions,
                     EffectScheduler,
                     effectScope,
                     EffectScope,
                     getCurrentScope,
                     onScopeDispose,
                     TrackOpTypes,
                     TriggerOpTypes,
                     watch,
                     watchEffect,
                     watchSyncEffect,
                     createPathGetter,
                     WatchEffect,
                     WatchOptions,
                     WatchOptionsBase,
                     WatchCallback,
                     WatchSource,
                     WatchStopHandle
                 }
             }
             export { reactivity }

             /**
              * Takes an object (reactive or plain) or a ref and returns a readonly proxy to
              * the original.
              *
              * A readonly proxy is deep: any nested property accessed will be readonly as
              * well. It also has the same ref-unwrapping behavior as {@link reactive()},
              * except the unwrapped values will also be made readonly.
              *
              * @example
              * ```js
              * const original = reactive({ count: 0 })
              *
              * const copy = readonly(original)
              *
              * watchEffect(() => {
              *   // works for reactivity tracking
              *   console.log(copy.count)
              * })
              *
              * // mutating original will trigger watchers relying on the copy
              * original.count++
              *
              * // mutating the copy will fail and result in a warning
              * copy.count++ // warning!
              * ```
              *
              * @param target - The source object.
              */
              function readonly<T extends object>(target: T): DeepReadonly<UnwrapNestedRefs<T>>;

             export  class RecordState {
                 position: Vector3;
                 size: number;
                 color: Vector4;
                 /**
                  * Creates a new record state.
                  * @param {Vector3} position - The position of the particle.
                  * @param {number} size - The size of the particle.
                  * @param {Vector4} color - The color of the particle.
                  */
                 constructor(position: Vector3, size: number, color: Vector4);
             }

              class Rect extends Path<RectProps> {
                 shape: RectShape;
                 constructor(opts?: RectProps);
                 getDefaultShape(): RectShape;
                 buildPath(ctx: CanvasRenderingContext2D, shape: RectShape): void;
                 isZeroArea(): boolean;
             }

             export  class RectCollideModule extends AppModuleBase implements IAppModuleBase {
                 #private;
                 static moduleName: string;
                 options: RectCollideModuleOptions;
                 constructor(app?: App, options?: RectCollideModuleOptions);
                 onAwake(): void;
                 addCollideRectObject(item: IRectCollide): void;
                 removeCollideRectObject(item: IRectCollide): void;
                 setCollideRectDirty(): void;
                 updateCollideRect(): void;
                 onAppUpdate(time: Time): void;
                 setupUiConfig(): UiObjectConfig;
             }

             export  interface RectCollideModuleOptions {
                 /**  */
                 overlapMargin?: number;
                 /** 500 */
                 refreshTimeout?: number;
                 /**  falsefalse */
                 useDebounce?: boolean;
             }

              type RectLike = {
                 x: number;
                 y: number;
                 width: number;
                 height: number;
             };

              interface RectProps extends PathProps {
                 shape?: Partial<RectShape>;
             }

              class RectShape {
                 r?: number | number[];
                 x: number;
                 y: number;
                 width: number;
                 height: number;
             }

              function reduce<T, S, Context>(arr: readonly T[], cb: (this: Context, previousValue: S, currentValue: T, currentIndex?: number, arr?: readonly T[]) => S, memo?: S, context?: Context): S;

              interface Ref<T = any> {
                 value: T;
                 /**
                  * Type differentiator only.
                  * We need this to be in public d.ts but don't want it to show up in IDE
                  * autocomplete, so we use a private Symbol instead.
                  */
                 [RefSymbol]: true;
             }

             /**
              * Takes an inner value and returns a reactive and mutable ref object, which
              * has a single property `.value` that points to the inner value.
              *
              * @param value - The object to wrap in the ref.
              */
              function ref<T extends Ref>(value: T): T;

              function ref<T>(value: T): Ref<UnwrapRef<T>>;

              function ref<T = any>(): Ref<T | undefined>;

             export  class ReflectorBlurMaterial extends RawShaderMaterial {
                 constructor();
             }

             export  class ReflectorDudvMaterial extends RawShaderMaterial {
                 constructor({ map, reflectivity, dithering }?: {
                     map?: any;
                     reflectivity?: number;
                     dithering?: boolean;
                 });
             }

             /**  */
             export  class ReflectorMaterial extends RawShaderMaterial {
                 constructor({ color, map, normalMap, normalScale, reflectivity, mirror, mixStrength, fog, dithering }?: {
                     color?: Color;
                     map?: any;
                     normalMap?: any;
                     normalScale?: Vector2;
                     reflectivity?: number;
                     mirror?: number;
                     mixStrength?: number;
                     fog?: any;
                     dithering?: boolean;
                 });
             }

             export  class ReflectorObject extends Group_2 {
                 clipBias: number;
                 blurIterations: number;
                 reflectorPlane: Plane;
                 normal: Vector3;
                 reflectorWorldPosition: Vector3;
                 cameraWorldPosition: Vector3;
                 rotationMatrix: Matrix4;
                 lookAtPosition: Vector3;
                 clipPlane: Vector4;
                 view: Vector3;
                 target: Vector3;
                 q: Vector4;
                 textureMatrix: Matrix4;
                 virtualCamera: PerspectiveCamera;
                 textureMatrixUniform: {
                     value: any;
                 };
                 renderTarget: any;
                 renderTargetRead: any;
                 renderTargetWrite: any;
                 renderTargetUniform: {
                     value: any;
                 };
                 blurMaterial: ReflectorBlurMaterial;
                 screenCamera: OrthographicCamera;
                 screenTriangle: any;
                 screen: any;
                 constructor({ width, height, clipBias, blurIterations }?: {
                     width?: number;
                     height?: number;
                     clipBias?: number;
                     blurIterations?: number;
                 });
                 setSize(width: any, height: any): void;
                 update(renderer: any, scene: any, camera: any): void;
                 destroy(): any;
             }

              const RefSymbol: unique symbol;

              interface RefTypeValue {
                 value: number;
             }

             /**
              * This is a special exported interface for other packages to declare
              * additional types that should bail out for ref unwrapping. For example
              * \@vue/runtime-dom can  it like so in its d.ts:
              *
              * ``` ts
              *  module '@vue/reactivity' {
              *   export interface RefUnwrapBailTypes {
              *     runtimeDOMBailTypes: Node | Window
              *   }
              * }
              * ```
              */
              interface RefUnwrapBailTypes {
             }

              function registerPainter(name: string, Ctor: PainterBaseCtor): void;

             export  function registerShaderChunks(): void;

              function registerSSRDataGetter<T>(getter: ElementSSRDataGetter<T>): void;

             /**
              * Returns a blob:// URL which points to a javascript file which will call importScripts with the given URL, to be used for cross-origin workers.
              * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
              * @param url - URL to the worker js file
              * @param wasmURL - optional wasm file URL, will be passed to a created Module.locateFile (for emscripten)
              */
             export  function remoteWorkerURL(url: string, wasmURL?: string): string;

              class Render2D {
                 /**
                  * Not necessary if using SSR painter like svg-ssr
                  */
                 dom?: HTMLElement;
                 id: number;
                 storage: Storage_2;
                 painter: PainterBase;
                 handler: Handler;
                 animation: Animation_2;
                 private _sleepAfterStill;
                 private _stillFrameAccum;
                 private _needsRefresh;
                 private _needsRefreshHover;
                 /**
                  * If theme is dark mode. It will determine the color strategy for labels.
                  */
                 private _darkMode;
                 private _backgroundColor;
                 constructor(id: number, dom?: HTMLElement, opts?: Render2DInitOpt);
                 /**
                  * 
                  */
                 add(el: Element_2): void;
                 /**
                  * 
                  */
                 remove(el: Element_2): void;
                 /**
                  * Change configuration of layer
                  */
                 configLayer(zLevel: number, config: LayerConfig): void;
                 /**
                  * Set background color
                  */
                 setBackgroundColor(backgroundColor: string | GradientObject | PatternObject): void;
                 getBackgroundColor(): string | GradientObject | PatternObject;
                 /**
                  * Force to set dark mode
                  */
                 setDarkMode(darkMode: boolean): void;
                 isDarkMode(): boolean;
                 /**
                  * Repaint the canvas immediately
                  */
                 refreshImmediately(fromInside?: boolean): void;
                 /**
                  * Mark and repaint the canvas in the next frame of browser
                  */
                 refresh(): void;
                 /**
                  * Perform all refresh
                  */
                 flush(): void;
                 private _flush;
                 /**
                  * Set sleep after still for frames.
                  * Disable auto sleep when it's 0.
                  */
                 setSleepAfterStill(stillFramesCount: number): void;
                 /**
                  * Wake up animation loop. But not render.
                  */
                 wakeUp(): void;
                 /**
                  * Refresh hover in next frame
                  */
                 refreshHover(): void;
                 /**
                  * Refresh hover immediately
                  */
                 refreshHoverImmediately(): void;
                 /**
                  * Resize the canvas.
                  * Should be invoked when container size is changed
                  */
                 resize(opts?: {
                     width?: number | string;
                     height?: number | string;
                 }): void;
                 /**
                  * Stop and clear all animation immediately
                  */
                 clearAnimation(): void;
                 /**
                  * Get container width
                  */
                 getWidth(): number;
                 /**
                  * Get container height
                  */
                 getHeight(): number;
                 /**
                  * Set default cursor
                  * @param cursorStyle='default'  crosshair
                  */
                 setCursorStyle(cursorStyle: string): void;
                 /**
                  * Find hovered element
                  * @param x
                  * @param y
                  * @return {target, topTarget}
                      */
                  findHover(x: number, y: number): {
                      target: Displayable;
                      topTarget: Displayable;
                  };
                  on<Ctx>(eventName: ElementEventName, eventHandler: ElementEventCallback<Ctx, Render2dType>, context?: Ctx): this;
                  on<Ctx>(eventName: string, eventHandler: WithThisType<EventCallback<any[]>, unknown extends Ctx ? Render2dType : Ctx>, context?: Ctx): this;
                  /**
                   * Unbind event
                   * @param eventName Event name
                   * @param eventHandler Handler function
                   */
                  off(eventName?: string, eventHandler?: EventCallback): void;
                  /**
                   * Trigger event manually
                   *
                   * @param eventName Event name
                   * @param event Event object
                   */
                  trigger(eventName: string, event?: unknown): void;
                  /**
                   * Clear all objects and the canvas.
                   */
                  clear(): void;
                  /**
                   * Dispose self.
                   */
                  dispose(): void;
                 }

                  namespace render2d {
                     export {
                         init,
                         dispose,
                         disposeAll,
                         getInstance,
                         registerPainter,
                         getElementSSRData,
                         registerSSRDataGetter,
                         Render2DInitOpt,
                         ElementSSRData,
                         ElementSSRDataGetter,
                         Render2dType,
                         Point,
                         PointLike,
                         Element_2 as Element,
                         ElementAnimateConfig,
                         ElementTextConfig,
                         ElementTextGuideLineConfig,
                         ElementEvent,
                         ElementEventCallback,
                         ElementProps,
                         Displayable,
                         DisplayableProps,
                         Group,
                         GroupProps,
                         Path,
                         PathStyleProps,
                         PathProps,
                         PathStatePropNames,
                         PathState,
                         ZRImage as Image,
                         ImageStyleProps,
                         ImageProps,
                         ImageState,
                         CompoundPath,
                         CompoundPathShape,
                         TSpan,
                         TSpanStyleProps,
                         TSpanProps,
                         TSpanState,
                         IncrementalDisplayable,
                         ZRText as Text,
                         TextStylePropsPart,
                         TextStyleProps,
                         TextProps_2 as TextProps,
                         TextState,
                         Arc,
                         ArcProps,
                         ArcShape,
                         BezierCurve,
                         BezierCurveProps,
                         BezierCurveShape,
                         Circle,
                         CircleProps,
                         CircleShape,
                         Droplet,
                         DropletProps,
                         DropletShape,
                         Ellipse,
                         EllipseProps,
                         EllipseShape,
                         Heart,
                         HeartProps,
                         HeartShape,
                         Isogon,
                         IsogonProps,
                         IsogonShape,
                         Line,
                         LineProps,
                         LineShape,
                         Polygon,
                         PolygonProps,
                         PolygonShape,
                         Polyline,
                         PolylineProps,
                         PolylineShape,
                         Rect,
                         RectProps,
                         RectShape,
                         Ring,
                         RingProps,
                         RingShape,
                         Rose,
                         RoseProps,
                         RoseShape,
                         Sector,
                         SectorProps,
                         SectorShape,
                         Star,
                         StarProps,
                         StarShape,
                         Trochoid,
                         TrochoidProps,
                         TrochoidShape,
                         LinearGradient,
                         LinearGradientObject,
                         RadialGradient,
                         RadialGradientObject,
                         Pattern,
                         PatternObjectBase,
                         PatternObject,
                         ImagePatternObject,
                         SVGPatternObject,
                         BoundingRect,
                         RectLike,
                         OrientedBoundingRect,
                         matrix,
                         vector,
                         colorTool as color,
                         pathTool as path,
                         zrUtil as util,
                         morphPathTool as morph,
                         parseSVG,
                         showDebugDirtyRect,
                         setPlatformAPI,
                         measureBoundingRect
                     }
                 }
                 export { render2d }

                  interface Render2DInitOpt {
                     renderer?: string;
                     devicePixelRatio?: number;
                     width?: number | string;
                     height?: number | string;
                     useDirtyRect?: boolean;
                     useCoarsePointer?: 'auto' | boolean;
                     pointerSize?: number;
                     ssr?: boolean;
                 }

                 export  interface Render2dTextureOptions {
                     /**  */
                     elements?: render2d.Element | render2d.Element[];
                     /**  */
                     render2dObject?: render2d.Render2dType;
                     /**  */
                     pointerEvents?: boolean;
                     /**  */
                     canvasWidth?: number;
                     /**  */
                     canvasHeight?: number;
                     /**  */
                     autoCanvasSize?: boolean;
                     /** canvas */
                     sharedCanvas?: boolean;
                     /** srgb */
                     colorSpace?: ColorSpace;
                 }

                 /**
                  * @type {string}
                  */
                  interface Render2dType extends Render2D {
                 }

                 /**
                  * 3d
                  */
                 export  class Render3dTexture {
                     #private;
                     fbo: WebGLRenderTarget;
                     app: App;
                     scene: Scene;
                     camera: Camera;
                     renderCount: number;
                     renderInterval: number;
                     _texture: CanvasTexture | Texture;
                     signal: {
                         onRenderFinsh: Signal;
                         onRenderOne: Signal;
                     };
                     /**
                      *
                      * @param app appoptionssceneappapp
                      * @param options
                      */
                     constructor(app: App, options?: Render3dTextureOptions);
                     /**
                      * 
                      */
                     get texture(): Texture | CanvasTexture;
                     update(): void;
                     dispose(): void;
                 }

                 export  interface Render3dTextureOptions extends FBOSettings {
                     /**
                      * 
                      */
                     scene?: Scene;
                     /**
                      * 
                      */
                     camera?: Camera;
                     /** (1024)pixelRatio */
                     width?: number;
                     /** (1024)pixelRatio */
                     height?: number;
                     /**  0 */
                     renderCount?: number;
                     /**  0 */
                     renderInterval?: number;
                     /** appapp true */
                     autoDisposeApp?: boolean;
                 }

                 export  interface RenderElementFlowMaterialOptions {
                     geometryWidth: number;
                     geometryHeight: number;
                     flowDirection?: "horizon" | "vertical";
                     flowSpeed?: number;
                     element: Element_2 | Element_2[];
                     canvasWidth?: number;
                     canvasHeight?: number;
                     autoCanvasSize?: boolean;
                     expandRect?: number | [number, number, number, number];
                 }

                 export  type RendererEmitterSettings = TrailSettings | MeshSettings | BillBoardSettings | StretchedBillBoardSettings;

                 /**
                  * Enum representing the render modes for particles.
                  */
                 export  enum RenderMode {
                     /**
                      * Renders particles as billboards facing the camera.
                      */
                     BillBoard = 0,
                     /**
                      * Renders particles as billboards that stretches towards the direction the particle is moving to.
                      */
                     StretchedBillBoard = 1,
                     /**
                      * Renders particles as meshes.
                      */
                     Mesh = 2,
                     /**
                      * Renders particles as trails.
                      */
                     Trail = 3,
                     /**
                      * Renders particles as horizontal billboards.
                      */
                     HorizontalBillBoard = 4,
                     /**
                      * Renders particles as vertical billboards.
                      */
                     VerticalBillBoard = 5
                 }

                 

                 /**
                  * Converts a render target to a png/jpeg data url string.
                  * Note: this will clamp the values to [0, 1] and converts to srgb for float and half-float render targets.
                  * @param target
                  * @param mimeType
                  * @param quality
                  * @param textureIndex - index of the texture to use in the render target (only in case of multiple render target)
                  */
                 export  function renderTargetToDataUrl(renderer: WebGLRenderer, target: WebGLMultipleRenderTargets | WebGLRenderTarget, mimeType?: string, quality?: number, textureIndex?: number): string;

                 /**
                  * @extends {Behavior}
                  */
                 export  class RepeatBehavior extends AbstractDecoratorBehavior {
                     limit: number;
                     protected __iterator: number;
                     /**
                      *
                      * @param {Behavior} source
                      * @param {number} [count=Infinity]
                      */
                     constructor(source: Behavior, count?: number);
                     /**
                      * @deprecated use .limit directly instead
                      * @param {number} v
                      */
                     setCount(v: number): void;
                     /**
                      * @deprecated use .limit directly instead
                      * @return {number}
                      */
                     getCount(): number;
                     /**
                      *
                      * @param {Behavior} source
                      * @param {number} [count]
                      * @return {RepeatBehavior}
                      */
                     static from(source: Behavior, count?: number): RepeatBehavior;
                     initialize(context: BehaviorContext): void;
                     tick(timeDelta: number): BehaviorStatus.Initial | BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Suspended | BehaviorStatus.Invalid;
                 }

                 /**
                  * @extends {Behavior}
                  */
                 export  class RepeatUntilFailureBehavior extends AbstractDecoratorBehavior {
                     protected __limit: number;
                     protected __iterator: number;
                     /**
                      *
                      * @param {Behavior} source
                      * @param {number} [count=Infinity]
                      */
                     constructor(source: Behavior, count?: number);
                     /**
                      *
                      * @returns {RepeatUntilFailureBehavior}
                      * @param {Behavior} source
                      * @param {number} [limit]
                      */
                     static from(source: Behavior, limit?: number): RepeatUntilFailureBehavior;
                     tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
                 }

                 export  class RepeatUntilSuccessBehavior extends AbstractDecoratorBehavior {
                     protected __limit: number;
                     protected __iterator: number;
                     /**
                      *
                      * @param {Behavior} source
                      * @param {number} [count=Infinity]
                      */
                     constructor(source: Behavior, count?: number);
                     /**
                      *
                      * @param {Behavior} source
                      * @param {number} [limit]
                      * @return {RepeatUntilSuccessBehavior}
                      */
                     static from(source: Behavior, limit?: number): RepeatUntilSuccessBehavior;
                     tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded | BehaviorStatus.Failed;
                 }

                 /**
                  * Replace all occurrences of a string in another string
                  * @param str - The string to search
                  * @param find - The string to replace
                  * @param replace - The replacement string
                  *
                  * @category Text
                  */
                 export  function replaceAll(str: string, find: string, replace: string): string;

                 /**
                  * Resets the previous global effect tracking state.
                  */
                  function resetTracking(): void;

                 /** uv */
                 export  const resetUV: (geometry: BufferGeometry) => void;

                 export  const ResManager: ResourceManager;

                 export  interface ResourceItem {
                     /**  */
                     name?: string;
                     /**  */
                     url?: string;
                     /**  */
                     useCache?: boolean;
                     /**  customoptions */
                     type?: "model" | "texture" | "plugin" | "library" | "extensionIfcLoader" | "extensionLoader" | "custom" | string;
                     /**  */
                     options?: ILoadModelOption | LoadPluginOpts | Function;
                 }

                 export  class ResourceManager {
                     #private;
                     loaderManager: LoaderManager;
                     defaultError: (err: string) => void;
                     useCacheResMap: Map<string, any>;
                     serviceAasserUrlPath: string;
                     constructor(_loaderManager?: LoaderManager);
                     /**
                      * 
                      * @param path
                      */
                     setServiceUrlPath(path: string, dirs?: Array<string>): void;
                     /**
                      * 
                      * @param name  . 
                      * @param type assert
                      */
                     svrUrl(name?: string, type?: string): string;
                     /**
                      * 
                      * @param url
                      * @param useCache 
                      * @param fileType url
                      * @returns this
                      */
                     loadRes(url: string, useCache: boolean, fileType?: string): Promise<any>;
                     /**
                      * ()
                      * @param url
                      * @param useCache ()
                      * @param  fileType   img
                      * @param onError 
                      */
                     loadTextureLinear(url: string, useCache?: boolean, fileType?: string, onError?: (err: any) => void): Texture;
                     /**
                      * ()promise
                      * @param url
                      * @param useCache ()
                      * @param  fileType   img
                      * @param colorSpace  SRGBColorSpace
                      */
                     loadTextureLinearSync(url: string, useCache?: boolean, fileType?: string, colorSpace?: ColorSpace): Promise<Texture>;
                     /**
                      * (srgb)
                      * @param url
                      * @param useCache ()
                      * @param  fileType   img
                      * @param onError 
                      * @param colorSpace  SRGBColorSpace
                      */
                     loadTexture(url: string, useCache?: boolean, fileType?: string, onError?: (err: any) => void, colorSpace?: ColorSpace): Texture;
                     /**
                      * (srgb)promise
                      * @param url
                      * @param useCache ()
                      * @param  fileType   img
                      * @param colorSpace  SRGBColorSpace
                      */
                     loadTextureSync(url: string, useCache?: boolean, fileType?: string, colorSpace?: ColorSpace): Promise<Texture>;
                     /**
                      * 
                      */
                     loadModelRes(url: string, option?: ILoadModelOption): Promise<Object3D>;
                     /**
                      * 
                      * res 
                      * url url
                      * option 
                      */
                     addModel(res: any, url: string, option?: ILoadModelOption): Entity;
                     /**
                      * 
                      */
                     loadModel(url: string, option?: ILoadModelOption): Promise<Entity>;
                     /**  */
                     loadResources(_resources: ResourceItem[]): RosourceItemsReturnType;
                     /**
                      * 
                      */
                     clearResourceCache(): void;
                     /**
                      * loader
                      */
                     loadExtensionLoader(): Promise<void>;
                     /**
                      * IfcLoader
                      */
                     loadExtensionIfcLoader(options?: {
                         setupOptionalCategoriesOpts?: Record<string, any>;
                         applyWebIfcConfigOpts?: Record<string, any>;
                     }): Promise<void>;
                     /**
                      * 
                      * @param ext 
                      * @returns
                      */
                     getLoader(ext: string): Loader | null;
                     dispose(): void;
                 }

                  interface Response_2 {
                     status: number;
                     response: Record<string, unknown>;
                     data?: string | Record<string, unknown>;
                     xhr: XMLHttpRequest;
                 }
                 export { Response_2 as Response }

                 /**
                  * 
                  */
                 export  enum ResStatus {
                     /**  */
                     NoExist = 0,
                     /**  */
                     Loading = 1,
                     /**  */
                     LoadFinish = 2,
                     /**  */
                     LoadError = 3
                 }

                 /**
                  * If value1 is not null, then return value1, otherwise judget rest of values.
                  * Low performance.
                  * @return Final value
                  */
                  function retrieve<T>(...args: T[]): T;

                  function retrieve2<T, R>(value0: T, value1: R): T | R;

                  function retrieve3<T, R, W>(value0: T, value1: R, value2: W): T | R | W;

                  const REVERSE_SUBTRACTION: CSGOperation;

                 /**
                  * Simple vehicle helper class with spherical rigid body wheels.
                  */
                  class RigidVehicle {
                     /**
                      * The bodies of the wheels.
                      */
                     wheelBodies: Body_2[];
                     coordinateSystem: Vec3;
                     /**
                      * The chassis body.
                      */
                     chassisBody: Body_2;
                     /**
                      * The constraints.
                      */
                     constraints: (HingeConstraint & {
                         motorTargetVelocity?: number;
                     })[];
                     /**
                      * The wheel axes.
                      */
                     wheelAxes: Vec3[];
                     /**
                      * The wheel forces.
                      */
                     wheelForces: number[];
                     constructor(options?: {
                         /**
                          * A Vector3 defining the world coordinate system.
                          * @default new Vec3(1, 2, 3)
                          */
                         coordinateSystem?: Vec3;
                         /**
                          * Optionally pass a body for the chassis
                          */
                         chassisBody?: Body_2;
                     });
                     /**
                      * Add a wheel
                      */
                     addWheel(options?: {
                         /** The wheel body */
                         body?: Body_2;
                         /** Position of the wheel, locally in the chassis body. */
                         position?: Vec3;
                         /** Axis of rotation of the wheel, locally defined in the chassis. */
                         axis?: Vec3;
                         /** Slide direction of the wheel along the suspension. */
                         direction?: Vec3;
                     }): number;
                     /**
                      * Set the steering value of a wheel.
                      * @todo check coordinateSystem
                      */
                     setSteeringValue(value: number, wheelIndex: number): void;
                     /**
                      * Set the target rotational speed of the hinge constraint.
                      */
                     setMotorSpeed(value: number, wheelIndex: number): void;
                     /**
                      * Set the target rotational speed of the hinge constraint.
                      */
                     disableMotor(wheelIndex: number): void;
                     /**
                      * Set the wheel force to apply on one of the wheels each time step
                      */
                     setWheelForce(value: number, wheelIndex: number): void;
                     /**
                      * Apply a torque on one of the wheels.
                      */
                     applyWheelForce(value: number, wheelIndex: number): void;
                     /**
                      * Add the vehicle including its constraints to the world.
                      */
                     addToWorld(world: World): void;
                     private _update;
                     /**
                      * Remove the vehicle including its constraints from the world.
                      */
                     removeFromWorld(world: World): void;
                     /**
                      * Get current rotational velocity of a wheel
                      */
                     getWheelSpeed(wheelIndex: number): number;
                 }

                  type RigidVehicleOptions = ConstructorParameters<typeof RigidVehicle>[0];

                  class Ring extends Path<RingProps> {
                     shape: RingShape;
                     constructor(opts?: RingProps);
                     getDefaultShape(): RingShape;
                     buildPath(ctx: CanvasRenderingContext2D, shape: RingShape): void;
                 }

                  interface RingProps extends PathProps {
                     shape?: Partial<RingShape>;
                 }

                  class RingShape {
                     cx: number;
                     cy: number;
                     r: number;
                     r0: number;
                 }

                  class Rose extends Path<RoseProps> {
                     shape: RoseShape;
                     constructor(opts?: RoseProps);
                     getDefaultStyle(): {
                         stroke: string;
                         fill: string;
                     };
                     getDefaultShape(): RoseShape;
                     buildPath(ctx: CanvasRenderingContext2D, shape: RoseShape): void;
                 }

                  interface RoseProps extends PathProps {
                     shape?: Partial<RoseShape>;
                 }

                  class RoseShape {
                     cx: number;
                     cy: number;
                     r: number[];
                     k: number;
                     n: number;
                 }

                 export  interface RosourceItemsReturnType {
                     promises: (progressCb?: (percentage: number, error?: any) => void) => Promise<any[]>;
                     getResouces: () => {
                         name?: string;
                         url?: string;
                         type?: string;
                         resource: any;
                     }[];
                     getResource: (name: any) => any;
                     getTexture: (name: any) => Texture;
                     getModel: (name: any) => Entity;
                     /**  */
                     cloneModel: (name: string, options?: ILoadModelOption) => Entity;
                 }

                 /**
                  * 
                  */
                  function rotate(out: MatrixArray, a: MatrixArray, rad: number, pivot?: VectorArray): MatrixArray;

                 /**
                  * .
                  */
                 export  class RotatingApertureMarker extends AnimateMarkerBase {
                     constructor(features: FeatureCollection | {
                         position: [number, number, number?];
                         text?: string;
                     }, options?: AnimateMarkerLayerOption);
                     setMarkersWidth(width: number, index?: number): void;
                     setMarkersColors(colors: string[], index?: number): void;
                     _createMarker(): void;
                     private _createMakerElement;
                     private _getDotsStyleObj;
                 }

                 /**
                  * .
                  */
                 export  class RotatingTextBorderMarker extends AnimateMarkerBase {
                     constructor(features: FeatureCollection | {
                         position: [number, number, number?];
                         text?: string;
                     }, options?: AnimateMarkerLayerOption);
                     setMarkersWidth(width: number): void;
                     setMarkersHeight(height: number): void;
                     setMarkersTextField(textField: string, index?: number): void;
                     setMarkersTextColor(textColor: string, index?: number): void;
                     setMarkersTextFontSize(textFontSize: number, index?: number): void;
                     setMarkersColors(colors: string[], index?: number): void;
                     _createMarker(): void;
                     _setMarkerContainerProperty(properties: any, index?: number): void;
                 }

                 /**
                  * Apply rotation to particles over their life.
                  */
                 export  class Rotation3DOverLife implements Simulation {
                     angularVelocity: RotationGenerator;
                     type: string;
                     private tempQuat;
                     private dynamic;
                     constructor(angularVelocity: RotationGenerator);
                     initialize(particle: Particle): void;
                     update(particle: Particle, delta: number): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 /**
                  * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
                  */
                  class RotationalEquation extends Equation {
                     /**
                      * World oriented rotational axis.
                      */
                     axisA: Vec3;
                     /**
                      * World oriented rotational axis.
                      */
                     axisB: Vec3;
                     /**
                      * maxAngle
                      */
                     maxAngle: number;
                     constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                         /**
                          * World oriented rotational axis.
                          */
                         axisA?: Vec3;
                         /**
                          * World oriented rotational axis.
                          */
                         axisB?: Vec3;
                         /**
                          * maxAngle
                          */
                         maxAngle?: number;
                         /**
                          * @default 1e6
                          */
                         maxForce?: number;
                     });
                     computeB(h: number): number;
                 }

                  type RotationalEquationOptions = ConstructorParameters<typeof RotationalEquation>[2];

                 /**
                  * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
                  */
                  class RotationalMotorEquation extends Equation {
                     /**
                      * World oriented rotational axis.
                      */
                     axisA: Vec3;
                     /**
                      * World oriented rotational axis.
                      */
                     axisB: Vec3;
                     /**
                      * Motor velocity.
                      */
                     targetVelocity: number;
                     constructor(bodyA: Body_2, bodyB: Body_2, maxForce?: number);
                     computeB(h: number): number;
                 }

                 export  class RotationBehavior extends Behavior {
                     axis: Vector3;
                     speed: number;
                     angle: number;
                     __offset: Quaternion;
                     resetWhenFinalize: boolean;
                     constructor();
                     static fromJSON(param: {
                         axis?: Vector3;
                         speed?: number;
                         angle?: number;
                         resetWhenFinalize?: boolean;
                     }): RotationBehavior;
                     /**
                      *
                      * @param axis
                      * @param speed
                      * @param angle
                      */
                     fromJSON(param: {
                         axis?: Vector3;
                         speed?: number;
                         angle?: number;
                         resetWhenFinalize?: boolean;
                     }): void;
                     initialize(context: BehaviorContext): void;
                     tick(timeDelta: any): BehaviorStatus;
                     finalize(): void;
                 }

                 /**
                  * Apply rotation to particles based on their speed.
                  */
                 export  class RotationBySpeed implements Simulation {
                     angularVelocity: ValueGenerator | FunctionValueGenerator;
                     speedRange: IntervalValue;
                     type: string;
                     private tempQuat;
                     constructor(angularVelocity: ValueGenerator | FunctionValueGenerator, speedRange: IntervalValue);
                     initialize(particle: Particle): void;
                     update(particle: Particle, delta: number): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 export  interface RotationGenerator {
                     type: 'rotation';
                     genValue(q: Quaternion, t?: number): Quaternion;
                     toJSON(): FunctionJSON;
                     clone(): RotationGenerator;
                 }

                 export  function RotationGeneratorFromJSON(json: FunctionJSON): RotationGenerator;

                 /**
                  * Apply rotation to particles over their life.
                  */
                 export  class RotationOverLife implements Simulation {
                     angularVelocity: ValueGenerator | FunctionValueGenerator;
                     type: string;
                     private dynamic;
                     constructor(angularVelocity: ValueGenerator | FunctionValueGenerator);
                     initialize(particle: Particle): void;
                     update(particle: Particle, delta: number): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 export  function roundToStep(value: number, step: number): number;

                 /**
                  * This class represents a running tween for a specific target object.
                  * It manages the execution of actions and tweens associated with the tween.
                  * Don't instantiate this manually.
                  * @template T - The type of the target object.
                  */
                 export  class RunningTween<T = any> {
                     /**
                      * Indicates whether the execution of the running tween is paused.
                      * If set to `true`, the tween will not progress until it is resumed.
                      */
                     paused: boolean;
                     /**
                      * The time scale factor for the running tween.
                      * It determines the speed at which the tween progresses.
                      * A value of `1` represents normal speed, while `0.5` would be half-speed, and `2` would be double-speed.
                      */
                     timeScale: number;
                     /**
                      * Indicates whether the running tween has finished executing.
                      */
                     get finished(): boolean;
                     tweenManager: TweenManager;
                     /**
                      * Don't instantiate this manually.
                      */
                     constructor(target: T, tween: Tween<T>, tweenManager: TweenManager);
                     /**
                      * Set the time scale for the running tween.
                      * @param value - The time scale value to apply.
                      * @returns The updated RunningTween instance.
                      */
                     setTimeScale(value: number): this;
                     /**
                      * Pause the execution of the running tween.
                      */
                     pause(): void;
                     /**
                      * Resume the execution of the running tween if it was paused.
                      */
                     resume(): void;
                     /**
                      * Stop the running tween, causing it to finish immediately.
                      */
                     stop(): void;
                     /**
                      * Complete the running tween, causing it to finish immediately.
                      */
                     complete(): void;
                 }

                 /**
                  * Set value only if setter exists
                  * @param object - object to set
                  * @param prop - property to set
                  * @param value - value to set
                  * @param allowWritable - allow writable properties without setter
                  * @param allowAny - allow any property (even if it doesn't exist)
                  *
                  * @category JS Object
                  */
                 export  function safeSetProperty<T, K extends keyof T>(object: T | undefined | null, prop: K, value: NonNullable<T>[K], allowWritable?: boolean, allowAny?: boolean): boolean;

                  const SAH: SplitStrategy;

                 /**
                  * Sweep and prune broadphase along one axis.
                  */
                  class SAPBroadphase extends Broadphase {
                     /**
                      * List of bodies currently in the broadphase.
                      */
                     axisList: Body_2[];
                     /**
                      * The world to search in.
                      */
                     world: World | null;
                     /**
                      * Axis to sort the bodies along.
                      * Set to 0 for x axis, and 1 for y axis.
                      * For best performance, pick the axis where bodies are most distributed.
                      */
                     axisIndex: 0 | 1 | 2;
                     private _addBodyHandler;
                     private _removeBodyHandler;
                     /**
                      * Check if the bounds of two bodies overlap, along the given SAP axis.
                      */
                     static checkBounds(bi: Body_2, bj: Body_2, axisIndex: 0 | 1 | 2): boolean;
                     /**
                      * insertionSortX
                      */
                     static insertionSortX(a: Body_2[]): Body_2[];
                     /**
                      * insertionSortY
                      */
                     static insertionSortY(a: Body_2[]): Body_2[];
                     /**
                      * insertionSortZ
                      */
                     static insertionSortZ(a: Body_2[]): Body_2[];
                     constructor(world: World);
                     /**
                      * Change the world
                      */
                     setWorld(world: World): void;
                     /**
                      * Collect all collision pairs
                      */
                     collisionPairs(world: World, p1: Body_2[], p2: Body_2[]): void;
                     sortList(): void;
                     /**
                      * Computes the variance of the body positions and estimates the best axis to use.
                      * Will automatically set property `axisIndex`.
                      */
                     autoDetectAxis(): void;
                     /**
                      * Returns all the bodies within an AABB.
                      * @param result An array to store resulting bodies in.
                      */
                     aabbQuery(world: World, aabb: AABB, result?: Body_2[]): Body_2[];
                 }

                 /**
                  * 
                  */
                  function scale(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;

                 /**
                  * 
                  */
                  function scale_2<T extends VectorArray>(out: T, v: VectorArray, s: number): T;

                 /**
                  * 
                  */
                  function scaleAndAdd<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray, a: number): T;

                 export  class SceneModule extends AppModuleBase implements IAppModuleBase {
                     #private;
                     static moduleName: string;
                     allScenes: Scene[];
                     allCameras: Camera[];
                     allControlStates: (CameraState | undefined)[];
                     options: SceneModuleOptions;
                     _axesHelper: AxesHelper;
                     _loadedResources: RosourceItemsReturnType;
                     _config: EnvConfigOption & {
                         [key: string]: any;
                     };
                     constructor(app?: App, options?: SceneModuleOptions);
                     get sceneEntity(): any;
                     setAxesHelperVisible(visible?: boolean, size?: number): void;
                     isAxesHelperVisible(): boolean;
                     setBackgroundEnvironment(options?: BackgroundEnvironmentOptions): Promise<void>;
                     get envConfig(): EnvConfigOption & {
                         [key: string]: any;
                     };
                     setEnvConfig(key: string, value: any): void;
                     clearScenes(): void;
                     addScene(scene?: Scene, camera?: CameraOptions): Scene;
                     activeScene(_scene: Scene, opts?: {
                         oldScene?: Scene;
                         camera?: Camera;
                         oldCamera?: Camera;
                         cameraState?: CameraState;
                         enableTransition?: boolean;
                         exitBlurTime?: number;
                     }): Promise<void>;
                     removeScene(_scene: Scene): Promise<boolean>;
                     setScene(scene?: Scene, camera?: CameraOptions): Promise<Scene>;
                     /**  */
                     initScene(scene: Scene, opts?: {
                         defaultLights?: boolean;
                         gridHelper?: GridHelperModuleOptions;
                     }): void;
                     onAwake(): void;
                     updateSceneMatixWorld(): void;
                     addDefaultLights(scene?: Scene): void;
                     getSceneStatData(): {
                         objects: number;
                         vertices: number;
                         triangles: number;
                     };
                     setFocus(): void;
                     /**  */
                     loadResources(_resources: ResourceItem[], options?: loadResourcesOptions): Promise<RosourceItemsReturnType>;
                     getLoadedResources(): RosourceItemsReturnType;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  type SceneModuleOptions = EnvConfigOption & BackgroundEnvironmentOptions;

                 /**
                  * The Scheduler is in charge of managing the Providers that
                  * are used to gather resources needed to display the layers on a View.
                  * There is only one instance of a Scheduler per webview, and it is instanciated
                  * with the creation of the first view.
                  *
                  * @constructor
                  */
                 export  class Scheduler {
                     constructor();
                     runCommand(command: any, queue: any, executingCounterUpToDate: any): void;
                     execute(command: {
                         id?: string;
                         url?: string;
                         priority?: number;
                         notifyChange?: Function;
                         executeCommand?: Function;
                         [key: string]: any;
                     }): any;
                     /**
                      * Adds a provider for a specified protocol. The provider will be used when
                      * executing the queue to provide resources.
                      */
                     addProtocolProvider(protocol: any, provider: any): void;
                     /**
                      * Get a specific Provider given a particular protocol.
                      *
                      * @param {string} protocol
                      *
                      * @return {Provider}
                      */
                     getProtocolProvider(protocol: any): any;
                     commandsWaitingExecutionCount(): any;
                     commandsRunningCount(): any;
                     resetCommandsCount(type: any): any;
                     deQueue(queue: any): any;
                 }

                 /**
                  * 
                  */
                 export  class ScreenQuad {
                     material: Material;
                     mesh: Mesh;
                     constructor(app: App, config?: Partial<PlaneConfig>);
                 }

                 export  interface Screenshot {
                     quality?: number;
                     mine?: string;
                     download?: boolean;
                 }

                 export  interface ScriptDefaultOptions {
                     src: string;
                     strategy?: string;
                     injectLocation?: string;
                     async?: boolean;
                 }

                  class Sector extends Path<SectorProps> {
                     shape: SectorShape;
                     constructor(opts?: SectorProps);
                     getDefaultShape(): SectorShape;
                     buildPath(ctx: CanvasRenderingContext2D, shape: SectorShape): void;
                     isZeroArea(): boolean;
                 }

                  interface SectorProps extends PathProps {
                     shape?: Partial<SectorShape>;
                 }

                  class SectorShape {
                     cx: number;
                     cy: number;
                     r0: number;
                     r: number;
                     startAngle: number;
                     endAngle: number;
                     clockwise: boolean;
                     /**
                      * Corner radius of sector
                      *
                      * clockwise, from inside to outside, four corners are
                      * inner start -> inner end
                      * outer start -> outer end
                      *
                      * 5               => [5, 5, 5, 5]
                      * [5]             => [5, 5, 0, 0]
                      * [5, 10]         => [5, 5, 10, 10]
                      * [5, 10, 15]     => [5, 10, 15, 15]
                      * [5, 10, 15, 20] => [5, 10, 15, 20]
                      */
                     cornerRadius: number | number[];
                 }

                 /**
                  * 
                  * @param x1
                  * @param y1
                  * @param x2
                  * @param y2
                  * @param x3
                  * @param y3
                  * @param x4
                  * @param y4
                  * @return {{result: string, status: boolean} | {result: string, status: boolean} | {x: number, y: number, status: boolean, ratio: number} | {result: string, status: boolean}}
                  */
                 export  function segmentIntersect(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): {
                     result: string;
                     status: boolean;
                     x?: undefined;
                     y?: undefined;
                     ratio?: undefined;
                 } | {
                     status: boolean;
                     x: number;
                     y: number;
                     ratio: number;
                     result?: undefined;
                 };

                 /**
                  * 
                  * @param p1 - 
                  * @param p2 - 
                  * @param p3 - 
                  * @param p4 - 
                  * @returns {Object} 
                  */
                 export  function segmentIntersect3d(p1: any, p2: any, p3: any, p4: any, epsilon?: number): {
                     status: boolean;
                     result: string;
                     point: Vector3;
                     ratio: number;
                 };

                 

                 /**
                  * Will try every child behaviour in order until one succeeds or if all fail - the selector behavior will fail too
                  */
                 export  class SelectorBehavior extends CompositeBehavior {
                     __currentBehaviour: Behavior;
                     __currentBehaviourIndex: number;
                     constructor();
                     /**
                      *
                      * @param {Behavior[]} children
                      * @returns {SelectorBehavior}
                      */
                     static from(children: Behavior[]): SelectorBehavior;
                     tick(timeDelta: number): BehaviorStatus;
                     finalize(): void;
                     initialize(context: BehaviorContext): void;
                 }

                 export  class SendEventBehavior extends Behavior {
                     event: string;
                     data: any;
                     target: any;
                     constructor();
                     fromJSON({ event, data, target }: {
                         event: any;
                         data?: {};
                         target?: any;
                     }): void;
                     static fromJSON(j: {
                         event: string;
                         data: any;
                         target?: any;
                     }): SendEventBehavior;
                     tick(timeDelta: number): BehaviorStatus;
                 }

                  interface SeparateConfig extends ElementAnimateConfig {
                     dividePath?: DividePath;
                     individualDelay?: IndividualDelay;
                 }

                 /**
                  * Make separate morphing from one path to many paths.
                  * Make the MorphingKind of `toPath` become `'ONE_ONE'`.
                  */
                  function separateMorph(fromPath: Path, toPathList: Path[], animationOpts: SeparateConfig): {
                     fromIndividuals: Path<PathProps>[];
                     toIndividuals: Path<PathProps>[];
                     count: number;
                 };

                 /**
                  * Executes all contained behaviors one after another in a sequence, next behaviour in the sequence will not be started until the previous one signal success
                  * If any of the contained behaviours fail - the whole sequence fails
                  */
                 export  class SequenceBehavior extends CompositeBehavior {
                     __currentBehaviourIndex: number;
                     __currentBehaviourState: BehaviorStatus;
                     __currentBehaviour: Behavior;
                     constructor();
                     initialize(context: BehaviorContext): void;
                     /**
                      *
                      * @param {number} timeDelta
                      * @returns {BehaviorStatus}
                      */
                     tick(timeDelta: number): BehaviorStatus;
                     finalize(): void;
                     /**
                      *
                      * @param {Behavior[]} list
                      * @return {SequenceBehavior}
                      */
                     static from(list: Behavior[]): SequenceBehavior;
                 }

                 export  interface Sequencer {
                     transform(position: Vector3, index: number): void;
                     toJSON(): any;
                     clone(): Sequencer;
                 }

                 export  function SequencerFromJSON(json: any): Sequencer;

                 /**
                  * Decorator to mark a class as serializable using the {@link Serialization} class.
                  * @note - Requires "experimentalDecorators": true in tsconfig.json
                  * @param id - The id to use when serializing the class. This is used to identify the class when deserializing. Class names can be mangled during minification, so it is required to provide an id.
                  */
                 export  function serializable(id: string): <T extends new (...args: any[]) => any>(constructor: T) => T;

                 /**
                  * Serialization class with static methods for serializing and deserializing objects.
                  * Properties and classes can be marked serializable by adding {@link serialize} and {@link serializable} decorators.
                  * @category Serialization
                  */
                 export  class Serialization {
                     static TypeMap: Map<ObjectConstructor, [string, string][]>;
                     static SerializableClasses: Map<string, any>;
                     /**
                      * Serializers for primitive, array and struct/custom object types
                      */
                     static Serializers: Serializer[];
                     static GetSerializer(obj: any): Serializer;
                     static RegisterSerializer(...serializers: Serializer[]): void;
                     static UnregisterSerializer(...serializers: Serializer[]): void;
                     /**
                      * Serialize an object
                      * @param obj - object to serialize
                      * @param meta - Optional object to store common meta-data/resources across the serialization process of multiple objects
                      @param isThis - true if called from inside the serialization function, like custom {@link IJSONSerializable.toJSON}.
                      */
                     static Serialize(obj: any, meta?: Record<string, Record<string, any>>, isThis?: boolean): any;
                     /**
                      * Deserialize an object
                      * @param data - data to deserialize
                      * @param obj - current object that's set. If of the same class/type the data is deserialized into that instead of creating new objects.
                      * @param meta - Optional object to retrieve common meta-data/resources across the deserialization process of multiple objects. Objects in meta must be class instances, not js objects. (like Material, Texture, Object3D etc)
                      * @param isThis - true if called from inside the deserialization function, like custom {@link IJSONSerializable.fromJSON}
                      */
                     static Deserialize(data: any, obj: any, meta?: Record<string, any>, isThis?: boolean): any;
                 }

                 export  interface SerializationOptions {
                     /**
                      * Use URL for image.
                      * @type {boolean}
                      */
                     useUrlForImage?: boolean;
                 }

                 /**
                  * Decorator to mark a class property as serializable using the {@link Serialization} class.
                  * @note - Requires "experimentalDecorators": true in tsconfig.json
                  * @param key - The key to use when serializing the property. If not provided, the property name is used (for this make sure the property name is not mangled during minification).
                  * @category Decorators
                  */
                 export  function serialize(key?: string): PropertyDecorator;

                  interface Serialized {
                     nodes: Array<{
                         id: NodeId;
                     }>;
                     links: Array<{
                         source: NodeId;
                         target: NodeId;
                         weight: EdgeWeight;
                     }>;
                 }

                  class SerializedBVH {
                     roots: Array<ArrayBuffer>;
                     index: ArrayBufferView;
                 }

                 /**
                  * Serializer interface for primitive, array and struct/custom object types
                  * @category Serialization
                  */
                 export  interface Serializer {
                     serialize: (obj: any, meta?: any) => any;
                     deserialize: (data: any, obj: any, meta?: any) => any;
                     isType: (obj: any) => boolean;
                     priority?: number;
                 }

                 /**
                  * `Service` .
                  *
                  */
                 export  class Service {
                     /**
                      * 
                      * @type {string}
                      */
                     serverUrl: string;
                     /**
                      * 
                      * @type {string}
                      */
                     accessToken: string;
                     private readonly _reqImpl;
                     private _cur_map_param;
                     private _svr_url_map;
                     private readonly _svr_url_service;
                     private _secretKeys?;
                     private _accessKeys?;
                     private _workspaceName?;
                     /**
                      * 
                      * @param url 
                      * @param token 
                      * @param req )
                      */
                     constructor(url: string, token?: string, req?: IRequest);
                     private _url;
                     /**
                      * 
                      * @param isCloneWorkspace  ()
                      * @return Service
                      */
                     clone(isCloneWorkspace?: boolean): Service;
                     /**
                      * 
                      * @param u 
                      * @return string
                      */
                     serviceUrl(u: string): string;
                     /**
                      * 
                      * @param workspaceName 
                      * @return
                      */
                     switchWorkspace(workspaceName: string): void;
                     /**
                      * 
                      * @return
                      */
                     getCurWorkspaceName(): string;
                     /**
                      * (roottoken)
                      * @return
                      */
                     getWorkspaces(): Promise<any>;
                     /**
                      * (root)
                      * @param workspace 
                      * @return
                      */
                     workspaceCreate(workspace: IWorkspace): Promise<any>;
                     /**
                      * (root)
                      * @param workspace 
                      * @return
                      */
                     workspaceModify(workspace: IWorkspace): Promise<any>;
                     /**
                      * (root)
                      * @param name 
                      * @return
                      */
                     workspaceDelete(name: string): Promise<any>;
                     /**
                      * 
                      * @param pwd 
                      */
                     pwdToSecretKey(pwd: string): string;
                     /**
                      * key
                      * @param key key
                      */
                     addSecretKey(key: string): Set<string>;
                     /**
                      * key, keyundefined
                      * @param key key
                      */
                     removeSecretKey(key: string): Set<string>;
                     /**
                      * key
                      * @param key key
                      */
                     addAccessKey(key: string): Set<string>;
                     /**
                      * key, keyundefined
                      * @param key key
                      */
                     removeAccessKey(key: string): void;
                     private _to_layer_string;
                     private _addTokenHeader;
                     private _get;
                     private _post;
                     private _del;
                     /**
                      * 
                      * @param layernames 
                      * @param layers 
                      * @return {number[]}
                      */
                     toLayerIndex(layernames: string[], layers: any[]): number[];
                     private _waitOpenMap;
                     /**
                      * 
                      */
                     setCurrentMapParam(param: IOpenMapResponse): IOpenMapResponse | null;
                     /**
                      * 
                      */
                     currentMapParam(): IOpenMapResponse | null;
                     /**
                      * 
                      * @param param
                      * @param isWaitFinish 
                      * @return {Promise<any>}
                      */
                     openMap(param: IOpenMapParam, isWaitFinish?: boolean): Promise<any>;
                     /**
                      * 
                      * @param param
                      * @param isWaitFinish 
                      */
                     updateMap(param: IUpdateMapParam, isWaitFinish?: boolean): Promise<any>;
                     /**
                      * 
                      * @param param
                      */
                     glyphsUrl(): string;
                     /**
                      * 
                      */
                     baseUrl(): string;
                     /**
                      * 
                      * @param name 
                      */
                     spriteUrl(name: string): string;
                     /**
                      * 
                      * @param name 
                      */
                     setSprite(name: string): string;
                     /**
                      * 
                      */
                     blankTileUrl(): string;
                     /**
                      * 
                      * @param content 
                      * @param size 256
                      */
                     qrcodeUrl(content: string, size?: number): string;
                     /**
                      * 
                      * @param param
                      */
                     rasterTileUrl(param?: ITileUrlParam): string;
                     /**
                      * 
                      * @param param
                      */
                     vectorTileUrl(param?: ITileUrlParam): string;
                     /**
                      * 
                      * @param filemd5 md5
                      */
                     checkFileHasUpload(filemd5: string): Promise<any>;
                     /**
                      * url
                      * @return {string}
                      */
                     uploadUrl(): string;
                     /**
                      * Md5
                      * @param str
                      * @return {string}
                      */
                     strMd5(str: string): string;
                     /**
                      * style
                      */
                     styleVersion(): number;
                     /**
                      * Md5
                      * @param file
                      * @return {Promise<any>}
                      */
                     fileMd5(file: File): Promise<any>;
                     /**
                      * 
                      * @param file
                      * @return {Promise<any>}
                      */
                     uploadMap(file: File): Promise<any>;
                     /**
                      * 
                      * @return {string}
                      */
                     execCommand(cmdname: string, param?: Record<string, any>, mapid?: string, version?: string, useGet?: boolean): Promise<any>;
                     /**
                      * 
                      * @param mapid ID , 
                      * @param version  ;
                      */
                     metadata(mapid?: string, version?: string): Promise<any>;
                     /**
                      * 
                      * @param meta 
                      * @param mapid ID , 
                      * @param version  ;
                      */
                     updateMetadata(meta: Record<string, number | boolean | string | undefined | null>, mapid?: string, version?: string): Promise<any>;
                     /**
                      * 
                      * @param mapid IDIDID{curPage: 1, pageCount: 10}
                      * @param version ; * 
                      */
                     listMaps(mapid?: string | string[] | {
                         curPage: number;
                         pageCount: number;
                         mapIds?: string[];
                     }, version?: string): Promise<any>;
                     /**
                      * 
                      * @param mapid ID
                      * @param version 
                      * @param tryTime ()
                      * @param maxTryTimes 
                      * @return {Promise<void>}
                      */
                     waitMapOpenFinish(mapid: string, version: string, tryTime?: number, maxTryTimes?: number): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      */
                     processQueryResult(param: any, cb?: (point: [number, number]) => [number, number] | null | undefined): any;
                     /**
                      * 
                      * @private
                      */
                     private _processQueryResult;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      */
                     pointQueryFeature(param: IPointQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      */
                     rectQueryFeature(param: IRectQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      */
                     exprQueryFeature(param: IExprQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      */
                     conditionQueryFeature(param: IConditionQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
                     /**
                      * 
                      */
                     getMapLayers(): IMapLayer[];
                     /**
                      * 
                      * @param visibleLayers 
                      * @param expression 
                      * @return {Promise<void>}
                      */
                     cmdSwitchLayers(visibleLayers: string[], expression?: string): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @return {Promise<any>}
                      *
                      *
                      * Example:
                      * ```typescript
                      * const res = svc.cmdUpdateStyle({
                      *     name: "style1",
                      *     layeron: [0,1,2,4,5,6,7,8,9],
                      *     layeroff: "",
                      *     clipbounds: "",
                      *     backcolor: 0,
                      *     lineweight:[1,1,0]
                      *     expression: "gOutColorRed := gInColorGreen;gOutColorGreen := gInColorBlue;gOutColorBlue := gInColorRed;gOutColorAlpha := gInColorAlpha;"
                      * });
                      * ```
                      */
                     cmdUpdateStyle(param: IUpdateStyle): Promise<any>;
                     /**
                      * 
                      * @param param
                      * @return {Promise<any>}
                      */
                     cmdSliceLayer(param: ISliceLayer): Promise<any>;
                     /**
                      * 
                      * @param style 
                      * @param mapid ID
                      * @param version ;
                      * @param isGeomLayer (true)
                      * @return {Promise<any>}
                      */
                     createStyle(style: IMapStyleParam, mapid?: string, version?: string, isGeomLayer?: boolean): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @return {Promise<any>}
                      */
                     getSliceCacheZoom(param: ISliceCacheZoom): Promise<any>;
                     /**
                      * 
                      * @param mapid id
                      * @param version 
                      * @return {Promise<any>}
                      */
                     cmdGetDrawBounds(mapid?: string, version?: string): Promise<GeoBounds | null>;
                     /**
                      * 
                      * @param mapid ID
                      * @param version ;
                      * @param isGeomLayer (true)
                      * @param name ;
                      * @return {Promise<any>}
                      */
                     getStyleLayerName(mapid: string, version?: string, isGeomLayer?: boolean, name?: string): Promise<any>;
                     /**
                      * 
                      * @param mapid
                      * @param version
                      * @param width
                      * @param height
                      * @param darkTheme 
                      */
                     thumbnailUrl(mapid?: string, version?: string, width?: number, height?: number, darkTheme?: boolean): string;
                     wmsTileUrl(param: IWmsTileUrl): string;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param mapid ID
                      * @param version "*"
                      * @param retainVersionMaxCount 10retainVersionMaxCount33
                      */
                     cmdDeleteMap(mapid: string, version: string, retainVersionMaxCount?: number): Promise<any>;
                     /**
                      * AccessKey
                      * @param mapid ID
                      * @param key secretKeysuperKey
                      * @return {Promise<any>}
                      */
                     cmdGetAccessKey(mapid: string, key: string): Promise<any>;
                     /**
                      * AccessKey
                      * @param mapid ID
                      * @param key secretKeysuperKey
                      * @return {Promise<any>}
                      */
                     cmdResetAccessKey(mapid: string, key: string): Promise<any>;
                     /**
                      * 
                      * @param mapid ID
                      * @param key secretKeysuperKey
                      * @param newKey secretKey
                      * @return {Promise<any>}
                      */
                     cmdSetMapPassword(mapid: string, key: string, newKey: string): Promise<any>;
                     /**
                      * ID
                      * @return {Promise<any>}
                      * @param oldMapID ID
                      * @param newMapID ID
                      */
                     cmdRenameMap(oldMapID: string, newMapID: string): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param mapid ID
                      * @param version 
                      */
                     cmdClearMapCache(mapid: string, version: string): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param mapid ID
                      * @param version 
                      */
                     cmdClearTileCache(mapid: string, version: string): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param param 
                      */
                     cmdDeleteStyle(param: IDeleteStyle): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param param 
                      */
                     cmdDeleteCache(param: IDeleteCache): Promise<any>;
                     /**
                      * 
                      * @param mapfileNames 
                      * @return {Promise<any>}
                      */
                     cmdDeleteMapFile(mapfileNames: string | string[]): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param bDetail  (false)
                      */
                     cmdRunStatus(bDetail?: boolean): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      */
                     cmdGetSupportFormat(): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      */
                     getConstData(): Promise<any>;
                     /**
                      * style
                      * @param minzoom 0
                      * @param maxzoom 24
                      * @param prefix rasterBlank
                      */
                     rasterBlankStyle(minzoom?: number, maxzoom?: number, prefix?: string): {
                         version: number;
                         sources: {
                             [x: string]: {
                                 type: string;
                                 tiles: string[];
                                 tileSize: number;
                                 minzoom: number;
                                 maxzoom: number;
                             };
                         };
                         glyphs: string;
                         layers: {
                             id: string;
                             type: string;
                             source: string;
                             minzoom: number;
                             maxzoom: number;
                             layout: {
                                 visibility: string;
                             };
                         }[];
                     };
                     /**
                      * ID
                      * @param prefix
                      * @return {string}
                      */
                     rasterLayerId(prefix?: string): string;
                     /**
                      * ID
                      * @param prefix
                      * @return {string}
                      */
                     rasterSourceId(prefix?: string): string;
                     /**
                      * style
                      * @param tileUrl 
                      * @param minzoom 0
                      * @param maxzoom 24
                      * @param prefix raster
                      */
                     rasterStyle(tileUrl?: string, minzoom?: number, maxzoom?: number, prefix?: string): {
                         version: number;
                         sources: {
                             [x: string]: {
                                 type: string;
                                 tiles: string[];
                                 tileSize: number;
                                 minzoom: number;
                                 maxzoom: number;
                             };
                         };
                         glyphs: string;
                         layers: {
                             id: string;
                             type: string;
                             source: string;
                             minzoom: number;
                             maxzoom: number;
                             layout: {
                                 visibility: string;
                             };
                         }[];
                     };
                     /**
                      * style
                      * @param tileUrl  ObjectObject
                      * @param minzoom 0
                      * @param maxzoom 24
                      * @param prefix vector
                      * @param hoverColor rgba(0,0,255,255)
                      * @param hoverOpacity ,0.5
                      * @param hoverLineWidth ,3
                      * @param customColorCaseExpr [12,...][['==', ['feature-state', 'status'], 'alarm'], '#ff0000', ['==', ['feature-state', 'status'], 'normal'], '#00ff00'],
                      * @param customOpacityCaseExpr ,
                      * @param customLineWidthCaseExpr ,
                      * @param disableHover hover
                      */
                     vectorStyle(tileUrl?: string | Record<string, any>, minzoom?: number, maxzoom?: number, prefix?: string, hoverColor?: string, hoverOpacity?: number, hoverLineWidth?: number, customColorCaseExpr?: any[], customOpacityCaseExpr?: any[], customLineWidthCaseExpr?: any[], disableHover?: boolean): {
                         layers: ({
                             id: string;
                             type: string;
                             source: string;
                             "source-layer": string;
                             paint: {
                                 "line-color": any[];
                                 "line-opacity": any[];
                                 "line-width": (string | number | boolean | (string | boolean | string[])[])[];
                                 "fill-color"?: undefined;
                                 "fill-antialias"?: undefined;
                                 "fill-outline-color"?: undefined;
                                 "fill-opacity"?: undefined;
                                 "line-blur"?: undefined;
                                 "circle-radius"?: undefined;
                                 "circle-color"?: undefined;
                                 "circle-stroke-color"?: undefined;
                                 "circle-opacity"?: undefined;
                             };
                             layout?: undefined;
                         } | {
                             id: string;
                             type: string;
                             source: string;
                             "source-layer": string;
                             paint: {
                                 "fill-color": any[];
                                 "fill-antialias": boolean;
                                 "fill-outline-color": any[];
                                 "fill-opacity": any[];
                                 "line-color"?: undefined;
                                 "line-opacity"?: undefined;
                                 "line-width"?: undefined;
                                 "line-blur"?: undefined;
                                 "circle-radius"?: undefined;
                                 "circle-color"?: undefined;
                                 "circle-stroke-color"?: undefined;
                                 "circle-opacity"?: undefined;
                             };
                             layout: {
                                 "line-cap"?: undefined;
                             };
                         } | {
                             id: string;
                             type: string;
                             source: string;
                             "source-layer": string;
                             layout: {
                                 "line-cap": string;
                             };
                             paint: {
                                 "line-color": any[];
                                 "line-blur": (string | number | boolean | (string | boolean | string[])[])[];
                                 "line-opacity": any[];
                                 "line-width": any[];
                                 "fill-color"?: undefined;
                                 "fill-antialias"?: undefined;
                                 "fill-outline-color"?: undefined;
                                 "fill-opacity"?: undefined;
                                 "circle-radius"?: undefined;
                                 "circle-color"?: undefined;
                                 "circle-stroke-color"?: undefined;
                                 "circle-opacity"?: undefined;
                             };
                         } | {
                             id: string;
                             type: string;
                             source: string;
                             "source-layer": string;
                             paint: {
                                 "circle-radius": any[];
                                 "circle-color": any[];
                                 "circle-stroke-color": any[];
                                 "circle-opacity": any[];
                                 "line-color"?: undefined;
                                 "line-opacity"?: undefined;
                                 "line-width"?: undefined;
                                 "fill-color"?: undefined;
                                 "fill-antialias"?: undefined;
                                 "fill-outline-color"?: undefined;
                                 "fill-opacity"?: undefined;
                                 "line-blur"?: undefined;
                             };
                             layout?: undefined;
                         })[];
                         version: number;
                         sources: {
                             [x: string]: {
                                 type: string;
                                 tiles: (string | Record<string, any>)[];
                                 maxzoom: number;
                                 minzoom: number;
                             };
                         };
                         glyphs: string;
                     };
                     /**
                      * 
                      * @return {Promise<any>}
                      */
                     getFontsCapacity(): Promise<unknown>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param prefix key
                      */
                     clearCache(prefix?: string): Promise<unknown>;
                     /**
                      * 
                      * @param tileProvider
                      * @return {string}
                      */
                     webMapUrl(tileProvider: {
                         tileCrs?: "gcj02" | "wgs84";
                         tileSize?: number;
                         tileRetina?: number;
                         tileMaxZoom?: number;
                         tileUrl: string | string[];
                         tileShards?: string;
                         tileToken?: string | string[];
                         tileFlipY?: boolean;
                         mapbounds?: string;
                         fourParameterBefore?: string;
                         fourParameterAfter?: string;
                         srs?: string;
                     }): string;
                     /**
                      * 
                      * @param param 
                      * @return {Promise<any>}
                      */
                     composeNewMap(param: IComposeNewMap | IComposeNewMap[]): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @return {Promise<any>}
                      */
                     cmdMapDiff(param: IMapDiff): Promise<any>;
                     /**
                      * dwg
                      * @param param 
                      * @return {Promise<any>}
                      */
                     cmdExportLayout(param: IExportLayout): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @return {Promise<any>}
                      */
                     cmdMatchObject(param: IMatchObject): Promise<any>;
                     /**
                      * 
                      * @param param 
                      * @param cb 
                      * @return {Promise<any>}
                      */
                     cmdCreateEntitiesGeomData(param: ICreateEntitiesGeomData, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
                     /**
                      * 
                      * @return {Promise<any>}
                      * @param srs  EPSG:4326
                      * @param crs  EPSG:3857
                      * @param points 
                      * @param fourParameter (x,y,)
                      * @param isInverseFourParamter 
                      */
                     cmdTransform(srs: string, crs: string, points: GeoPoint | GeoPoint[], fourParameter?: string | string[], isInverseFourParamter?: boolean): Promise<any>;
                     /**
                      * prjWKTproj4
                      * @return {Promise<any>}
                      * @param srs prjWKT
                      * @param from WKT
                      */
                     cmdPrjWktToPrj4(wkt: string, from?: undefined | "" | "wmsauto" | "xml" | "urn" | "crsurl" | "url" | "micoordsys" | "pci"): Promise<any>;
                     /**
                      * 
                      * @param key (key)
                      * @param value 
                      * @param prop 
                      * @param ttl 
                      */
                     saveCustomData(key: string | {
                         key: string;
                         value: any;
                         prop?: any;
                         ttl?: number;
                     }[], value?: any, prop?: any, ttl?: number): Promise<any>;
                     /**
                      * 
                      * @param key .
                      * @param options  retDataType,"value""prop"contentType,json"image".
                      */
                     getCustomData(key: string | string[], options?: {
                         retDataType?: "" | "value" | "prop";
                         contentType?: "" | "image";
                     }): Promise<any>;
                     /**
                      * 
                      * @param prefix 
                      */
                     getCustomDataKeysByPrefix(prefix: string): Promise<any>;
                     /**
                      * 
                      * @param key 
                      * @param isPrefix keyfalse
                      */
                     deleteCustomData(key: string | string[], isPrefix?: boolean): Promise<any>;
                     /**
                      * 
                      * @param content contentjson
                      * @return {string}
                      */
                     toDbDoc(content: string | Record<string, any>): string;
                 }

                 /**
                  * 
                  */
                  function set<T extends VectorArray>(out: T, a: number, b: number): T;

                 /**
                  * Set an object as primitive to be ignored traversing children in clone or merge
                  */
                  function setAsPrimitive(obj: any): void;

                 export  class SetDataCommand extends BaseCommand {
                     private readonly oldData;
                     private readonly newData;
                     private readonly object;
                     constructor(object: IHasDataEntity, newData: any, oldData?: any, autoExecute?: boolean);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 export  class SetEmitDirection implements Simulation {
                     type: string;
                     _temp: Vector3;
                     _q: Quaternion;
                     velocityX: number;
                     velocityY: number;
                     velocityZ: number;
                     opts: any;
                     constructor(opts: {
                         velocityX?: ValueGenerator;
                         velocityY?: ValueGenerator;
                         velocityZ?: ValueGenerator;
                     });
                     initialize(particle: Particle): void;
                     update(particle: Particle, delta: number): void;
                     frameUpdate(delta: number): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     clone(): Simulation;
                     reset(): void;
                 }

                 export  class SetMaterialMapCommand extends BaseCommand {
                     private material;
                     private mapName;
                     private newMap;
                     private materialSlot;
                     private oldMap;
                     constructor(material: Material, mapName: any, newMap: Texture, materialSlot: any);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 /**
                  * 
                  * @param material
                  * @param opacity 
                  * @param opts isAccOpacity (turefalse), isClone  disposeOldMaterial 
                  */
                 export  const setMaterialOpacity: (material: Mesh | Material | Material[], opacity: number, opts?: {
                     isAccOpacity?: boolean;
                     isClone?: boolean;
                     disposeOldMaterial?: boolean;
                 }) => any;

                 export  class SetMultipleValuesCommand<T> extends BaseCommand {
                     private object;
                     private attributes;
                     private oldValues;
                     constructor(object: T, attributes: Partial<T>);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 export  function setPhysicsResolver(resolver: PhysicsResolver): void;

                  function setPlatformAPI(newPlatformApis: Partial<Platform>): void;

                 export  class SetPositionCommand extends BaseCommand {
                     private object;
                     private newPosition;
                     private oldPosition;
                     constructor(object: Object3D, newPosition: Vector3, oldPosition?: Vector3);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 export  class SetRotationCommand extends BaseCommand {
                     private object;
                     private newRotation;
                     private optionalOldRotation;
                     private readonly oldRotation;
                     constructor(object: Object3D, newRotation: Euler, optionalOldRotation?: Euler);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 export  class SetScaleCommand extends BaseCommand {
                     private object;
                     private newScale;
                     private optionalOldScale?;
                     private readonly oldScale;
                     constructor(object: Object3D, newScale: Vector3, optionalOldScale?: Vector3);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 /**
                  * Set URL query parameter. If value is null, remove parameter. Similar to PHP's $_GET
                  * @param p - parameter name to set
                  * @param v - parameter value or null to remove
                  * @param reload - reload page after setting parameter, default false. If false, `history.replaceState` is used.
                  *
                  * @category URL
                  */
                 export  function setUrlQueryParam(p: string, v: string | null, reload?: boolean): void;

                 export  class SetValueCommand<T, K extends keyof T> extends BaseCommand {
                     private object;
                     private attributeName;
                     private newValue;
                     private oldValue;
                     constructor(object: T, attributeName: K, newValue: T[K], oldValue?: T[K]);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                  const shaderFunctions: string;

                 export  function shaderMaterial<TProps extends UniformProps>(uniforms: TProps, vertexShader: string, fragmentShader: string, onInit?: (material: ShaderMaterialInstance<TProps>) => void): ShaderMaterialEx<TProps>;

                  type ShaderMaterialEx<TProps extends UniformProps> = (new (parameters?: ShaderMaterialParametersEx<TProps>, uniforms?: Partial<TProps>) => ShaderMaterialInstance<TProps>) & {
                     key: string;
                 };

                  type ShaderMaterialInstance<TProps extends UniformProps> = ShaderMaterial & TProps;

                  type ShaderMaterialParametersEx<TProps extends UniformProps> = ShaderMaterialParameters & Partial<TProps>;

                 

                  const shaderStructs: string;

                 /**
                  *  Shadertoy shader (imageBuffer,BufferA,B,C,D)https://www.shadertoy.com/
                  */
                 export  class ShadertoyMaterial extends ShaderMaterial {
                     constructor(app: App, parameters?: ShadertoyMaterialParameters);
                 }

                 export  interface ShadertoyMaterialParameters extends ShaderMaterialParameters {
                     /**
                      * 
                      */
                     color?: ColorRepresentation;
                     /**
                      *  (0-1)
                      * */
                     colorOpacity?: number;
                     /**
                      * 
                      */
                     map?: Texture;
                     /**
                      * commom shader
                      */
                     common?: string;
                     /**
                      * imageshader
                      */
                     shader?: string;
                     /**
                      * 
                      */
                     opacity?: number;
                     /**
                      * 
                      */
                     opacityColor?: ColorRepresentation;
                     /**
                      *  0*0 1-)*
                      */
                     brightOpacity?: number;
                     /**
                      * uniforms
                      */
                     inputUniforms?: {
                         /**
                          * uniform
                          */
                         name: string;
                         /**
                          *  shader
                          */
                         defs: string;
                         /**
                          * 
                          */
                         value: Uniform_2;
                     }[];
                     /**
                      * hsb ()
                      */
                     hsbOffset?: [number, number, number];
                     /**
                      * hsb (hsb)
                      */
                     hsbExpr?: string;
                     /**
                      * 
                      */
                     mouseInputPos?: [number, number];
                     /**
                      * 
                      */
                     defines?: Record<string, any>;
                     /**
                      * 
                      */
                     repeat?: [number, number];
                     /**
                      * 1000,1000
                      */
                     resolution?: [number, number];
                     /**
                      * () falsetrue
                      */
                     sizeAttenuation?: boolean;
                     /**
                      * sizeAttenuationfalsexyz
                      */
                     sizeAttScale?: number | [number, number, number];
                     /**
                      * uv
                      */
                     uvRotateAngle?: number;
                     /**
                      * uv0.50.5
                      */
                     uvRotateCenter?: [number, number];
                     /**
                      * uv
                      */
                     uvScale?: [number, number];
                     /**
                      * uv0.50.5
                      */
                     uvScaleCenter?: [number, number];
                     /**
                      * uv(r,b,g,a) (0-1)
                      */
                     uvScaleBgColor?: [number, number, number, number];
                 }

                 /**
                  *  Shadertoy https://www.shadertoy.com/
                  */
                 export  class ShadertoyTexture {
                     app: App;
                     _texture: Texture;
                     image: BufferShader;
                     bufferA: BufferShader;
                     bufferB: BufferShader;
                     bufferC: BufferShader;
                     bufferD: BufferShader;
                     opacityColor?: Color;
                     uniforms: UniformMap;
                     clock: Clock;
                     set common(value: string);
                     get texture(): Texture;
                     constructor(app: App, options: ShadertoyTextureOptions);
                     render(): void;
                     dispose(): void;
                 }

                 export  interface ShadertoyTextureItemOptions {
                     shader?: string;
                     iChannel0?: (Texture | BufferShader);
                     iChannel1?: (Texture | BufferShader);
                     iChannel2?: (Texture | BufferShader);
                     iChannel3?: (Texture | BufferShader);
                 }

                 export  interface ShadertoyTextureOptions {
                     /**  */
                     width: number;
                     /**  */
                     height: number;
                     /**  */
                     color?: ColorRepresentation;
                     /** (0-1) */
                     colorOpacity?: number;
                     /**  */
                     map?: Texture;
                     /** commonshader */
                     common?: string;
                     /** imageshader */
                     shader?: string;
                     /** imageshader */
                     image?: ShadertoyTextureItemOptions;
                     /** bufferAshader */
                     bufferA?: ShadertoyTextureItemOptions;
                     /** bufferBshader */
                     bufferB?: ShadertoyTextureItemOptions;
                     /** bufferCshader */
                     bufferC?: ShadertoyTextureItemOptions;
                     /** bufferDshader */
                     bufferD?: ShadertoyTextureItemOptions;
                     /**  */
                     opacity?: number;
                     /**  */
                     opacityColor?: ColorRepresentation;
                     /**  0*0 1-)* */
                     brightOpacity?: number;
                     /** uniforms */
                     inputUniforms?: {
                         /** uniform */
                         name: string;
                         /**  shader */
                         defs: string;
                         value: Uniform_2;
                     }[];
                     /** hsb () */
                     hsbOffset?: [number, number, number];
                     /** hsb (hsb) */
                     hsbExpr?: string;
                     /**   */
                     mouseInputPos?: [number, number];
                     /**  */
                     defines?: Record<string, any>;
                     /**  */
                     materialParameters?: MaterialParameters;
                     /**  */
                     renderTargetOptions?: RenderTargetOptions;
                     /**  */
                     repeat?: [number, number];
                     /**
                      * uv
                      */
                     uvRotateAngle?: number;
                     /**
                      * uv0.50.5
                      */
                     uvRotateCenter?: [number, number];
                     /**
                      * uv
                      */
                     uvScale?: [number, number];
                     /**
                      * uv0.50.5
                      */
                     uvScaleCenter?: [number, number];
                     /**
                      * uv(r,b,g,a) (0-1)
                      */
                     uvScaleBgColor?: [number, number, number, number];
                 }

                  type ShallowReactive<T> = T & {
                     [ShallowReactiveMarker]?: true;
                 };

                 /**
                  * Shallow version of {@link reactive()}.
                  *
                  * Unlike {@link reactive()}, there is no deep conversion: only root-level
                  * properties are reactive for a shallow reactive object. Property values are
                  * stored and exposed as-is - this also means properties with ref values will
                  * not be automatically unwrapped.
                  *
                  * @example
                  * ```js
                  * const state = shallowReactive({
                  *   foo: 1,
                  *   nested: {
                  *     bar: 2
                  *   }
                  * })
                  *
                  * // mutating state's own properties is reactive
                  * state.foo++
                  *
                  * // ...but does not convert nested objects
                  * isReactive(state.nested) // false
                  *
                  * // NOT reactive
                  * state.nested.bar++
                  * ```
                  *
                  * @param target - The source object.
                  */
                  function shallowReactive<T extends object>(target: T): ShallowReactive<T>;

                  const ShallowReactiveMarker: unique symbol;

                 /**
                  * Shallow version of {@link readonly()}.
                  *
                  * Unlike {@link readonly()}, there is no deep conversion: only root-level
                  * properties are made readonly. Property values are stored and exposed as-is -
                  * this also means properties with ref values will not be automatically
                  * unwrapped.
                  *
                  * @example
                  * ```js
                  * const state = shallowReadonly({
                  *   foo: 1,
                  *   nested: {
                  *     bar: 2
                  *   }
                  * })
                  *
                  * // mutating state's own properties will fail
                  * state.foo++
                  *
                  * // ...but works on nested objects
                  * isReadonly(state.nested) // false
                  *
                  * // works
                  * state.nested.bar++
                  * ```
                  *
                  * @param target - The source object.
                  */
                  function shallowReadonly<T extends object>(target: T): Readonly<T>;

                  type ShallowRef<T = any> = Ref<T> & {
                     [ShallowRefMarker]?: true;
                 };

                 /**
                  * Shallow version of {@link ref()}.
                  *
                  * @example
                  * ```js
                  * const state = shallowRef({ count: 1 })
                  *
                  * // does NOT trigger change
                  * state.value.count = 2
                  *
                  * // does trigger change
                  * state.value = { count: 2 }
                  * ```
                  *
                  * @param value - The "inner value" for the shallow ref.
                  */
                  function shallowRef<T extends object>(value: T): T extends Ref ? T : ShallowRef<T>;

                  function shallowRef<T>(value: T): ShallowRef<T>;

                  function shallowRef<T = any>(): ShallowRef<T | undefined>;

                  const ShallowRefMarker: unique symbol;

                  type ShallowUnwrapRef<T> = {
                     [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K] extends Ref<infer V> | undefined ? unknown extends V ? undefined : V | undefined : T[K];
                 };

                 /**
                  * Base class for shapes
                  */
                  class Shape {
                     /**
                      * Identifier of the Shape.
                      */
                     id: number;
                     /**
                      * The type of this shape. Must be set to an int > 0 by subclasses.
                      */
                     type: ShapeType | 0;
                     /**
                      * The local bounding sphere radius of this shape.
                      */
                     boundingSphereRadius: number;
                     /**
                      * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
                      * @default true
                      */
                     collisionResponse: boolean;
                     /**
                      * @default 1
                      */
                     collisionFilterGroup: number;
                     /**
                      * @default -1
                      */
                     collisionFilterMask: number;
                     /**
                      * Optional material of the shape that regulates contact properties.
                      */
                     material: Material_2 | null;
                     /**
                      * The body to which the shape is added to.
                      */
                     body: Body_2 | null;
                     static idCounter: number;
                     /**
                      * All the Shape types.
                      */
                     static types: {
                         /** SPHERE */
                         readonly SPHERE: 1;
                         /** PLANE */
                         readonly PLANE: 2;
                         /** BOX */
                         readonly BOX: 4;
                         /** COMPOUND */
                         readonly COMPOUND: 8;
                         /** CONVEXPOLYHEDRON */
                         readonly CONVEXPOLYHEDRON: 16;
                         /** HEIGHTFIELD */
                         readonly HEIGHTFIELD: 32;
                         /** PARTICLE */
                         readonly PARTICLE: 64;
                         /** CYLINDER */
                         readonly CYLINDER: 128;
                         /** TRIMESH */
                         readonly TRIMESH: 256;
                     };
                     constructor(options?: {
                         /**
                          * The type of this shape.
                          */
                         type?: ShapeType;
                         /**
                          * Whether to produce contact forces when in contact with other bodies.
                          * @default true
                          */
                         collisionResponse?: boolean;
                         /**
                          * @default 1
                          */
                         collisionFilterGroup?: number;
                         /**
                          * @default -1
                          */
                         collisionFilterMask?: number;
                         /**
                          * Optional material of the shape that regulates contact properties.
                          * @default null
                          * @todo check this, the material is passed to the body, right?
                          */
                         material?: Material_2;
                     });
                     /**
                      * Computes the bounding sphere radius.
                      * The result is stored in the property `.boundingSphereRadius`
                      */
                     updateBoundingSphereRadius(): void;
                     /**
                      * Get the volume of this shape
                      */
                     volume(): number;
                     /**
                      * Calculates the inertia in the local frame for this shape.
                      * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
                      */
                     calculateLocalInertia(mass: number, target: Vec3): void;
                     /**
                      * @todo use abstract for these kind of methods
                      */
                     calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
                 }

                 /**
                  * The available shape types.
                  */
                  const SHAPE_TYPES: {
                     /** SPHERE */
                     readonly SPHERE: 1;
                     /** PLANE */
                     readonly PLANE: 2;
                     /** BOX */
                     readonly BOX: 4;
                     /** COMPOUND */
                     readonly COMPOUND: 8;
                     /** CONVEXPOLYHEDRON */
                     readonly CONVEXPOLYHEDRON: 16;
                     /** HEIGHTFIELD */
                     readonly HEIGHTFIELD: 32;
                     /** PARTICLE */
                     readonly PARTICLE: 64;
                     /** CYLINDER */
                     readonly CYLINDER: 128;
                     /** TRIMESH */
                     readonly TRIMESH: 256;
                 };

                  enum ShapecastIntersection {
                 }

                  function shapeCompareFunc(a: Displayable, b: Displayable): number;

                 export  interface ShapeJSON {
                     type: string;
                     radius?: number;
                     arc?: number;
                     thickness?: number;
                     donutRadius?: number;
                     angle?: number;
                     width?: number;
                     height?: number;
                     column?: number;
                     row?: number;
                     mesh?: string;
                     mode?: number;
                     particleSystem?: string;
                     spread?: number;
                     speed?: any;
                 }

                 export  interface ShapeOptions {
                     type?: ShapeType2;
                     cylinderAxis?: 'x' | 'y' | 'z';
                     sphereRadius?: number;
                 }

                  type ShapeOptions2 = ConstructorParameters<typeof Shape>[0];

                 export  interface ShapeParameters<T extends ShapeType2 = ShapeType2> {
                     type: T;
                     params: ShapeTypeToShapeParameters[T];
                     offset?: CANNON.Vec3;
                     orientation?: CANNON.Quaternion;
                 }

                 export  interface ShapeResult<T extends CANNON.Shape = CANNON.Shape> {
                     shape: T;
                     offset?: CANNON.Vec3;
                     orientation?: CANNON.Quaternion;
                 }

                 /**
                  * ShapeType
                  */
                  type ShapeType = typeof SHAPE_TYPES[keyof typeof SHAPE_TYPES];

                 export  enum ShapeType2 {
                     BOX = "Box",
                     CYLINDER = "Cylinder",
                     SPHERE = "Sphere",
                     HULL = "ConvexPolyhedron",
                     MESH = "Trimesh"
                 }

                  type ShapeTypeToShapeParameters = {
                     Box: BoxParameters;
                     Cylinder: CylinderParameters;
                     Sphere: SphereParameters;
                     ConvexPolyhedron: ConvexPolyhedronParameters;
                     Trimesh: TrimeshParameters;
                 };

                  function showDebugDirtyRect(zr: Render2dType, opts?: Opts): void;

                 /**
                  * Signal is a type of event bus. You can subscribe to events using {@link add} method and dispatch using sendN method where N is the number of arguments you wish to pass
                  * Signal is different from a normal event bus in that 1 signal corresponds to 1 event type. For example, in HTML you have `addEventListener` which lets you subscribe to any kind of event, let's use "mousedown" as a reference. Using a Signal you would instead have a signal corresponding to "mousedown" and dispatch this signal only for this event.
                  * @example `const mouseDown = new Signal<MouseEvent>(); mouseDown.send1(myMouseEvent);`
                  */
                 export  class Signal {
                     handlers: any;
                     /**
                      * Event dispatcher dedicated to single event type
                      * @constructor
                      */
                     constructor();
                     get dispatching(): boolean;
                     /**
                      * @deprecated
                      * @param {boolean} v
                      */
                     set dispatching(v: boolean);
                     /**
                      *
                      * @returns {boolean}
                      */
                     get silent(): boolean;
                     /**
                      *
                      * @param {boolean} v
                      */
                     set silent(v: boolean);
                     setFlag(flag: any): void;
                     clearFlag(flag: any): void;
                     writeFlag(flag: any, value: any): void;
                     getFlag(flag: any): boolean;
                     /**
                      *
                      * @param {function} h
                      * @returns {boolean}
                      */
                     contains(h: any): boolean;
                     mute(): void;
                     unmute(): void;
                     /**
                      * Tells if there are any handlers attached to the signal or not
                      * @returns {boolean}
                      */
                     hasHandlers(): boolean;
                     /**
                      *
                      * @param {function} h
                      * @param {*} [context]
                      */
                     addOne(h: any, context?: any): () => boolean;
                     /**
                      *
                      * @param {function} h
                      * @param {*} [context]
                      */
                     add(h: any, context?: any): () => boolean;
                     /**
                      *
                      * @param {function} h
                      * @param {*} [thisArg] if supplied, will match handlers with a specific context only
                      * @returns {boolean} true if a handler was removed, false otherwise
                      */
                     remove(h: any, thisArg?: any): boolean;
                     /**
                      * Remove all handlers
                      */
                     removeAll(): void;
                     /**
                      * @param {...*} args
                      */
                     dispatch(...args: any[]): void;
                     /**
                      * @deprecated do not use
                      * @returns {boolean}
                      */
                     isDispatching(): boolean;
                     /**
                      *
                      * @param {Signal} other
                      * @returns {Signal} merged signal combining events from this and other
                      */
                     merge(other: any): Signal;
                 }

                 export  class SignalHandler {
                     /**
                      *
                      * @param {function} handle
                      * @param {*} [context]
                      */
                     constructor(handle: any, context: any);
                     setFlag(flag: any): void;
                     clearFlag(flag: any): void;
                     writeFlag(flag: any, value: any): void;
                     getFlag(flag: any): boolean;
                 }

                  class SilhouetteGenerator {
                     [key: string]: any;
                 }

                 /**
                  * A simple event dispatcher with typed event types, see {@link IEventDispatcher}.
                  */
                 export  class SimpleEventDispatcher<T extends string> implements IEventDispatcher<T> {
                     constructor();
                     private readonly _eventListeners;
                     addEventListener(type: T, listener: (event: IEvent<T>) => void): void;
                     hasEventListener(type: T, listener: (event: IEvent<T>) => void): boolean;
                     removeEventListener(type: T, listener: (event: IEvent<T>) => void): void;
                     dispatchEvent(event: IEvent<T>): void;
                 }

                 /** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */
                  class SimplexNoise {
                     private p;
                     private perm;
                     private permMod12;
                     /**
                      * Creates a new `SimplexNoise` instance.
                      * This involves some setup. You can save a few cpu cycles by reusing the same instance.
                      * @param randomOrSeed A random number generator or a seed (string|number).
                      * Defaults to Math.random (random irreproducible initialization).
                      */
                     constructor(randomOrSeed?: RandomFn | string | number);
                     /**
                      * Samples the noise field in 2 dimensions
                      * @param x
                      * @param y
                      * @returns a number in the interval [-1, 1]
                      */
                     noise2D(x: number, y: number): number;
                     /**
                      * Samples the noise field in 3 dimensions
                      * @param x
                      * @param y
                      * @param z
                      * @returns a number in the interval [-1, 1]
                      */
                     noise3D(x: number, y: number, z: number): number;
                     /**
                      * Samples the noise field in 4 dimensions
                      * @param x
                      * @param y
                      * @param z
                      * @returns a number in the interval [-1, 1]
                      */
                     noise4D(x: number, y: number, z: number, w: number): number;
                 }

                 export  function simplifyPoints(points: [number, number][], tolerance?: number, highestQuality?: boolean): [number, number][];

                 /**
                  * Interface for particle simulations.
                  * a simulation is a function that modifies a particle's properties over time.
                  */
                 export  interface Simulation {
                     type: string;
                     initialize(particle: Particle, particleSystem: IParticleSystem): void;
                     update(particle: Particle, delta: number): void;
                     frameUpdate(delta: number): void;
                     toJSON(): any;
                     clone(): Simulation;
                     reset(): void;
                 }

                 export  function SimulationFromJSON(json: any, particleSystem: ParticleSystem): Simulation;

                 export  interface SimulationParticlePlugin {
                     type: string;
                     constructor: Constructable<Simulation>;
                     params: ParameterPair[];
                     loadJSON: (json: any, particleSystem: ParticleSystem) => Simulation;
                 }

                 export  const SimulationTypes: {
                     [key: string]: SimulationParticlePlugin;
                 };

                  type singleTouchAction = typeof ACTION.TOUCH_ROTATE | typeof ACTION.TOUCH_TRUCK | typeof ACTION.TOUCH_OFFSET | typeof ACTION.DOLLY | typeof ACTION.ZOOM | typeof ACTION.NONE;

                 /**
                  * Apply size to particles based on their speed.
                  */
                 export  class SizeBySpeed implements Simulation {
                     size: FunctionValueGenerator;
                     speedRange: IntervalValue;
                     type: string;
                     initialize(particle: Particle): void;
                     constructor(size: FunctionValueGenerator, speedRange: IntervalValue);
                     update(particle: Particle): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 /**
                  *  Apply size to particles based on their life.
                  */
                 export  class SizeOverLife implements Simulation {
                     size: FunctionValueGenerator;
                     type: string;
                     initialize(particle: Particle): void;
                     constructor(size: FunctionValueGenerator);
                     update(particle: Particle): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 /** 1 */
                 export  function sleep(ms?: number): Promise<void>;

                  function slice<T>(arr: ArrayLike_2<T>, ...args: SliceParams): T[];

                  type SliceParams = Parameters<typeof nativeSlice>;

                 

                 

                 /**
                  * 
                  * points 
                  * curvePointNum 5
                  * curvePointPosRatio  (0-1)  0.9
                  * oldIndexTarget 
                  */
                 export  function smoothPoints(points: Array<[number, number, number]>, curvePointNum?: number, curvePointPosRatio?: number, oldIndexTarget?: number[]): any[];

                 /**
                  * Constraint equation solver base class.
                  */
                  class Solver {
                     /**
                      * All equations to be solved
                      */
                     equations: Equation[];
                     /**
                      * @todo remove useless constructor
                      */
                     constructor();
                     /**
                      * Should be implemented in subclasses!
                      * @todo use abstract
                      * @return number of iterations performed
                      */
                     solve(dt: number, world: World): number;
                     /**
                      * Add an equation
                      */
                     addEquation(eq: Equation): void;
                     /**
                      * Remove an equation
                      */
                     removeEquation(eq: Equation): void;
                     /**
                      * Add all equations
                      */
                     removeAllEquations(): void;
                 }

                 /**
                  * Apply speed to particles based on their life.
                  */
                 export  class SpeedOverLife implements Simulation {
                     speed: FunctionValueGenerator;
                     type: string;
                     initialize(particle: Particle): void;
                     constructor(speed: FunctionValueGenerator);
                     update(particle: Particle): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     frameUpdate(delta: number): void;
                     clone(): Simulation;
                     reset(): void;
                 }

                 /**
                  * Spherical shape
                  * @example
                  *     const radius = 1
                  *     const sphereShape = new CANNON.Sphere(radius)
                  *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
                  *     world.addBody(sphereBody)
                  */
                  class Sphere_2 extends Shape {
                     /**
                      * The radius of the sphere.
                      */
                     radius: number;
                     /**
                      *
                      * @param radius The radius of the sphere, a non-negative number.
                      */
                     constructor(radius: number);
                     /** calculateLocalInertia */
                     calculateLocalInertia(mass: number, target?: Vec3): Vec3;
                     /** volume */
                     volume(): number;
                     updateBoundingSphereRadius(): void;
                     calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
                 }

                 export  class SphereEmitter implements EmitterShape {
                     type: string;
                     radius: number;
                     arc: number;
                     thickness: number;
                     mode: EmitterMode;
                     spread: number;
                     speed: ValueGenerator | FunctionValueGenerator;
                     constructor(parameters?: SphereEmitterParameters);
                     private currentValue;
                     update(system: ParticleSystem, delta: number): void;
                     initialize(p: Particle, emissionState: EmissionState): void;
                     toJSON(): ShapeJSON;
                     static fromJSON(json: any): SphereEmitter;
                     clone(): EmitterShape;
                 }

                 /**
                  * Interface representing the parameters for a sphere emitter.
                  */
                 export  interface SphereEmitterParameters {
                     /**
                      * The radius of the sphere.
                      */
                     radius?: number;
                     /**
                      * The arc of the sphere.
                      */
                     arc?: number;
                     /**
                      * The thickness of the sphere. 1 is a full sphere, 0 is a thin shell.
                      */
                     thickness?: number;
                     /**
                      * The mode of the emitter.
                      * {@link EmitterMode}
                      */
                     mode?: EmitterMode;
                     /**
                      * The length of the segment at which the emitter point converges at the start and end, when mode is EmitterMode.Loop or EmitterMode.PingPong.
                      * {@link EmitterMode}
                      */
                     spread?: number;
                     /**
                      * The speed of the emitter start point when mode is EmitterMode.Loop or EmitterMode.PingPong.
                      * {@link EmitterMode}
                      */
                     speed?: ValueGenerator | FunctionValueGenerator;
                 }

                 export  type SphereParameters = {
                     radius: number;
                 };

                 /**
                  * Smoothed-particle hydrodynamics system
                  * @todo Make parameters customizable in the constructor
                  */
                  class SPHSystem {
                     /**
                      * The particles array.
                      */
                     particles: Body_2[];
                     /**
                      * Density of the system (kg/m3).
                      * @default 1
                      */
                     density: number;
                     /**
                      * Distance below which two particles are considered to be neighbors.
                      * It should be adjusted so there are about 15-20 neighbor particles within this radius.
                      * @default 1
                      */
                     smoothingRadius: number;
                     /**
                      * @default 1
                      */
                     speedOfSound: number;
                     /**
                      * Viscosity of the system.
                      * @default 0.01
                      */
                     viscosity: number;
                     /**
                      * @default 0.000001
                      */
                     eps: number;
                     pressures: number[];
                     densities: number[];
                     neighbors: Body_2[][];
                     constructor();
                     /**
                      * Add a particle to the system.
                      */
                     add(particle: Body_2): void;
                     /**
                      * Remove a particle from the system.
                      */
                     remove(particle: Body_2): void;
                     /**
                      * Get neighbors within smoothing volume, save in the array neighbors
                      */
                     getNeighbors(particle: Body_2, neighbors: Body_2[]): void;
                     update(): void;
                     w(r: number): number;
                     gradw(rVec: Vec3, resultVec: Vec3): void;
                     nablaw(r: number): number;
                 }

                 export  class SphubeGeometry extends ParametricGeometry {
                     constructor(slices?: number, stacks?: number);
                 }

                  function split(path: Path, count: number): any[];

                 /**
                  * Splits the equations into islands and solves them independently. Can improve performance.
                  */
                  class SplitSolver extends Solver {
                     /**
                      * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
                      */
                     iterations: number;
                     /**
                      * When tolerance is reached, the system is assumed to be converged.
                      */
                     tolerance: number;
                     /** subsolver */
                     subsolver: GSSolver;
                     nodes: SplitSolverNode[];
                     nodePool: SplitSolverNode[];
                     constructor(subsolver: GSSolver);
                     /**
                      * createNode
                      */
                     createNode(): SplitSolverNode;
                     /**
                      * Solve the subsystems
                      * @return number of iterations performed
                      */
                     solve(dt: number, world: World): number;
                 }

                  type SplitSolverNode = {
                     body: Body_2 | null;
                     children: SplitSolverNode[];
                     eqs: Equation[];
                     visited: boolean;
                 };

                  enum SplitStrategy {
                 }

                 /**
                  * A spring, connecting two bodies.
                  * @example
                  *     const spring = new Spring(boxBody, sphereBody, {
                  *       restLength: 0,
                  *       stiffness: 50,
                  *       damping: 1,
                  *     })
                  *
                  *     // Compute the force after each step
                  *     world.addEventListener('postStep', (event) => {
                  *       spring.applyForce()
                  *     })
                  */
                  class Spring {
                     /**
                      * Rest length of the spring. A number > 0.
                      * @default 1
                      */
                     restLength: number;
                     /**
                      * Stiffness of the spring. A number >= 0.
                      * @default 100
                      */
                     stiffness: number;
                     /**
                      * Damping of the spring. A number >= 0.
                      * @default 1
                      */
                     damping: number;
                     /**
                      * First connected body.
                      */
                     bodyA: Body_2;
                     /**
                      * Second connected body.
                      */
                     bodyB: Body_2;
                     /**
                      * Anchor for bodyA in local bodyA coordinates.
                      * Where to hook the spring to body A, in local body coordinates.
                      * @default new Vec3()
                      */
                     localAnchorA: Vec3;
                     /**
                      * Anchor for bodyB in local bodyB coordinates.
                      * Where to hook the spring to body B, in local body coordinates.
                      * @default new Vec3()
                      */
                     localAnchorB: Vec3;
                     constructor(bodyA: Body_2, bodyB: Body_2, options?: {
                         /**
                          * Rest length of the spring. A number > 0.
                          * @default 1
                          */
                         restLength?: number;
                         /**
                          * Stiffness of the spring. A number >= 0.
                          * @default 100
                          */
                         stiffness?: number;
                         /**
                          * Damping of the spring. A number >= 0.
                          * @default 1
                          */
                         damping?: number;
                         /**
                          * Anchor for bodyA in local bodyA coordinates.
                          * Where to hook the spring to body A, in local body coordinates.
                          * @default new Vec3()
                          */
                         localAnchorA?: Vec3;
                         /**
                          * Anchor for bodyB in local bodyB coordinates.
                          * Where to hook the spring to body B, in local body coordinates.
                          * @default new Vec3()
                          */
                         localAnchorB?: Vec3;
                         /**
                          * Where to hook the spring to body A, in world coordinates.
                          */
                         worldAnchorA?: Vec3;
                         /**
                          * Where to hook the spring to body B, in world coordinates.
                          */
                         worldAnchorB?: Vec3;
                     });
                     /**
                      * Set the anchor point on body A, using world coordinates.
                      */
                     setWorldAnchorA(worldAnchorA: Vec3): void;
                     /**
                      * Set the anchor point on body B, using world coordinates.
                      */
                     setWorldAnchorB(worldAnchorB: Vec3): void;
                     /**
                      * Get the anchor point on body A, in world coordinates.
                      * @param result The vector to store the result in.
                      */
                     getWorldAnchorA(result: Vec3): void;
                     /**
                      * Get the anchor point on body B, in world coordinates.
                      * @param result The vector to store the result in.
                      */
                     getWorldAnchorB(result: Vec3): void;
                     /**
                      * Apply the spring force to the connected bodies.
                      */
                     applyForce(): void;
                 }

                  type SpringOptions = ConstructorParameters<typeof Spring>[2];

                 /**
                  * 
                  */
                 export  class SpriteAnimatorEntity extends Entity {
                     constructor(options: SpriteAnimatorEntityOptions);
                     /**
                      * 
                      */
                     readonly spriteAnimator: SpriteAnimatorType;
                     /**
                      * 
                      */
                     pauseAnimation: () => void;
                     /**
                      * 
                      */
                     playAnimation: () => void;
                     /**
                      * 
                      */
                     setFrameName: (name: string) => void;
                 }

                 export  type SpriteAnimatorEntityOptions = EntityOptions & SpriteAnimatorProps;

                 /**
                  * 
                  */
                 export  class SpriteAnimatorModule extends EntityModuleBase implements IEntityModuleBase {
                     #private;
                     static moduleName: string;
                     isLoaded?: boolean;
                     constructor(entity: Entity, options?: SpriteAnimatorProps);
                     setupUiConfig(): UiObjectConfig;
                     get spriteAnimator(): SpriteAnimatorType;
                     onAppUpdate(time: Time): void;
                     pauseAnimation(): void;
                     playAnimation(): void;
                     setFrameName(name: string): void;
                 }

                 export  type SpriteAnimatorProps = {
                     startFrame?: number;
                     endFrame?: number;
                     fps?: number;
                     frameName?: string;
                     textureDataURL?: string;
                     textureImageURL: string;
                     loop?: boolean;
                     numberOfFrames?: number;
                     autoPlay?: boolean;
                     animationNames?: Array<string>;
                     onStart?: Function;
                     onEnd?: Function;
                     onLoopEnd?: Function;
                     onFrame?: Function;
                     play?: boolean;
                     pause?: boolean;
                     flipX?: boolean;
                     position?: Array<number>;
                     alphaTest?: number;
                     asSprite?: boolean;
                 };

                 export  type SpriteAnimatorType = {
                     group: Group_2;
                     init: Function;
                     update: Function;
                     pauseAnimation: Function;
                     playAnimation: Function;
                     setFrameName: Function;
                 };

                 /**
                  * A VFX batch that render sprites in a batch.
                  */
                 export  class SpriteBatch extends VFXBatch {
                     geometry: InstancedBufferGeometry;
                     private offsetBuffer;
                     private rotationBuffer;
                     private sizeBuffer;
                     private colorBuffer;
                     private uvTileBuffer;
                     private velocityBuffer?;
                     constructor(settings: VFXBatchSettings);
                     buildExpandableBuffers(): void;
                     setupBuffers(): void;
                     expandBuffers(target: number): void;
                     rebuildMaterial(): void;
                     vector_: Vector3;
                     vector2_: Vector3;
                     vector3_: Vector3;
                     quaternion_: Quaternion;
                     quaternion2_: Quaternion;
                     quaternion3_: Quaternion;
                     rotationMat_: Matrix3;
                     rotationMat2_: Matrix3;
                     update(): void;
                     dispose(): void;
                 }

                 export  interface SpriteImageItem extends SpriteImageItemData {
                     material: SpriteMaterial;
                     highlightMaterial?: SpriteMaterial;
                     object: SpriteMarker;
                 }

                 /**
                  * 
                  */
                 export  interface SpriteImageItemData {
                     /**  */
                     position: Vector3 | [number, number, number];
                     /**  */
                     icon: string | ImageLike;
                     /**  */
                     highlightIcon?: string | ImageLike;
                     /**  */
                     highlightOpacity?: number;
                     /** x  */
                     anchorX?: number | 'left' | 'center' | 'right';
                     /** y */
                     anchorY?: number | 'top' | 'center' | 'bottom';
                     /** x */
                     offsetX?: number;
                     /** y */
                     offsetY?: number;
                     /** (0-360) */
                     rotation?: number;
                     /** (sizeAttenuationfalse) */
                     width?: number;
                     /** (sizeAttenuationfalse) */
                     height?: number;
                     /** zindex */
                     collideZIndex?: number;
                     /** id */
                     collideId?: string;
                 }

                 /**
                  * 
                  */
                 export  class SpriteImages extends Group_2 {
                     #private;
                     app: App;
                     data: SpriteImageItem[];
                     constructor(options: SpriteImagesOptions, app: App);
                     getOptions(): SpriteImagesOptions;
                     update(): void;
                     getData(): SpriteImageItem[];
                     setItemHighlight(index: number, isHighlight?: boolean): void;
                     setData(data: SpriteImageItemData[]): Promise<void>;
                     dispose(): void;
                 }

                 /**
                  * 
                  */
                 export  class SpriteImagesEntity extends Entity {
                     constructor(options: SpriteImagesEntityOptions);
                     /**
                      * 
                      */
                     readonly SpriteImages: SpriteImages;
                     /**
                      * 
                      */
                     getOptions(): SpriteImagesOptions;
                     /**
                      * 
                      */
                     update(): void;
                     /**
                      * 
                      */
                     getData(): SpriteImageItem[];
                     /**
                      * 
                      */
                     setItemHighlight(index: number, isHighlight?: boolean): void;
                     /**
                      * 
                      */
                     setData(data: SpriteImageItemData[]): Promise<void>;
                     /**
                      * 
                      */
                     isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
                 }

                 export  type SpriteImagesEntityOptions = EntityOptions & SpriteImagesOptions;

                 /**
                  * 
                  */
                 export  class SpriteImagesModule extends EntityModuleBase implements IEntityModuleBase {
                     #private;
                     static moduleName: string;
                     isLoaded?: boolean;
                     constructor(entity: Entity, options?: SpriteImagesOptions);
                     get SpriteImages(): SpriteImages;
                 }

                 /**
                  * 
                  */
                 export  interface SpriteImagesOptions {
                     /**  */
                     data: SpriteImageItemData[];
                     /** () falsetrue */
                     sizeAttenuation?: boolean;
                     /**  */
                     materialParameters?: SpriteMaterialParameters;
                     /** 20 */
                     refreshRenderThrottleTimeout?: number;
                     /**  */
                     fadeDistance?: number;
                     /**  */
                     allowOverlap?: boolean;
                     /**   */
                     collideGroupName?: string;
                     /**  (,y, x,y) */
                     expandRect?: number | [number, number, number, number];
                 }

                 /**
                  * 
                  */
                 export  class SpriteMarker extends Sprite {
                     #private;
                     options: SpriteMarkerOptions;
                     width: number;
                     height: number;
                     app: App;
                     constructor(options: SpriteMarkerOptions, app?: App);
                     setMaterial(material: SpriteMaterial): void;
                     updateRenderTexture(cb: (context: {
                         group: render2d.Group;
                         render: render2d.Render2dType;
                         canvas: HTMLCanvasElement;
                     }) => boolean): void;
                     refreshRenderTexture(): void;
                     dispatchRenderTextureEvent(eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number): void;
                     setAllowOverlap(allowOverlap: boolean): void;
                     updateScale(): void;
                     updateAnchor(): void;
                     getBoundingRect(): {
                         x1: number;
                         y1: number;
                         x2: any;
                         y2: any;
                         cx: number;
                         cy: number;
                         rotation: number;
                         position: Vector3;
                         zIndex: number;
                         id: string;
                         groupName: string;
                         setVisible: (visible: any) => any;
                     };
                     dispose(): void;
                 }

                 /**
                  * 
                  */
                 export  class SpriteMarkerEntity extends Entity {
                     constructor(options: SpriteMarkerEntityOptions);
                     /**
                      * 
                      */
                     readonly SpriteMarker: SpriteMarker;
                     /**
                      * 
                      */
                     setMaterial(material: SpriteMaterial): void;
                     /**
                      *
                      */
                     updateRenderTexture(cb: (context: {
                         group: render2d.Group;
                         render: render2d.Render2dType;
                         canvas: HTMLCanvasElement;
                     }) => boolean): void;
                     /**
                      *
                      */
                     refreshRenderTexture(): void;
                     /**
                      * 
                      */
                     dispatchRenderTextureEvent(eventName: "mousemove" | "mouseout" | "click" | "mousedown" | "mouseup" | "mousewheel" | "dblclick" | "contextmenu", x?: number | Vector2, y?: number): void;
                     /**
                      * 
                      */
                     setAllowOverlap(allowOverlap: boolean): void;
                     /**
                      * 
                      */
                     updateScale(): void;
                     /**
                      * 
                      */
                     updateAnchor(): void;
                     /**
                      * 
                      */
                     getBoundingRect(): {
                         x1: number;
                         y1: number;
                         x2: any;
                         y2: any;
                         cx: number;
                         cy: number;
                         rotation: number;
                         position: Vector3;
                         zIndex: number;
                         id: string;
                         groupName: string;
                         setVisible: (visible: any) => any;
                     };
                 }

                 export  type SpriteMarkerEntityOptions = EntityOptions & SpriteMarkerOptions;

                 /**
                  * 
                  */
                 export  class SpriteMarkerModule extends EntityModuleBase implements IEntityModuleBase {
                     #private;
                     static moduleName: string;
                     isLoaded?: boolean;
                     constructor(entity: Entity, options?: SpriteMarkerOptions);
                     get SpriteMarker(): SpriteMarker;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  interface SpriteMarkerOptions {
                     /**  */
                     position: Vector3 | [number, number, number];
                     /** x  */
                     anchorX?: number | 'left' | 'center' | 'right';
                     /** y */
                     anchorY?: number | 'top' | 'center' | 'bottom';
                     /** x */
                     offsetX?: number;
                     /** y */
                     offsetY?: number;
                     /** (0-360) */
                     rotation?: number;
                     /**  */
                     material?: SpriteMaterial;
                     /**  */
                     materialParameters?: SpriteMaterialParameters;
                     /** () falsetrue */
                     sizeAttenuation?: boolean;
                     /** (sizeAttenuationfalse) */
                     width?: number;
                     /** (sizeAttenuationfalse) */
                     height?: number;
                     /**  */
                     renderTexture?: Render2dTextureOptions;
                     /** renderTexture) */
                     texture?: Texture;
                     /** 20 */
                     refreshRenderThrottleTimeout?: number;
                     /**  */
                     fadeDistance?: number;
                     /**  */
                     allowOverlap?: boolean;
                     /** zindex */
                     collideZIndex?: number;
                     /** id */
                     collideId?: string;
                     /**   */
                     collideGroupName?: string;
                     /**  (,y, x,y) */
                     expandRect?: number | [number, number, number, number];
                 }

                 /**
                  * Particle implementation for sprite-based particle.
                  */
                 export  class SpriteParticle implements Particle {
                     /**
                      * Parent matrix for transformation.
                      * @type {Matrix4}
                      */
                     parentMatrix?: Matrix4;
                     /**
                      * Initial speed of the particle.
                      * @type {number}
                      */
                     startSpeed: number;
                     /**
                      * Initial color of the particle.
                      * @type {Vector4}
                      */
                     startColor: Vector4;
                     /**
                      * Initial size of the particle.
                      * @type {number}
                      */
                     startSize: number;
                     /**
                      * Position of the particle.
                      * @type {Vector3}
                      */
                     position: Vector3;
                     /**
                      * Velocity of the particle.
                      * @type {Vector3}
                      */
                     velocity: Vector3;
                     /**
                      * Age of the particle.
                      * @type {number}
                      */
                     age: number;
                     /**
                      * Life duration of the particle.
                      * @type {number}
                      */
                     life: number;
                     /**
                      * Size of the particle.
                      * @type {number}
                      */
                     size: number;
                     /**
                      * Speed modifier of the particle.
                      * @type {number}
                      */
                     speedModifier: number;
                     /**
                      * Angular velocity of the particle.
                      * @type {number | Quaternion}
                      */
                     angularVelocity?: number | Quaternion;
                     /**
                      * Rotation of the particle.
                      * @type {number | Quaternion}
                      */
                     rotation: number | Quaternion;
                     /**
                      * Color of the particle.
                      * @type {Vector4}
                      */
                     color: Vector4;
                     /**
                      * UV tile index.
                      * @type {number}
                      */
                     uvTile: number;
                     /**
                      * Indicates if the particle has died.
                      * @type {boolean}
                      */
                     get died(): boolean;
                 }

                 export  interface SpriteTextItem extends SpriteTextItemData {
                     material: SpriteMaterial;
                     highlightMaterial?: SpriteMaterial;
                     object: SpriteMarker;
                 }

                 /**
                  * 
                  */
                 export  interface SpriteTextItemData {
                     /** id */
                     id?: string;
                     /**  */
                     position: Vector3 | [number, number, number];
                     /**  */
                     text: string;
                     /**  */
                     style?: TextStyleProps;
                     /**  */
                     highlightStyle?: TextStyleProps;
                     /** x  */
                     anchorX?: number | 'left' | 'center' | 'right';
                     /** y */
                     anchorY?: number | 'top' | 'center' | 'bottom';
                     /** x */
                     offsetX?: number;
                     /** y */
                     offsetY?: number;
                     /** (0-360) */
                     rotation?: number;
                     /** (sizeAttenuationfalse) */
                     width?: number;
                     /** (sizeAttenuationfalse) */
                     height?: number;
                     /** zindex */
                     collideZIndex?: number;
                     /** id */
                     collideId?: string;
                     /**  true */
                     autoCanvasSize?: boolean;
                     /** canvas true */
                     sharedCanvas?: boolean;
                 }

                 /**
                  * 
                  */
                 export  class SpriteTexts extends Group_2 {
                     #private;
                     app: App;
                     data: SpriteTextItem[];
                     constructor(options: SpriteTextsOptions, app: App);
                     getOptions(): SpriteTextsOptions;
                     update(): void;
                     getData(): SpriteTextItem[];
                     setItemHighlight(index: number, isHighlight?: boolean): void;
                     setData(data: SpriteTextItemData[]): Promise<void>;
                     dispose(): void;
                 }

                 /**
                  * 
                  */
                 export  class SpriteTextsEntity extends Entity {
                     constructor(options: SpriteTextsEntityOptions);
                     /**
                      * 
                      */
                     readonly SpriteTexts: SpriteTexts;
                     /**
                      * 
                      */
                     getOptions(): SpriteTextsOptions;
                     /**
                      * 
                      */
                     update(): void;
                     /**
                      * 
                      */
                     getData(): SpriteTextItem[];
                     /**
                      * 
                      */
                     setItemHighlight(index: number, isHighlight?: boolean): void;
                     /**
                      * 
                      */
                     setData(data: SpriteTextItemData[]): Promise<void>;
                     /**
                      * 
                      */
                     isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
                 }

                 export  type SpriteTextsEntityOptions = EntityOptions & SpriteTextsOptions;

                 /**
                  * 
                  */
                 export  class SpriteTextsModule extends EntityModuleBase implements IEntityModuleBase {
                     #private;
                     static moduleName: string;
                     isLoaded?: boolean;
                     constructor(entity: Entity, options?: SpriteTextsOptions);
                     get SpriteTexts(): SpriteTexts;
                 }

                 /**
                  * 
                  */
                 export  interface SpriteTextsOptions {
                     /**
                      * 
                      */
                     data: SpriteTextItemData[];
                     /**
                      * () falsetrue
                      */
                     sizeAttenuation?: boolean;
                     /**  */
                     materialParameters?: SpriteMaterialParameters;
                     /** 20 */
                     refreshRenderThrottleTimeout?: number;
                     /**  */
                     fadeDistance?: number;
                     /**  */
                     allowOverlap?: boolean;
                     /**   */
                     collideGroupName?: string;
                     /**  (,y, x,y) */
                     expandRect?: number | [number, number, number, number];
                 }

                 /**
                  * Converts a single color channel from the sRGB color space to linear.
                  * @param c - The color channel to be converted.
                  * @category Color
                  */
                 export  function SRGBToLinear(c: number): number;

                 

                  interface Stage {
                     update?: () => void;
                 }

                  class Star extends Path<StarProps> {
                     shape: StarShape;
                     constructor(opts?: StarProps);
                     getDefaultShape(): StarShape;
                     buildPath(ctx: CanvasRenderingContext2D, shape: StarShape): void;
                 }

                  interface StarProps extends PathProps {
                     shape?: Partial<StarShape>;
                 }

                  class StarShape {
                     cx: number;
                     cy: number;
                     n: number;
                     r0: number;
                     r: number;
                 }

                 /** @public */
                 export  abstract class StateNode {
                     editor: App;
                     private _current;
                     private _isActive;
                     app: App;
                     parent: StateNode;
                     constructor(editor: App, parent?: StateNode);
                     static id: string;
                     static initial?: string;
                     static children?: () => TLStateNodeConstructor[];
                     id: string;
                     type: TLStateNodeType;
                     initial?: string;
                     children?: Record<string, StateNode>;
                     /**
                      * This node's path of active state nodes
                      *
                      * @public
                      */
                     getPath(): string;
                     /**
                      * This node's current active child node, if any.
                      *
                      * @public
                      */
                     getCurrent(): any;
                     /**
                      * Whether this node is active.
                      *
                      * @public
                      */
                     getIsActive(): boolean;
                     setIsActive(b: boolean): void;
                     /**
                      * Transition to a new active child state node.
                      *
                      * @example
                      * ```ts
                      * parentState.transition('childStateA')
                      * parentState.transition('childStateB', { myData: 4 })
                      *```
                      *
                      * @param id - The id of the child state node to transition to.
                      * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
                      *
                      * @public
                      */
                     transition: (id: string, info?: {
                         [key: string]: any;
                         name?: string;
                         event?: InteractiveEvent;
                         object?: InteractiveObject;
                     }) => this;
                     handleEvent: (info: {
                         name: string;
                         event: InteractiveEvent;
                         object: InteractiveObject;
                     }) => void;
                     enter: (info: TLEventType, from: string) => void;
                     exit: (info: TLEventType, from: string) => void;
                     /**
                      * This is a hack / escape hatch that will tell the editor to
                      * report a different state as active (in `getCurrentToolId()`) when
                      * this state is active. This is usually used when a tool transitions
                      * to a child of a different state for a certain interaction and then
                      * returns to the original tool when that interaction completes; and
                      * where we would want to show the original tool as active in the UI.
                      *
                      * @public
                      */
                     _currentToolIdMask: Ref<string>;
                     getCurrentToolIdMask(): string;
                     setCurrentToolIdMask(id: string | undefined): void;
                     onMouseUp?: (info: TLEventHandler) => void;
                     onMouseDown?: (info: TLEventHandler) => void;
                     onMouseClick?: (info: TLEventHandler) => void;
                     onMouseDblClick?: (info: TLEventHandler) => void;
                     onMouseMove?: (info: TLEventHandler) => void;
                     onPointerDown?: (info: TLEventHandler) => void;
                     onPointerMove?: (info: TLEventHandler) => void;
                     onPointerUp?: (info: TLEventHandler) => void;
                     onPointerDownUp?: (info: TLEventHandler) => void;
                     onPointerCancel?: (info: TLEventHandler) => void;
                     onContextMenu?: (info: TLEventHandler) => void;
                     onMouseOut?: (info: TLEventHandler) => void;
                     onMouseOver?: (info: TLEventHandler) => void;
                     onMouseLeave?: (info: TLEventHandler) => void;
                     onMouseEnter?: (info: TLEventHandler) => void;
                     onMouseWheel?: (info: TLEventHandler) => void;
                     onKeyDown?: (info: TLEventHandler) => void;
                     onKeyUp?: (info: TLEventHandler) => void;
                     onEnter?: TLEnterEventHandler;
                     onExit?: TLExitEventHandler;
                 }

                  class StaticGeometryGenerator {
                     useGroups: boolean;
                     attributes: Array<string>;
                     applyWorldTransforms: boolean;
                     constructor(objects: Array<Object3D> | Object3D);
                     getMaterials(): Array<Material>;
                     generate(target?: BufferGeometry): BufferGeometry;
                 }

                 export  class StatModule extends AppModuleBase implements IAppModuleBase {
                     static moduleName: string;
                     private _stats;
                     options: StatModuleOptions;
                     constructor(app?: App, options?: StatModuleOptions);
                     get showStat(): any;
                     set showStat(show: any);
                     onAwake(): void;
                     onAppBeforeUpdate(): void;
                     onAppAfterRender(): void;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  interface StatModuleOptions {
                     show?: boolean;
                     id?: string;
                     left?: string;
                     right?: string;
                     top?: string;
                     bottom?: string;
                     panelIndex?: number;
                 }

                 /**
                  * Stops the effect associated with the given runner.
                  *
                  * @param runner - Association with the effect to stop tracking.
                  */
                  function stop_2(runner: ReactiveEffectRunner): void;

                  class Storage_2 {
                     private _roots;
                     private _displayList;
                     private _displayListLen;
                     traverse<T>(cb: (this: T, el: Element_2) => void, context?: T): void;
                     /**
                      * get a list of elements to be rendered
                      *
                      * @param {boolean} update whether to update elements before return
                      * @param {DisplayParams} params options
                      * @return {Displayable[]} a list of elements
                      */
                     getDisplayList(update?: boolean, includeIgnore?: boolean): Displayable[];
                     /**
                      * 
                      * GroupShapeShape
                      * zlevel > z > 
                      */
                     updateDisplayList(includeIgnore?: boolean): void;
                     private _updateAndAddDisplayable;
                     /**
                      * (Displayable)(Group)
                      */
                     addRoot(el: Element_2): void;
                     /**
                      * (Displayable)(Group)
                      * @param el
                      */
                     delRoot(el: Element_2 | Element_2[]): void;
                     delAllRoots(): void;
                     getRoots(): Element_2<ElementProps>[];
                     /**
                      * Storage
                      */
                     dispose(): void;
                     displayableSortFunc: typeof shapeCompareFunc;
                 }

                 /**
                  * 
                  */
                 export  class Store {
                     /** appapp */
                     static app: App;
                     /**  */
                     static service: Service;
                     /**  */
                     static useData: Record<string, any>;
                 }

                 export  interface StoredBatchSettings {
                     instancingGeometry: BufferGeometry;
                     material: Material;
                     uTileCount: number;
                     vTileCount: number;
                     blendTiles: boolean;
                     softParticles: boolean;
                     softNearFade: number;
                     softFarFade: number;
                     renderMode: RenderMode;
                     renderOrder: number;
                     layers: Layers;
                 }

                 export  interface StretchedBillBoardSettings {
                     /**
                      * how stretched the particle is in the direction of the camera based on the speed of the particle.
                      * @type {number}
                      */
                     speedFactor: number;
                     /**
                      * how stretched the particle is in the direction of the camera based on the size of the particle.
                      * @type {number}
                      */
                     lengthFactor: number;
                 }

                 /**
                  * @param arrColor like [12,33,44,0.4]
                  * @param type 'rgba', 'hsva', ...
                  * @return Result color. (If input illegal, return undefined).
                  */
                  function stringify(arrColor: number[], type: string): string;

                 /**
                  * Extract keys from object that are strings
                  */
                 export  type StringKeyOf<T extends any> = Extract<keyof T, string>;

                 /**
                  * Md5
                  * @param str
                  * @return {string}
                  */
                 export  function strMd5(str: string): string;

                 /**
                  * 
                  */
                  function sub<T extends VectorArray>(out: T, v1: VectorArray, v2: VectorArray): T;

                 export  enum SubParticleEmitMode {
                     Death = 0,
                     Birth = 1,
                     Frame = 2
                 }

                  const SUBTRACTION: CSGOperation;

                 /**
                  * Behavior that always succeeds
                  */
                 export  class SucceedingBehavior extends Behavior {
                     delayTicks: number;
                     constructor(delayTicks?: number);
                     tick(timeDelta: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
                     static INSTANCE: SucceedingBehavior;
                 }

                  type SVGNodeTagLower = 'g' | 'rect' | 'circle' | 'line' | 'ellipse' | 'polygon' | 'polyline' | 'image' | 'text' | 'tspan' | 'path' | 'defs' | 'switch';

                  interface SVGParserOption {
                     width?: number;
                     height?: number;
                     ignoreViewBox?: boolean;
                     ignoreRootClip?: boolean;
                 }

                  interface SVGParserResult {
                     root: Group;
                     width: number;
                     height: number;
                     viewBoxRect: RectLike;
                     viewBoxTransform: {
                         x: number;
                         y: number;
                         scale: number;
                     };
                     named: SVGParserResultNamedItem[];
                 }

                  interface SVGParserResultNamedItem {
                     name: string;
                     namedFrom: SVGParserResultNamedItem;
                     svgNodeTagLower: SVGNodeTagLower;
                     el: Element_2;
                 }

                  class SVGPath extends Path {
                     applyTransform(m: MatrixArray): void;
                 }

                  type SVGPathOption = Omit<PathProps, 'shape' | 'buildPath'>;

                  interface SVGPatternObject extends PatternObjectBase {
                     /**
                      * svg vnode can only be used in svg renderer currently.
                      * svgWidth, svgHeight defines width and height used for pattern.
                      */
                     svgElement?: SVGVNode;
                     svgWidth?: number;
                     svgHeight?: number;
                 }

                 /**
                  * Renders an SVG to a canvas.
                  * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
                  * @param options - options
                  *
                  * @category SVGs
                  */
                 export  const svgToCanvas: (svgDataUrl: string, options: ImageCanvasOptions) => Promise<HTMLCanvasElement>;

                 /**
                  * Renders an SVG to a png data url.
                  * @param svgDataUrl - data url of the svg. Can be created with {@link svgUrl}
                  * @param options - options
                  *
                  * @category SVGs
                  */
                 export  const svgToPng: (svgDataUrl: string, options: ImageCanvasOptions) => Promise<string>;

                 /**
                  * Converts an SVG string to data url. This is useful for creating images from SVGs, or using SVGs in CSS.
                  * To use put in template string: `url(${svgUrl\`<svg>...</svg>\`})`
                  * @param strings - template strings
                  * @param rest - template values
                  *
                  * @example
                  * ```ts
                  * const url = svgUrl\`
                  *  <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> ... </svg>
                  * \`
                  * console.log(url) // data:image/svg+xml;charset=UTF-8,...
                  * ```
                  *
                  * @category Template Literals
                  */
                 export  const svgUrl: (strings: any, ...rest: any[]) => string;

                  interface SVGVNode {
                     tag: string;
                     attrs: SVGVNodeAttrs;
                     children?: SVGVNode[];
                     text?: string;
                     elm?: Node;
                     key: string;
                 }

                  type SVGVNodeAttrs = Record<string, string | number | undefined | boolean>;

                 /**
                  * 
                  */
                 export  class SymbolEntity extends Entity {
                     constructor(options: SymbolEntityOptions);
                     /**
                      * 
                      */
                     readonly symbolObject: Points;
                     /**
                      * 
                      */
                     updateStyle: (style: SymbolMaterialProps) => void;
                     /**
                      * 
                      */
                     getData: () => SymbolItemData[];
                     /**
                      * 
                      */
                     setData: (data: SymbolItemData[]) => void;
                     /**
                      * pointIndex
                      * @param pointIndex 
                      * @param isRefData ,false,
                      */
                     getItemDataByPointIndex: (pointIndex: number, isRefData?: boolean) => SymbolItemData;
                     /**
                      * 
                      */
                     isFireEventsByIntersect(closestObject: InteractiveObject, newClosestObject: InteractiveObject): boolean;
                 }

                 export  type SymbolEntityOptions = EntityOptions & SymbolModuleOption;

                 export  interface SymbolItemData {
                     /** id */
                     id?: string;
                     /**  */
                     position: [number, number, number];
                     /**  */
                     color?: ColorRepresentation;
                     /**  */
                     borderColor?: ColorRepresentation;
                     /**  */
                     size?: number;
                     /** ,  */
                     highlightColor?: ColorRepresentation;
                     /** ,  */
                     highlightBorderColor?: ColorRepresentation;
                     /** ,  */
                     highlightSize?: number;
                     /**  */
                     disableEdit?: boolean;
                     /**  */
                     hidden?: boolean;
                 }

                 export  interface SymbolMaterialProps extends PointsMaterialParameters {
                     /**  */
                     borderWidth?: number;
                     /**  */
                     borderColor?: ColorRepresentation;
                     /**  */
                     fadeDistance?: number;
                     /**  */
                     shape?: "square" | "circle" | "triangle";
                     /**  */
                     vertexSize?: boolean;
                     /**  */
                     vertexBorderColor?: boolean;
                 }

                 /**
                  * symbol,
                  */
                 export  class SymbolModule extends EntityModuleBase implements IEntityModuleBase {
                     #private;
                     static moduleName: string;
                     symbol: Points;
                     material: PointsMaterial;
                     geometry: BufferGeometry;
                     _symbolData: SymbolItemData[];
                     style: SymbolMaterialProps;
                     useBvh: boolean;
                     constructor(entity: Entity, options?: SymbolModuleOption);
                     get symbolObject(): Points<BufferGeometry<NormalBufferAttributes>, Material | Material[], Object3DEventMap>;
                     getData(): SymbolItemData[];
                     setData(data?: SymbolItemData[]): void;
                     updateStyle(style: SymbolMaterialProps): void;
                     /**
                      * pointIndex
                      * @param pointIndex 
                      * @param isRefData ,false,
                      */
                     getItemDataByPointIndex(pointIndex: number, isRefData?: boolean): SymbolItemData;
                 }

                 export  interface SymbolModuleOption {
                     /**  */
                     data: SymbolItemData[];
                     /**  */
                     style?: SymbolMaterialProps;
                     /**  */
                     pixelRaycasting?: boolean;
                     /**  bvh */
                     useBvh?: boolean;
                 }

                 export  const tea: {
                     utf8Encode: (str: any) => any;
                     utf8Decode: (bs: any, n: any) => any;
                     encrypt: (data: any, key: any) => any;
                     encryptToBase64: (data: any, key: any) => any;
                     encryptToBase64Url: (data: any, key: any) => any;
                     decrypt: (data: any, key: any) => any;
                     decryptFromBase64: (data: any, key: any) => any;
                     decryptFromBase64Url: (data: any, key: any) => any;
                 };

                 export  function texImageToCanvas(image: TexImageSource, maxWidth: number, flipY?: boolean): HTMLCanvasElement;

                  type TextAlign = 'left' | 'center' | 'right';

                 export  interface TextFlowMaterialOptions extends TextStyleProps {
                     geometryWidth: number;
                     geometryHeight: number;
                     flowDirection?: "horizon" | "vertical";
                     flowSpeed?: number;
                 }

                  interface TextPositionCalculationResult {
                     x: number;
                     y: number;
                     align: TextAlign;
                     verticalAlign: TextVerticalAlign;
                 }

                 export  type TextProps = {
                     text: string;
                     characters?: string;
                     color?: number | string;
                     fontSize?: number;
                     maxWidth?: number;
                     lineHeight?: number;
                     letterSpacing?: number;
                     textAlign?: 'left' | 'right' | 'center' | 'justify';
                     font?: string;
                     anchorX?: number | 'left' | 'center' | 'right';
                     anchorY?: number | 'top' | 'top-baseline' | 'middle' | 'bottom-baseline' | 'bottom';
                     clipRect?: [number, number, number, number];
                     depthOffset?: number;
                     direction?: 'auto' | 'ltr' | 'rtl';
                     overflowWrap?: 'normal' | 'break-word';
                     whiteSpace?: 'normal' | 'overflowWrap' | 'nowrap';
                     outlineWidth?: number | string;
                     outlineOffsetX?: number | string;
                     outlineOffsetY?: number | string;
                     outlineBlur?: number | string;
                     outlineColor?: number | string;
                     outlineOpacity?: number;
                     strokeWidth?: number | string;
                     strokeColor?: number | string;
                     strokeOpacity?: number;
                     fillOpacity?: number;
                     sdfGlyphSize?: number;
                     debugSDF?: boolean;
                     onSync?: (troika: any) => void;
                     onPreloadEnd?: () => void;
                 };

                  interface TextProps_2 extends DisplayableProps {
                     style?: TextStyleProps;
                     zlevel?: number;
                     z?: number;
                     z2?: number;
                     culling?: boolean;
                     cursor?: string;
                 }

                  type TextState = Pick<TextProps_2, DisplayableStatePropNames> & ElementCommonState;

                  interface TextStyleProps extends TextStylePropsPart {
                     text?: string;
                     x?: number;
                     y?: number;
                     /**
                      * Only support number in the top block.
                      */
                     width?: number;
                     /**
                      * Text styles for rich text.
                      */
                     rich?: Dictionary<TextStylePropsPart>;
                     /**
                      * Strategy when calculated text width exceeds textWidth.
                      * break: break by word
                      * break: will break inside the word
                      * truncate: truncate the text and show ellipsis
                      * Do nothing if not set
                      */
                     overflow?: 'break' | 'breakAll' | 'truncate' | 'none';
                     /**
                      * Strategy when text lines exceeds textHeight.
                      * Do nothing if not set
                      */
                     lineOverflow?: 'truncate';
                     /**
                      * Epllipsis used if text is truncated
                      */
                     ellipsis?: string;
                     /**
                      * Placeholder used if text is truncated to empty
                      */
                     placeholder?: string;
                     /**
                      * Min characters for truncating
                      */
                     truncateMinChar?: number;
                 }

                  interface TextStylePropsPart {
                     text?: string;
                     fill?: string;
                     stroke?: string;
                     strokeNoScale?: boolean;
                     opacity?: number;
                     fillOpacity?: number;
                     strokeOpacity?: number;
                     /**
                      * textStroke may be set as some color as a default
                      * value in upper applicaion, where the default value
                      * of lineWidth should be 0 to make sure that
                      * user can choose to do not use text stroke.
                      */
                     lineWidth?: number;
                     lineDash?: false | number[];
                     lineDashOffset?: number;
                     borderDash?: false | number[];
                     borderDashOffset?: number;
                     /**
                      * If `fontSize` or `fontFamily` exists, `font` will be reset by
                      * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
                      * So do not visit it directly in upper application (like ),
                      * but use `contain/text#makeFont` instead.
                      */
                     font?: string;
                     /**
                      * The same as font. Use font please.
                      * @deprecated
                      */
                     textFont?: string;
                     /**
                      * It helps merging respectively, rather than parsing an entire font string.
                      */
                     fontStyle?: FontStyle;
                     /**
                      * It helps merging respectively, rather than parsing an entire font string.
                      */
                     fontWeight?: FontWeight;
                     /**
                      * It helps merging respectively, rather than parsing an entire font string.
                      */
                     fontFamily?: string;
                     /**
                      * It helps merging respectively, rather than parsing an entire font string.
                      * Should be 12 but not '12px'.
                      */
                     fontSize?: number | string;
                     align?: TextAlign;
                     verticalAlign?: TextVerticalAlign;
                     /**
                      * Line height. Default to be text height of ''
                      */
                     lineHeight?: number;
                     /**
                      * Width of text block. Not include padding
                      * Used for background, truncate, wrap
                      */
                     width?: number | string;
                     /**
                      * Height of text block. Not include padding
                      * Used for background, truncate
                      */
                     height?: number;
                     /**
                      * Reserved for special functinality, like 'hr'.
                      */
                     tag?: string;
                     textShadowColor?: string;
                     textShadowBlur?: number;
                     textShadowOffsetX?: number;
                     textShadowOffsetY?: number;
                     backgroundColor?: string | {
                         image: ImageLike | string;
                     };
                     /**
                      * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
                      */
                     padding?: number | number[];
                     /**
                      * Margin of label. Used when layouting the label.
                      */
                     margin?: number;
                     borderColor?: string;
                     borderWidth?: number;
                     borderRadius?: number | number[];
                     /**
                      * Shadow color for background box.
                      */
                     shadowColor?: string;
                     /**
                      * Shadow blur for background box.
                      */
                     shadowBlur?: number;
                     /**
                      * Shadow offset x for background box.
                      */
                     shadowOffsetX?: number;
                     /**
                      * Shadow offset y for background box.
                      */
                     shadowOffsetY?: number;
                 }

                 export  type TextType = {
                     mesh: Mesh;
                     updateProps: (newProps: Partial<TextProps>) => void;
                     dispose: () => void;
                 };

                 export  function textureDataToImageData(imgData: TextureImageData | ImageData | {
                     data: Float32Array | Uint16Array | Uint8Array;
                     width: number;
                     height: number;
                 }, colorSpace?: ColorSpace, outData?: ImageData): ImageData;

                 

                 export  class TextureSequencer implements Sequencer {
                     scaleX: number;
                     scaleY: number;
                     position: Vector3;
                     locations: Vector2[];
                     constructor(scaleX?: number, scaleY?: number, position?: Vector3);
                     transform(position: Vector3, index: number): void;
                     static fromJSON(json: any): Sequencer;
                     clone(): Sequencer;
                     toJSON(): any;
                     fromImage(img: CanvasImageSource, threshold: number): void;
                 }

                 /**
                  *
                  * @param texture
                  * @param maxWidth
                  * @param flipY
                  * @param canvas
                  */
                 export  function textureToCanvas(texture: Texture | DataTexture, maxWidth: number, flipY?: boolean): HTMLCanvasElement;

                 export  function textureToDataUrl(texture: Texture | DataTexture, maxWidth: number, flipY: boolean, mimeType?: string, quality?: number): string;

                 /**
                  * Utils for texture creation and manipulation.
                  */
                 export  class TextureUtils {
                     /**
                      * Create a new texture filled with a CSS style.
                      *
                      * Can be color, gradient or pattern. Supports all options supported in the fillStyle of the canvas API.
                      *
                      * @param color - Style to apply to the texture surface.
                      * @param width - Width of the canvas in pixels.
                      * @param height - Height of the canvas in pixels.
                      */
                     static createFillTexture(color?: (string | CanvasGradient | CanvasPattern), width?: number, height?: number): Texture;
                 }

                  type TextVerticalAlign = 'top' | 'middle' | 'bottom';

                 /**
                  * Given a THREE.Object3D instance, creates a corresponding CANNON shape.
                  */
                 export  const threeToCannon: (object: Object3D, options?: ShapeOptions) => ShapeResult | null;

                  interface Throttle {
                     <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "leading" | "both"): (...args: Args) => Result;
                     <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailing"): (...args: Args) => Result | undefined;
                     <Args extends unknown[], Result>(fn: (...args: Args) => Result, timeout?: number, edge?: "trailingPromise"): (...args: Args) => Promise<Result>;
                 }

                 export  const throttle: Throttle;

                 /**
                  * Documented 3d-tile state managed by the TilesRenderer* / used/usable in priority / traverseFunctions!
                  */
                  interface Tile extends TileBase {
                     parent: Tile;
                     /**
                      * Hierarchy Depth from the TileGroup
                      */
                     __depth: number;
                     /**
                      * The screen space error for this tile
                      */
                     __error: number;
                     /**
                      * How far is this tiles bounds from the nearest active Camera.
                      * Expected to be filled in during calculateError implementations.
                      */
                     __distanceFromCamera: number;
                     /**
                      * This tile is currently active if:
                      *  1: Tile content is loaded and ready to be made visible if needed
                      */
                     __active: boolean;
                     /**
                      * This tile is currently visible if:
                      *  1: Tile content is loaded
                      *  2: Tile is within a camera frustum
                      *  3: Tile meets the SSE requirements
                      */
                     __visible: boolean;
                     /**
                      * Whether or not the tile was visited during the last update run.
                      */
                     __used: boolean;
                     /**
                      * Whether or not the tile was within the frustum on the last update run.
                      */
                     __inFrustum: boolean;
                     /**
                      * TODO: Document this if it is useful enough to be the default property in the LRU sorting.
                      */
                     __depthFromRenderedParent: number;
                 }

                 /**
                  * 3d-tiles Tile object per spec:
                  * (incomplete, expanding as features become supported by this package.)
                  *
                  * See spec for full schema: https://github.com/CesiumGS/3d-tiles/blob/master/specification/schema/tile.schema.json
                  */
                  interface TileBase {
                     boundingVolume: {
                         /**
                          * An array of 12 numbers that define an oriented bounding box. The first three elements define the x, y, and z
                          * values for the center of the box. The next three elements (with indices 3, 4, and 5) define the x axis
                          * direction and half-length. The next three elements (indices 6, 7, and 8) define the y axis direction and
                          * half-length. The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.
                          */
                         box?: number[];
                         /**
                          * An array of four numbers that define a bounding sphere. The first three elements define the x, y, and z
                          * values for the center of the sphere. The last element (with index 3) defines the radius in meters.
                          */
                         sphere?: number[];
                     };
                     /**
                      * The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.
                      */
                     geometricError: number;
                     children?: TileBase[];
                     content?: {
                         uri: string;
                         /**
                          * Dictionary object with content specific extension objects.
                          */
                         extensions?: Record<string, any>;
                         extras?: Record<string, any>;
                         url?: string;
                     };
                     /**
                      * Dictionary object with tile specific extension objects.
                      */
                     extensions?: Record<string, any>;
                     extras?: Record<string, any>;
                     refine?: 'REPLACE' | 'ADD';
                     transform?: number[];
                 }

                  namespace Tiles3dPluginType {
                     export {
                         get3dTilesLngLatHeight,
                         TileBase,
                         Tile,
                         Tileset,
                         TilesRendererBase,
                         TilesGroup,
                         TilesRenderer
                     }
                 }
                 export { Tiles3dPluginType }

                 /**
                  * A 3d-tiles tileset.
                  *
                  * Schema, see: https://github.com/CesiumGS/3d-tiles/blob/main/specification/schema/tileset.schema.json
                  */
                  interface Tileset {
                     /**
                      * Metadata about the entire tileset.
                      */
                     asset: {
                         /**
                          * 3d-tiles version
                          */
                         version: string;
                         /**
                          * Application specific version
                          */
                         tilesetVersion?: string;
                         /**
                          * Dictionary object with extension-specific objects.
                          */
                         extensions?: Record<string, any>;
                     };
                     /**
                      * The error, in meters, introduced if this tileset is not rendered. At runtime, the geometric error is used to compute screen space error (SSE), i.e., the error measured in pixels.
                      */
                     geometricError: Number;
                     /**
                      * The root tile.
                      */
                     root: TileBase;
                     /**
                      * Names of 3D Tiles extensions used somewhere in this tileset.
                      */
                     extensionsUsed?: string[];
                     /**
                      * Names of 3D Tiles extensions required to properly load this tileset.
                      */
                     extensionsRequired?: string[];
                     /**
                      * A dictionary object of metadata about per-feature properties.
                      */
                     properties?: Record<string, any>;
                     /**
                      * Dictionary object with extension-specific objects.
                      */
                     extensions?: Record<string, any>;
                     extras?: Record<string, any>;
                 }

                  class TilesGroup extends Group_2 {
                     tilesRenderer: TilesRenderer;
                     constructor(tilesRenderer: TilesRenderer);
                 }

                  class TilesRenderer extends TilesRendererBase {
                     constructor(url: String, options?: {
                         clearRootTransform?: boolean;
                     });
                     autoDisableRendererCulling: Boolean;
                     optimizeRaycast: Boolean;
                     manager: LoadingManager;
                     group: TilesGroup;
                     getBoundingBox(box: Box3): Boolean;
                     getOrientedBoundingBox(box: Box3, matrix: Matrix4): Boolean;
                     getBoundingSphere(sphere: Sphere): Boolean;
                     hasCamera(camera: Camera): Boolean;
                     setCamera(camera: Camera): Boolean;
                     deleteCamera(camera: Camera): Boolean;
                     setResolution(camera: Camera, x: Number, y: Number): Boolean;
                     setResolution(camera: Camera, resolution: Vector2): Boolean;
                     setResolutionFromRenderer(camera: Camera, renderer: WebGLRenderer): Boolean;
                     forEachLoadedModel(callback: (scene: Object3D, tile: Tile) => void): void;
                     onLoadTileSet: ((tileSet: Tileset) => void) | null;
                     onLoadModel: ((scene: Object3D, tile: Tile) => void) | null;
                     onDisposeModel: ((scene: Object3D, tile: Tile) => void) | null;
                     onTileVisibilityChange: ((scene: Object3D, tile: Tile, visible: boolean) => void) | null;
                     addEventListener(type: String, cb: (e: Object) => void): any;
                     hasEventListener(type: String, cb: (e: Object) => void): any;
                     removeEventListener(type: String, cb: (e: Object) => void): any;
                     dispatchEvent(e: Object): any;
                 }

                  class TilesRendererBase {
                     readonly rootTileset: Object | null;
                     readonly root: Object | null;
                     errorTarget: Number;
                     errorThreshold: Number;
                     loadSiblings: Boolean;
                     displayActiveTiles: Boolean;
                     maxDepth: Number;
                     stopAtEmptyTiles: Boolean;
                     fetchOptions: any;
                     /** function to preprocess the url for each individual tile */
                     preprocessURL: ((uri: string | URL) => string) | null;
                     lruCache: any;
                     parseQueue: any;
                     downloadQueue: any;
                     constructor(url: String);
                     update(): void;
                     traverse(beforeCb: ((tile: Object, parent: Object, depth: Number) => Boolean) | null, afterCb: ((tile: Object, parent: Object, depth: Number) => Boolean) | null): void;
                     dispose(): void;
                     resetFailedTiles(): void;
                 }

                 /**
                  * .
                  */
                 export  class Time {
                     private _frameCount;
                     private _deltaTime;
                     private _actualDeltaTime;
                     private _elapsedTime;
                     private _actualElapsedTime;
                     private _lastSystemTime;
                     /** . */
                     maximumDeltaTime: number;
                     /** . */
                     timeScale: number;
                     get frameCount(): number;
                     /**
                      * .
                      *
                      * @remarks  deltaTime  maximumDeltaTime * timeScale 
                      */
                     get deltaTime(): number;
                     /**
                      * .
                      */
                     get elapsedTime(): number;
                     /**
                      * .
                      *
                      * @remarks  maximumDeltaTime * timeScale 
                      */
                     get actualDeltaTime(): number;
                     /**
                      * .
                      */
                     get actualElapsedTime(): number;
                     /**
                      * .
                      */
                     constructor();
                 }

                 /**
                  * Returns a promise that resolves after the given duration. Basically a setTimeout that returns a promise.
                  * @param duration - in ms
                  *
                  * @category Time
                  */
                 export  function timeout(duration: number): Promise<unknown>;

                 export  type TLEnterEventHandler = (info: TLEventType, from: string) => void;

                 export  interface TLEventHandler {
                     name?: string;
                     event?: InteractiveEvent;
                     object?: InteractiveObject;
                 }

                 export  interface TLEventType extends TLEventHandler {
                     /**  */
                     onInteractionEnd?: string;
                     /**  */
                     onInteractionEndContext?: Record<string, any>;
                     /**  */
                     onEnterCallBack?: (node: StateNode, context: any, from: string) => void;
                     /**  */
                     onExitCallBack?: (node: StateNode, context: any) => void;
                     [key: string]: any;
                 }

                 /** @public */
                 export  type TLExitEventHandler = (info: TLEventType, to: string) => void;

                 /** @public */
                 export  interface TLStateNodeConstructor {
                     new (editor: App, parent?: StateNode): StateNode;
                     id: string;
                     initial?: string;
                     children?: () => TLStateNodeConstructor[];
                 }

                  type TLStateNodeType = 'branch' | 'leaf' | 'root';

                 /**
                  * Modifies the supplied geometry if it is non-indexed, otherwise creates a new, non-indexed geometry. Returns the
                  * geometry with smooth normals everywhere except faces that meet at an angle greater than the crease angle.
                  *
                  * @param geometry The input geometry.
                  * @param creaseAngle The crease angle in radians.
                  */
                  function toCreasedNormals(geometry: BufferGeometry, creaseAngle?: number): BufferGeometry;

                 /**
                  * .
                  * @param dist 
                  * @param isMap2dHeightMeter false
                  * @param app 
                  * @param mapView
                  */
                 export  function toDist(dist: number, isMap2dHeightMeter?: boolean, app?: App, mapView?: MapViewEntity): number;

                  function toHex(color: string): string;

                 

                 

                 export  class ToolStateModule extends AppModuleBase implements IAppModuleBase {
                     static moduleName: string;
                     _rootState: StateNode;
                     options: ToolStateModuleOptions;
                     constructor(app?: App, options?: ToolStateModuleOptions);
                     onAwake(): void;
                     get rootState(): StateNode;
                     /**
                      * The editor's current path of active states.
                      *
                      * @example
                      * ```ts
                      * app.getStatePath() // "draw.idle"
                      * ```
                      *
                      * @public
                      */
                     getStatePath(): string;
                     /**
                      * Get whether a certain tool (or other state node) is currently active.
                      *
                      * @example
                      * ```ts
                      * app.stateIsIn('draw')
                      * app.stateIsIn('draw.drawpoint')
                      * ```
                      *
                      * @param path - The path of active states, separated by periods.
                      *
                      * @public
                      */
                     stateIsIn(path: string): boolean;
                     /**
                      * Get whether the state node is in any of the given active paths.
                      *
                      * @example
                      * ```ts
                      * app.stateInAny('draw', 'pick')
                      * app.stateInAny('draw.drawpoint', 'pick.idle')
                      * ```
                      *
                      * @public
                      */
                     stateInAny(...paths: string[]): boolean;
                     /**
                      * Set the selected tool.
                      *
                      * @example
                      * ```ts
                      * app.setCurrentTool('transform')
                      * app.setCurrentTool("draw.drawpolygon", {color: 0xff0000})
                      * ```
                      *
                      * @param id - The id of the tool to select.
                      * @param info - Arbitrary data to pass along into the transition.
                      *
                      * @public
                      */
                     setCurrentTool(id?: string, info?: Record<string, any>): App;
                     /**
                      * The current selected tool.
                      *
                      * @public
                      */
                     getCurrentTool(): StateNode;
                     /**
                      * The id of the current selected tool.
                      *
                      * @public
                      */
                     getCurrentToolId(): string;
                     addTool(Tool: TLStateNodeConstructor): void;
                     removeTool(Tool: TLStateNodeConstructor): void;
                     /**
                      * Get a descendant by its path.
                      *
                      * @example
                      * ```ts
                      * app.getStateDescendant('select')
                      * app.getStateDescendant('select.brushing')
                      * ```
                      *
                      * @param path - The descendant's path of state ids, separated by periods.
                      *
                      * @public
                      */
                     getStateDescendant<T extends StateNode>(path: string): T | undefined;
                     /**
                      * 
                      */
                     isInActiveTool(): boolean;
                     /**
                      * 
                      */
                     isInteracting(): boolean;
                     /**
                      *  
                      */
                     transformObject(options: TransformEnterOptions): Promise<StateNode>;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  interface ToolStateModuleOptions {
                     tools?: TLStateNodeConstructor[];
                 }

                 /**
                  * Returns the raw, original object of a Vue-created proxy.
                  *
                  * `toRaw()` can return the original object from proxies created by
                  * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or
                  * {@link shallowReadonly()}.
                  *
                  * This is an escape hatch that can be used to temporarily read without
                  * incurring proxy access / tracking overhead or write without triggering
                  * changes. It is **not** recommended to hold a persistent reference to the
                  * original object. Use with caution.
                  *
                  * @example
                  * ```js
                  * const foo = {}
                  * const reactiveFoo = reactive(foo)
                  *
                  * console.log(toRaw(reactiveFoo) === foo) // true
                  * ```
                  *
                  * @param observed - The object for which the "raw" value is requested.
                  */
                  function toRaw<T>(observed: T): T;

                  type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>;

                 /**
                  * Used to normalize values / refs / getters into refs.
                  *
                  * @example
                  * ```js
                  * // returns existing refs as-is
                  * toRef(existingRef)
                  *
                  * // creates a ref that calls the getter on .value access
                  * toRef(() => props.foo)
                  *
                  * // creates normal refs from non-function values
                  * // equivalent to ref(1)
                  * toRef(1)
                  * ```
                  *
                  * Can also be used to create a ref for a property on a source reactive object.
                  * The created ref is synced with its source property: mutating the source
                  * property will update the ref, and vice-versa.
                  *
                  * @example
                  * ```js
                  * const state = reactive({
                  *   foo: 1,
                  *   bar: 2
                  * })
                  *
                  * const fooRef = toRef(state, 'foo')
                  *
                  * // mutating the ref updates the original
                  * fooRef.value++
                  * console.log(state.foo) // 2
                  *
                  * // mutating the original also updates the ref
                  * state.foo++
                  * console.log(fooRef.value) // 3
                  * ```
                  *
                  * @param source - A getter, an existing ref, a non-function value, or a
                  *                 reactive object to create a property ref from.
                  * @param [key] - (optional) Name of the property in the reactive object.
                  */
                  function toRef<T>(value: T): T extends () => infer R ? Readonly<Ref<R>> : T extends Ref ? T : Ref<UnwrapRef<T>>;

                  function toRef<T extends object, K extends keyof T>(object: T, key: K): ToRef<T[K]>;

                  function toRef<T extends object, K extends keyof T>(object: T, key: K, defaultValue: T[K]): ToRef<Exclude<T[K], undefined>>;

                  type ToRefs<T = any> = {
                     [K in keyof T]: ToRef<T[K]>;
                 };

                 /**
                  * Converts a reactive object to a plain object where each property of the
                  * resulting object is a ref pointing to the corresponding property of the
                  * original object. Each individual ref is created using {@link toRef()}.
                  *
                  * @param object - Reactive object to be made into an object of linked refs.
                  */
                  function toRefs<T extends object>(object: T): ToRefs<T>;

                 /**
                  * Convert a string to title case
                  * @param str - The string to convert
                  *
                  * @category Text
                  */
                 export  function toTitleCase(str: string): string;

                  function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: TrianglesDrawModes): BufferGeometry;

                  interface Touches {
                     one: singleTouchAction;
                     two: multiTouchAction;
                     three: multiTouchAction;
                 }

                 /**
                  * Normalizes values / refs / getters to values.
                  * This is similar to {@link unref()}, except that it also normalizes getters.
                  * If the argument is a getter, it will be invoked and its return value will
                  * be returned.
                  *
                  * @example
                  * ```js
                  * toValue(1) // 1
                  * toValue(ref(1)) // 1
                  * toValue(() => 1) // 1
                  * ```
                  *
                  * @param source - A getter, an existing ref, or a non-function value.
                  */
                  function toValue<T>(source: MaybeRefOrGetter<T>): T;

                 /**
                  * vector3
                  * @param v 
                  * @returns
                  */
                 export  function toVector3(v: Vector3 | [number, number, number] | number): Vector3;

                 /**
                  *  .
                  */
                 export  function toWorld(vec3: [number, number, number?], app?: App, mapView?: MapViewEntity): Vector3;

                 export  type TParams<T> = ValOrFunc<Partial<UiObjectConfig>, [T]>;

                  class Track {
                     keyframes: Keyframe_2[];
                     propName: string;
                     valType: ValueType;
                     discrete: boolean;
                     _invalid: boolean;
                     private _finished;
                     private _needsSort;
                     private _additiveTrack;
                     private _additiveValue;
                     /**
                      * Last frame
                      */
                     private _lastFr;
                     /**
                      * Percent of last frame.
                      */
                     private _lastFrP;
                     constructor(propName: string);
                     isFinished(): boolean;
                     setFinished(): void;
                     needsAnimate(): boolean;
                     getAdditiveTrack(): Track;
                     addKeyframe(time: number, rawValue: unknown, easing?: AnimationEasing): Keyframe_2;
                     prepare(maxTime: number, additiveTrack?: Track): void;
                     step(target: any, percent: number): void;
                     private _addToTarget;
                 }

                 /**
                  * Tracks access to a reactive property.
                  *
                  * This will check which effect is running at the moment and record it as dep
                  * which records all effects that depend on the reactive property.
                  *
                  * @param target - Object holding the reactive property.
                  * @param type - Defines the type of access to the reactive property.
                  * @param key - Identifier of the reactive property to track.
                  */
                  function track(target: object, type: TrackOpTypes, key: unknown): void;

                 /**
                  * wasTracked and newTracked maintain the status for several levels of effect
                  * tracking recursion. One bit per level is used to define whether the dependency
                  * was/is tracked.
                  */
                  interface TrackedMarkers {
                     /**
                      * wasTracked
                      */
                     w: number;
                     /**
                      * newTracked
                      */
                     n: number;
                 }

                  const enum TrackOpTypes {
                     GET = "get",
                     HAS = "has",
                     ITERATE = "iterate"
                 }

                 /**
                  * A VFX batch that render trails in a batch.
                  */
                 export  class TrailBatch extends VFXBatch {
                     geometry: BufferGeometry;
                     private positionBuffer;
                     private previousBuffer;
                     private nextBuffer;
                     private uvBuffer;
                     private sideBuffer;
                     private widthBuffer;
                     private colorBuffer;
                     private indexBuffer;
                     constructor(settings: VFXBatchSettings);
                     setupBuffers(): void;
                     expandBuffers(target: number): void;
                     rebuildMaterial(): void;
                     vector_: Vector3;
                     vector2_: Vector3;
                     vector3_: Vector3;
                     quaternion_: Quaternion;
                     update(): void;
                     dispose(): void;
                 }

                 export  class TrailLine {
                     iconUrl: string;
                     _originPositions: any;
                     color: Color;
                     opacity: any;
                     lineWidth: any;
                     useAlpha: any;
                     showLine: any;
                     placeLength: any;
                     placeSpace: any;
                     isAnimate: any;
                     speed: any;
                     smooth: any;
                     uvOffset: number;
                     colorArr: any[];
                     _map: any;
                     positions: any;
                     previous: any[];
                     next: any[];
                     side: any[];
                     width: any[];
                     indices: any[];
                     uvs: any[];
                     geometry: any;
                     texture: any;
                     material: any;
                     trail: any;
                     options: any;
                     /**
                      * 
                      * @param options
                      */
                     constructor(options?: TrailLineOptions);
                     /**
                      * 
                      * @private
                      */
                     _init(): void;
                     setVisible(bool: any): void;
                     start(): void;
                     stop(): void;
                     compareV3(a: any, b: any): boolean;
                     copyV3(a: any): any[];
                     _process(): void;
                     update(app: App): void;
                 }

                 /**
                  * 
                  */
                 export  class TrailLineEntity extends Entity {
                     trailLine: TrailLine;
                     constructor(options: TrailLineEntityOptions);
                 }

                 export  type TrailLineEntityOptions = EntityOptions & TrailLineOptions;

                 export  interface TrailLineOptions {
                     /** url */
                     iconUrl?: string;
                     /**  */
                     positions?: [number, number, number][];
                     /**  */
                     color?: Color;
                     /**  */
                     opacity?: number;
                     /** 20 */
                     width?: number;
                     /** alpha,false */
                     useAlpha?: boolean;
                     /** ,true */
                     showLine?: boolean;
                     /** ,10 */
                     placeLength?: number;
                     /** ,10 */
                     placeSpace?: number;
                     /** ,false */
                     isAnimate?: boolean;
                     /** ,3 */
                     speed?: number;
                     /** ,true */
                     smooth?: boolean;
                 }

                 /**
                  * Particle implementation for trail-based particles.
                  */
                 export  class TrailParticle implements Particle {
                     /**
                      * Parent matrix for transformation.
                      * @type {Matrix4}
                      */
                     parentMatrix?: Matrix4;
                     /**
                      * Initial speed of the particle.
                      * @type {number}
                      */
                     startSpeed: number;
                     /**
                      * Initial color of the particle.
                      * @type {Vector4}
                      */
                     startColor: Vector4;
                     /**
                      * Initial size of the particle.
                      * @type {number}
                      */
                     startSize: number;
                     /**
                      * Position of the particle.
                      * @type {Vector3}
                      */
                     position: Vector3;
                     /**
                      * Local position of the particle.
                      * @type {Vector3}
                      */
                     localPosition?: Vector3;
                     /**
                      * Velocity of the particle.
                      * @type {Vector3}
                      */
                     velocity: Vector3;
                     /**
                      * Age of the particle.
                      * @type {number}
                      */
                     age: number;
                     /**
                      * Life duration of the particle.
                      * @type {number}
                      */
                     life: number;
                     /**
                      * Size of the particle.
                      * @type {number}
                      */
                     size: number;
                     /**
                      * Length of the trail.
                      * @type {number}
                      */
                     length: number;
                     /**
                      * Speed modifier of the particle.
                      * @type {number}
                      */
                     speedModifier: number;
                     /**
                      * Color of the particle.
                      * @type {Vector4}
                      */
                     color: Vector4;
                     /**
                      * Previous states of the particle.
                      * @type {LinkedList<RecordState>}
                      */
                     previous: LinkedList<RecordState>;
                     /**
                      * UV tile index.
                      * @type {number}
                      */
                     uvTile: number;
                     /**
                      * Updates the particle state.
                      */
                     update(): void;
                     /**
                      * Indicates if the particle has died.
                      * @type {boolean}
                      */
                     get died(): boolean;
                     /**
                      * Resets the particle properties and clears the previous states.
                      */
                     reset(): void;
                 }

                 export  interface TrailSettings {
                     /**
                      * Start length of the trail.
                      * @type {ValueGenerator | FunctionValueGenerator}
                      */
                     startLength: ValueGenerator | FunctionValueGenerator;
                     /**
                      * Whether to follow the local origin.
                      * @type {boolean}
                      */
                     followLocalOrigin: boolean;
                 }

                 /**
                  * Transformation utilities.
                  */
                  class Transform {
                     /**
                      * position
                      */
                     position: Vec3;
                     /**
                      * quaternion
                      */
                     quaternion: Quaternion_2;
                     constructor(options?: {
                         /**
                          * position
                          */
                         position?: Vec3;
                         /**
                          * quaternion
                          */
                         quaternion?: Quaternion_2;
                     });
                     /**
                      * Get a global point in local transform coordinates.
                      */
                     pointToLocal(worldPoint: Vec3, result?: Vec3): Vec3;
                     /**
                      * Get a local point in global transform coordinates.
                      */
                     pointToWorld(localPoint: Vec3, result?: Vec3): Vec3;
                     /**
                      * vectorToWorldFrame
                      */
                     vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
                     /**
                      * pointToLocalFrame
                      */
                     static pointToLocalFrame(position: Vec3, quaternion: Quaternion_2, worldPoint: Vec3, result?: Vec3): Vec3;
                     /**
                      * pointToWorldFrame
                      */
                     static pointToWorldFrame(position: Vec3, quaternion: Quaternion_2, localPoint: Vec3, result?: Vec3): Vec3;
                     /**
                      * vectorToWorldFrame
                      */
                     static vectorToWorldFrame(quaternion: Quaternion_2, localVector: Vec3, result?: Vec3): Vec3;
                     /**
                      * vectorToLocalFrame
                      */
                     static vectorToLocalFrame(position: Vec3, quaternion: Quaternion_2, worldVector: Vec3, result?: Vec3): Vec3;
                 }

                 export  const transform: {
                     CRSTypes: typeof CRSTypes;
                     convert: typeof convert;
                     EpsgCrsTypes: typeof EpsgCrsTypes;
                     getEpsgParam: typeof getEpsgParam;
                     getEpsgCode: typeof getEpsgCode;
                 };

                  class Transformable {
                     parent: Transformable;
                     x: number;
                     y: number;
                     scaleX: number;
                     scaleY: number;
                     skewX: number;
                     skewY: number;
                     rotation: number;
                     /**
                      * Will translated the element to the anchor position before applying other transforms.
                      */
                     anchorX: number;
                     anchorY: number;
                     /**
                      * Origin of scale, rotation, skew
                      */
                     originX: number;
                     originY: number;
                     /**
                      * Scale ratio
                      */
                     globalScaleRatio: number;
                     transform: matrix.MatrixArray;
                     invTransform: matrix.MatrixArray;
                     /**
                      * Get computed local transform
                      */
                     getLocalTransform(m?: matrix.MatrixArray): matrix.MatrixArray;
                     /**
                      * Set position from array
                      */
                     setPosition(arr: number[]): void;
                     /**
                      * Set scale from array
                      */
                     setScale(arr: number[]): void;
                     /**
                      * Set skew from array
                      */
                     setSkew(arr: number[]): void;
                     /**
                      * Set origin from array
                      */
                     setOrigin(arr: number[]): void;
                     /**
                      * If needs to compute transform
                      */
                     needLocalTransform(): boolean;
                     /**
                      * Update global transform
                      */
                     updateTransform(): void;
                     private _resolveGlobalScaleRatio;
                     /**
                      * Get computed global transform
                      * NOTE: this method will force update transform on all ancestors.
                      * Please be aware of the potential performance cost.
                      */
                     getComputedTransform(): matrix.MatrixArray;
                     setLocalTransform(m: vector.VectorArray): void;
                     /**
                      * `transform``position`, `rotation`, `scale`
                      */
                     decomposeTransform(): void;
                     /**
                      * Get global scale
                      */
                     getGlobalScale(out?: vector.VectorArray): vector.VectorArray;
                     /**
                      *  shape 
                      */
                     transformCoordToLocal(x: number, y: number): number[];
                     /**
                      * 
                      */
                     transformCoordToGlobal(x: number, y: number): number[];
                     getLineScale(): number;
                     copyTransform(source: Transformable): void;
                     static getLocalTransform(target: Transformable, m?: matrix.MatrixArray): matrix.MatrixArray;
                     private static initDefaultProps;
                 }

                  const TRANSFORMABLE_PROPS: readonly ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"];

                 /**  */
                 export  class TransformControls<TCamera extends Camera = Camera> extends Object3D {
                     readonly isTransformControls = true;
                     visible: boolean;
                     private domElement;
                     private raycaster;
                     private gizmo;
                     private plane;
                     private tempVector;
                     private tempVector2;
                     private tempQuaternion;
                     private unit;
                     private pointStart;
                     private pointEnd;
                     private offset;
                     private rotationAxis;
                     private startNorm;
                     private endNorm;
                     private rotationAngle;
                     private cameraPosition;
                     private cameraQuaternion;
                     private cameraScale;
                     private parentPosition;
                     private parentQuaternion;
                     private parentQuaternionInv;
                     private parentScale;
                     private worldPositionStart;
                     private worldQuaternionStart;
                     private worldScaleStart;
                     private worldPosition;
                     private worldQuaternion;
                     private worldQuaternionInv;
                     private worldScale;
                     private eye;
                     private positionStart;
                     private quaternionStart;
                     private scaleStart;
                     private camera;
                     private object;
                     private enabled;
                     private axis;
                     private mode;
                     private translationSnap;
                     private rotationSnap;
                     private scaleSnap;
                     private space;
                     private size;
                     private dragging;
                     private showX;
                     private showY;
                     private showZ;
                     private changeEvent;
                     private mouseDownEvent;
                     private mouseUpEvent;
                     private objectChangeEvent;
                     app: App;
                     constructor(camera: TCamera, domElement: HTMLElement | undefined, app?: App);
                     private intersectObjectWithRay;
                     attach: (object: Object3D) => this;
                     detach: () => this;
                     reset: () => this;
                     updateMatrixWorld: () => void;
                     private pointerHover;
                     private pointerDown;
                     private pointerMove;
                     private pointerUp;
                     private getPointer;
                     private onPointerHover;
                     private onPointerDown;
                     private onPointerMove;
                     private onPointerUp;
                     getMode: () => TransformControls['mode'];
                     setMode: (mode: TransformControls['mode']) => void;
                     setTranslationSnap: (translationSnap: number) => void;
                     setRotationSnap: (rotationSnap: number) => void;
                     setScaleSnap: (scaleSnap: number) => void;
                     setSize: (size: number) => void;
                     setSpace: (space: string) => void;
                     update: () => void;
                     connect: (domElement: HTMLElement) => void;
                     dispose: () => void;
                 }

                 export  class TransformControlsGizmo extends Object3D {
                     private isTransformControlsGizmo;
                     type: string;
                     private tempVector;
                     private tempEuler;
                     private alignVector;
                     private zeroVector;
                     private lookAtMatrix;
                     private tempQuaternion;
                     private tempQuaternion2;
                     private identityQuaternion;
                     private unitX;
                     private unitY;
                     private unitZ;
                     private gizmo;
                     picker: TransformControlsGizmoPrivateGizmos;
                     private helper;
                     private rotationAxis;
                     private cameraPosition;
                     private worldPositionStart;
                     private worldQuaternionStart;
                     private worldPosition;
                     private worldQuaternion;
                     private eye;
                     private camera;
                     private enabled;
                     private axis;
                     private mode;
                     private space;
                     private size;
                     private dragging;
                     private showX;
                     private showY;
                     private showZ;
                     constructor();
                     updateMatrixWorld: () => void;
                 }

                  type TransformControlsGizmoPrivateGizmos = {
                     ['translate']: Object3D;
                     ['scale']: Object3D;
                     ['rotate']: Object3D;
                     ['visible']: boolean;
                 };

                 export  class TransformControlsPlane extends Mesh<PlaneGeometry, MeshBasicMaterial> {
                     private isTransformControlsPlane;
                     type: string;
                     constructor();
                     private unitX;
                     private unitY;
                     private unitZ;
                     private tempVector;
                     private dirVector;
                     private alignVector;
                     private tempMatrix;
                     private identityQuaternion;
                     private cameraQuaternion;
                     private worldPosition;
                     private worldQuaternion;
                     private eye;
                     private axis;
                     private mode;
                     private space;
                     updateMatrixWorld: () => void;
                 }

                 export  interface TransformControlsPointerObject {
                     x: number;
                     y: number;
                     button: number;
                 }

                 export  type TransformedTypes<T> = TransformType<TransformType<T, Color, ColorRepresentation>, Vector3, number>;

                 /**  */
                 export  interface TransformEnterOptions extends TLEventType {
                     /**  */
                     target?: Object3D | Vector3;
                     /**  */
                     axis?: string | null;
                     /**  */
                     mode?: 'translate' | 'rotate' | 'scale';
                     /**  */
                     translationSnap?: number;
                     /**  */
                     rotationSnap?: number;
                     /**  */
                     scaleSnap?: number;
                     /**  */
                     space?: 'world' | "local";
                     /**  */
                     size?: number;
                     /** x,  */
                     showX?: boolean | ('translate' | 'rotate' | 'scale')[];
                     /** y,  */
                     showY?: boolean | ('translate' | 'rotate' | 'scale')[];
                     /** z,  */
                     showZ?: boolean | ('translate' | 'rotate' | 'scale')[];
                     /**  Q   true*/
                     pressQKeySwitchSpace?: boolean;
                     /**  shfit  true*/
                     pressShiftKeySnap?: boolean;
                     /**  W   true*/
                     pressWKeyModeTranslate?: boolean;
                     /**  E   true*/
                     pressEKeyModeRotate?: boolean;
                     /**  R   true*/
                     pressRKeyModeScale?: boolean;
                     /**  X x  true*/
                     pressXKeyShowX?: boolean;
                     /**  Y x  true*/
                     pressYKeyShowY?: boolean;
                     /**  Z x  true*/
                     pressZKeyShowZ?: boolean;
                     /**  */
                     queryOptions?: EntityQueryOption;
                     /**  true */
                     clickNoEntityExit?: boolean;
                     /**  false */
                     clickNoSelfEntityExit?: boolean;
                     /**  */
                     clickIsEqualObject?: Object3D | Function;
                     /**  true */
                     clickEntityAttach?: boolean;
                     /**  true*/
                     editAsCommand?: boolean;
                     /**  false */
                     rightClickConfirmExit?: boolean;
                     /** esc  true */
                     enterEscConfirmExit?: boolean;
                     /**  */
                     transformSize?: number;
                     /**  */
                     dragCallBack?: (cb: {
                         /**  */
                         isReset: boolean;
                         /**  */
                         isOnceFinish: boolean;
                         position: Vector3;
                         scale: Vector3;
                         rotation: Euler;
                         deltaPosition: Vector3;
                         deltaScale: Vector3;
                         oldRotation: Euler;
                         /**  */
                         command?: MultiCmdsCommand;
                     }) => void;
                 }

                  type TransformOptions = ConstructorParameters<typeof Transform>[0];

                  type TransformProp = (typeof TRANSFORMABLE_PROPS)[number];

                 /**  */
                 export  class TransformTool extends StateNode {
                     static id: string;
                     static initial: string;
                     static children: () => (typeof Idle_3)[];
                 }

                 export  type TransformType<T, U, V> = {
                     [P in keyof T]: T[P] extends U ? T[P] | V : T[P];
                 };

                 /**
                  * 
                  */
                  function translate(out: MatrixArray, a: MatrixArray, v: VectorArray): MatrixArray;

                 /**
                  * 
                  * @param material
                  */
                 export  const traverseMaterial: (material: Mesh | Material | Material[], cb: (material: Material) => any) => any;

                  interface TreeNode {
                     bounds: Box3;
                     count: number;
                     offset: number;
                     left?: TreeNode;
                     right?: TreeNode;
                 }

                 export  function triangle2dArea(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): number;

                  class TriangleIntersectData {
                     intersects: Object;
                     triangle: Triangle;
                     constructor(tri: Triangle);
                     addTriangle(index: number, tri: Triangle): void;
                     getIntersectArray(): Array<Triangle>;
                 }

                  class TriangleIntersectionSets {
                     addTriangleIntersection(ia: number, tribA: Triangle, ib: number, triB: Triangle): void;
                     getTrianglesAsArray(id?: number): Array<Triangle>;
                     getTriangleIndices(): Array<number>;
                     getIntersectionIndices(id: number): void;
                     getIntersectionsAsArray(id?: number, id2?: number): Array<Triangle>;
                 }

                  class TrianglePool {
                     getTriangle(): Triangle;
                     clear(): void;
                     reset(): void;
                 }

                  class TriangleSetHelper extends Group_2 {
                     constructor(triangles?: Triangle[]);
                     setTriangles(triangles: Triangle[]): void;
                 }

                  class TriangleSplitter {
                     trianglePool: TrianglePool;
                     triangles: Triangle[];
                     normal: Vector3;
                     initialize(tri: Triangle): void;
                     splitByTriangle(triangle: Triangle): void;
                     splitByPlane(plane: Plane, triangle: Triangle, coplanarIndex: number): void;
                     reset(): void;
                 }

                 export  function triangulate(vertices: number[], holes: number[], dimensions?: number): number[];

                 export  function triangulatFlatten(data: number[][][]): {
                     vertices: any[];
                     holes: any[];
                     dimensions: any;
                 };

                 /**
                  * Finds all deps associated with the target (or a specific property) and
                  * triggers the effects stored within.
                  *
                  * @param target - The reactive object.
                  * @param type - Defines the type of the operation that needs to trigger effects.
                  * @param key - Can be used to target a specific reactive property in the target object.
                  */
                  function trigger(target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown): void;

                  const enum TriggerOpTypes {
                     SET = "set",
                     ADD = "add",
                     DELETE = "delete",
                     CLEAR = "clear"
                 }

                 /**
                  * Force trigger effects that depends on a shallow ref. This is typically used
                  * after making deep mutations to the inner value of a shallow ref.
                  *
                  * @example
                  * ```js
                  * const shallow = shallowRef({
                  *   greet: 'Hello, world'
                  * })
                  *
                  * // Logs "Hello, world" once for the first run-through
                  * watchEffect(() => {
                  *   console.log(shallow.value.greet)
                  * })
                  *
                  * // This won't trigger the effect because the ref is shallow
                  * shallow.value.greet = 'Hello, universe'
                  *
                  * // Logs "Hello, universe"
                  * triggerRef(shallow)
                  * ```
                  *
                  * @param ref - The ref whose tied effects shall be executed.
                  */
                  function triggerRef(ref: Ref): void;

                 /**
                  * @param str string to be trimed
                  * @return trimed string
                  */
                  function trim(str: string): string;

                 /**
                  * Trimesh.
                  * @example
                  *     // How to make a mesh with a single triangle
                  *     const vertices = [
                  *         0, 0, 0, // vertex 0
                  *         1, 0, 0, // vertex 1
                  *         0, 1, 0  // vertex 2
                  *     ]
                  *     const indices = [
                  *         0, 1, 2  // triangle 0
                  *     ]
                  *     const trimeshShape = new CANNON.Trimesh(vertices, indices)
                  */
                  class Trimesh extends Shape {
                     /**
                      * vertices
                      */
                     vertices: Float32Array;
                     /**
                      * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
                      */
                     indices: Int16Array;
                     /**
                      * The normals data.
                      */
                     normals: Float32Array;
                     /**
                      * The local AABB of the mesh.
                      */
                     aabb: AABB;
                     /**
                      * References to vertex pairs, making up all unique edges in the trimesh.
                      */
                     edges: Int16Array | null;
                     /**
                      * Local scaling of the mesh. Use .setScale() to set it.
                      */
                     scale: Vec3;
                     /**
                      * The indexed triangles. Use .updateTree() to update it.
                      */
                     tree: Octree;
                     constructor(vertices: number[], indices: number[]);
                     /**
                      * updateTree
                      */
                     updateTree(): void;
                     /**
                      * Get triangles in a local AABB from the trimesh.
                      * @param result An array of integers, referencing the queried triangles.
                      */
                     getTrianglesInAABB(aabb: AABB, result: number[]): number[];
                     /**
                      * setScale
                      */
                     setScale(scale: Vec3): void;
                     /**
                      * Compute the normals of the faces. Will save in the `.normals` array.
                      */
                     updateNormals(): void;
                     /**
                      * Update the `.edges` property
                      */
                     updateEdges(): void;
                     /**
                      * Get an edge vertex
                      * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
                      * @param vertexStore Where to store the result
                      */
                     getEdgeVertex(edgeIndex: number, firstOrSecond: number, vertexStore: Vec3): void;
                     /**
                      * Get a vector along an edge.
                      */
                     getEdgeVector(edgeIndex: number, vectorStore: Vec3): void;
                     /**
                      * Get face normal given 3 vertices
                      */
                     static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;
                     /**
                      * Get vertex i.
                      * @return The "out" vector object
                      */
                     getVertex(i: number, out: Vec3): Vec3;
                     /**
                      * Get raw vertex i
                      * @return The "out" vector object
                      */
                     private _getUnscaledVertex;
                     /**
                      * Get a vertex from the trimesh,transformed by the given position and quaternion.
                      * @return The "out" vector object
                      */
                     getWorldVertex(i: number, pos: Vec3, quat: Quaternion_2, out: Vec3): Vec3;
                     /**
                      * Get the three vertices for triangle i.
                      */
                     getTriangleVertices(i: number, a: Vec3, b: Vec3, c: Vec3): void;
                     /**
                      * Compute the normal of triangle i.
                      * @return The "target" vector object
                      */
                     getNormal(i: number, target: Vec3): Vec3;
                     /**
                      * @return The "target" vector object
                      */
                     calculateLocalInertia(mass: number, target: Vec3): Vec3;
                     /**
                      * Compute the local AABB for the trimesh
                      */
                     computeLocalAABB(aabb: AABB): void;
                     /**
                      * Update the `.aabb` property
                      */
                     updateAABB(): void;
                     /**
                      * Will update the `.boundingSphereRadius` property
                      */
                     updateBoundingSphereRadius(): void;
                     /**
                      * calculateWorldAABB
                      */
                     calculateWorldAABB(pos: Vec3, quat: Quaternion_2, min: Vec3, max: Vec3): void;
                     /**
                      * Get approximate volume
                      */
                     volume(): number;
                     /**
                      * Create a Trimesh instance, shaped as a torus.
                      */
                     static createTorus(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number): Trimesh;
                 }

                 export  type TrimeshParameters = {
                     vertices: Float32Array;
                     indices: Uint32Array;
                 };

                  class Trochoid extends Path<TrochoidProps> {
                     shape: TrochoidShape;
                     constructor(opts?: TrochoidProps);
                     getDefaultStyle(): {
                         stroke: string;
                         fill: string;
                     };
                     getDefaultShape(): TrochoidShape;
                     buildPath(ctx: CanvasRenderingContext2D, shape: TrochoidShape): void;
                 }

                  interface TrochoidProps extends PathProps {
                     shape?: Partial<TrochoidShape>;
                 }

                  class TrochoidShape {
                     cx: number;
                     cy: number;
                     r: number;
                     r0: number;
                     d: number;
                     location: string;
                 }

                  class TSpan extends Displayable<TSpanProps> {
                     style: TSpanStyleProps;
                     hasStroke(): boolean;
                     hasFill(): boolean;
                     /**
                      * Create an image style object with default values in it's prototype.
                      * @override
                      */
                     createStyle(obj?: TSpanStyleProps): TSpanStyleProps;
                     /**
                      * Set bounding rect calculated from Text
                      * For reducing time of calculating bounding rect.
                      */
                     setBoundingRect(rect: BoundingRect): void;
                     getBoundingRect(): BoundingRect;
                     protected static initDefaultProps: void;
                 }

                  interface TSpanProps extends DisplayableProps {
                     style?: TSpanStyleProps;
                 }

                  type TSpanState = Pick<TSpanProps, DisplayableStatePropNames>;

                  interface TSpanStyleProps extends PathStyleProps {
                     x?: number;
                     y?: number;
                     text?: string;
                     font?: string;
                     fontSize?: number;
                     fontWeight?: FontWeight;
                     fontStyle?: FontStyle;
                     fontFamily?: string;
                     textAlign?: CanvasTextAlign;
                     textBaseline?: CanvasTextBaseline;
                 }

                 export  type TUiRefreshModes = 'preRender' | 'postRender' | 'preFrame' | 'postFrame';

                 /**
                  * TupleDictionary
                  */
                  class TupleDictionary {
                     data: {
                         [id: string]: any;
                         keys: string[];
                     };
                     /** get */
                     get(i: number, j: number): any;
                     /** set */
                     set(i: number, j: number, value: any): void;
                     /** delete */
                     delete(i: number, j: number): void;
                     /** reset */
                     reset(): void;
                 }

                 /**
                  * Apply turbulence to particles.
                  */
                 export  class TurbulenceField implements Simulation {
                     scale: Vector3;
                     octaves: number;
                     velocityMultiplier: Vector3;
                     timeScale: Vector3;
                     type: string;
                     generator: SimplexNoise;
                     timeOffset: Vector3;
                     temp: Vector3;
                     temp2: Vector3;
                     constructor(scale: Vector3, octaves: number, velocityMultiplier: Vector3, timeScale: Vector3);
                     initialize(particle: Particle): void;
                     update(particle: Particle, delta: number): void;
                     toJSON(): any;
                     frameUpdate(delta: number): void;
                     static fromJSON(json: any): Simulation;
                     clone(): Simulation;
                     reset(): void;
                 }

                 /**
                  * A Tween represents a series of actions that can be applied to a target object to create animations or sequences of events.
                  * @template T - The type of the target object.
                  */
                 export  class Tween<T = any> {
                     /** The object to apply the tween to. */
                     target: T;
                     /** Tags used for filtering and management. */
                     tags: string[];
                     /** Unique identifier. If specified, the old tween with the same id will be stopped. */
                     id: string;
                     tweenManager: TweenManager;
                     runningTween: RunningTween;
                     /**
                      * @param target - The object to apply the tween to.
                      */
                     constructor(target: T, tweenManager?: TweenManager);
                     /**
                      * id
                      * @param id The identifier to assign to the Tween.
                      * @returns The updated Tween instance.
                      */
                     setId(id: string): this;
                     /**
                      * 
                      * @param tags - Tags to associate with the Tween.
                      * @returns The updated Tween instance.
                      */
                     setTags(...tags: string[]): this;
                     /**
                      * 
                      * @param target - The object to apply the tween to.
                      * @returns The updated Tween instance.
                      */
                     setTarget(target: T): this;
                     /**
                      * ,  
                      * @param time - The duration of the motion in milliseconds.
                      * @param action - The motion configuration.
                      * @param config - Additional motion configuration options.
                      * @returns The updated Tween instance.
                      */
                     to(time: number, action: Motion<T>, config?: MotionConfig<T>): this;
                     /**
                      * .
                      * @param time - The duration of the motion in milliseconds.
                      * @param action - The motion configuration.
                      * @param config - Additional motion configuration options.
                      * @returns The updated Tween instance.
                      */
                     by(time: number, action: Motion<T>, config?: MotionConfig<T>): this;
                     /**
                      * 
                      * @param action - The motion configuration.
                      * @returns The updated Tween instance.
                      */
                     set(action: Motion<T>): this;
                     /**
                      * .
                      * @param callback - The callback function to execute.
                      * @returns The updated Tween instance.
                      */
                     call(callback: () => void): this;
                     /**
                      *  .delay() , 
                      * @param time - The duration of the delay in milliseconds.
                      * @returns The updated Tween instance.
                      */
                     delay(time: number): this;
                     /**
                      *  , 
                      * @param times - The number of times to repeat the action.
                      * @returns The updated Tween instance.
                      */
                     repeat(times?: number): this;
                     /**
                      * 
                      * @returns The updated Tween instance.
                      */
                     repeatForever(): this;
                     /**
                      * , , , 
                      * @param times - The number of times to yoyo the last action.
                      * @returns The updated Tween instance.
                      */
                     yoyo(times?: number): this;
                     /**
                      * 
                      * @returns The updated Tween instance.
                      */
                     yoyoForever(): this;
                     /**
                      * 
                      * @param tween - The Tween to chain.
                      * @returns The updated Tween instance.
                      */
                     then(tween: Tween<T>): this;
                     /**
                      * 
                      * @param tweens - The Tweens to run in parallel.
                      * @returns The updated Tween instance.
                      */
                     parallel(...tweens: Tween<T>[]): this;
                     /**
                      * 
                      * @param tweens - The Tweens to run in sequence.
                      * @returns The updated Tween instance.
                      */
                     sequence(...tweens: Tween<T>[]): this;
                     /**
                      *  .chain() .
                      *  @param tween - The Tween containing actions to chain.
                      * @returns The updated Tween instance.
                      */
                     chain(tween: Tween<T>): this;
                     /**
                      * .
                      * @returns A new Tween instance with the same configuration.
                      */
                     clone(): Tween<T>;
                     /**
                      * 
                      * @returns A RunningTween instance that controls the execution of the Tween.
                      */
                     start(tweenManager?: TweenManager): RunningTween<T>;
                 }

                 /**
                  * This class is responsible for managing and controlling running tweens.
                  */
                 export  class TweenManager {
                     private _running;
                     private _runningChildren;
                     /**
                      * Stop the running tween with a specific id.
                      * @param id Tween identifier.
                      */
                     stopById(id: string): void;
                     /**
                      * Stop all running tweens.
                      */
                     stopAll(): void;
                     /**
                      * Stop all running tweens with a specific tag.
                      * @param tag - The tag to filter running tweens.
                      */
                     stopAllByTag(tag: string): void;
                     /**
                      * Complete all running tweens.
                      */
                     completeAll(): void;
                     /**
                      * Complete all running tweens with a specific tag.
                      * @param tag - The tag to filter running tweens.
                      */
                     completeAllByTag(tag: string): void;
                 }

                 /**
                  * Mapping of typed array constructors by name
                  * @category ArrayBuffer
                  */
                 export  const TYPED_ARRAYS: {
                     Int8Array: Int8ArrayConstructor;
                     Uint8Array: Uint8ArrayConstructor;
                     Uint8ClampedArray: Uint8ClampedArrayConstructor;
                     Int16Array: Int16ArrayConstructor;
                     Uint16Array: Uint16ArrayConstructor;
                     Int32Array: Int32ArrayConstructor;
                     Uint32Array: Uint32ArrayConstructor;
                     Float32Array: Float32ArrayConstructor;
                     Float64Array: Float64ArrayConstructor;
                 };

                  class TypedAttributeData {
                     groupAttributes: Object[];
                     groupCount: number;
                     getType(name: String): string;
                     getTotalLength(name: String): number;
                     getGroupSet(index?: number): Object;
                     getGroupAttrArray(name: string, index?: number): Array<number>;
                     initializeArray(name: string, type: string): void;
                     clear(): void;
                     delete(key: string): void;
                     reset(): void;
                 }

                 export  function uiButton<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  function uiColor<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  function uiConfig<T = any>(uiType?: string, params?: Partial<UiObjectConfig> & {
                     params?: TParams<T>;
                     group?: string;
                 }): PropertyDecorator;

                 export  interface UiConfigContainer<TValue = any, TType extends string = string> extends IUiConfigContainer<TValue, TType> {
                     [id: string]: any;
                 }

                 export  class UiConfigMethods {
                     protected _renderer: UiConfigRendererBase;
                     constructor(_renderer: UiConfigRendererBase);
                     getBinding(config: UiObjectConfig): [any, string | number];
                     getValue<T>(config: UiObjectConfig<T>): T | undefined;
                     dispatchOnChangeSync(config: UiObjectConfig, props: {
                         last?: boolean;
                         config?: UiObjectConfig;
                         configPath?: UiObjectConfig[];
                     }, ...args: any[]): void;
                     setValue<T>(config: UiObjectConfig<T>, value: T, props: {
                         last?: boolean;
                         config?: UiObjectConfig;
                         configPath?: UiObjectConfig[];
                     }, forceOnChange?: boolean): Promise<boolean>;
                     dispatchOnChange<T>(config: UiObjectConfig<T>, props: {
                         last?: boolean;
                         config?: UiObjectConfig;
                         configPath?: UiObjectConfig[];
                     }): Promise<void>;
                     getLabel(config: UiObjectConfig): string;
                     getChildren(config: UiObjectConfig): UiObjectConfig[];
                     clickButton(config: UiObjectConfig, options?: {
                         args: any[];
                     }): Promise<void>;
                     runAtEvent<T>(config: UiObjectConfig, run: () => T | Promise<T>): Promise<T>;
                     initUiConfig(config: UiObjectConfig): void;
                 }

                 export  abstract class UiConfigRendererBase<TUiNode = any> extends SimpleEventDispatcher<"preFrame" | "preRender" | "postRender" | "postFrame"> {
                     readonly methods: UiConfigMethods;
                     readonly config: UiObjectConfig<any, "panel">;
                     protected constructor(container?: HTMLElement, autoFrameEvents?: boolean, methods?: UiConfigMethods);
                     protected _refreshQueue: Record<TUiRefreshModes, Array<[UiObjectConfig, number, string | undefined]>>;
                     private _lastModeTime;
                     refreshQueue(mode: TUiRefreshModes): void;
                     private _addToRefreshQueue;
                     dispose(): void;
                     appendChild(config?: UiObjectConfig): void;
                     removeChild(config: UiObjectConfig): void;
                     refreshRoot(deep?: boolean, mode?: TUiRefreshModes | "immediate", delay?: number): void;
                     abstract renderUiConfig(uiConfig: UiObjectConfig): void;
                     protected _root?: TUiNode;
                     /**
                      * Disposes the UI associated with a config, doesn't makes change to the object or its parent.
                      * @param config
                      * @param performDispose
                      */
                     disposeUiConfig(config?: UiObjectConfig, performDispose?: boolean): void;
                     addToRefreshQueue(mode: TUiRefreshModes | "immediate", uiConfig: UiObjectConfig, deep: boolean, delay: number): void;
                     protected abstract _refreshUiConfigObject(config: UiObjectConfig): void;
                     protected _createUiContainer(): HTMLDivElement;
                     private _flattenUiConfig;
                 }

                 export  class UiConfigTypeMap {
                     static Map: Map<ObjectConstructor, any[]>;
                 }

                 export  function uiContainer(label: string, params?: any, type?: string): <T extends new (...args: any[]) => any>(constructor: T) => {
                     new (...args: any[]): {
                         [x: string]: any;
                         uiConfig: UiObjectConfig<any, string, any>;
                     };
                 } & T;

                 export  function uiDropdown<T = any>(label?: string, children?: UiObjectConfig[], params?: TParams<T>): PropertyDecorator;

                 export  function uiFolderContainer(label: string, params?: any): <T extends new (...args: any[]) => any>(constructor: T) => {
                     new (...args: any[]): {
                         [x: string]: any;
                         uiConfig: UiObjectConfig<any, string, any>;
                     };
                 } & T;

                 export  function uiImage<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  function uiInput<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  class UiModule extends AppModuleBase implements IAppModuleBase {
                     static moduleName: string;
                     _controls: Array<IControl>;
                     _controlContainer: HTMLElement;
                     _controlPositions: Record<string, HTMLElement>;
                     options: UiModuleOptions;
                     configPane?: any;
                     constructor(app?: App, options?: UiModuleOptions);
                     onAwake(): void;
                     /**
                      * 
                      * @param cur 
                      */
                     setCursor(cur: string): void;
                     setControlMargin(opts: ControlMarginOptions): void;
                     /**
                      *  ( `control.onAdd(this)` ).
                      *
                      * @param control .
                      * @param {string} [position] . 'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`
                      */
                     addControl(control: IControl, position?: ControlPosition): App;
                     /**
                      * .
                      *
                      * @param {IControl} control .

                      */
                     removeControl(control: IControl): App;
                     /**
                      * .
                      *
                      * @param {IControl} control .
                      */
                     hasControl(control: IControl): boolean;
                     getConfigPane(opts?: {
                         /**  */
                         isReset?: boolean;
                         /**  */
                         title?: string;
                         /**  */
                         style?: Partial<CSSStyleDeclaration>;
                     }): Promise<{
                         configPane: any;
                         rootPane: any;
                         element: HTMLElement;
                         isInit: boolean;
                         setVisible: (b: any) => "" | "none";
                         isVisible: () => boolean;
                         reset: () => void;
                         appendChild: (config?: UiObjectConfig, params?: UiObjectConfig) => any;
                         renderUiConfig: (uiConfig: UiObjectConfig) => any;
                         renderUiObject: (uiConfig: UiObjectConfig, parent?: any) => any;
                         uiRefresh(deep?: boolean, mode?: TUiRefreshModes | 'immediate', delay?: number): any;
                     }>;
                     /**
                      * 
                      * - text
                      * - type  "log"
                      * - time  2500
                      */
                     logInfo(text: string, type?: logInfoType | number, time?: number): void;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  interface UiModuleOptions {
                     /**  */
                     control?: ControlMarginOptions;
                     /**  */
                     configPane?: {
                         /** body */
                         container?: HTMLElement;
                         /** true */
                         expanded?: boolean;
                         /** true */
                         autoPostFrame?: boolean;
                         /**  */
                         style?: Partial<CSSStyleDeclaration>;
                         /**  */
                         title?: string;
                     };
                 }

                 export  function uiMonitor<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  function uiNumber<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  interface UiObjectConfig<T = any, TType extends UiObjectType = UiObjectType, TTarget = any> {
                     app?: App;
                     /**
                      * An optional uuid to identify this object. If not provided, one will be generated during first render.
                      * This must be provided if a new UiObjectConfig object is generated each time the config is rendered.
                      */
                     uuid?: string;
                     /**
                      * The type of the object. This is used to determine the component to use.
                      * Examples: 'button', 'slider', 'dropdown', 'folder', 'input' etc
                      */
                     type?: TType;
                     /**
                      * The label to use for the object. This is used as the title for folders, and as the label for inputs.
                      * This can be a string or a function that returns a string.
                      * If not provided, the label will be determined automatically, by the key of the property or sets to defaults
                      */
                     label?: ValOrFunc<string>;
                     /**
                      * Children of this object. This is used for folders and dropdowns.
                      * This can be an array of UiObjectConfig objects, or an array of functions that returns an array of UiObjectConfig objects.
                      */
                     children?: Array<UiObjectConfig | Fof<ValOrArrOp<UiObjectConfig>>>;
                     /**
                      * The property to bind to. This is used for inputs.
                      * This can be an array of [target, key] or a function that returns an array of [target, key].
                      * key can be a number for arrays.
                      */
                     property?: ValOrFunc<[TTarget, StringKeyOf<TTarget> | number]>;
                     /**
                      * Alias for property
                      */
                     binding?: ValOrFunc<[TTarget, StringKeyOf<TTarget>]>;
                     /**
                      * The value of the object. This is used for inputs, if property is not provided.
                      */
                     value?: T;
                     /**
                      * getValue function. This is used for inputs, if property, value is not specified.
                      * This is called to get the value of the input on each render/update.
                      */
                     getValue?: () => T;
                     /**
                      * setValue function. This is used for inputs, if property, value is not specified.
                      * This is called when the value of the input changes.
                      * @param value - The value to set
                      * @param args - other arguments like the config, renderer, etc. See source code for details.
                      */
                     setValue?: (value: T, ...args: ChangeArgs) => void;
                     /**
                      * The Ui element will be hidden if this is true.
                      * This can be a boolean or a function that returns a boolean.
                      */
                     hidden?: ValOrFunc<boolean>;
                     /**
                      * The Ui input will be disabled if this is true, i.e. the user will not be able to change the value.
                      * This can be a boolean or a function that returns a boolean.
                      */
                     disabled?: ValOrFunc<boolean>;
                     /**
                      * The Ui input will be read-only if this is true, i.e. the user will not be able to change the value.
                      * This can be a boolean or a function that returns a boolean.
                      * This can also be achieved by setting specifying a getValue function, but not a setValue function. Or by setting disabled to true.
                      */
                     readOnly?: ValOrFunc<boolean>;
                     /**
                      * tags can be added to the config object to be used for filtering, like rendering only objects with a certain tag.
                      * This can be a string or an array of strings.
                      */
                     tags?: ValOrArr<string>;
                     /**
                      * onChange callbacks can be added to the config object to be called when the value of the object changes.
                      * This can be a function or an array of functions.
                      */
                     onChange?: ValOrArrOp<((...args: ChangeArgs) => void)>;
                     /**
                      * A function to be called when the Ui element is clicked.
                      * Only for buttons. This is an alias of config.value or config.property for buttons.
                      * @param args
                      */
                     onClick?: (...args: any[]) => void;
                     /**
                      * bounds for the value of the object. This is used for numeric inputs like number and sliders.
                      * This can be an array of [min, max] or a function that returns an array of [min, max].
                      */
                     bounds?: ValOrFunc<number[]>;
                     /**
                      * stepSize for specifying the min change in the value. This is used for numeric inputs like number and slider.
                      * The value will be rounded to the nearest multiple of stepSize.
                      * This can be a number or a function that returns a number.
                      */
                     stepSize?: ValOrFunc<number>;
                     /**
                      * Only for folders. The Ui element will be expanded if this is true.
                      * This can be a boolean or a function that returns a boolean.
                      * If this is not set to a function, config.expanded can be read to get the current state.
                      */
                     expanded?: ValOrFunc<boolean>;
                     /**
                      * Only for folders. The callback called when a folder is expanded or collapsed.
                      * @param c
                      */
                     onExpand?: (c: UiObjectConfig) => void;
                     /**
                      * Only for elements with inline picker support
                      * This can be a boolean or a function that returns a boolean.
                      */
                     inlinePicker?: ValOrFunc<boolean>;
                     /**
                      * Extra HTMLElements to be added to the UI element. This is used for customizing the UI.
                      * This can be an array of HTMLElement or a function that returns an array of HTMLElement.
                      */
                     domChildren?: HTMLElement[] | (() => HTMLElement[]);
                     /**
                      * After initial rendering, config.uiRef will be set to the instance of the UI component that's created.
                      * The type of this will depend on the type of the component and the base UI library used.
                      * This can be used to access the UI component directly, for example to add event listeners. Note that the uiRef might change on render.
                      */
                     uiRef?: any;
                     /**
                      * The type of the UI component that's referenced by config.uiRef. This is set during rendering and used to re-render the UI if config.type changes.
                      */
                     uiRefType?: UiObjectType;
                     /**
                      * After initial rendering, config.uiRefresh will be set to a function that can be used to re-render the UI.
                      * @param deep - If true, the UI will be re-rendered recursively, otherwise only the current object will be re-rendered.
                      * @param mode - The mode to re-render in. See TUiRefreshModes for details. Use when syncing with custom render loop
                      * @param delay - The delay in ms to wait before re-rendering. This is useful if multiple changes are made in quick succession. If another refresh event is in the queue for the same object, it will be postponed by this amount. This is not exact for small values.
                      */
                     uiRefresh?: (deep?: boolean, mode?: TUiRefreshModes | 'immediate', delay?: number) => void;
                     dispatchMode?: TUiRefreshModes | 'immediate';
                     /**
                      * Individual components can support custom options. These can be added to the config object.
                      */
                     [id: string]: any;
                 }

                 export  type UiObjectType = string;

                 export  function uiPanelContainer(label: string, params?: any): <T extends new (...args: any[]) => any>(constructor: T) => {
                     new (...args: any[]): {
                         [x: string]: any;
                         uiConfig: UiObjectConfig<any, string, any>;
                     };
                 } & T;

                 export  class UiPanelJsonConfig {
                     children: (Controller | UiPanelJsonConfig)[];
                     isFolder?: boolean;
                     title?: string;
                     expanded?: boolean;
                     hidden?: boolean;
                     constructor();
                     /**
                      * Adds a controller to the GUI, inferring controller type using the `typeof` operator.
                      * @example
                      * gui.add( object, 'property' );
                      * gui.add( object, 'number', 0, 100, 1 );
                      * gui.add( object, 'options', [ 1, 2, 3 ] );
                      *
                      * @param {object} object The object the controller will modify.
                      * @param {string} property Name of the property to control.
                      * @param {number|object|Array} [values] Minimum value for number controllers, or the set of
                      * selectable values for a dropdown.
                      * @param {number} [max] Maximum value for number controllers.
                      * @param {number} [step] Step value for number controllers.
                      * @returns {Controller}
                      */
                     add(object: object, property: string, values?: number | object | any[], max?: number, step?: number): Controller;
                     addBinding(object: object, property: string, opt_params?: {
                         min?: number;
                         max?: number;
                         step?: number;
                         label?: string;
                         type?: string;
                         view?: string;
                         options?: any[] | object;
                     }): Controller;
                     /**
                      * Adds a color controller to the GUI.
                      * @example
                      * params = {
                      * 	cssColor: '#ff00ff',
                      * 	rgbColor: { r: 0, g: 0.2, b: 0.4 },
                      * 	customRange: [ 0, 127, 255 ],
                      * };
                      *
                      * gui.addColor( params, 'cssColor' );
                      * gui.addColor( params, 'rgbColor' );
                      * gui.addColor( params, 'customRange', 255 );
                      *
                      * @param {object} object The object the controller will modify.
                      * @param {string} property Name of the property to control.
                      * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may
                      * need to set this to 255 if your colors are too bright.
                      * @returns {Controller}
                      */
                     addColor(object: object, property: string): Controller;
                     /**
                      * Adds a folder to the GUI, which is just another GUI. This method returns
                      * the nested GUI so you can add controllers to it.
                      * @example
                      * const folder = gui.addFolder( 'Position' );
                      * folder.add( position, 'x' );
                      * folder.add( position, 'y' );
                      * folder.add( position, 'z' );
                      *
                      * @param {string} title Name to display in the folder's title bar.
                      */
                     addFolder(title: string | {
                         title: string;
                         expanded?: boolean;
                     }): UiPanelJsonConfig;
                     /**
                      * 
                      * @example
                      * gui.addButton( "", () => console.log(1) );
                      *
                      * @param {string} title Name to display in the folder's title bar.
                      */
                     addButton(title: string, cb: Function): Controller;
                     /**
                      * 
                      */
                     addFunction(cb: Function): void;
                     /**
                      * Opens a GUI or folder. GUI and folders are open by default.
                      * @param {boolean} open Pass false to close
                      * @returns {this}
                      * @example
                      * gui.open(); // open
                      * gui.open( false ); // close
                      * gui.open( gui._closed ); // toggle
                      */
                     open(open?: boolean): this;
                     /**
                      * Shows the GUI after it's been hidden.
                      * @param {boolean} show
                      * @returns {this}
                      * @example
                      * gui.show();
                      * gui.show( false ); // hide
                      * gui.show( gui._hidden ); // toggle
                      */
                     show(show?: boolean): this;
                     toJson(): any;
                 }

                 export  function uiSlider<T = any>(label?: string, bounds?: [number, number], stepSize?: number, params?: TParams<T>): PropertyDecorator;

                 export  function uiToggle<T = any>(label?: string, params?: TParams<T>): PropertyDecorator;

                 export  function uiVector<T = any>(label?: string, bounds?: [number, number], stepSize?: number, params?: TParams<T>): PropertyDecorator;

                 export  type Uniform = {
                     [key: string]: IUniform<any>;
                 };

                  type UniformMap = {
                     [uniform: string]: IUniform<any>;
                 };

                  type UniformProps = {
                     [name: string]: UniformValue;
                 };

                  type UniformValue = CubeTexture | Texture | Int32Array | Float32Array | Matrix4 | Matrix3 | Quaternion | Vector4 | Vector3 | Vector2 | Color | number | boolean | Array<any> | null;

                  type UninitializedUniform<Value> = {
                     value: Value | null;
                 };

                 /**
                  * Units utils contains methods to convert data between representations.
                  *
                  * Multiple methods are used to reprent world coordinates based on the type of data being presented.
                  *
                  * WGS84 is the most commonly used representation with (latitude, longitude, altitude).
                  *
                  * EPSG:900913 is used for planar coordinates in (X, Y, Z)
                  */
                 export  class UnitsUtils {
                     static EARTH_RADIUS: number;
                     /**
                      * Earth equator perimeter in meters.
                      */
                     static EARTH_PERIMETER: number;
                     /**
                      * Earth equator perimeter in meters.
                      */
                     static EARTH_ORIGIN: number;
                     /**
                      * Converts coordinates from WGS84 Datum to XY in Spherical Mercator EPSG:900913.
                      *
                      * @param latitude - Latitude value in degrees.
                      * @param longitude - Longitude value in degrees.
                      */
                     /**
                      * Converts XY point from Spherical Mercator EPSG:900913 to WGS84 Datum.
                      *
                      * @param x - X coordinate.
                      * @param y - Y coordinate.
                      */
                     /**
                      * Converts quad tree zoom/x/y to lat/lon in WGS84 Datum.
                      *
                      * The X and Y start from 0 from the top/left corner of the quadtree up to (4^zoom - 1)
                      *
                      * @param zoom - Zoom level of the quad tree.
                      * @param x - X coordinate.
                      * @param y - Y coordinate.
                      */
                     /**
                      * Direction vector to WGS84 coordinates.
                      *
                      * Can be used to transform surface points of world sphere to coordinates.
                      *
                      * @param dir - Direction vector.
                      * @returns WGS84 coordinates.
                      */
                     /**
                      * Get a direction vector from WGS84 coordinates.
                      *
                      * The vector obtained will be normalized.
                      *
                      * @param latitude - Latitude value in degrees.
                      * @param longitude - Longitude value in degrees.
                      * @returns Direction vector normalized.
                      */
                     /**
                      * Get altitude from RGB color for mapbox altitude encoding
                      *
                      * https://docs.mapbox.com/data/tilesets/guides/access-elevation-data/~
                      *
                      * @param color - Color of the pixel
                      * @returns The altitude encoded in meters.
                      */
                     static mapboxAltitude(color: Color): number;
                 }

                 export  function unloadParticlePlugin(pluginId: string): void;

                 /**
                  * 
                  * number  (-1  1 )
                  * boolean undefined false , true
                  * Plane xz xy
                  * Vector3 
                  * Object3D[] 
                  * object  
                  */
                 export  type UnProjectOpts = number | Plane | Vector3 | boolean | Object3D[] | {
                     include?: Object3D[];
                     exclude: Object3D[];
                 };

                 /**
                  * Returns the inner value if the argument is a ref, otherwise return the
                  * argument itself. This is a sugar function for
                  * `val = isRef(val) ? val.value : val`.
                  *
                  * @example
                  * ```js
                  * function useFoo(x: number | Ref<number>) {
                  *   const unwrapped = unref(x)
                  *   // unwrapped is guaranteed to be number now
                  * }
                  * ```
                  *
                  * @param ref - Ref or plain value to be converted into the plain value.
                  */
                  function unref<T>(ref: MaybeRef<T>): T;

                  type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>;

                  type UnwrapRef<T> = T extends ShallowRef<infer V> ? V : T extends Ref<infer V> ? UnwrapRefSimple<V> : UnwrapRefSimple<T>;

                  type UnwrapRefSimple<T> = T extends Function | CollectionTypes | BaseTypes | Ref | RefUnwrapBailTypes[keyof RefUnwrapBailTypes] | {
                     [RawSymbol]?: true;
                 } ? T : T extends readonly any[] ? {
                     [K in keyof T]: UnwrapRefSimple<T[K]>;
                 } : T extends object & {
                     [ShallowReactiveMarker]?: never;
                 } ? {
                     [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>;
                 } : T;

                 /**
                  * Updates the bit at the given position to the given value.
                  * @param number - the number to update
                  * @param bitPosition - the bit position to update from the least significant bit (0) to most significant bit (31)
                  * @param bitValue - 0 or 1
                  */
                 export  function updateBit(number: number, bitPosition: number, bitValue: number): number;

                 export  class UpdateValueCommand<T extends IHasUpdate, K extends keyof T> extends BaseCommand {
                     private object;
                     private attributeName;
                     private newValue;
                     private oldValue;
                     constructor(object: T, attributeName: K, newValue: T[K], oldValue?: T[K]);
                     execute(): void;
                     undo(): void;
                     redo(): void;
                 }

                 /**
                  * Prompt the user to select a file or directory in the browser.
                  * @param multiple - allow multiple files
                  * @param directory - allow directory
                  * @param accept - file types to accept (default: all), e.g. 'image/*'
                  * @category Browser
                  */
                 export  function uploadFile(multiple?: boolean, directory?: boolean, accept?: string): Promise<File[]>;

                 /**  */
                 export  function uploadFileGetContent(accept?: string, asBlob?: number): Promise<any>;

                 export  function useFBO(
                 /** Width in pixels */
                 width?: number, 
                 /** Height in pixels */
                 height?: number, 
                 /**Settings */
                 settings?: FBOSettings): WebGLRenderTarget;

                 export  class UvAtlasWebWorker extends BaseUvAtlas {
                     init(onLoad: () => void, onProgress: (mode: any, progress: any) => void, wasmFilePath: string, workerFilePath?: string): void;
                 }

                 export  class UVUnwrapper extends BaseUVUnwrapper {
                     protected _createUvAtlas(): any;
                 }

                  function validateBounds(bvh: MeshBVH): boolean;

                 /**
                  * Type for a value of type T or an array of values of type T
                  */
                 export  type ValOrArr<T> = T | T[];

                 /**
                  * Type for a value of type `T|undefined` or an array of values of type `T|undefined`
                  */
                 export  type ValOrArrOp<T> = ValOrArr<T | undefined>;

                 /**
                  * Type for a value of type T or a function that returns a value of type T
                  */
                 export  type ValOrFunc<T, TArgs extends any[] = any[]> = T | Fof<T, TArgs>;

                 export  interface ValueGenerator {
                     type: 'value';
                     genValue(): number;
                     toJSON(): FunctionJSON;
                     clone(): ValueGenerator;
                 }

                 export  function ValueGeneratorFromJSON(json: FunctionJSON): FunctionValueGenerator | ValueGenerator;

                  type ValueType = 0 | 1 | 2 | 3 | 4 | 5 | 6;

                 /**
                  * @description  curve, radiusArr, 20, valuesArr, mapValuesArr, LUT
                  * @param curve <CatmullRomCurve3>  
                  * @param radiusArr <Array> [[''<Number>,''<Number>]...] ,
                  * @param radialSegments <Number>  8
                  * @param valuesArr <Array> [''<Number>,''<Number>] ,
                  * @param mapValuesArr <Array>  [''<Number>,''<Number>] 
                  * @param LUT <Lut> 
                  */
                 export  class VariableTubeGeometry extends BufferGeometry {
                     constructor(path: CatmullRomCurve3, radiusArr: [number, number][], radialSegments?: number, valuesArr?: number[], mapValuesArr?: number[], lut?: Lut);
                 }

                 /**
                  * 3-dimensional vector
                  * @example
                  *     const v = new Vec3(1, 2, 3)
                  *     console.log('x=' + v.x) // x=1
                  */
                  class Vec3 {
                     x: number;
                     y: number;
                     z: number;
                     static ZERO: Vec3;
                     static UNIT_X: Vec3;
                     static UNIT_Y: Vec3;
                     static UNIT_Z: Vec3;
                     constructor(x?: number, y?: number, z?: number);
                     /**
                      * Vector cross product
                      * @param target Optional target to save in.
                      */
                     cross(vector: Vec3, target?: Vec3): Vec3;
                     /**
                      * Set the vectors' 3 elements
                      */
                     set(x: number, y: number, z: number): Vec3;
                     /**
                      * Set all components of the vector to zero.
                      */
                     setZero(): void;
                     /**
                      * Vector addition
                      */
                     vadd(vector: Vec3): Vec3;
                     vadd(vector: Vec3, target: Vec3): void;
                     /**
                      * Vector subtraction
                      * @param target Optional target to save in.
                      */
                     vsub(vector: Vec3): Vec3;
                     vsub(vector: Vec3, target: Vec3): void;
                     /**
                      * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
                      *
                      * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
                      */
                     crossmat(): Mat3;
                     /**
                      * Normalize the vector. Note that this changes the values in the vector.

                      * @return Returns the norm of the vector
                      */
                     normalize(): number;
                     /**
                      * Get the version of this vector that is of length 1.
                      * @param target Optional target to save in
                      * @return Returns the unit vector
                      */
                     unit(target?: Vec3): Vec3;
                     /**
                      * Get the length of the vector
                      */
                     length(): number;
                     /**
                      * Get the squared length of the vector.
                      */
                     lengthSquared(): number;
                     /**
                      * Get distance from this point to another point
                      */
                     distanceTo(p: Vec3): number;
                     /**
                      * Get squared distance from this point to another point
                      */
                     distanceSquared(p: Vec3): number;
                     /**
                      * Multiply all the components of the vector with a scalar.
                      * @param target The vector to save the result in.
                      */
                     scale(scalar: number, target?: Vec3): Vec3;
                     /**
                      * Multiply the vector with an other vector, component-wise.
                      * @param target The vector to save the result in.
                      */
                     vmul(vector: Vec3, target?: Vec3): Vec3;
                     /**
                      * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
                      * @param target The vector to save the result in.
                      */
                     addScaledVector(scalar: number, vector: Vec3, target?: Vec3): Vec3;
                     /**
                      * Calculate dot product
                      * @param vector
                      */
                     dot(vector: Vec3): number;
                     isZero(): boolean;
                     /**
                      * Make the vector point in the opposite direction.
                      * @param target Optional target to save in
                      */
                     negate(target?: Vec3): Vec3;
                     /**
                      * Compute two artificial tangents to the vector
                      * @param t1 Vector object to save the first tangent in
                      * @param t2 Vector object to save the second tangent in
                      */
                     tangents(t1: Vec3, t2: Vec3): void;
                     /**
                      * Converts to a more readable format
                      */
                     toString(): string;
                     /**
                      * Converts to an array
                      */
                     toArray(): [number, number, number];
                     /**
                      * Copies value of source to this vector.
                      */
                     copy(vector: Vec3): Vec3;
                     /**
                      * Do a linear interpolation between two vectors
                      * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
                      */
                     lerp(vector: Vec3, t: number, target: Vec3): void;
                     /**
                      * Check if a vector equals is almost equal to another one.
                      */
                     almostEquals(vector: Vec3, precision?: number): boolean;
                     /**
                      * Check if a vector is almost zero
                      */
                     almostZero(precision?: number): boolean;
                     /**
                      * Check if the vector is anti-parallel to another vector.
                      * @param precision Set to zero for exact comparisons
                      */
                     isAntiparallelTo(vector: Vec3, precision?: number): boolean;
                     /**
                      * Clone the vector
                      */
                     clone(): Vec3;
                 }

                 /**
                  * Vec3Pool
                  */
                  class Vec3Pool extends Pool {
                     type: typeof Vec3;
                     /**
                      * Construct a vector
                      */
                     constructObject(): Vec3;
                 }

                  namespace vector {
                     export {
                         create_2 as create,
                         copy_2 as copy,
                         clone_2 as clone,
                         set,
                         add,
                         scaleAndAdd,
                         sub,
                         len,
                         lenSquare,
                         mul_2 as mul,
                         div,
                         dot,
                         scale_2 as scale,
                         normalize,
                         distance,
                         distanceSquare,
                         negate,
                         lerp_2 as lerp,
                         applyTransform,
                         min,
                         max,
                         VectorArray,
                         length_2 as length,
                         lengthSquare,
                         dist,
                         distSquare
                     }
                 }

                  type VectorArray = number[];

                 /**
                  * Base class for VFX batches.
                  */
                 export  abstract class VFXBatch extends Mesh {
                     type: string;
                     systems: Set<IParticleSystem>;
                     material: ShaderMaterial;
                     settings: StoredBatchSettings;
                     protected maxParticles: any;
                     protected constructor(settings: VFXBatchSettings);
                     addSystem(system: IParticleSystem): void;
                     removeSystem(system: IParticleSystem): void;
                     applyDepthTexture(depthTexture: Texture | null): void;
                     abstract setupBuffers(): void;
                     abstract expandBuffers(target: number): void;
                     abstract rebuildMaterial(): void;
                     abstract update(): void;
                     abstract dispose(): void;
                 }

                 /**
                  * the settings for rendering a batch of VFX system.
                  */
                 export  interface VFXBatchSettings {
                     /**
                      * Geometry for instancing.
                      * @type {BufferGeometry}
                      */
                     instancingGeometry: BufferGeometry;
                     /**
                      * Material for rendering.
                      * @type {Material}
                      */
                     material: Material;
                     /**
                      * Number of horizontal tiles in the texture.
                      * @type {number}
                      */
                     uTileCount: number;
                     /**
                      * Number of vertical tiles in the texture.
                      * @type {number}
                      */
                     vTileCount: number;
                     /**
                      * Whether to blend tiles.
                      * @type {boolean}
                      */
                     blendTiles: boolean;
                     /**
                      * Enable soft particles.
                      * @type {boolean}
                      */
                     softParticles: boolean;
                     /**
                      * Near fade distance for soft particles.
                      * @type {number}
                      */
                     softNearFade: number;
                     /**
                      * Far fade distance for soft particles.
                      * @type {number}
                      */
                     softFarFade: number;
                     /**
                      * Render mode.
                      * @type {RenderMode}
                      */
                     renderMode: RenderMode;
                     /**
                      * Render order.
                      * @type {number}
                      */
                     renderOrder: number;
                     /**
                      * layers control visibility of the object.
                      * @type {Layers}
                      * @see {@link https://threejs.org/docs/index.html#api/en/core/Layers | Official Documentation}
                      * @see {@link https://github.com/mrdoob/three.js/blob/master/src/core/Layers.js | Source}
                      */
                     layers: Layers;
                 }

                 export  interface VFXParameters {
                     autoDestroy?: boolean;
                     looping?: boolean;
                     prewarm?: boolean;
                     duration?: number;
                     emissionGraph: NodeGraph;
                     updateGraph: NodeGraph;
                     instancingGeometry?: BufferGeometry;
                     renderMode?: RenderMode;
                     rendererEmitterSettings?: TrailSettings | MeshSettings | BillBoardSettings;
                     speedFactor?: number;
                     material: Material;
                     layers?: Layers;
                     renderOrder?: number;
                     worldSpace?: boolean;
                 }

                  class VideoLoader extends Loader {
                     static autoplay: boolean;
                     static preload: "" | "none" | "metadata" | "auto";
                     static muted: boolean;
                     static loop: boolean;
                     constructor(manager?: LoadingManager);
                     load(url: string, onLoad?: (video: HTMLVideoElement) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: string | Event) => void): HTMLVideoElement;
                 }

                 export  class ViewHelper extends Object3D {
                     isViewHelper: boolean;
                     animating: boolean;
                     center: Vector3;
                     viewSize: number;
                     render: (renderer: any) => void;
                     dispose: () => void;
                     handleClick: (event: any) => Promise<boolean>;
                     container: HTMLElement;
                     constructor(app: App, position?: "leftTop" | "rightTop" | "leftBottom" | "rightBottom", size?: number);
                 }

                  namespace vjmap3d {
                     export {
                         computeBoundsTree,
                         disposeBoundsTree,
                         acceleratedRaycast,
                         SMAAEffect,
                         EdgeDetectionMode,
                         LambdaPass,
                         FXAAEffect,
                         KernelSize,
                         PredicationMode,
                         SMAAPreset,
                         BloomEffect,
                         KawaseBlurPass,
                         ToneMappingEffect,
                         ToneMappingMode,
                         DepthOfFieldEffect,
                         ChromaticAberrationEffect,
                         GlitchEffect,
                         GlitchMode,
                         GodRaysEffect,
                         PixelationEffect,
                         SSAOEffect,
                         NormalPass,
                         OverrideMaterialManager,
                         EffectComposer,
                         DotScreenEffect,
                         DepthPickingPass,
                         TextureEffect,
                         Effect,
                         ColorDepthEffect,
                         CopyPass,
                         DepthPass,
                         BlendFunction,
                         ShaderPass,
                         EffectAttribute,
                         EffectPass,
                         OutlineEffect,
                         RenderPass,
                         Pass,
                         SelectiveBloomEffect,
                         reactivity,
                         render2d,
                         __buildDate,
                         __buildVersion,
                         __buildVerNo,
                         __DEV,
                         deleteArrItem,
                         generateUUID,
                         cloneDeep,
                         pick,
                         bindAll,
                         extend,
                         strMd5,
                         sleep,
                         pushObjectStatus,
                         throttle,
                         debounce,
                         applyMixins,
                         BidirectionalMap,
                         isObjectBehindCamera,
                         cameraDistance2NdcZ,
                         isObjectOcclude,
                         addResourceRefCount,
                         disposeObject3D,
                         containSkeleton,
                         objectTransformToMatrix,
                         getBoundingBox,
                         getObjectAnchorPoint,
                         disableRayQuery,
                         disableSelected,
                         disableBloom,
                         disableOutline,
                         disableBloomSelectedRayQuery,
                         Anchor3d,
                         getObjectRefCount,
                         ObjectTransform,
                         resetUV,
                         cameraWorldDirection,
                         randColor,
                         randHtmlColor,
                         randPoint3D,
                         randPoint2D,
                         isMapMode,
                         createScreenSpaceEntity,
                         object2Entity,
                         getOwerScene,
                         getObjectOwnerEntity,
                         getEntityParents,
                         IUniformB,
                         IUniformN,
                         IUniformNArray,
                         IUniformV2,
                         IUniformV3,
                         IUniformV3Array,
                         IUniformColor,
                         IUniformTexture,
                         HighlightMaterialOption,
                         traverseMaterial,
                         cloneMaterial,
                         disposeMaterial,
                         setMaterialOpacity,
                         enableMaterialVerticeOpacity,
                         toWorld,
                         fromWorld,
                         toDist,
                         fromDist,
                         clamp,
                         lerp,
                         lerpEuler,
                         approxZero,
                         approxEquals,
                         maxValue,
                         minValue,
                         randInt,
                         approxArrayEquals,
                         roundToStep,
                         infinityToMaxNumber,
                         maxNumberToInfinity,
                         max3,
                         min3,
                         max2,
                         min2,
                         smoothPoints,
                         toVector3,
                         getFilterColorMatrix,
                         degToRad,
                         radToDeg,
                         DEG2RAD,
                         RAD2DEG,
                         FilterColorOptions,
                         expandLine,
                         pointDistance,
                         lineDistance,
                         lineSlice,
                         interpolatePointsByRatio,
                         BitSet,
                         isLeftButton,
                         isMiddleButton,
                         isRightButton,
                         isShiftKeyDown,
                         isCtrlKeyDown,
                         isAltKeyDown,
                         eventKeyCode,
                         isEnterKey,
                         isEscKey,
                         isDeleteKey,
                         preventDefaultEvent,
                         eventXY,
                         textureDataToImageData,
                         renderTargetToDataUrl,
                         textureToDataUrl,
                         textureToCanvas,
                         texImageToCanvas,
                         exportRenderTarget,
                         loadImage,
                         DOM,
                         addScript,
                         ScriptDefaultOptions,
                         lerpCoordinates,
                         dist2d,
                         offsetCoords,
                         segmentIntersect3d,
                         line3dSplit,
                         multiLine3dSplit,
                         isPointInPolygon,
                         intersectLine3D,
                         getFullscreenTriangle,
                         getSphericalCube,
                         getScreenSpaceBox,
                         getFrustum,
                         getFrustumFromHeight,
                         lerpCameras,
                         createUnProjectMenu,
                         explodeGroup,
                         enableSRGBColorSpace,
                         optimizeModelRender,
                         enableRealisticRender,
                         enableShadow,
                         getEnvmapFromHDRTexture,
                         getEnvmapFromScene,
                         flatModel,
                         Graph,
                         buildTopoGraph,
                         buildPathTubeTopo,
                         findShortestPath,
                         EventDispatcher,
                         Logger,
                         DependencyError,
                         Time,
                         ModuleManager,
                         AppBaseOptions,
                         AppBase,
                         IAppModuleBase,
                         AppModuleBase,
                         AppModuleConstructor,
                         AppObject,
                         IModuleBase,
                         OrderIndex,
                         ModuleBase,
                         EntityBaseOptions,
                         EntityBase,
                         InteractiveEvent,
                         DispatchEvent,
                         IEntityModuleBase,
                         EntityModuleBase,
                         EntityModuleConstructor,
                         findSignalHandlerIndexByHandle,
                         findSignalHandlerIndexByHandleAndContext,
                         dispatchViaProxy,
                         SignalHandler,
                         Signal,
                         Store,
                         CancelledCommandException,
                         Scheduler,
                         createWorker,
                         workerWrap,
                         workerProxy,
                         workerTransfer,
                         workerLink,
                         createWorkerWrap,
                         geoBounds,
                         GeoBounds,
                         geoPoint,
                         GeoPoint,
                         GeoPointLike,
                         isGeoPointLike,
                         Projection,
                         GeoProjection,
                         transform,
                         InterpolationOptions,
                         Interpolation,
                         triangulate,
                         triangulatFlatten,
                         offsetPolygon,
                         extrudePolygon,
                         extrudePolyline,
                         extrudeGeoJSON,
                         lineIntersection,
                         triangle2dArea,
                         simplifyPoints,
                         pointToSegmentDistance,
                         closestPointOnSegment,
                         closestToSegment3d,
                         closestPointOnPolyline,
                         closestPointOnPolylines,
                         segmentIntersect,
                         lineSplit,
                         multiLineSplit,
                         Screenshot,
                         IWebGLRendererModule,
                         WebGLRendererModuleOptions,
                         WebGLRendererModule,
                         ICameraModule,
                         CameraOptions,
                         CameraModuleOptions,
                         CameraModule,
                         EnvConfigOption,
                         loadResourcesOptions,
                         ISceneModule,
                         BackgroundTexture,
                         BackgroundEnvironmentOptions,
                         SceneModuleOptions,
                         SceneModule,
                         IOrbitControlModule,
                         OrbitControlModuleOptions,
                         OrbitControlModule,
                         IStatModule,
                         StatModuleOptions,
                         StatModule,
                         PostProcessModuleOptions,
                         IPostProcessModule,
                         PostProcessModule,
                         InputModuleOptions,
                         IInputModule,
                         InputModule,
                         ICoordSystemModule,
                         CoordSystemOption,
                         UnProjectOpts,
                         CoordSystemModule,
                         ICSS2DRendererModule,
                         CSS2DRendererModuleOptions,
                         CSS2DRendererModule,
                         ICSS3DRendererModule,
                         CSS3DRendererModuleOptions,
                         CSS3DRendererModule,
                         IEntityManagerModule,
                         EntityManagerModule,
                         EntityOutlineModuleOptions,
                         EntityOutlineModule,
                         IEntityQueryModule,
                         EntityQueryOption,
                         InteractiveObject,
                         EntityQueryModule,
                         IDrawPointEnterOptions,
                         IDrawLineEnterOptions,
                         IDrawPolygonEnterOptions,
                         IDrawEditEnterOptions,
                         IPickModule,
                         PickPointOptions,
                         PickEntityOptions,
                         PickModule,
                         ICommandModule,
                         CommandModuleOptions,
                         CommandModule,
                         IParticleRenderModule,
                         ParticleRenderModuleOptions,
                         ParticleRenderModule,
                         IRectCollide,
                         IRectCollideModule,
                         RectCollideModuleOptions,
                         RectCollideModule,
                         IToolStateModule,
                         ToolStateModuleOptions,
                         ToolStateModule,
                         IPhysicsManagerModule,
                         PhysicsManagerModuleOptions,
                         PhysicsBodyOption,
                         MeshPhysicsObject,
                         MeshPhysicsObjectParams,
                         PhysicsManagerModule,
                         ControlPosition,
                         IControl,
                         logInfoType,
                         IUiModule,
                         ControlMarginOptions,
                         UiModuleOptions,
                         UiModule,
                         CameraState,
                         CameraControls,
                         GridHelperModuleOptions,
                         GridHelperModule,
                         MeshModuleOption,
                         MeshModule,
                         InstancedMeshModuleOption,
                         DynamicInstancedMesh,
                         InstancedMeshModule,
                         SymbolItemData,
                         SymbolModuleOption,
                         BetterRaycastingPoints,
                         SymbolModule,
                         BillboardModule,
                         OutlineModule,
                         SpriteAnimatorModule,
                         PolylineItemData,
                         PolylinesModuleOption,
                         PolylinesModule,
                         PolygonItemData,
                         PolygonsModuleOption,
                         PolygonsModule,
                         FillExtrusionItemData,
                         FillExtrusionsModuleOption,
                         FillExtrusionsModule,
                         GlLineItemData,
                         GlLinesModuleOption,
                         GlLinesModule,
                         BehaviorModule,
                         SpriteMarkerModule,
                         SpriteImagesModule,
                         SpriteTextsModule,
                         ParticleModuleOption,
                         ParticleModule,
                         AnimatorModuleOptions,
                         AnimatorModule,
                         ModelModuleOptions,
                         ModelModule,
                         EventModuleOptions,
                         EventModule,
                         PhysicsModule,
                         PathAnimateModuleOptions,
                         PathAnimateModule,
                         AppOptions,
                         App,
                         EntityOptions,
                         RayQueryType,
                         Entity,
                         LoadDetail,
                         ResStatus,
                         LoadUnit,
                         LoaderManagerOptions,
                         LoaderManager,
                         ILoadModelOption,
                         ResourceItem,
                         RosourceItemsReturnType,
                         ResourceManager,
                         LoadManager,
                         ResManager,
                         AlgorithmPluginType,
                         Tiles3dPluginType,
                         LoadPluginOpts,
                         PluginManager,
                         Plugins,
                         loadPluginAlgorithm,
                         loadPlugin3dtiles,
                         IEvent,
                         IEventDispatcher,
                         ImageCanvasOptions,
                         AnyFunction,
                         AnyOptions,
                         Class,
                         IDisposable,
                         IJSONSerializable,
                         PartialPick,
                         PartialRecord,
                         StringKeyOf,
                         Fof,
                         ValOrFunc,
                         ValOrArr,
                         ValOrArrOp,
                         Serializer,
                         PointerDragHelper,
                         SimpleEventDispatcher,
                         createCanvasElement,
                         createDiv,
                         createImage,
                         createStyles,
                         createScriptFromURL,
                         TYPED_ARRAYS,
                         arrayBufferToBase64,
                         base64ToArrayBuffer,
                         getTypedArray,
                         escapeRegExp,
                         getFilenameFromPath,
                         parseFileExtension,
                         replaceAll,
                         toTitleCase,
                         longestCommonPrefix,
                         prettyScrollbar,
                         blobToDataURL,
                         downloadBlob,
                         downloadFile,
                         uploadFile,
                         mobileAndTabletCheck,
                         uploadFileGetContent,
                         LinearToSRGB,
                         SRGBToLinear,
                         colorToDataUrl,
                         onChange,
                         onChange2,
                         onChange3,
                         serialize,
                         serializable,
                         aesGcmDecrypt,
                         aesGcmEncrypt,
                         embedUrlRefs,
                         htmlToCanvas,
                         htmlToPng,
                         htmlToSvg,
                         imageToCanvas,
                         imageBitmapToBase64,
                         imageUrlToImageData,
                         imageDataToCanvas,
                         canvasFlipY,
                         isWebpExportSupported,
                         absMax,
                         clearBit,
                         updateBit,
                         includesAll,
                         copyProps,
                         getOrCall,
                         getPropertyDescriptor,
                         isPropertyWritable,
                         safeSetProperty,
                         deepAccessObject,
                         getKeyByValue,
                         objectHasOwn,
                         makeColorSvg,
                         makeTextSvg,
                         makeColorSvgCircle,
                         svgToCanvas,
                         svgToPng,
                         timeout,
                         now,
                         pathJoin,
                         getUrlQueryParam,
                         setUrlQueryParam,
                         remoteWorkerURL,
                         css,
                         glsl,
                         html,
                         svgUrl,
                         Serialization,
                         BaseUvAtlas,
                         UvAtlasWebWorker,
                         PackOptions,
                         ChartOptions,
                         BaseUVUnwrapper,
                         UVUnwrapper,
                         GridProps,
                         GridType,
                         Grid,
                         ViewHelper,
                         ShadertoyMaterialParameters,
                         ShadertoyMaterial,
                         shaderMaterial,
                         convertToMaterialParameters,
                         FixedSizeMeshMaterial,
                         highlightMaterial,
                         SymbolMaterialProps,
                         createSymbolMaterial,
                         FlowMaterialProps,
                         FlowMaterial,
                         TextFlowMaterialOptions,
                         RenderElementFlowMaterialOptions,
                         createRenderElementFlowMaterial,
                         createTextFlowMaterial,
                         AnimatorFrameMaterialProps,
                         AnimatorFrameMaterial,
                         createAnimatorFrameSpriteMaterial,
                         MeshReflectorMaterialConfig,
                         MeshReflectorMaterial,
                         ConvolutionMaterial,
                         MeshTransmissionMaterialConfig,
                         FBOConfig,
                         MeshTransmissionMaterial,
                         CustomShaderMaterial,
                         MaterialConstructor,
                         iCSMPatchMap,
                         iCSMParams,
                         iCSMUpdateParams,
                         iCSMInternals,
                         Uniform,
                         iCSMShader,
                         createFlowGradientMaterial,
                         RadarMaterialProps,
                         RadarMaterial,
                         HolographicMaterial,
                         ReflectorMaterial,
                         ReflectorDudvMaterial,
                         Render2dTextureOptions,
                         createRender2dTexture,
                         useFBO,
                         Render3dTextureOptions,
                         Render3dTexture,
                         ShadertoyTextureItemOptions,
                         ShadertoyTextureOptions,
                         ShadertoyTexture,
                         BufferShader,
                         CharInfo,
                         AtlasData,
                         CharLayoutInfo,
                         LayoutInfo,
                         FontManagerOptions,
                         FontManager,
                         LabelMaterial,
                         Label,
                         LabelPool,
                         LabelOptions,
                         createLabel,
                         ExtrudePath,
                         ExtrudeMeshProps,
                         ExtrudeMesh,
                         MeshLineGeometry,
                         MeshLineMaterial,
                         MeshLine,
                         PathPointList,
                         PathGeometry,
                         PathTubeGeometry,
                         PathTubeEntitiesOptions,
                         PathTubeEntities,
                         BillboardProps,
                         BillboardType,
                         Billboard,
                         Outlines,
                         OutlinesProps,
                         OutlinesType,
                         TextProps,
                         TextType,
                         createTextMesh,
                         SpriteAnimatorProps,
                         SpriteAnimatorType,
                         createSpriteAnimator,
                         TrailLineOptions,
                         TrailLine,
                         Line2,
                         LineGeometry,
                         LineMaterialParameters,
                         LineMaterial,
                         LineSegments2,
                         LineSegmentsGeometry,
                         Wireframe,
                         WireframeGeometry2,
                         SpriteMarkerOptions,
                         SpriteMarker,
                         SpriteImageItemData,
                         SpriteImageItem,
                         SpriteImagesOptions,
                         SpriteImages,
                         SpriteTextItemData,
                         SpriteTextItem,
                         SpriteTextsOptions,
                         SpriteTexts,
                         AnimationClipOptions,
                         AnimatorOptions,
                         Animator,
                         PlaneConfig,
                         ScreenQuad,
                         BoxHelperOptions,
                         BoxHelper,
                         HeatmapOptions,
                         Heatmap,
                         ReflectorBlurMaterial,
                         ReflectorObject,
                         createReflectorShaderMesh,
                         MeasureRulerOptions,
                         creataMeasureRuler,
                         Environment,
                         PackedMipMapGenerator,
                         FullScreenQuad,
                         DynamicEnvConfig,
                         DynamicEnvironment,
                         createFlyline,
                         createMapApp,
                         map2dUtils,
                         MapThreeLayerOptions,
                         MapThreeLayer,
                         VariableTubeGeometry,
                         HyperbolicHelicoidGeometry,
                         SphubeGeometry,
                         createWallBufferGeometry,
                         MapView,
                         LODControl,
                         LODRaycast,
                         MapProvider,
                         MapNodeGeometry,
                         MapNodeHeightGeometry,
                         MapNode,
                         QuadTreePosition,
                         MapHeightNode,
                         MapPlaneNode,
                         UnitsUtils,
                         MapUtils,
                         CanvasUtils,
                         CancelablePromise,
                         XHRUtils,
                         TextureUtils,
                         MapViewEntity,
                         AllowedTypes,
                         Omitype,
                         PickType,
                         TransformType,
                         TransformedTypes,
                         FilteredType,
                         Motion,
                         MotionConfig,
                         EasingFunction,
                         Easing,
                         DEFAULT_EASING,
                         Easings,
                         RunningTween,
                         Tween,
                         TweenManager,
                         animation,
                         animationAsync,
                         MeshEntityOptions,
                         MeshEntity,
                         InstancedMeshEntityOptions,
                         InstancedMeshEntity,
                         SymbolEntityOptions,
                         SymbolEntity,
                         SpriteAnimatorEntityOptions,
                         SpriteAnimatorEntity,
                         PolylinesEntityOptions,
                         PolylinesEntity,
                         PolygonsEntityOptions,
                         PolygonsEntity,
                         FillExtrusionsEntityOptions,
                         FillExtrusionsEntity,
                         GlLinesEntityOptions,
                         GlLinesEntity,
                         SpriteMarkerEntityOptions,
                         SpriteMarkerEntity,
                         SpriteImagesEntityOptions,
                         SpriteImagesEntity,
                         SpriteTextsEntityOptions,
                         SpriteTextsEntity,
                         TrailLineEntityOptions,
                         TrailLineEntity,
                         MetaData,
                         ParticleEmitter,
                         IParticle,
                         Particle,
                         NodeParticle,
                         SpriteParticle,
                         RecordState,
                         TrailParticle,
                         BurstParameters,
                         BurstParametersJSON,
                         ParticleSystemParameters,
                         ParticleSystemJSONParameters,
                         JsonMetaData,
                         EmissionState,
                         ParticleSystem,
                         StoredBatchSettings,
                         RenderMode,
                         VFXBatch,
                         SpriteBatch,
                         TrailBatch,
                         VFXBatchSettings,
                         SerializationOptions,
                         RendererEmitterSettings,
                         StretchedBillBoardSettings,
                         BillBoardSettings,
                         TrailSettings,
                         MeshSettings,
                         IParticleSystem,
                         BatchedRenderer,
                         ParticleLoader,
                         Constructable,
                         FieldType,
                         ParameterType,
                         ParameterPair,
                         loadParticlePlugin,
                         unloadParticlePlugin,
                         ParticlePlugin,
                         ParticlePlugins,
                         getValueFromEmitterMode,
                         ShapeJSON,
                         EmitterMode,
                         EmitterShape,
                         ConeEmitterParameters,
                         ConeEmitter,
                         CircleEmitterParameters,
                         CircleEmitter,
                         DonutEmitterParameters,
                         DonutEmitter,
                         PointEmitter,
                         SphereEmitterParameters,
                         SphereEmitter,
                         HemisphereEmitterParameters,
                         HemisphereEmitter,
                         GridEmitterParameters,
                         GridEmitter,
                         MeshSurfaceEmitter,
                         EmitterFromJSON,
                         EmitterShapeParticlePlugin,
                         EmitterShapes,
                         Bezier,
                         ColorGeneratorFromJSON,
                         ColorGenerator,
                         FunctionColorGenerator,
                         MemorizedFunctionColorGenerator,
                         ConstantColor,
                         ColorRange,
                         ConstantValue,
                         FunctionJSON,
                         Gradient,
                         RandomColorBetweenGradient,
                         IntervalValue,
                         PiecewiseBezier,
                         PiecewiseFunction,
                         RandomColor,
                         ValueGeneratorFromJSON,
                         ValueGenerator,
                         FunctionValueGenerator,
                         RandomQuatGenerator,
                         AxisAngleGenerator,
                         RotationGeneratorFromJSON,
                         RotationGenerator,
                         EulerGenerator,
                         GeneratorFromJSON,
                         ColorOverLife,
                         RotationOverLife,
                         Rotation3DOverLife,
                         ForceOverLife,
                         SizeOverLife,
                         SpeedOverLife,
                         FrameOverLife,
                         OrbitOverLife,
                         WidthOverLength,
                         ApplyForce,
                         GravityForce,
                         ChangeEmitDirection,
                         SubParticleEmitMode,
                         EmitSubParticleSystem,
                         TurbulenceField,
                         Noise,
                         ApplySequences,
                         setPhysicsResolver,
                         getPhysicsResolver,
                         ApplyCollision,
                         ColorBySpeed,
                         SizeBySpeed,
                         RotationBySpeed,
                         LimitSpeedOverLife,
                         SimulationFromJSON,
                         Simulation,
                         SimulationParticlePlugin,
                         SimulationTypes,
                         TextureSequencer,
                         SequencerFromJSON,
                         Sequencer,
                         Interpreter,
                         NodeData,
                         Node_2 as Node,
                         ConstInput,
                         Wire,
                         Adapter,
                         NodeTypes,
                         OutputNodeTypeNames,
                         NodeGraph,
                         ExecutionContext,
                         NodeTypeSignature,
                         NodeType,
                         NodeDef,
                         GraphNodeType,
                         NodeValueType,
                         getAlignOfNodeValueType,
                         getSizeOfNodeValueType,
                         genDefaultForNodeValueType,
                         VFXParameters,
                         NodeVFX,
                         WebGPUCompiler,
                         registerShaderChunks,
                         CubeEmitterParameters,
                         CubeEmitter,
                         PathEmitterParameters,
                         PathEmitter,
                         SetEmitDirection,
                         ApplyRoute,
                         BehaviorContext,
                         BehaviorStatus,
                         Behavior,
                         AbstractDecoratorBehavior,
                         ConditionalBehavior,
                         LogMessageBehavior,
                         SendEventBehavior,
                         ActionBehavior,
                         DelayBehavior,
                         ParallelBehaviorPolicy,
                         ParallelBehavior,
                         SequenceBehavior,
                         DestoryBehavior,
                         PromiseBehavior,
                         SucceedingBehavior,
                         FailingBehavior,
                         RepeatBehavior,
                         WaitForEventBehavior,
                         BranchBehavior,
                         FilterBehavior,
                         RepeatUntilFailureBehavior,
                         CompositeBehavior,
                         IgnoreFailureBehavior,
                         RepeatUntilSuccessBehavior,
                         ConditionBehavior,
                         InvertStatusBehavior,
                         SelectorBehavior,
                         RotationBehavior,
                         AnimationTrackPlayback,
                         AnimationTrack,
                         AnimationBehavior,
                         TLEventHandler,
                         TLEventType,
                         TLEnterEventHandler,
                         TLExitEventHandler,
                         TLStateNodeConstructor,
                         StateNode,
                         DefaultTool,
                         DrawShapeTool,
                         TransformControlsPointerObject,
                         TransformControls,
                         TransformControlsGizmo,
                         TransformControlsPlane,
                         TransformEnterOptions,
                         TransformTool,
                         PickEnterOptions,
                         PickTool,
                         ICommand,
                         ICommandCallback,
                         BaseCommand,
                         SetMaterialMapCommand,
                         IHasUpdate,
                         SetValueCommand,
                         UpdateValueCommand,
                         CallFunctionCommand,
                         SetMultipleValuesCommand,
                         CommandHistory,
                         MultiCmdsCommand,
                         SetRotationCommand,
                         SetPositionCommand,
                         PushValueCommand,
                         SetScaleCommand,
                         IHasDataEntity,
                         SetDataCommand,
                         AddObject3DCommand,
                         Anchor,
                         anchorTranslate,
                         anchorOrigin,
                         Marker2dOptions,
                         createDefaultMarkerElement,
                         Marker2D,
                         PopopOffset,
                         PopupOptions,
                         Popup2D,
                         Marker3dOptions,
                         Marker3D,
                         AnimateMarkerType,
                         AnimateMarkerLayerOption,
                         AnimateMarkerBase,
                         BreathingApertureMarker,
                         DiffusedApertureMarker,
                         FluorescenceMarker,
                         HaloRingMarker,
                         RotatingApertureMarker,
                         RotatingTextBorderMarker,
                         ContextMenuSubItemOptions,
                         ContextMenuOptions,
                         ContextMenu,
                         ButtonGroupControlOptions,
                         ButtonGroupControl,
                         MousePositionControlOption,
                         MousePositionControl,
                         FullscreenControlOptions,
                         FullscreenControl,
                         MiniMapControlOption,
                         MiniMapControl,
                         UiConfigRendererBase,
                         UiConfigMethods,
                         UiConfigContainer,
                         IUiConfigContainer,
                         UiObjectConfig,
                         UiObjectType,
                         TUiRefreshModes,
                         ChangeArgs,
                         ChangeEvent,
                         uiConfig,
                         uiContainer,
                         uiMonitor,
                         uiSlider,
                         uiVector,
                         uiDropdown,
                         uiButton,
                         uiInput,
                         uiColor,
                         uiImage,
                         uiToggle,
                         uiNumber,
                         uiPanelContainer,
                         uiFolderContainer,
                         generateUiConfig,
                         generateUiFolder,
                         UiConfigTypeMap,
                         TParams,
                         UiPanelJsonConfig,
                         makeObject3DUiConfig,
                         makeSamplerUi,
                         getEmptyMeta,
                         iMaterialUI,
                         makeBasicMaterialUiConfig,
                         makePhongMaterialUiConfig,
                         makePhysicalMaterialUiConfig,
                         makeMaterialUiConfig,
                         makeGeomertyUiConfig,
                         makeCameraUiConfig,
                         makeLightUiConfig,
                         encryptToBase64,
                         decryptFromBase64,
                         tea,
                         MapOpenWay,
                         IMapStyleParam,
                         IOpenMapBaseParam,
                         IOpenMapParam,
                         IUpdateMapParam,
                         IOpenMapResponse,
                         ITileUrlParam,
                         IQueryBaseFeatures,
                         IPointQueryFeatures,
                         IRectQueryFeatures,
                         IExprQueryFeatures,
                         IConditionQueryFeatures,
                         IMapLayer,
                         IUpdateStyle,
                         ISliceLayer,
                         ISliceCacheZoom,
                         IWmsTileUrl,
                         IDeleteStyle,
                         IDeleteCache,
                         IExportLayout,
                         IMatchObject,
                         IComposeNewMap,
                         IMapDiff,
                         ICreateEntitiesGeomData,
                         IWorkspace,
                         openMapDarkStyle,
                         openMapLightStyle,
                         Service,
                         Config,
                         Response_2 as Response,
                         IRequest,
                         httpHelper,
                         loadPhysicsEngine,
                         CANNON,
                         BoxParameters,
                         CylinderParameters,
                         SphereParameters,
                         ConvexPolyhedronParameters,
                         TrimeshParameters,
                         ShapeType2,
                         ShapeOptions,
                         ShapeParameters,
                         ShapeResult,
                         getShapeParameters,
                         threeToCannon
                     }
                 }
                 

                  namespace vjmap3d_2 {
                     export {
                         vjmap3d as default,
                         computeBoundsTree,
                         disposeBoundsTree,
                         acceleratedRaycast,
                         SMAAEffect,
                         EdgeDetectionMode,
                         LambdaPass,
                         FXAAEffect,
                         KernelSize,
                         PredicationMode,
                         SMAAPreset,
                         BloomEffect,
                         KawaseBlurPass,
                         ToneMappingEffect,
                         ToneMappingMode,
                         DepthOfFieldEffect,
                         ChromaticAberrationEffect,
                         GlitchEffect,
                         GlitchMode,
                         GodRaysEffect,
                         PixelationEffect,
                         SSAOEffect,
                         NormalPass,
                         OverrideMaterialManager,
                         EffectComposer,
                         DotScreenEffect,
                         DepthPickingPass,
                         TextureEffect,
                         Effect,
                         ColorDepthEffect,
                         CopyPass,
                         DepthPass,
                         BlendFunction,
                         ShaderPass,
                         EffectAttribute,
                         EffectPass,
                         OutlineEffect,
                         RenderPass,
                         Pass,
                         SelectiveBloomEffect,
                         reactivity,
                         render2d,
                         __buildDate,
                         __buildVersion,
                         __buildVerNo,
                         __DEV,
                         deleteArrItem,
                         generateUUID,
                         cloneDeep,
                         pick,
                         bindAll,
                         extend,
                         strMd5,
                         sleep,
                         pushObjectStatus,
                         throttle,
                         debounce,
                         applyMixins,
                         BidirectionalMap,
                         isObjectBehindCamera,
                         cameraDistance2NdcZ,
                         isObjectOcclude,
                         addResourceRefCount,
                         disposeObject3D,
                         containSkeleton,
                         objectTransformToMatrix,
                         getBoundingBox,
                         getObjectAnchorPoint,
                         disableRayQuery,
                         disableSelected,
                         disableBloom,
                         disableOutline,
                         disableBloomSelectedRayQuery,
                         Anchor3d,
                         getObjectRefCount,
                         ObjectTransform,
                         resetUV,
                         cameraWorldDirection,
                         randColor,
                         randHtmlColor,
                         randPoint3D,
                         randPoint2D,
                         isMapMode,
                         createScreenSpaceEntity,
                         object2Entity,
                         getOwerScene,
                         getObjectOwnerEntity,
                         getEntityParents,
                         IUniformB,
                         IUniformN,
                         IUniformNArray,
                         IUniformV2,
                         IUniformV3,
                         IUniformV3Array,
                         IUniformColor,
                         IUniformTexture,
                         HighlightMaterialOption,
                         traverseMaterial,
                         cloneMaterial,
                         disposeMaterial,
                         setMaterialOpacity,
                         enableMaterialVerticeOpacity,
                         toWorld,
                         fromWorld,
                         toDist,
                         fromDist,
                         clamp,
                         lerp,
                         lerpEuler,
                         approxZero,
                         approxEquals,
                         maxValue,
                         minValue,
                         randInt,
                         approxArrayEquals,
                         roundToStep,
                         infinityToMaxNumber,
                         maxNumberToInfinity,
                         max3,
                         min3,
                         max2,
                         min2,
                         smoothPoints,
                         toVector3,
                         getFilterColorMatrix,
                         degToRad,
                         radToDeg,
                         DEG2RAD,
                         RAD2DEG,
                         FilterColorOptions,
                         expandLine,
                         pointDistance,
                         lineDistance,
                         lineSlice,
                         interpolatePointsByRatio,
                         BitSet,
                         isLeftButton,
                         isMiddleButton,
                         isRightButton,
                         isShiftKeyDown,
                         isCtrlKeyDown,
                         isAltKeyDown,
                         eventKeyCode,
                         isEnterKey,
                         isEscKey,
                         isDeleteKey,
                         preventDefaultEvent,
                         eventXY,
                         textureDataToImageData,
                         renderTargetToDataUrl,
                         textureToDataUrl,
                         textureToCanvas,
                         texImageToCanvas,
                         exportRenderTarget,
                         loadImage,
                         DOM,
                         addScript,
                         ScriptDefaultOptions,
                         lerpCoordinates,
                         dist2d,
                         offsetCoords,
                         segmentIntersect3d,
                         line3dSplit,
                         multiLine3dSplit,
                         isPointInPolygon,
                         intersectLine3D,
                         getFullscreenTriangle,
                         getSphericalCube,
                         getScreenSpaceBox,
                         getFrustum,
                         getFrustumFromHeight,
                         lerpCameras,
                         createUnProjectMenu,
                         explodeGroup,
                         enableSRGBColorSpace,
                         optimizeModelRender,
                         enableRealisticRender,
                         enableShadow,
                         getEnvmapFromHDRTexture,
                         getEnvmapFromScene,
                         flatModel,
                         Graph,
                         buildTopoGraph,
                         buildPathTubeTopo,
                         findShortestPath,
                         EventDispatcher,
                         Logger,
                         DependencyError,
                         Time,
                         ModuleManager,
                         AppBaseOptions,
                         AppBase,
                         IAppModuleBase,
                         AppModuleBase,
                         AppModuleConstructor,
                         AppObject,
                         IModuleBase,
                         OrderIndex,
                         ModuleBase,
                         EntityBaseOptions,
                         EntityBase,
                         InteractiveEvent,
                         DispatchEvent,
                         IEntityModuleBase,
                         EntityModuleBase,
                         EntityModuleConstructor,
                         findSignalHandlerIndexByHandle,
                         findSignalHandlerIndexByHandleAndContext,
                         dispatchViaProxy,
                         SignalHandler,
                         Signal,
                         Store,
                         CancelledCommandException,
                         Scheduler,
                         createWorker,
                         workerWrap,
                         workerProxy,
                         workerTransfer,
                         workerLink,
                         createWorkerWrap,
                         geoBounds,
                         GeoBounds,
                         geoPoint,
                         GeoPoint,
                         GeoPointLike,
                         isGeoPointLike,
                         Projection,
                         GeoProjection,
                         transform,
                         InterpolationOptions,
                         Interpolation,
                         triangulate,
                         triangulatFlatten,
                         offsetPolygon,
                         extrudePolygon,
                         extrudePolyline,
                         extrudeGeoJSON,
                         lineIntersection,
                         triangle2dArea,
                         simplifyPoints,
                         pointToSegmentDistance,
                         closestPointOnSegment,
                         closestToSegment3d,
                         closestPointOnPolyline,
                         closestPointOnPolylines,
                         segmentIntersect,
                         lineSplit,
                         multiLineSplit,
                         Screenshot,
                         IWebGLRendererModule,
                         WebGLRendererModuleOptions,
                         WebGLRendererModule,
                         ICameraModule,
                         CameraOptions,
                         CameraModuleOptions,
                         CameraModule,
                         EnvConfigOption,
                         loadResourcesOptions,
                         ISceneModule,
                         BackgroundTexture,
                         BackgroundEnvironmentOptions,
                         SceneModuleOptions,
                         SceneModule,
                         IOrbitControlModule,
                         OrbitControlModuleOptions,
                         OrbitControlModule,
                         IStatModule,
                         StatModuleOptions,
                         StatModule,
                         PostProcessModuleOptions,
                         IPostProcessModule,
                         PostProcessModule,
                         InputModuleOptions,
                         IInputModule,
                         InputModule,
                         ICoordSystemModule,
                         CoordSystemOption,
                         UnProjectOpts,
                         CoordSystemModule,
                         ICSS2DRendererModule,
                         CSS2DRendererModuleOptions,
                         CSS2DRendererModule,
                         ICSS3DRendererModule,
                         CSS3DRendererModuleOptions,
                         CSS3DRendererModule,
                         IEntityManagerModule,
                         EntityManagerModule,
                         EntityOutlineModuleOptions,
                         EntityOutlineModule,
                         IEntityQueryModule,
                         EntityQueryOption,
                         InteractiveObject,
                         EntityQueryModule,
                         IDrawPointEnterOptions,
                         IDrawLineEnterOptions,
                         IDrawPolygonEnterOptions,
                         IDrawEditEnterOptions,
                         IPickModule,
                         PickPointOptions,
                         PickEntityOptions,
                         PickModule,
                         ICommandModule,
                         CommandModuleOptions,
                         CommandModule,
                         IParticleRenderModule,
                         ParticleRenderModuleOptions,
                         ParticleRenderModule,
                         IRectCollide,
                         IRectCollideModule,
                         RectCollideModuleOptions,
                         RectCollideModule,
                         IToolStateModule,
                         ToolStateModuleOptions,
                         ToolStateModule,
                         IPhysicsManagerModule,
                         PhysicsManagerModuleOptions,
                         PhysicsBodyOption,
                         MeshPhysicsObject,
                         MeshPhysicsObjectParams,
                         PhysicsManagerModule,
                         ControlPosition,
                         IControl,
                         logInfoType,
                         IUiModule,
                         ControlMarginOptions,
                         UiModuleOptions,
                         UiModule,
                         CameraState,
                         CameraControls,
                         GridHelperModuleOptions,
                         GridHelperModule,
                         MeshModuleOption,
                         MeshModule,
                         InstancedMeshModuleOption,
                         DynamicInstancedMesh,
                         InstancedMeshModule,
                         SymbolItemData,
                         SymbolModuleOption,
                         BetterRaycastingPoints,
                         SymbolModule,
                         BillboardModule,
                         OutlineModule,
                         SpriteAnimatorModule,
                         PolylineItemData,
                         PolylinesModuleOption,
                         PolylinesModule,
                         PolygonItemData,
                         PolygonsModuleOption,
                         PolygonsModule,
                         FillExtrusionItemData,
                         FillExtrusionsModuleOption,
                         FillExtrusionsModule,
                         GlLineItemData,
                         GlLinesModuleOption,
                         GlLinesModule,
                         BehaviorModule,
                         SpriteMarkerModule,
                         SpriteImagesModule,
                         SpriteTextsModule,
                         ParticleModuleOption,
                         ParticleModule,
                         AnimatorModuleOptions,
                         AnimatorModule,
                         ModelModuleOptions,
                         ModelModule,
                         EventModuleOptions,
                         EventModule,
                         PhysicsModule,
                         PathAnimateModuleOptions,
                         PathAnimateModule,
                         AppOptions,
                         App,
                         EntityOptions,
                         RayQueryType,
                         Entity,
                         LoadDetail,
                         ResStatus,
                         LoadUnit,
                         LoaderManagerOptions,
                         LoaderManager,
                         ILoadModelOption,
                         ResourceItem,
                         RosourceItemsReturnType,
                         ResourceManager,
                         LoadManager,
                         ResManager,
                         AlgorithmPluginType,
                         Tiles3dPluginType,
                         LoadPluginOpts,
                         PluginManager,
                         Plugins,
                         loadPluginAlgorithm,
                         loadPlugin3dtiles,
                         IEvent,
                         IEventDispatcher,
                         ImageCanvasOptions,
                         AnyFunction,
                         AnyOptions,
                         Class,
                         IDisposable,
                         IJSONSerializable,
                         PartialPick,
                         PartialRecord,
                         StringKeyOf,
                         Fof,
                         ValOrFunc,
                         ValOrArr,
                         ValOrArrOp,
                         Serializer,
                         PointerDragHelper,
                         SimpleEventDispatcher,
                         createCanvasElement,
                         createDiv,
                         createImage,
                         createStyles,
                         createScriptFromURL,
                         TYPED_ARRAYS,
                         arrayBufferToBase64,
                         base64ToArrayBuffer,
                         getTypedArray,
                         escapeRegExp,
                         getFilenameFromPath,
                         parseFileExtension,
                         replaceAll,
                         toTitleCase,
                         longestCommonPrefix,
                         prettyScrollbar,
                         blobToDataURL,
                         downloadBlob,
                         downloadFile,
                         uploadFile,
                         mobileAndTabletCheck,
                         uploadFileGetContent,
                         LinearToSRGB,
                         SRGBToLinear,
                         colorToDataUrl,
                         onChange,
                         onChange2,
                         onChange3,
                         serialize,
                         serializable,
                         aesGcmDecrypt,
                         aesGcmEncrypt,
                         embedUrlRefs,
                         htmlToCanvas,
                         htmlToPng,
                         htmlToSvg,
                         imageToCanvas,
                         imageBitmapToBase64,
                         imageUrlToImageData,
                         imageDataToCanvas,
                         canvasFlipY,
                         isWebpExportSupported,
                         absMax,
                         clearBit,
                         updateBit,
                         includesAll,
                         copyProps,
                         getOrCall,
                         getPropertyDescriptor,
                         isPropertyWritable,
                         safeSetProperty,
                         deepAccessObject,
                         getKeyByValue,
                         objectHasOwn,
                         makeColorSvg,
                         makeTextSvg,
                         makeColorSvgCircle,
                         svgToCanvas,
                         svgToPng,
                         timeout,
                         now,
                         pathJoin,
                         getUrlQueryParam,
                         setUrlQueryParam,
                         remoteWorkerURL,
                         css,
                         glsl,
                         html,
                         svgUrl,
                         Serialization,
                         BaseUvAtlas,
                         UvAtlasWebWorker,
                         PackOptions,
                         ChartOptions,
                         BaseUVUnwrapper,
                         UVUnwrapper,
                         GridProps,
                         GridType,
                         Grid,
                         ViewHelper,
                         ShadertoyMaterialParameters,
                         ShadertoyMaterial,
                         shaderMaterial,
                         convertToMaterialParameters,
                         FixedSizeMeshMaterial,
                         highlightMaterial,
                         SymbolMaterialProps,
                         createSymbolMaterial,
                         FlowMaterialProps,
                         FlowMaterial,
                         TextFlowMaterialOptions,
                         RenderElementFlowMaterialOptions,
                         createRenderElementFlowMaterial,
                         createTextFlowMaterial,
                         AnimatorFrameMaterialProps,
                         AnimatorFrameMaterial,
                         createAnimatorFrameSpriteMaterial,
                         MeshReflectorMaterialConfig,
                         MeshReflectorMaterial,
                         ConvolutionMaterial,
                         MeshTransmissionMaterialConfig,
                         FBOConfig,
                         MeshTransmissionMaterial,
                         CustomShaderMaterial,
                         MaterialConstructor,
                         iCSMPatchMap,
                         iCSMParams,
                         iCSMUpdateParams,
                         iCSMInternals,
                         Uniform,
                         iCSMShader,
                         createFlowGradientMaterial,
                         RadarMaterialProps,
                         RadarMaterial,
                         HolographicMaterial,
                         ReflectorMaterial,
                         ReflectorDudvMaterial,
                         Render2dTextureOptions,
                         createRender2dTexture,
                         useFBO,
                         Render3dTextureOptions,
                         Render3dTexture,
                         ShadertoyTextureItemOptions,
                         ShadertoyTextureOptions,
                         ShadertoyTexture,
                         BufferShader,
                         CharInfo,
                         AtlasData,
                         CharLayoutInfo,
                         LayoutInfo,
                         FontManagerOptions,
                         FontManager,
                         LabelMaterial,
                         Label,
                         LabelPool,
                         LabelOptions,
                         createLabel,
                         ExtrudePath,
                         ExtrudeMeshProps,
                         ExtrudeMesh,
                         MeshLineGeometry,
                         MeshLineMaterial,
                         MeshLine,
                         PathPointList,
                         PathGeometry,
                         PathTubeGeometry,
                         PathTubeEntitiesOptions,
                         PathTubeEntities,
                         BillboardProps,
                         BillboardType,
                         Billboard,
                         Outlines,
                         OutlinesProps,
                         OutlinesType,
                         TextProps,
                         TextType,
                         createTextMesh,
                         SpriteAnimatorProps,
                         SpriteAnimatorType,
                         createSpriteAnimator,
                         TrailLineOptions,
                         TrailLine,
                         Line2,
                         LineGeometry,
                         LineMaterialParameters,
                         LineMaterial,
                         LineSegments2,
                         LineSegmentsGeometry,
                         Wireframe,
                         WireframeGeometry2,
                         SpriteMarkerOptions,
                         SpriteMarker,
                         SpriteImageItemData,
                         SpriteImageItem,
                         SpriteImagesOptions,
                         SpriteImages,
                         SpriteTextItemData,
                         SpriteTextItem,
                         SpriteTextsOptions,
                         SpriteTexts,
                         AnimationClipOptions,
                         AnimatorOptions,
                         Animator,
                         PlaneConfig,
                         ScreenQuad,
                         BoxHelperOptions,
                         BoxHelper,
                         HeatmapOptions,
                         Heatmap,
                         ReflectorBlurMaterial,
                         ReflectorObject,
                         createReflectorShaderMesh,
                         MeasureRulerOptions,
                         creataMeasureRuler,
                         Environment,
                         PackedMipMapGenerator,
                         FullScreenQuad,
                         DynamicEnvConfig,
                         DynamicEnvironment,
                         createFlyline,
                         createMapApp,
                         map2dUtils,
                         MapThreeLayerOptions,
                         MapThreeLayer,
                         VariableTubeGeometry,
                         HyperbolicHelicoidGeometry,
                         SphubeGeometry,
                         createWallBufferGeometry,
                         MapView,
                         LODControl,
                         LODRaycast,
                         MapProvider,
                         MapNodeGeometry,
                         MapNodeHeightGeometry,
                         MapNode,
                         QuadTreePosition,
                         MapHeightNode,
                         MapPlaneNode,
                         UnitsUtils,
                         MapUtils,
                         CanvasUtils,
                         CancelablePromise,
                         XHRUtils,
                         TextureUtils,
                         MapViewEntity,
                         AllowedTypes,
                         Omitype,
                         PickType,
                         TransformType,
                         TransformedTypes,
                         FilteredType,
                         Motion,
                         MotionConfig,
                         EasingFunction,
                         Easing,
                         DEFAULT_EASING,
                         Easings,
                         RunningTween,
                         Tween,
                         TweenManager,
                         animation,
                         animationAsync,
                         MeshEntityOptions,
                         MeshEntity,
                         InstancedMeshEntityOptions,
                         InstancedMeshEntity,
                         SymbolEntityOptions,
                         SymbolEntity,
                         SpriteAnimatorEntityOptions,
                         SpriteAnimatorEntity,
                         PolylinesEntityOptions,
                         PolylinesEntity,
                         PolygonsEntityOptions,
                         PolygonsEntity,
                         FillExtrusionsEntityOptions,
                         FillExtrusionsEntity,
                         GlLinesEntityOptions,
                         GlLinesEntity,
                         SpriteMarkerEntityOptions,
                         SpriteMarkerEntity,
                         SpriteImagesEntityOptions,
                         SpriteImagesEntity,
                         SpriteTextsEntityOptions,
                         SpriteTextsEntity,
                         TrailLineEntityOptions,
                         TrailLineEntity,
                         MetaData,
                         ParticleEmitter,
                         IParticle,
                         Particle,
                         NodeParticle,
                         SpriteParticle,
                         RecordState,
                         TrailParticle,
                         BurstParameters,
                         BurstParametersJSON,
                         ParticleSystemParameters,
                         ParticleSystemJSONParameters,
                         JsonMetaData,
                         EmissionState,
                         ParticleSystem,
                         StoredBatchSettings,
                         RenderMode,
                         VFXBatch,
                         SpriteBatch,
                         TrailBatch,
                         VFXBatchSettings,
                         SerializationOptions,
                         RendererEmitterSettings,
                         StretchedBillBoardSettings,
                         BillBoardSettings,
                         TrailSettings,
                         MeshSettings,
                         IParticleSystem,
                         BatchedRenderer,
                         ParticleLoader,
                         Constructable,
                         FieldType,
                         ParameterType,
                         ParameterPair,
                         loadParticlePlugin,
                         unloadParticlePlugin,
                         ParticlePlugin,
                         ParticlePlugins,
                         getValueFromEmitterMode,
                         ShapeJSON,
                         EmitterMode,
                         EmitterShape,
                         ConeEmitterParameters,
                         ConeEmitter,
                         CircleEmitterParameters,
                         CircleEmitter,
                         DonutEmitterParameters,
                         DonutEmitter,
                         PointEmitter,
                         SphereEmitterParameters,
                         SphereEmitter,
                         HemisphereEmitterParameters,
                         HemisphereEmitter,
                         GridEmitterParameters,
                         GridEmitter,
                         MeshSurfaceEmitter,
                         EmitterFromJSON,
                         EmitterShapeParticlePlugin,
                         EmitterShapes,
                         Bezier,
                         ColorGeneratorFromJSON,
                         ColorGenerator,
                         FunctionColorGenerator,
                         MemorizedFunctionColorGenerator,
                         ConstantColor,
                         ColorRange,
                         ConstantValue,
                         FunctionJSON,
                         Gradient,
                         RandomColorBetweenGradient,
                         IntervalValue,
                         PiecewiseBezier,
                         PiecewiseFunction,
                         RandomColor,
                         ValueGeneratorFromJSON,
                         ValueGenerator,
                         FunctionValueGenerator,
                         RandomQuatGenerator,
                         AxisAngleGenerator,
                         RotationGeneratorFromJSON,
                         RotationGenerator,
                         EulerGenerator,
                         GeneratorFromJSON,
                         ColorOverLife,
                         RotationOverLife,
                         Rotation3DOverLife,
                         ForceOverLife,
                         SizeOverLife,
                         SpeedOverLife,
                         FrameOverLife,
                         OrbitOverLife,
                         WidthOverLength,
                         ApplyForce,
                         GravityForce,
                         ChangeEmitDirection,
                         SubParticleEmitMode,
                         EmitSubParticleSystem,
                         TurbulenceField,
                         Noise,
                         ApplySequences,
                         setPhysicsResolver,
                         getPhysicsResolver,
                         ApplyCollision,
                         ColorBySpeed,
                         SizeBySpeed,
                         RotationBySpeed,
                         LimitSpeedOverLife,
                         SimulationFromJSON,
                         Simulation,
                         SimulationParticlePlugin,
                         SimulationTypes,
                         TextureSequencer,
                         SequencerFromJSON,
                         Sequencer,
                         Interpreter,
                         NodeData,
                         Node_2 as Node,
                         ConstInput,
                         Wire,
                         Adapter,
                         NodeTypes,
                         OutputNodeTypeNames,
                         NodeGraph,
                         ExecutionContext,
                         NodeTypeSignature,
                         NodeType,
                         NodeDef,
                         GraphNodeType,
                         NodeValueType,
                         getAlignOfNodeValueType,
                         getSizeOfNodeValueType,
                         genDefaultForNodeValueType,
                         VFXParameters,
                         NodeVFX,
                         WebGPUCompiler,
                         registerShaderChunks,
                         CubeEmitterParameters,
                         CubeEmitter,
                         PathEmitterParameters,
                         PathEmitter,
                         SetEmitDirection,
                         ApplyRoute,
                         BehaviorContext,
                         BehaviorStatus,
                         Behavior,
                         AbstractDecoratorBehavior,
                         ConditionalBehavior,
                         LogMessageBehavior,
                         SendEventBehavior,
                         ActionBehavior,
                         DelayBehavior,
                         ParallelBehaviorPolicy,
                         ParallelBehavior,
                         SequenceBehavior,
                         DestoryBehavior,
                         PromiseBehavior,
                         SucceedingBehavior,
                         FailingBehavior,
                         RepeatBehavior,
                         WaitForEventBehavior,
                         BranchBehavior,
                         FilterBehavior,
                         RepeatUntilFailureBehavior,
                         CompositeBehavior,
                         IgnoreFailureBehavior,
                         RepeatUntilSuccessBehavior,
                         ConditionBehavior,
                         InvertStatusBehavior,
                         SelectorBehavior,
                         RotationBehavior,
                         AnimationTrackPlayback,
                         AnimationTrack,
                         AnimationBehavior,
                         TLEventHandler,
                         TLEventType,
                         TLEnterEventHandler,
                         TLExitEventHandler,
                         TLStateNodeConstructor,
                         StateNode,
                         DefaultTool,
                         DrawShapeTool,
                         TransformControlsPointerObject,
                         TransformControls,
                         TransformControlsGizmo,
                         TransformControlsPlane,
                         TransformEnterOptions,
                         TransformTool,
                         PickEnterOptions,
                         PickTool,
                         ICommand,
                         ICommandCallback,
                         BaseCommand,
                         SetMaterialMapCommand,
                         IHasUpdate,
                         SetValueCommand,
                         UpdateValueCommand,
                         CallFunctionCommand,
                         SetMultipleValuesCommand,
                         CommandHistory,
                         MultiCmdsCommand,
                         SetRotationCommand,
                         SetPositionCommand,
                         PushValueCommand,
                         SetScaleCommand,
                         IHasDataEntity,
                         SetDataCommand,
                         AddObject3DCommand,
                         Anchor,
                         anchorTranslate,
                         anchorOrigin,
                         Marker2dOptions,
                         createDefaultMarkerElement,
                         Marker2D,
                         PopopOffset,
                         PopupOptions,
                         Popup2D,
                         Marker3dOptions,
                         Marker3D,
                         AnimateMarkerType,
                         AnimateMarkerLayerOption,
                         AnimateMarkerBase,
                         BreathingApertureMarker,
                         DiffusedApertureMarker,
                         FluorescenceMarker,
                         HaloRingMarker,
                         RotatingApertureMarker,
                         RotatingTextBorderMarker,
                         ContextMenuSubItemOptions,
                         ContextMenuOptions,
                         ContextMenu,
                         ButtonGroupControlOptions,
                         ButtonGroupControl,
                         MousePositionControlOption,
                         MousePositionControl,
                         FullscreenControlOptions,
                         FullscreenControl,
                         MiniMapControlOption,
                         MiniMapControl,
                         UiConfigRendererBase,
                         UiConfigMethods,
                         UiConfigContainer,
                         IUiConfigContainer,
                         UiObjectConfig,
                         UiObjectType,
                         TUiRefreshModes,
                         ChangeArgs,
                         ChangeEvent,
                         uiConfig,
                         uiContainer,
                         uiMonitor,
                         uiSlider,
                         uiVector,
                         uiDropdown,
                         uiButton,
                         uiInput,
                         uiColor,
                         uiImage,
                         uiToggle,
                         uiNumber,
                         uiPanelContainer,
                         uiFolderContainer,
                         generateUiConfig,
                         generateUiFolder,
                         UiConfigTypeMap,
                         TParams,
                         UiPanelJsonConfig,
                         makeObject3DUiConfig,
                         makeSamplerUi,
                         getEmptyMeta,
                         iMaterialUI,
                         makeBasicMaterialUiConfig,
                         makePhongMaterialUiConfig,
                         makePhysicalMaterialUiConfig,
                         makeMaterialUiConfig,
                         makeGeomertyUiConfig,
                         makeCameraUiConfig,
                         makeLightUiConfig,
                         encryptToBase64,
                         decryptFromBase64,
                         tea,
                         MapOpenWay,
                         IMapStyleParam,
                         IOpenMapBaseParam,
                         IOpenMapParam,
                         IUpdateMapParam,
                         IOpenMapResponse,
                         ITileUrlParam,
                         IQueryBaseFeatures,
                         IPointQueryFeatures,
                         IRectQueryFeatures,
                         IExprQueryFeatures,
                         IConditionQueryFeatures,
                         IMapLayer,
                         IUpdateStyle,
                         ISliceLayer,
                         ISliceCacheZoom,
                         IWmsTileUrl,
                         IDeleteStyle,
                         IDeleteCache,
                         IExportLayout,
                         IMatchObject,
                         IComposeNewMap,
                         IMapDiff,
                         ICreateEntitiesGeomData,
                         IWorkspace,
                         openMapDarkStyle,
                         openMapLightStyle,
                         Service,
                         Config,
                         Response_2 as Response,
                         IRequest,
                         httpHelper,
                         loadPhysicsEngine,
                         CANNON,
                         BoxParameters,
                         CylinderParameters,
                         SphereParameters,
                         ConvexPolyhedronParameters,
                         TrimeshParameters,
                         ShapeType2,
                         ShapeOptions,
                         ShapeParameters,
                         ShapeResult,
                         getShapeParameters,
                         threeToCannon
                     }
                 }

                 export  class WaitForEventBehavior extends Behavior {
                     #private;
                     event: string;
                     data: any;
                     target: any;
                     detected: boolean;
                     constructor();
                     fromJSON(json: {
                         event: string;
                         target?: any;
                     }): void;
                     /**
                      *
                      * @param json
                      * @return {WaitForEventBehavior}
                      */
                     static fromJSON(json: {
                         event: string;
                         target?: any;
                     }): WaitForEventBehavior;
                     tick(timeDelta?: number): BehaviorStatus.Running | BehaviorStatus.Succeeded;
                     /**
                      * @private
                      */
                     listener(): void;
                     initialize(context: BehaviorContext): void;
                     finalize(): void;
                 }

                  function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;

                  function watch<T extends Readonly<MultiWatchSources>, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;

                  function watch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;

                  function watch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;

                  type WatchCallback<V = any, OV = any> = (value: V, oldValue: OV, onCleanup: OnCleanup) => any;

                  type WatchEffect = (onCleanup: OnCleanup) => void;

                  function watchEffect(effect: WatchEffect, options?: WatchOptionsBase): WatchStopHandle;

                  interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
                     immediate?: Immediate;
                     deep?: boolean;
                 }

                  interface WatchOptionsBase {
                     flush?: "pre" | "sync";
                 }

                  type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T);

                  type WatchStopHandle = () => void;

                  function watchSyncEffect(effect: WatchEffect): WatchStopHandle;

                  type WeakCollections = WeakMap<any, any> | WeakSet<any>;

                 export  class WebGLRendererModule extends AppModuleBase implements IAppModuleBase {
                     #private;
                     static moduleName: string;
                     options: WebGLRendererModuleOptions;
                     _commonUniforms: {
                         time: Uniform_2<Vector4>;
                         resolution: Uniform_2<Vector2>;
                         iGlobalTime: Uniform_2<number>;
                         iTime: Uniform_2<number>;
                         iTimeDelta: Uniform_2<number>;
                         iResolution: Uniform_2<Vector3>;
                         iMouse: Uniform_2<Vector4>;
                         iFrame: Uniform_2<number>;
                         iDate: Uniform_2<Vector4>;
                         iSampleRate: Uniform_2<number>;
                         iChannelTime: Uniform_2<[number, number, number, number]>;
                     };
                     constructor(app?: App, options?: WebGLRendererModuleOptions);
                     getScreenshot(params?: Screenshot): Promise<unknown>;
                     get renderer(): any;
                     get isMapMode(): boolean;
                     get commonUniforms(): {
                         time: Uniform_2<Vector4>;
                         resolution: Uniform_2<Vector2>;
                         iGlobalTime: Uniform_2<number>;
                         iTime: Uniform_2<number>;
                         iTimeDelta: Uniform_2<number>;
                         iResolution: Uniform_2<Vector3>;
                         iMouse: Uniform_2<Vector4>;
                         iFrame: Uniform_2<number>;
                         iDate: Uniform_2<Vector4>;
                         iSampleRate: Uniform_2<number>;
                         iChannelTime: Uniform_2<[number, number, number, number]>;
                     };
                     onAwake(): void;
                     onAppRender(time: Time): void;
                     setupUiConfig(): UiObjectConfig;
                 }

                 export  interface WebGLRendererModuleOptions extends WebGLRendererParameters {
                     clearColor?: ColorRepresentation;
                     clearColorAlpha?: number;
                     pixelRatio?: number;
                     renderUpdate?: boolean;
                     autoClear?: boolean;
                     stylePosition?: string;
                 }

                 export  class WebGPUCompiler extends BaseCompiler {
                     run(graph: NodeGraph, context: ExecutionContext): void;
                     constructor();
                     protected nodeResult: Map<Node_2, string>;
                     particleInstanceByteSize: number;
                     hasRandom: boolean;
                     private calculateMemoryLayout;
                     private buildPredefinedStructs;
                     private buildHeader;
                     private buildFooter;
                     private buildWebGPUCode;
                     private buildDataFlow;
                     build(graph: NodeGraph, context: ExecutionContext): string;
                     private buildFromValue;
                     private getTypeFromNodeType;
                     private buildFromAdapter;
                     private getResult;
                 }

                 /**
                  * WheelInfo
                  */
                  class WheelInfo {
                     /**
                      * Max travel distance of the suspension, in meters.
                      * @default 1
                      */
                     maxSuspensionTravel: number;
                     /**
                      * Speed to apply to the wheel rotation when the wheel is sliding.
                      * @default -0.1
                      */
                     customSlidingRotationalSpeed: number;
                     /**
                      * If the customSlidingRotationalSpeed should be used.
                      * @default false
                      */
                     useCustomSlidingRotationalSpeed: boolean;
                     /**
                      * sliding
                      */
                     sliding: boolean;
                     /**
                      * Connection point, defined locally in the chassis body frame.
                      */
                     chassisConnectionPointLocal: Vec3;
                     /**
                      * chassisConnectionPointWorld
                      */
                     chassisConnectionPointWorld: Vec3;
                     /**
                      * directionLocal
                      */
                     directionLocal: Vec3;
                     /**
                      * directionWorld
                      */
                     directionWorld: Vec3;
                     /**
                      * axleLocal
                      */
                     axleLocal: Vec3;
                     /**
                      * axleWorld
                      */
                     axleWorld: Vec3;
                     /**
                      * suspensionRestLength
                      * @default 1
                      */
                     suspensionRestLength: number;
                     /**
                      * suspensionMaxLength
                      * @default 2
                      */
                     suspensionMaxLength: number;
                     /**
                      * radius
                      * @default 1
                      */
                     radius: number;
                     /**
                      * suspensionStiffness
                      * @default 100
                      */
                     suspensionStiffness: number;
                     /**
                      * dampingCompression
                      * @default 10
                      */
                     dampingCompression: number;
                     /**
                      * dampingRelaxation
                      * @default 10
                      */
                     dampingRelaxation: number;
                     /**
                      * frictionSlip
                      * @default 10.5
                      */
                     frictionSlip: number;
                     /** forwardAcceleration */
                     forwardAcceleration: number;
                     /** sideAcceleration */
                     sideAcceleration: number;
                     /**
                      * steering
                      * @default 0
                      */
                     steering: number;
                     /**
                      * Rotation value, in radians.
                      * @default 0
                      */
                     rotation: number;
                     /**
                      * deltaRotation
                      * @default 0
                      */
                     deltaRotation: number;
                     /**
                      * rollInfluence
                      * @default 0.01
                      */
                     rollInfluence: number;
                     /**
                      * maxSuspensionForce
                      */
                     maxSuspensionForce: number;
                     /**
                      * engineForce
                      */
                     engineForce: number;
                     /**
                      * brake
                      */
                     brake: number;
                     /**
                      * isFrontWheel
                      * @default true
                      */
                     isFrontWheel: boolean;
                     /**
                      * clippedInvContactDotSuspension
                      * @default 1
                      */
                     clippedInvContactDotSuspension: number;
                     /**
                      * suspensionRelativeVelocity
                      * @default 0
                      */
                     suspensionRelativeVelocity: number;
                     /**
                      * suspensionForce
                      * @default 0
                      */
                     suspensionForce: number;
                     /**
                      * slipInfo
                      */
                     slipInfo: number;
                     /**
                      * skidInfo
                      * @default 0
                      */
                     skidInfo: number;
                     /**
                      * suspensionLength
                      * @default 0
                      */
                     suspensionLength: number;
                     /**
                      * sideImpulse
                      */
                     sideImpulse: number;
                     /**
                      * forwardImpulse
                      */
                     forwardImpulse: number;
                     /**
                      * The result from raycasting.
                      */
                     raycastResult: WheelRaycastResult;
                     /**
                      * Wheel world transform.
                      */
                     worldTransform: Transform;
                     /**
                      * isInContact
                      */
                     isInContact: boolean;
                     constructor(options?: {
                         /**
                          * Connection point, defined locally in the chassis body frame.
                          */
                         chassisConnectionPointLocal?: Vec3;
                         /**
                          * chassisConnectionPointWorld
                          */
                         chassisConnectionPointWorld?: Vec3;
                         /**
                          * directionLocal
                          */
                         directionLocal?: Vec3;
                         /**
                          * directionWorld
                          */
                         directionWorld?: Vec3;
                         /**
                          * axleLocal
                          */
                         axleLocal?: Vec3;
                         /**
                          * axleWorld
                          */
                         axleWorld?: Vec3;
                         /**
                          * suspensionRestLength
                          * @default 1
                          */
                         suspensionRestLength?: number;
                         /**
                          * suspensionMaxLength
                          * @default 2
                          */
                         suspensionMaxLength?: number;
                         /**
                          * radius
                          * @default 1
                          */
                         radius?: number;
                         /**
                          * suspensionStiffness
                          * @default 100
                          */
                         suspensionStiffness?: number;
                         /**
                          * dampingCompression
                          * @default 10
                          */
                         dampingCompression?: number;
                         /**
                          * dampingRelaxation
                          * @default 10
                          */
                         dampingRelaxation?: number;
                         /**
                          * frictionSlip
                          * @default 10.5
                          */
                         frictionSlip?: number;
                         /** forwardAcceleration */
                         forwardAcceleration?: number;
                         /** sideAcceleration */
                         sideAcceleration?: number;
                         /**
                          * steering
                          * @default 0
                          */
                         steering?: number;
                         /**
                          * Rotation value, in radians.
                          * @default 0
                          */
                         rotation?: number;
                         /**
                          * deltaRotation
                          * @default 0
                          */
                         deltaRotation?: number;
                         /**
                          * rollInfluence
                          * @default 0.01
                          */
                         rollInfluence?: number;
                         /**
                          * maxSuspensionForce
                          */
                         maxSuspensionForce?: number;
                         /**
                          * isFrontWheel
                          * @default true
                          */
                         isFrontWheel?: boolean;
                         /**
                          * clippedInvContactDotSuspension
                          * @default 1
                          */
                         clippedInvContactDotSuspension?: number;
                         /**
                          * suspensionRelativeVelocity
                          * @default 0
                          */
                         suspensionRelativeVelocity?: number;
                         /**
                          * suspensionForce
                          * @default 0
                          */
                         suspensionForce?: number;
                         /**
                          * slipInfo
                          */
                         slipInfo?: number;
                         /**
                          * skidInfo
                          * @default 0
                          */
                         skidInfo?: number;
                         /**
                          * suspensionLength
                          * @default 0
                          */
                         suspensionLength?: number;
                         /**
                          * Max travel distance of the suspension, in meters.
                          * @default 1
                          */
                         maxSuspensionTravel?: number;
                         /**
                          * If the customSlidingRotationalSpeed should be used.
                          * @default false
                          */
                         useCustomSlidingRotationalSpeed?: boolean;
                         /**
                          * Speed to apply to the wheel rotation when the wheel is sliding.
                          * @default -0.1
                          */
                         customSlidingRotationalSpeed?: number;
                     });
                     updateWheel(chassis: Body_2): void;
                 }

                  type WheelInfoOptions = ConstructorParameters<typeof WheelInfo>[0];

                  type WheelRaycastResult = RaycastResult & Partial<{
                     suspensionLength: number;
                     directionWorld: Vec3;
                     groundObject: number;
                 }>;

                 /**
                  * Apply width to particles based on their length.
                  */
                 export  class WidthOverLength implements Simulation {
                     width: FunctionValueGenerator;
                     type: string;
                     initialize(particle: Particle): void;
                     constructor(width: FunctionValueGenerator);
                     update(particle: Particle): void;
                     frameUpdate(delta: number): void;
                     toJSON(): any;
                     static fromJSON(json: any): Simulation;
                     clone(): Simulation;
                     reset(): void;
                 }

                 export  class Wire {
                     input: Node_2 | Adapter;
                     inputIndex: number;
                     output: Node_2 | Adapter;
                     outputIndex: number;
                     constructor(input: Node_2 | Adapter, inputIndex: number, output: Node_2 | Adapter, outputIndex: number);
                 }

                 export  class Wireframe extends Mesh {
                     constructor(geometry?: LineSegmentsGeometry, material?: LineMaterial);
                     computeLineDistances(): this;
                 }

                 export  class WireframeGeometry2 extends LineSegmentsGeometry {
                     constructor(geometry: any);
                 }

                  type WithThisType<Func extends (...args: any) => any, This> = (this: This, ...args: Parameters<Func>) => ReturnType<Func>;

                 export  function workerLink(): any;

                 export  function workerProxy(obj: any): any;

                 export  function workerTransfer(obj: any, transfers: any): any;

                 export  function workerWrap(ep: Worker, target?: any): any;

                 /**
                  * The physics world
                  */
                  class World extends EventTarget_2 {
                     /**
                      * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
                      */
                     dt: number;
                     /**
                      * Makes bodies go to sleep when they've been inactive.
                      * @default false
                      */
                     allowSleep: boolean;
                     /**
                      * All the current contacts (instances of ContactEquation) in the world.
                      */
                     contacts: ContactEquation[];
                     frictionEquations: FrictionEquation[];
                     /**
                      * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
                      * @default 0
                      */
                     quatNormalizeSkip: number;
                     /**
                      * Set to true to use fast quaternion normalization. It is often enough accurate to use.
                      * If bodies tend to explode, set to false.
                      * @default false
                      */
                     quatNormalizeFast: boolean;
                     /**
                      * The wall-clock time since simulation start.
                      */
                     time: number;
                     /**
                      * Number of timesteps taken since start.
                      */
                     stepnumber: number;
                     /**
                      * Default and last timestep sizes.
                      */
                     default_dt: number;
                     nextId: number;
                     /**
                      * The gravity of the world.
                      */
                     gravity: Vec3;
                     /**
                      * Gravity to use when approximating the friction max force (mu \* mass \* gravity).
                      * If undefined, global gravity will be used.
                      * Use to enable friction in a World with a null gravity vector (no gravity).
                      */
                     frictionGravity?: Vec3;
                     /**
                      * The broadphase algorithm to use.
                      * @default NaiveBroadphase
                      */
                     broadphase: Broadphase;
                     /**
                      * All bodies in this world
                      */
                     bodies: Body_2[];
                     /**
                      * True if any bodies are not sleeping, false if every body is sleeping.
                      */
                     hasActiveBodies: boolean;
                     /**
                      * The solver algorithm to use.
                      * @default GSSolver
                      */
                     solver: Solver;
                     constraints: Constraint[];
                     narrowphase: Narrowphase;
                     /**
                      * collisionMatrix
                      */
                     collisionMatrix: ArrayCollisionMatrix;
                     /**
                      * CollisionMatrix from the previous step.
                      */
                     collisionMatrixPrevious: ArrayCollisionMatrix;
                     bodyOverlapKeeper: OverlapKeeper;
                     shapeOverlapKeeper: OverlapKeeper;
                     /**
                      * All added contactmaterials.
                      */
                     contactmaterials: ContactMaterial[];
                     /**
                      * Used to look up a ContactMaterial given two instances of Material.
                      */
                     contactMaterialTable: TupleDictionary;
                     /**
                      * The default material of the bodies.
                      */
                     defaultMaterial: Material_2;
                     /**
                      * This contact material is used if no suitable contactmaterial is found for a contact.
                      */
                     defaultContactMaterial: ContactMaterial;
                     doProfiling: boolean;
                     profile: {
                         solve: number;
                         makeContactConstraints: number;
                         broadphase: number;
                         integrate: number;
                         narrowphase: number;
                     };
                     /**
                      * Time accumulator for interpolation.
                      * @see https://gafferongames.com/game-physics/fix-your-timestep/
                      */
                     accumulator: number;
                     subsystems: any[];
                     /**
                      * Dispatched after a body has been added to the world.
                      */
                     addBodyEvent: {
                         type: 'addBody';
                         body: Body_2 | null;
                     };
                     /**
                      * Dispatched after a body has been removed from the world.
                      */
                     removeBodyEvent: {
                         type: 'removeBody';
                         body: Body_2 | null;
                     };
                     idToBodyMap: {
                         [id: number]: Body_2;
                     };
                     lastCallTime?: number;
                     constructor(options?: {
                         /**
                          * The gravity of the world.
                          */
                         gravity?: Vec3;
                         /**
                          * Gravity to use when approximating the friction max force (mu*mass*gravity).
                          * If undefined, global gravity will be used.
                          */
                         frictionGravity?: Vec3;
                         /**
                          * Makes bodies go to sleep when they've been inactive.
                          * @default false
                          */
                         allowSleep?: boolean;
                         /**
                          * The broadphase algorithm to use.
                          * @default NaiveBroadphase
                          */
                         broadphase?: Broadphase;
                         /**
                          * The solver algorithm to use.
                          * @default GSSolver
                          */
                         solver?: Solver;
                         /**
                          * Set to true to use fast quaternion normalization. It is often enough accurate to use.
                          * If bodies tend to explode, set to false.
                          * @default false
                          */
                         quatNormalizeFast?: boolean;
                         /**
                          * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
                          * @default 0
                          */
                         quatNormalizeSkip?: number;
                     });
                     /**
                      * Get the contact material between materials m1 and m2
                      * @return The contact material if it was found.
                      */
                     getContactMaterial(m1: Material_2, m2: Material_2): ContactMaterial;
                     /**
                      * Store old collision state info
                      */
                     collisionMatrixTick(): void;
                     /**
                      * Add a constraint to the simulation.
                      */
                     addConstraint(c: Constraint): void;
                     /**
                      * Removes a constraint
                      */
                     removeConstraint(c: Constraint): void;
                     /**
                      * Raycast test
                      * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
                      */
                     rayTest(from: Vec3, to: Vec3, result: RaycastResult | RaycastCallback): void;
                     /**
                      * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
                      * @return True if any body was hit.
                      */
                     raycastAll(from?: Vec3, to?: Vec3, options?: RayOptions, callback?: RaycastCallback): boolean;
                     /**
                      * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
                      * @return True if any body was hit.
                      */
                     raycastAny(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
                     /**
                      * Ray cast, and return information of the closest hit.
                      * @return True if any body was hit.
                      */
                     raycastClosest(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
                     /**
                      * Add a rigid body to the simulation.
                      * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
                      * @todo Adding an array of bodies should be possible. This would save some loops too
                      */
                     addBody(body: Body_2): void;
                     /**
                      * Remove a rigid body from the simulation.
                      */
                     removeBody(body: Body_2): void;
                     getBodyById(id: number): Body_2;
                     /**
                      * @todo Make a faster map
                      */
                     getShapeById(id: number): Shape | null;
                     /**
                      * Adds a contact material to the World
                      */
                     addContactMaterial(cmat: ContactMaterial): void;
                     /**
                      * Removes a contact material from the World.
                      */
                     removeContactMaterial(cmat: ContactMaterial): void;
                     /**
                      * Step the simulation forward keeping track of last called time
                      * to be able to step the world at a fixed rate, independently of framerate.
                      *
                      * @param dt The fixed time step size to use (default: 1 / 60).
                      * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
                      * @see https://gafferongames.com/post/fix_your_timestep/
                      * @example
                      *     // Run the simulation independently of framerate every 1 / 60 ms
                      *     world.fixedStep()
                      */
                     fixedStep(dt?: number, maxSubSteps?: number): void;
                     /**
                      * Step the physics world forward in time.
                      *
                      * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
                      *
                      * @param dt The fixed time step size to use.
                      * @param timeSinceLastCalled The time elapsed since the function was last called.
                      * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
                      * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
                      * @example
                      *     // fixed timestepping without interpolation
                      *     world.step(1 / 60)
                      */
                     step(dt: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
                     internalStep(dt: number): void;
                     emitContactEvents(): void;
                     /**
                      * Sets all body forces in the world to zero.
                      */
                     clearForces(): void;
                 }

                  type WorldOptions = ConstructorParameters<typeof World>[0];

                  interface WritableArrayLike<T> {
                     readonly length: number;
                     [n: number]: T;
                 }

                  interface WritableComputedOptions<T> {
                     get: ComputedGetter<T>;
                     set: ComputedSetter<T>;
                 }

                  interface WritableComputedRef<T> extends Ref<T> {
                     readonly effect: ReactiveEffect<T>;
                 }

                 /**
                  * XHR utils contains public static methods to allow easy access to services via XHR.
                  */
                 export  class XHRUtils {
                     /**
                      * Get file data from URL as text, using a XHR call.
                      *
                      * @param url - Target for the request.
                      * @param onLoad - On load callback.
                      * @param onError - On progress callback.
                      */
                     static get(url: string): Promise<any>;
                     /**
                      * Get raw file data from URL, using a XHR call.
                      *
                      * @param url - Target for the request.
                      * @param onLoad - On load callback.
                      * @param onError - On progress callback.
                      */
                     static getRaw(url: string): Promise<ArrayBuffer>;
                     /**
                      * Perform a request with the specified configuration.
                      *
                      * Syncronous request should be avoided unless they are strictly necessary.
                      *
                      * @param url - Target for the request.
                      * @param type - Resquest type (POST, GET, ...)
                      * @param header - Object with data to be added to the request header.
                      * @param body - Data to be sent in the resquest.
                      * @param onLoad - On load callback, receives data (String or Object) and XHR as arguments.
                      * @param onError - XHR onError callback.
                      */
                     static request(url: string, type: string, header?: any, body?: any, onLoad?: Function, onError?: Function, onProgress?: Function): XMLHttpRequest;
                 }

                  type ZREventProperties = {
                     zrX: number;
                     zrY: number;
                     zrDelta: number;
                     zrEventControl: 'no_globalout' | 'only_globalout';
                     zrByTouch: boolean;
                 };

                  class ZRImage extends Displayable<ImageProps> {
                     style: ImageStyleProps;
                     __image: ImageLike;
                     __imageSrc: string;
                     onload: (image: ImageLike) => void;
                     /**
                      * Create an image style object with default values in it's prototype.
                      * @override
                      */
                     createStyle(obj?: ImageStyleProps): ImageStyleProps;
                     private _getSize;
                     getWidth(): number;
                     getHeight(): number;
                     getAnimationStyleProps(): MapToType<ImageProps, boolean>;
                     getBoundingRect(): BoundingRect;
                 }

                  type ZRRawEvent = ZRRawMouseEvent | ZRRawTouchEvent | ZRRawPointerEvent;

                  type ZRRawMouseEvent = MouseEvent & ZREventProperties;

                  type ZRRawPointerEvent = TouchEvent & ZREventProperties;

                  type ZRRawTouchEvent = TouchEvent & ZREventProperties;

                  interface ZRText {
                     animate(key?: '', loop?: boolean): Animator_2<this>;
                     animate(key: 'style', loop?: boolean): Animator_2<this['style']>;
                     getState(stateName: string): TextState;
                     ensureState(stateName: string): TextState;
                     states: Dictionary<TextState>;
                     stateProxy: (stateName: string) => TextState;
                 }

                  class ZRText extends Displayable<TextProps_2> implements GroupLike {
                     type: string;
                     style: TextStyleProps;
                     /**
                      * How to handling label overlap
                      *
                      * hidden:
                      */
                     overlap: 'hidden' | 'show' | 'blur';
                     /**
                      * Will use this to calculate transform matrix
                      * instead of Element itseelf if it's give.
                      * Not exposed to developers
                      */
                     innerTransformable: Transformable;
                     private _children;
                     private _childCursor;
                     private _defaultStyle;
                     constructor(opts?: TextProps_2);
                     childrenRef(): (ZRImage | Rect | TSpan)[];
                     update(): void;
                     updateTransform(): void;
                     getLocalTransform(m?: MatrixArray): MatrixArray;
                     getComputedTransform(): MatrixArray;
                     private _updateSubTexts;
                     addSelfToZr(zr: Render2dType): void;
                     removeSelfFromZr(zr: Render2dType): void;
                     getBoundingRect(): BoundingRect;
                     setDefaultTextStyle(defaultTextStyle: DefaultTextStyle): void;
                     setTextContent(textContent: never): void;
                     protected _mergeStyle(targetStyle: TextStyleProps, sourceStyle: TextStyleProps): TextStyleProps;
                     private _mergeRich;
                     getAnimationStyleProps(): MapToType<TextProps_2, boolean>;
                     private _getOrCreateChild;
                     private _updatePlainTexts;
                     private _updateRichTexts;
                     private _placeToken;
                     private _renderBackground;
                     static makeFont(style: TextStylePropsPart): string;
                 }

                  namespace zrUtil {
                     export {
                         guid,
                         logError,
                         clone_3 as clone,
                         merge,
                         mergeAll,
                         extend_2 as extend,
                         defaults,
                         indexOf,
                         inherits,
                         mixin,
                         isArrayLike,
                         each,
                         map,
                         reduce,
                         filter,
                         find,
                         keys,
                         isArray,
                         isFunction,
                         isString,
                         isStringSafe,
                         isNumber,
                         isObject,
                         isBuiltInObject,
                         isTypedArray,
                         isDom,
                         isGradientObject,
                         isImagePatternObject,
                         isRegExp,
                         eqNaN,
                         retrieve,
                         retrieve2,
                         retrieve3,
                         slice,
                         normalizeCssArray,
                         assert,
                         trim,
                         setAsPrimitive,
                         isPrimitive,
                         createHashMap,
                         concatArray,
                         createObject,
                         disableUserSelect,
                         hasOwn,
                         noop,
                         createCanvas,
                         Bind1,
                         Bind2,
                         Bind3,
                         Bind4,
                         Bind5,
                         bind,
                         Curry1,
                         Curry2,
                         Curry3,
                         Curry4,
                         curry,
                         HashMap,
                         RADIAN_TO_DEGREE
                     }
                 }

                 export { }

    }
    

declare namespace THREE {
// log handlers
export function warn(message?: any, ...optionalParams: any[]): void;
export function error(message?: any, ...optionalParams: any[]): void;
export function log(message?: any, ...optionalParams: any[]): void;

// typed array parameters
export type TypedArray =
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array;
import {
  WebGLRenderTarget,
  WebGLRenderTargetOptions,
} from './WebGLRenderTarget';

export class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );
}
import {
  WebGLRenderTargetOptions,
  WebGLRenderTarget,
} from './WebGLRenderTarget';
import { WebGLRenderer } from './WebGLRenderer';
import { Texture } from '../textures/Texture';

export class WebGLRenderTargetCube extends WebGLRenderTarget {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );

  fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
}
import { Vector4 } from '../math/Vector4';
import { Texture } from '../textures/Texture';
import { DepthTexture } from '../textures/DepthTexture';
import { EventDispatcher } from '../core/EventDispatcher';
import { Wrapping, TextureFilter, TextureDataType } from '../constants';

export interface WebGLRenderTargetOptions {
  wrapS?: Wrapping;
  wrapT?: Wrapping;
  magFilter?: TextureFilter;
  minFilter?: TextureFilter;
  format?: number; // RGBAFormat;
  type?: TextureDataType; // UnsignedByteType;
  anisotropy?: number; // 1;
  depthBuffer?: boolean; // true;
  stencilBuffer?: boolean; // true;
  generateMipmaps?: boolean; // true;
  depthTexture?: DepthTexture;
}

export class WebGLRenderTarget extends EventDispatcher {
  constructor(
    width: number,
    height: number,
    options?: WebGLRenderTargetOptions,
  );

  uuid: string;
  width: number;
  height: number;
  scissor: Vector4;
  scissorTest: boolean;
  viewport: Vector4;
  texture: Texture;
  depthBuffer: boolean;
  stencilBuffer: boolean;
  depthTexture: DepthTexture;
  /**
   * @deprecated Use {@link Texture#wrapS texture.wrapS} instead.
   */
  wrapS: any;
  /**
   * @deprecated Use {@link Texture#wrapT texture.wrapT} instead.
   */
  wrapT: any;
  /**
   * @deprecated Use {@link Texture#magFilter texture.magFilter} instead.
   */
  magFilter: any;
  /**
   * @deprecated Use {@link Texture#minFilter texture.minFilter} instead.
   */
  minFilter: any;
  /**
   * @deprecated Use {@link Texture#anisotropy texture.anisotropy} instead.
   */
  anisotropy: any;
  /**
   * @deprecated Use {@link Texture#offset texture.offset} instead.
   */
  offset: any;
  /**
   * @deprecated Use {@link Texture#repeat texture.repeat} instead.
   */
  repeat: any;
  /**
   * @deprecated Use {@link Texture#format texture.format} instead.
   */
  format: any;
  /**
   * @deprecated Use {@link Texture#type texture.type} instead.
   */
  type: any;
  /**
   * @deprecated Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.
   */
  generateMipmaps: any;

  setSize(width: number, height: number): void;
  clone(): this;
  copy(source: WebGLRenderTarget): this;
  dispose(): void;
}
import { Scene } from '../scenes/Scene';
import { Camera } from '../cameras/Camera';
import { WebGLExtensions } from './webgl/WebGLExtensions';
import { WebGLInfo } from './webgl/WebGLInfo';
import { WebGLShadowMap } from './webgl/WebGLShadowMap';
import { WebGLCapabilities } from './webgl/WebGLCapabilities';
import { WebGLProperties } from './webgl/WebGLProperties';
import { WebGLRenderLists } from './webgl/WebGLRenderLists';
import { WebGLState } from './webgl/WebGLState';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Color } from '../math/Color';
import { WebGLRenderTarget } from './WebGLRenderTarget';
import { Object3D } from '../core/Object3D';
import { Material } from '../materials/Material';
import { Fog } from '../scenes/Fog';
import { ToneMapping, ShadowMapType, CullFace } from '../constants';
import { WebVRManager } from '../renderers/webvr/WebVRManager';
import { RenderTarget } from './webgl/WebGLRenderLists';
import { Geometry } from '../core/Geometry';
import { BufferGeometry } from '../core/BufferGeometry';
import { Texture } from '../textures/Texture';

export interface Renderer {
  domElement: HTMLCanvasElement;

  render(scene: Scene, camera: Camera): void;
  setSize(width: number, height: number, updateStyle?: boolean): void;
}

export interface WebGLRendererParameters {
  /**
   * A Canvas where the renderer draws its output.
   */
  canvas?: HTMLCanvasElement | OffscreenCanvas;

  /**
   * A WebGL Rendering Context.
   * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
   *	Default is null
   */
  context?: WebGLRenderingContext;

  /**
   *	shader precision. Can be "highp", "mediump" or "lowp".
   */
  precision?: string;

  /**
   * default is true.
   */
  alpha?: boolean;

  /**
   * default is true.
   */
  premultipliedAlpha?: boolean;

  /**
   * default is false.
   */
  antialias?: boolean;

  /**
   * default is true.
   */
  stencil?: boolean;

  /**
   * default is false.
   */
  preserveDrawingBuffer?: boolean;

  /**
   *	Can be "high-performance", "low-power" or "default"
   */
  powerPreference?: string;

  /**
   * default is true.
   */
  depth?: boolean;

  /**
   * default is false.
   */
  logarithmicDepthBuffer?: boolean;
}

export interface WebGLDebug {
  /**
   * Enables error checking and reporting when shader programs are being compiled.
   */
  checkShaderErrors: boolean;
}

/**
 * The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.
 * This renderer has way better performance than CanvasRenderer.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js">src/renderers/WebGLRenderer.js</a>
 */
export class WebGLRenderer implements Renderer {
  /**
   * parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.
   */
  constructor(parameters?: WebGLRendererParameters);

  /**
   * A Canvas where the renderer draws its output.
   * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
   */
  domElement: HTMLCanvasElement;

  /**
   * The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.
   */
  context: WebGLRenderingContext;

  /**
   * Defines whether the renderer should automatically clear its output before rendering.
   */
  autoClear: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
   */
  autoClearColor: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
   */
  autoClearDepth: boolean;

  /**
   * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
   */
  autoClearStencil: boolean;

  /**
   * Debug configurations.
   */
  debug: WebGLDebug;

  /**
   * Defines whether the renderer should sort objects. Default is true.
   */
  sortObjects: boolean;

  clippingPlanes: any[];
  localClippingEnabled: boolean;

  extensions: WebGLExtensions;

  /**
   * Default is false.
   */
  gammaInput: boolean;

  /**
   * Default is false.
   */
  gammaOutput: boolean;

  physicallyCorrectLights: boolean;
  toneMapping: ToneMapping;
  toneMappingExposure: number;
  toneMappingWhitePoint: number;

  /**
   * Default is false.
   */
  shadowMapDebug: boolean;

  /**
   * Default is 8.
   */
  maxMorphTargets: number;

  /**
   * Default is 4.
   */
  maxMorphNormals: number;

  info: WebGLInfo;

  shadowMap: WebGLShadowMap;

  pixelRatio: number;

  capabilities: WebGLCapabilities;
  properties: WebGLProperties;
  renderLists: WebGLRenderLists;
  state: WebGLState;

  vr: WebVRManager;

  /**
   * Return the WebGL context.
   */
  getContext(): WebGLRenderingContext;
  getContextAttributes(): any;
  forceContextLoss(): void;

  /**
   * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
   */
  getMaxAnisotropy(): number;

  /**
   * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
   */
  getPrecision(): string;

  getPixelRatio(): number;
  setPixelRatio(value: number): void;

  getDrawingBufferSize(target: Vector2): Vector2;
  setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;

  getSize(target: Vector2): Vector2;

  /**
   * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
   */
  setSize(width: number, height: number, updateStyle?: boolean): void;

  getCurrentViewport(target: Vector4): Vector4;

  /**
   * Copies the viewport into target.
   */
  getViewport(target: Vector4): Vector4;

  /**
   * Sets the viewport to render from (x, y) to (x + width, y + height).
   * (x, y) is the lower-left corner of the region.
   */
  setViewport(
    x: Vector4 | number,
    y?: number,
    width?: number,
    height?: number,
  ): void;

  /**
   * Copies the scissor area into target.
   */
  getScissor(target: Vector4): Vector4;

  /**
   * Sets the scissor area from (x, y) to (x + width, y + height).
   */
  setScissor(
    x: Vector4 | number,
    y?: number,
    width?: number,
    height?: number,
  ): void;

  /**
   * Returns true if scissor test is enabled; returns false otherwise.
   */
  getScissorTest(): boolean;

  /**
   * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
   */
  setScissorTest(enable: boolean): void;

  /**
   * Returns a THREE.Color instance with the current clear color.
   */
  getClearColor(): Color;

  /**
   * Sets the clear color, using color for the color and alpha for the opacity.
   */
  setClearColor(color: Color, alpha?: number): void;
  setClearColor(color: string, alpha?: number): void;
  setClearColor(color: number, alpha?: number): void;

  /**
   * Returns a float with the current clear alpha. Ranges from 0 to 1.
   */
  getClearAlpha(): number;

  setClearAlpha(alpha: number): void;

  /**
   * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
   * Arguments default to true
   */
  clear(color?: boolean, depth?: boolean, stencil?: boolean): void;

  clearColor(): void;
  clearDepth(): void;
  clearStencil(): void;
  clearTarget(
    renderTarget: WebGLRenderTarget,
    color: boolean,
    depth: boolean,
    stencil: boolean,
  ): void;

  /**
   * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
   */
  resetGLState(): void;
  dispose(): void;

  /**
   * Tells the shadow map plugin to update using the passed scene and camera parameters.
   *
   * @param scene an instance of Scene
   * @param camera  an instance of Camera
   */
  renderBufferImmediate(
    object: Object3D,
    program: Object,
    material: Material,
  ): void;

  renderBufferDirect(
    camera: Camera,
    fog: Fog,
    geometry: Geometry | BufferGeometry,
    material: Material,
    object: Object3D,
    geometryGroup: any,
  ): void;

  /**
   * A build in function that can be used instead of requestAnimationFrame. For WebVR projects this function must be used.
   * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
   */
  setAnimationLoop(callback: Function | null): void;

  /**
   * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
   */
  animate(callback: Function): void;

  /**
   * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.
   */
  compile(scene: Scene, camera: Camera): void;

  /**
   * Render a scene using a camera.
   * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
   * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
   *
   * By default render buffers are cleared before rendering but you can prevent this by setting the property
   * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
   * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
   * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
   * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
   */
  render(scene: Scene, camera: Camera): void;

  /**
   * Returns the current active cube face.
   */
  getActiveCubeFace(): number;

  /**
   * Returns the current active mipmap level.
   */
  getActiveMipmapLevel(): number;

  /**
   * Returns the current render target. If no render target is set, null is returned.
   */
  getRenderTarget(): RenderTarget | null;

  /**
   * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
   */
  getCurrentRenderTarget(): RenderTarget | null;

  /**
   * Sets the active render target.
   *
   * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
   * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLRenderTargetCube}.
   * @param activeMipmapLevel Specifies the active mipmap level.
   */
  setRenderTarget(
    renderTarget: RenderTarget | null,
    activeCubeFace?: number,
    activeMipmapLevel?: number,
  ): void;

  readRenderTargetPixels(
    renderTarget: RenderTarget,
    x: number,
    y: number,
    width: number,
    height: number,
    buffer: any,
    activeCubeFaceIndex?: number,
  ): void;

  /**
   * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
   * This region is defined by the size of the destination texture's mip level, offset by the input position.
   *
   * @param position Specifies the pixel offset from which to copy out of the framebuffer.
   * @param texture Specifies the destination texture.
   * @param level Specifies the destination mipmap level of the texture.
   */
  copyFramebufferToTexture(
    position: Vector2,
    texture: Texture,
    level?: number,
  ): void;

  /**
   * Copies srcTexture to the specified level of dstTexture, offset by the input position.
   *
   * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
   * @param srcTexture Specifies the source texture.
   * @param dstTexture Specifies the destination texture.
   * @param level Specifies the destination mipmap level of the texture.
   */
  copyTextureToTexture(
    position: Vector2,
    srcTexture: Texture,
    dstTexture: Texture,
    level?: number,
  ): void;

  /**
   * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @param texture The texture to Initialize.
   */
  initTexture(texture: Texture): void;

  /**
   * @deprecated
   */
  gammaFactor: number;

  /**
   * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
   */
  shadowMapEnabled: boolean;

  /**
   * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
   */
  shadowMapType: ShadowMapType;

  /**
   * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
   */
  shadowMapCullFace: CullFace;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
   */
  supportsFloatTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
   */
  supportsHalfFloatTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
   */
  supportsStandardDerivatives(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
   */
  supportsCompressedTextureS3TC(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
   */
  supportsCompressedTexturePVRTC(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
   */
  supportsBlendMinMax(): any;

  /**
   * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
   */
  supportsVertexTextures(): any;

  /**
   * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
   */
  supportsInstancedArrays(): any;

  /**
   * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
   */
  enableScissorTest(boolean: any): any;
}
import { IUniform } from './UniformsLib';

export interface Shader {
  uniforms: { [uniform: string]: IUniform };
  vertexShader: string;
  fragmentShader: string;
}

export let ShaderLib: {
  [name: string]: Shader;
  basic: Shader;
  lambert: Shader;
  phong: Shader;
  standard: Shader;
  matcap: Shader;
  points: Shader;
  dashed: Shader;
  depth: Shader;
  normal: Shader;
  sprite: Shader;
  background: Shader;
  cube: Shader;
  equirect: Shader;
  distanceRGBA: Shader;
  shadow: Shader;
  physical: Shader;
};
export interface IUniform {
  value: any;
}

export let UniformsLib: {
  common: {
    diffuse: IUniform;
    opacity: IUniform;
    map: IUniform;
    uvTransform: IUniform;
    alphaMap: IUniform;
  };
  specularmap: {
    specularMap: IUniform;
  };
  envmap: {
    envMap: IUniform;
    flipEnvMap: IUniform;
    reflectivity: IUniform;
    refractionRatio: IUniform;
    maxMipLevel: IUniform;
  };
  aomap: {
    aoMap: IUniform;
    aoMapIntensity: IUniform;
  };
  lightmap: {
    lightMap: IUniform;
    lightMapIntensity: IUniform;
  };
  emissivemap: {
    emissiveMap: IUniform;
  };
  bumpmap: {
    bumpMap: IUniform;
    bumpScale: IUniform;
  };
  normalmap: {
    normalMap: IUniform;
    normalScale: IUniform;
  };
  displacementmap: {
    displacementMap: IUniform;
    displacementScale: IUniform;
    displacementBias: IUniform;
  };
  roughnessmap: {
    roughnessMap: IUniform;
  };
  metalnessmap: {
    metalnessMap: IUniform;
  };
  gradientmap: {
    gradientMap: IUniform;
  };
  fog: {
    fogDensity: IUniform;
    fogNear: IUniform;
    fogFar: IUniform;
    fogColor: IUniform;
  };
  lights: {
    ambientLightColor: IUniform;
    directionalLights: {
      value: any[];
      properties: {
        direction: {};
        color: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    directionalShadowMap: IUniform;
    directionalShadowMatrix: IUniform;
    spotLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        direction: {};
        distance: {};
        coneCos: {};
        penumbraCos: {};
        decay: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    spotShadowMap: IUniform;
    spotShadowMatrix: IUniform;
    pointLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        decay: {};
        distance: {};
        shadow: {};
        shadowBias: {};
        shadowRadius: {};
        shadowMapSize: {};
      };
    };
    pointShadowMap: IUniform;
    pointShadowMatrix: IUniform;
    hemisphereLights: {
      value: any[];
      properties: {
        direction: {};
        skycolor: {};
        groundColor: {};
      };
    };
    rectAreaLights: {
      value: any[];
      properties: {
        color: {};
        position: {};
        width: {};
        height: {};
      };
    };
  };
  points: {
    diffuse: IUniform;
    opacity: IUniform;
    size: IUniform;
    scale: IUniform;
    map: IUniform;
    uvTransform: IUniform;
  };
};
export function cloneUniforms(uniforms_src: any): any;
export function mergeUniforms(uniforms: any[]): any;

export namespace UniformsUtils {
  export { mergeUniforms as merge, cloneUniforms as clone };
}
// Renderers / Shaders /////////////////////////////////////////////////////////////////////
export let ShaderChunk: {
  [name: string]: string;

  alphamap_fragment: string;
  alphamap_pars_fragment: string;
  alphatest_fragment: string;
  aomap_fragment: string;
  aomap_pars_fragment: string;
  begin_vertex: string;
  beginnormal_vertex: string;
  bsdfs: string;
  bumpmap_pars_fragment: string;
  clipping_planes_fragment: string;
  clipping_planes_pars_fragment: string;
  clipping_planes_pars_vertex: string;
  clipping_planes_vertex: string;
  color_fragment: string;
  color_pars_fragment: string;
  color_pars_vertex: string;
  color_vertex: string;
  common: string;
  cube_frag: string;
  cube_vert: string;
  cube_uv_reflection_fragment: string;
  defaultnormal_vertex: string;
  depth_frag: string;
  depth_vert: string;
  distanceRGBA_frag: string;
  distanceRGBA_vert: string;
  displacementmap_vertex: string;
  displacementmap_pars_vertex: string;
  emissivemap_fragment: string;
  emissivemap_pars_fragment: string;
  encodings_pars_fragment: string;
  encodings_fragment: string;
  envmap_fragment: string;
  envmap_common_pars_fragment: string;
  envmap_pars_fragment: string;
  envmap_pars_vertex: string;
  envmap_vertex: string;
  equirect_frag: string;
  equirect_vert: string;
  fog_fragment: string;
  fog_pars_fragment: string;
  linedashed_frag: string;
  linedashed_vert: string;
  lightmap_fragment: string;
  lightmap_pars_fragment: string;
  lights_lambert_vertex: string;
  lights_pars_begin: string;
  envmap_physical_pars_fragment: string;
  lights_pars_map: string;
  lights_phong_fragment: string;
  lights_phong_pars_fragment: string;
  lights_physical_fragment: string;
  lights_physical_pars_fragment: string;
  lights_fragment_begin: string;
  lights_fragment_maps: string;
  lights_fragment_end: string;
  logdepthbuf_fragment: string;
  logdepthbuf_pars_fragment: string;
  logdepthbuf_pars_vertex: string;
  logdepthbuf_vertex: string;
  map_fragment: string;
  map_pars_fragment: string;
  map_particle_fragment: string;
  map_particle_pars_fragment: string;
  meshbasic_frag: string;
  meshbasic_vert: string;
  meshlambert_frag: string;
  meshlambert_vert: string;
  meshphong_frag: string;
  meshphong_vert: string;
  meshphysical_frag: string;
  meshphysical_vert: string;
  metalnessmap_fragment: string;
  metalnessmap_pars_fragment: string;
  morphnormal_vertex: string;
  morphtarget_pars_vertex: string;
  morphtarget_vertex: string;
  normal_flip: string;
  normal_frag: string;
  normal_fragment_begin: string;
  normal_fragment_maps: string;
  normal_vert: string;
  normalmap_pars_fragment: string;
  clearcoat_normal_fragment_begin: string;
  clearcoat_normal_fragment_maps: string;
  clearcoat_normalmap_pars_fragment: string;
  packing: string;
  points_frag: string;
  points_vert: string;
  shadow_frag: string;
  shadow_vert: string;

  premultiplied_alpha_fragment: string;
  project_vertex: string;
  roughnessmap_fragment: string;
  roughnessmap_pars_fragment: string;
  shadowmap_pars_fragment: string;
  shadowmap_pars_vertex: string;
  shadowmap_vertex: string;
  shadowmask_pars_fragment: string;
  skinbase_vertex: string;
  skinning_pars_vertex: string;
  skinning_vertex: string;
  skinnormal_vertex: string;
  specularmap_fragment: string;
  specularmap_pars_fragment: string;
  tonemapping_fragment: string;
  tonemapping_pars_fragment: string;
  uv2_pars_fragment: string;
  uv2_pars_vertex: string;
  uv2_vertex: string;
  uv_pars_fragment: string;
  uv_pars_vertex: string;
  uv_vertex: string;
  worldpos_vertex: string;
};
import { Color } from '../math/Color';
import { IFog } from './Fog';
/**
 * This class contains the parameters that define linear fog, i.e., that grows exponentially denser with the distance.
 */
export class FogExp2 implements IFog {
  constructor(hex: number | string, density?: number);

  name: string;
  color: Color;

  /**
   * Defines how fast the fog will grow dense.
   * Default is 0.00025.
   */
  density: number;

  clone(): this;
  toJSON(): any;
}
import { Color } from '../math/Color';

export interface IFog {
  name: string;
  color: Color;
  clone(): this;
  toJSON(): any;
}

/**
 * This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.
 */
export class Fog implements IFog {
  constructor(hex: number, near?: number, far?: number);

  name: string;

  /**
   * Fog color.
   */
  color: Color;

  /**
   * The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
   */
  near: number;

  /**
   * The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.
   * Default is 1000.
   */
  far: number;

  clone(): this;
  toJSON(): any;
}
import { IFog } from './Fog';
import { Material } from '../materials/Material';
import { Object3D } from '../core/Object3D';
import { Color } from '../math/Color';
import { Texture } from '../textures/Texture';
// Scenes /////////////////////////////////////////////////////////////////////

/**
 * Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
 */
export class Scene extends Object3D {
  constructor();

  type: 'Scene';

  /**
   * A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.
   */
  fog: IFog | null;

  /**
   * If not null, it will force everything in the scene to be rendered with that material. Default is null.
   */
  overrideMaterial: Material | null;
  autoUpdate: boolean;
  background: null | Color | Texture;

  toJSON(meta?: any): any;
  dispose(): void;
}
import { Vector2 } from '../math/Vector2';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { Intersection } from '../core/Raycaster';
import { SpriteMaterial } from '../materials/Materials';
import { BufferGeometry } from '../core/BufferGeometry';

export class Sprite extends Object3D {
  constructor(material?: SpriteMaterial);

  type: 'Sprite';
  isSprite: true;

  geometry: BufferGeometry;
  material: SpriteMaterial;
  center: Vector2;

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  copy(source: this): this;
}
import { Object3D } from '../core/Object3D';
import { Raycaster } from '../core/Raycaster';
import { Camera } from '../cameras/Camera';
import { Intersection } from '../core/Raycaster';

export class LOD extends Object3D {
  constructor();

  type: 'LOD';

  levels: { distance: number; object: Object3D }[];

  addLevel(object: Object3D, distance?: number): this;
  getObjectForDistance(distance: number): Object3D;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  update(camera: Camera): void;
  toJSON(meta: any): any;

  /**
   * @deprecated Use {@link LOD#levels .levels} instead.
   */
  objects: any[];
}
import { Geometry } from '../core/Geometry';
import { BufferGeometry } from '../core/BufferGeometry';
import { Material } from '../materials/Material';
import { BufferAttribute } from '../core/BufferAttribute.js.js';
import { Mesh } from './Mesh';
import { Matrix4 } from '../math/Matrix4';

export class InstancedMesh extends Mesh {
  constructor(
    geometry: Geometry | BufferGeometry,
    material: Material | Material[],
    count: number,
  );

  count: number;
  instanceMatrix: BufferAttribute;
  isInstancedMesh: true;

  setMatrixAt(index: number, matrix: Matrix4): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Matrix4 } from '../math/Matrix4';
import { Skeleton } from './Skeleton';
import { Mesh } from './Mesh';
import { BufferGeometry } from '../core/BufferGeometry';

export class SkinnedMesh extends Mesh {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    useVertexTexture?: boolean,
  );

  bindMode: string;
  bindMatrix: Matrix4;
  bindMatrixInverse: Matrix4;
  skeleton: Skeleton;

  bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
  pose(): void;
  normalizeSkinWeights(): void;
  updateMatrixWorld(force?: boolean): void;
}
import { Bone } from './Bone';
import { Matrix4 } from '../math/Matrix4';
import { DataTexture } from '../textures/DataTexture';

/**
 * @deprecated Use {@link Points THREE.Points} instead.
 */
/**
 * @deprecated Use {@link Points THREE.Points} instead.
 */

export class Skeleton {
  constructor(bones: Bone[], boneInverses?: Matrix4[]);

  /**
   * @deprecated This property has been removed completely.
   */
  useVertexTexture: boolean;
  identityMatrix: Matrix4;
  bones: Bone[];
  boneTextureWidth: number;
  boneTextureHeight: number;
  boneMatrices: Float32Array;
  boneTexture: DataTexture;
  boneInverses: Matrix4[];

  calculateInverses(bone: Bone): void;
  pose(): void;
  update(): void;
  clone(): this;
}
import { Object3D } from '../core/Object3D';

// Objects //////////////////////////////////////////////////////////////////////////////////

export class Bone extends Object3D {
  constructor();
  isBone: true;
  type: 'Bone';
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';
import { TrianglesDrawModes } from '../constants';

export class Mesh extends Object3D {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  geometry: Geometry | BufferGeometry;
  material: Material | Material[];
  drawMode: TrianglesDrawModes;
  morphTargetInfluences?: number[];
  morphTargetDictionary?: { [key: string]: number };
  isMesh: true;
  type: string;

  setDrawMode(drawMode: TrianglesDrawModes): void;
  updateMorphTargets(): void;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Line } from './Line';
import { BufferGeometry } from '../core/BufferGeometry';

/**
 * @deprecated
 */
export const LineStrip: number;
/**
 * @deprecated
 */
export const LinePieces: number;

export class LineSegments extends Line {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    mode?: number,
  );

  type: 'LineSegments';
  isLineSegments: true;
}
import { Line } from './Line';
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { BufferGeometry } from '../core/BufferGeometry';

export class LineLoop extends Line {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  type: 'LineLoop';
  isLineLoop: true;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';

export class Line extends Object3D {
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
    mode?: number,
  );

  geometry: Geometry | BufferGeometry;
  material: Material | Material[];

  type: 'Line' | 'LineLoop' | 'LineSegments';
  isLine: true;

  computeLineDistances(): this;
  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
}
import { Geometry } from '../core/Geometry';
import { Material } from '../materials/Material';
import { Raycaster } from '../core/Raycaster';
import { Object3D } from '../core/Object3D';
import { BufferGeometry } from '../core/BufferGeometry';
import { Intersection } from '../core/Raycaster';

/**
 * A class for displaying particles in the form of variable size points. For example, if using the WebGLRenderer, the particles are displayed using GL_POINTS.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/objects/ParticleSystem.js">src/objects/ParticleSystem.js</a>
 */
export class Points extends Object3D {
  /**
   * @param geometry An instance of Geometry or BufferGeometry.
   * @param material An instance of Material (optional).
   */
  constructor(
    geometry?: Geometry | BufferGeometry,
    material?: Material | Material[],
  );

  type: 'Points';
  morphTargetInfluences?: number[];
  morphTargetDictionary?: { [key: string]: number };
  isPoints: true;

  /**
   * An instance of Geometry or BufferGeometry, where each vertex designates the position of a particle in the system.
   */
  geometry: Geometry | BufferGeometry;

  /**
   * An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour.
   */
  material: Material | Material[];

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;
  updateMorphTargets(): void;
}
import { Object3D } from '../core/Object3D';

export class Group extends Object3D {
  constructor();
  type: 'Group';
  isGroup: true;
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
} from '../constants';

export class VideoTexture extends Texture {
  constructor(
    video: HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
  );
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';
import { TypedArray } from '../polyfills';

export class DataTexture extends Texture {
  constructor(
    data: TypedArray,
    width: number,
    height: number,
    format?: PixelFormat,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  image: ImageData;
}
import { Texture } from './Texture';
import { TypedArray } from '../polyfills';

export class DataTexture3D extends Texture {
  constructor(data: TypedArray, width: number, height: number, depth: number);
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  CompressedPixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

export class CompressedTexture extends Texture {
  constructor(
    mipmaps: ImageData[],
    width: number,
    height: number,
    format?: CompressedPixelFormat,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  image: { width: number; height: number };
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

export class CubeTexture extends Texture {
  constructor(
    images?: any[], // HTMLImageElement or HTMLCanvasElement
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  images: any; // returns and sets the value of Texture.image in the codde ?
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
} from '../constants';

export class CanvasTexture extends Texture {
  constructor(
    canvas: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
  );
}
import { Texture } from './Texture';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  TextureDataType,
} from '../constants';

export class DepthTexture extends Texture {
  constructor(
    width: number,
    heighht: number,
    type?: TextureDataType,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    anisotropy?: number,
  );

  image: { width: number; height: number };
}
import { Vector2, Vector } from '../math/Vector2';
import { EventDispatcher } from '../core/EventDispatcher';
import {
  Mapping,
  Wrapping,
  TextureFilter,
  PixelFormat,
  TextureDataType,
  TextureEncoding,
} from '../constants';

// Textures /////////////////////////////////////////////////////////////////////
export let TextureIdCount: number;

export class Texture extends EventDispatcher {
  constructor(
    image?: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,
    mapping?: Mapping,
    wrapS?: Wrapping,
    wrapT?: Wrapping,
    magFilter?: TextureFilter,
    minFilter?: TextureFilter,
    format?: PixelFormat,
    type?: TextureDataType,
    anisotropy?: number,
    encoding?: TextureEncoding,
  );

  id: number;
  uuid: string;
  name: string;
  sourceFile: string;
  image: any; // HTMLImageElement or ImageData or { width: number, height: number } in some children;
  mipmaps: ImageData[];
  mapping: Mapping;
  wrapS: Wrapping;
  wrapT: Wrapping;
  magFilter: TextureFilter;
  minFilter: TextureFilter;
  anisotropy: number;
  format: PixelFormat;
  type: TextureDataType;
  offset: Vector2;
  repeat: Vector2;
  center: Vector2;
  rotation: number;
  generateMipmaps: boolean;
  premultiplyAlpha: boolean;
  flipY: boolean;
  unpackAlignment: number;
  encoding: TextureEncoding;
  version: number;
  needsUpdate: boolean;
  onUpdate: () => void;
  static DEFAULT_IMAGE: any;
  static DEFAULT_MAPPING: any;

  clone(): this;
  copy(source: Texture): this;
  toJSON(meta: any): any;
  dispose(): void;
  transformUv(uv: Vector): void;
}
export * from './WireframeGeometry';
export * from './ParametricGeometry';
export * from './TetrahedronGeometry';
export * from './OctahedronGeometry';
export * from './IcosahedronGeometry';
export * from './DodecahedronGeometry';
export * from './PolyhedronGeometry';
export * from './TubeGeometry';
export * from './TorusKnotGeometry';
export * from './TorusGeometry';
export * from './TextGeometry';
export * from './SphereGeometry';
export * from './RingGeometry';
export * from './PlaneGeometry';
export * from './LatheGeometry';
export * from './ShapeGeometry';
export * from './ExtrudeGeometry';
export * from './EdgesGeometry';
export * from './ConeGeometry';
export * from './CylinderGeometry';
export * from './CircleGeometry';
export * from './BoxGeometry';
export * from './ShadowMaterial';
export * from './SpriteMaterial';
export * from './RawShaderMaterial';
export * from './ShaderMaterial';
export * from './PointsMaterial';
export * from './MeshPhysicalMaterial';
export * from './MeshStandardMaterial';
export * from './MeshPhongMaterial';
export * from './MeshToonMaterial';
export * from './MeshNormalMaterial';
export * from './MeshLambertMaterial';
export * from './MeshDepthMaterial';
export * from './MeshDistanceMaterial';
export * from './MeshBasicMaterial';
export * from './MeshMatcapMaterial';
export * from './LineDashedMaterial';
export * from './LineBasicMaterial';
export * from './Material';
import { LoadingManager } from './LoadingManager';
import { Loader } from './Loader';
import { AnimationClip } from '../animation/AnimationClip';

export class AnimationLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
  parse(json: any): AnimationClip[];
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { CompressedTexture } from '../textures/CompressedTexture';

export class CompressedTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (texture: CompressedTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { DataTexture } from '../textures/DataTexture';

export class DataTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (dataTexture: DataTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { CubeTexture } from '../textures/CubeTexture';

export class CubeTextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    urls: Array<string>,
    onLoad?: (texture: CubeTexture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): CubeTexture;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Texture } from '../textures/Texture';

/**
 * Class for loading a texture.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
export class TextureLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (texture: Texture) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): Texture;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Object3D } from '../core/Object3D';
import { Texture } from '../textures/Texture';
import { Material } from '../materials/Material';
import { AnimationClip } from '../animation/AnimationClip';

export class ObjectLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: <ObjectType extends Object3D>(object: ObjectType) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: Error | ErrorEvent) => void,
  ): void;
  parse<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void): T;
  parseGeometries(json: any): any[]; // Array of BufferGeometry or Geometry or Geometry2.
  parseMaterials(json: any, textures: Texture[]): Material[]; // Array of Classes that inherits from Matrial.
  parseAnimations(json: any): AnimationClip[];
  parseImages(
    json: any,
    onLoad: () => void,
  ): { [key: string]: HTMLImageElement };
  parseTextures(json: any, images: any): Texture[];
  parseObject<T extends Object3D>(
    data: any,
    geometries: any[],
    materials: Material[],
  ): T;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Texture } from '../textures/Texture';
import { Material } from '../materials/Material';

export class MaterialLoader extends Loader {
  constructor(manager?: LoadingManager);

  textures: { [key: string]: Texture };

  load(
    url: string,
    onLoad: (material: Material) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: Error | ErrorEvent) => void,
  ): void;
  setTextures(textures: { [key: string]: Texture }): this;
  parse(json: any): Material;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { BufferGeometry } from '../core/BufferGeometry';

export class BufferGeometryLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: (bufferGeometry: BufferGeometry) => void,
    onProgress?: (event: any) => void,
    onError?: (event: any) => void,
  ): void;
  parse(json: any): BufferGeometry;
}
import { Loader } from './Loader';

export const DefaultLoadingManager: LoadingManager;

/**
 * Handles and keeps track of loaded and pending data.
 */
export class LoadingManager {
  constructor(
    onLoad?: () => void,
    onProgress?: (url: string, loaded: number, total: number) => void,
    onError?: (url: string) => void,
  );

  onStart?: (url: string, loaded: number, total: number) => void;

  /**
   * Will be called when load starts.
   * The default is a function with empty body.
   */
  onLoad: () => void;

  /**
   * Will be called while load progresses.
   * The default is a function with empty body.
   */
  onProgress: (item: any, loaded: number, total: number) => void;

  /**
   * Will be called when each element in the scene completes loading.
   * The default is a function with empty body.
   */
  onError: (url: string) => void;

  /**
   * If provided, the callback will be passed each resource URL before a request is sent.
   * The callback may return the original URL, or a new URL to override loading behavior.
   * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
   * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
   */
  setURLModifier(callback?: (url: string) => string): this;

  /**
   * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
   * If no URL modifier is set, returns the original URL.
   * @param url the url to load
   */
  resolveURL(url: string): string;

  itemStart(url: string): void;
  itemEnd(url: string): void;
  itemError(url: string): void;

  // handlers

  addHandler(regex: RegExp, loader: Loader): this;
  removeHandler(regex: RegExp): this;
  getHandler(file: string): Loader | null;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

/**
 * A loader for loading an image.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
export class ImageLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (image: HTMLImageElement) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): HTMLImageElement;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager.js.js';

export class ImageBitmapLoader extends Loader {
  constructor(manager?: LoadingManager);

  options: undefined | object;

  setOptions(options: object): ImageBitmapLoader;
  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';
import { Font } from '../extras/core/Font';

export class FontLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad?: (responseFont: Font) => void,
    onProgress?: (event: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): void;
  parse(json: any): Font;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

export class FileLoader extends Loader {
  constructor(manager?: LoadingManager);

  mimeType: undefined | MimeType;
  responseType: undefined | string;
  withCredentials: undefined | string;
  requestHeader: undefined | { [header: string]: string };

  load(
    url: string,
    onLoad?: (response: string | ArrayBuffer) => void,
    onProgress?: (request: ProgressEvent) => void,
    onError?: (event: ErrorEvent) => void,
  ): any;
  setMimeType(mimeType: MimeType): FileLoader;
  setResponseType(responseType: string): FileLoader;
  setWithCredentials(value: string): FileLoader;
  setRequestHeader(value: { [header: string]: string }): FileLoader;
}
import { LoadingManager } from './LoadingManager';

/**
 * Base class for implementing loaders.
 */
export class Loader {
  constructor(manager?: LoadingManager);

  crossOrigin: string;
  path: string;
  resourcePath: string;
  manager: LoadingManager;

  /*
	load(): void;
	parse(): void;
	*/

  setCrossOrigin(crossOrigin: string): this;
  setPath(path: string): this;
  setResourcePath(resourcePath: string): this;
}
import { TypedArray } from '../polyfills';

export class LoaderUtils {
  static decodeText(array: TypedArray): string;
  static extractUrlBase(url: string): string;
}
export namespace Cache {
  export let enabled: boolean;
  export let files: any;

  export function add(key: string, file: any): void;
  export function get(key: string): any;
  export function remove(key: string): void;
  export function clear(): void;
}
import { Loader } from './Loader';
import { LoadingManager } from './LoadingManager';

export class AudioLoader extends Loader {
  constructor(manager?: LoadingManager);

  load(
    url: string,
    onLoad: Function,
    onPrgress: Function,
    onError: Function,
  ): void;
}
import { PerspectiveCamera } from '../cameras/PerspectiveCamera';
import { LightShadow } from './LightShadow';

export class SpotLightShadow extends LightShadow {
  camera: PerspectiveCamera;
}
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';
import { SpotLightShadow } from './SpotLightShadow';
import { Light } from './Light';

/**
 * A point light that can cast shadow in one direction.
 */
export class SpotLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    distance?: number,
    angle?: number,
    exponent?: number,
    decay?: number,
  );

  /**
   * Spotlight focus points at target.position.
   * Default position  (0,0,0).
   */
  target: Object3D;

  /**
   * Light's intensity.
   * Default  1.0.
   */
  intensity: number;

  /**
   * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
   * Default  0.0.
   */
  distance: number;

  /*
   * Maximum extent of the spotlight, in radians, from its direction.
   * Default  Math.PI/2.
   */
  angle: number;

  /**
   * Rapidity of the falloff of light from its target direction.
   * Default  10.0.
   */
  exponent: number;

  decay: number;
  shadow: SpotLightShadow;
  power: number;
  penumbra: number;
}
import { Color } from '../math/Color';
import { Light } from './Light';
import { PerspectiveCamera } from '../cameras/PerspectiveCamera';
import { LightShadow } from './LightShadow';

export class PointLightShadow extends LightShadow {
  camera: PerspectiveCamera;
}

/**
 * Affects objects using {@link MeshLambertMaterial} or {@link MeshPhongMaterial}.
 *
 * @example
 * var light = new THREE.PointLight( 0xff0000, 1, 100 );
 * light.position.set( 50, 50, 50 );
 * scene.add( light );
 */
export class PointLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    distance?: number,
    decay?: number,
  );

  /*
   * Light's intensity.
   * Default - 1.0.
   */
  intensity: number;

  /**
   * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
   * Default  0.0.
   */
  distance: number;

  decay: number;
  shadow: PointLightShadow;
  power: number;
}
import { Light } from './Light';
import { Color } from '../math/Color';

export class RectAreaLight extends Light {
  constructor(
    color?: Color | string | number,
    intensity?: number,
    width?: number,
    height?: number,
  );

  type: string;
  width: number;
  height: number;
  intensity: number;
}
import { Color } from '../math/Color';
import { Light } from './Light';

export class HemisphereLight extends Light {
  constructor(
    skyColor?: Color | string | number,
    groundColor?: Color | string | number,
    intensity?: number,
  );

  skyColor: Color;
  groundColor: Color;
  intensity: number;
}
import { OrthographicCamera } from '../cameras/OrthographicCamera';
import { LightShadow } from './LightShadow';

export class DirectionalLightShadow extends LightShadow {
  camera: OrthographicCamera;
}
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';
import { DirectionalLightShadow } from './DirectionalLightShadow';
import { Light } from './Light';

/**
 * Affects objects using MeshLambertMaterial or MeshPhongMaterial.
 *
 * @example
 * // White directional light at half intensity shining from the top.
 * var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
 * directionalLight.position.set( 0, 1, 0 );
 * scene.add( directionalLight );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/lights/DirectionalLight.js">src/lights/DirectionalLight.js</a>
 */
export class DirectionalLight extends Light {
  constructor(color?: Color | string | number, intensity?: number);

  /**
   * Target used for shadow camera orientation.
   */
  target: Object3D;

  /**
   * Light's intensity.
   * Default  1.0.
   */
  intensity: number;

  shadow: DirectionalLightShadow;
}
import { Color } from '../math/Color';
import { Light } from './Light';

/**
 * This light's color gets applied to all the objects in the scene globally.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/lights/AmbientLight.js
 */
export class AmbientLight extends Light {
  /**
   * This creates a Ambientlight with a color.
   * @param color Numeric value of the RGB component of the color or a Color instance.
   */
  constructor(color?: Color | string | number, intensity?: number);

  castShadow: boolean;
}
import { Camera } from '../cameras/Camera';
import { Light } from '../lights/Light';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Matrix4 } from '../math/Matrix4';
import { RenderTarget } from '../renderers/webgl/WebGLRenderLists';

export class LightShadow {
  constructor(camera: Camera);

  camera: Camera;
  bias: number;
  radius: number;
  mapSize: Vector2;
  map: RenderTarget;
  mapPass: RenderTarget;
  matrix: Matrix4;

  copy(source: LightShadow): this;
  clone(recursive?: boolean): this;
  toJSON(): any;
  getFrustum(): number;
  updateMatrices(light: Light, viewportIndex?: number): void;
  getViewport(viewportIndex: number): Vector4;
  getFrameExtents(): Vector2;
}
import { Color } from '../math/Color';
import { LightShadow } from './LightShadow';
import { Object3D } from '../core/Object3D';

// Lights //////////////////////////////////////////////////////////////////////////////////

/**
 * Abstract base class for lights.
 */
export class Light extends Object3D {
  constructor(hex?: number | string, intensity?: number);

  color: Color;
  intensity: number;
  isLight: true;
  receiveShadow: boolean;
  shadow: LightShadow;
  /**
   * @deprecated Use shadow.camera.fov instead.
   */
  shadowCameraFov: any;
  /**
   * @deprecated Use shadow.camera.left instead.
   */
  shadowCameraLeft: any;
  /**
   * @deprecated Use shadow.camera.right instead.
   */
  shadowCameraRight: any;
  /**
   * @deprecated Use shadow.camera.top instead.
   */
  shadowCameraTop: any;
  /**
   * @deprecated Use shadow.camera.bottom instead.
   */
  shadowCameraBottom: any;
  /**
   * @deprecated Use shadow.camera.near instead.
   */
  shadowCameraNear: any;
  /**
   * @deprecated Use shadow.camera.far instead.
   */
  shadowCameraFar: any;
  /**
   * @deprecated Use shadow.bias instead.
   */
  shadowBias: any;
  /**
   * @deprecated Use shadow.mapSize.width instead.
   */
  shadowMapWidth: any;
  /**
   * @deprecated Use shadow.mapSize.height instead.
   */
  shadowMapHeight: any;
}
import { Color } from '../math/Color';
import { LightProbe } from './LightProbe';

export class AmbientLightProbe extends LightProbe {
  constructor(color?: Color | string | number, intensity?: number);

  isAmbientLightProbe: true;
}
import { Color } from '../math/Color';
import { LightProbe } from './LightProbe';

export class HemisphereLightProbe extends LightProbe {
  constructor(
    skyColor?: Color | string | number,
    groundColor?: Color | string | number,
    intensity?: number,
  );

  isHemisphereLightProbe: true;
}
import { SphericalHarmonics3 } from '../math/SphericalHarmonics3';
import { Light } from './Light';

export class LightProbe extends Light {
  constructor(sh?: SphericalHarmonics3, intensity?: number);

  isLightProbe: true;
  sh: SphericalHarmonics3;
}
import { PerspectiveCamera } from './PerspectiveCamera';
import { Camera } from './Camera';

export class StereoCamera extends Camera {
  constructor();

  type: 'StereoCamera';

  aspect: number;
  eyeSep: number;
  cameraL: PerspectiveCamera;
  cameraR: PerspectiveCamera;

  update(camera: PerspectiveCamera): void;
}
import { Camera } from './Camera';

/**
 * Camera with perspective projection.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/cameras/PerspectiveCamera.js
 */
export class PerspectiveCamera extends Camera {
  /**
   * @param fov Camera frustum vertical field of view. Default value is 50.
   * @param aspect Camera frustum aspect ratio. Default value is 1.
   * @param near Camera frustum near plane. Default value is 0.1.
   * @param far Camera frustum far plane. Default value is 2000.
   */
  constructor(fov?: number, aspect?: number, near?: number, far?: number);

  type: 'PerspectiveCamera';

  isPerspectiveCamera: true;

  zoom: number;

  /**
   * Camera frustum vertical field of view, from bottom to top of view, in degrees.
   */
  fov: number;

  /**
   * Camera frustum aspect ratio, window width divided by window height.
   */
  aspect: number;

  /**
   * Camera frustum near plane.
   */
  near: number;

  /**
   * Camera frustum far plane.
   */
  far: number;

  focus: number;
  view: null | {
    enabled: boolean;
    fullWidth: number;
    fullHeight: number;
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
  };
  filmGauge: number;
  filmOffset: number;

  setFocalLength(focalLength: number): void;
  getFocalLength(): number;
  getEffectiveFOV(): number;
  getFilmWidth(): number;
  getFilmHeight(): number;

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:
   *
   *		 +---+---+---+
   *		 | A | B | C |
   *		 +---+---+---+
   *		 | D | E | F |
   *		 +---+---+---+
   *
   * then for each monitor you would call it like this:
   *
   *		 var w = 1920;
   *		 var h = 1080;
   *		 var fullWidth = w * 3;
   *		 var fullHeight = h * 2;
   *
   *		 // A
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *		 // B
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *		 // C
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *		 // D
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *		 // E
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *		 // F
   *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param fullWidth full width of multiview setup
   * @param fullHeight full height of multiview setup
   * @param x horizontal offset of subcamera
   * @param y vertical offset of subcamera
   * @param width width of subcamera
   * @param height height of subcamera
   */
  setViewOffset(
    fullWidth: number,
    fullHeight: number,
    x: number,
    y: number,
    width: number,
    height: number,
  ): void;
  clearViewOffset(): void;

  /**
   * Updates the camera projection matrix. Must be called after change of parameters.
   */
  updateProjectionMatrix(): void;
  toJSON(meta?: any): any;

  /**
   * @deprecated Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.
   */
  setLens(focalLength: number, frameHeight?: number): void;
}
import { Camera } from './Camera';

/**
 * Camera with orthographic projection
 *
 * @example
 * var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
 * scene.add( camera );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/cameras/OrthographicCamera.js">src/cameras/OrthographicCamera.js</a>
 */
export class OrthographicCamera extends Camera {
  /**
   * @param left Camera frustum left plane.
   * @param right Camera frustum right plane.
   * @param top Camera frustum top plane.
   * @param bottom Camera frustum bottom plane.
   * @param near Camera frustum near plane.
   * @param far Camera frustum far plane.
   */
  constructor(
    left: number,
    right: number,
    top: number,
    bottom: number,
    near?: number,
    far?: number,
  );

  type: 'OrthographicCamera';

  isOrthographicCamera: true;

  zoom: number;
  view: null | {
    enabled: boolean;
    fullWidth: number;
    fullHeight: number;
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
  };

  /**
   * Camera frustum left plane.
   */
  left: number;

  /**
   * Camera frustum right plane.
   */
  right: number;

  /**
   * Camera frustum top plane.
   */
  top: number;

  /**
   * Camera frustum bottom plane.
   */
  bottom: number;

  /**
   * Camera frustum near plane.
   */
  near: number;

  /**
   * Camera frustum far plane.
   */
  far: number;

  /**
   * Updates the camera projection matrix. Must be called after change of parameters.
   */
  updateProjectionMatrix(): void;
  setViewOffset(
    fullWidth: number,
    fullHeight: number,
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
  ): void;
  clearViewOffset(): void;
  toJSON(meta?: any): any;
}
import { WebGLRenderTargetCube } from '../renderers/WebGLRenderTargetCube';
import { WebGLRenderTargetOptions } from '../renderers/WebGLRenderTarget';
import { Scene } from '../scenes/Scene';
import { WebGLRenderer } from '../renderers/WebGLRenderer';
import { Object3D } from '../core/Object3D';

export class CubeCamera extends Object3D {
  constructor(
    near?: number,
    far?: number,
    cubeResolution?: number,
    options?: WebGLRenderTargetOptions,
  );

  type: 'CubeCamera';

  renderTarget: WebGLRenderTargetCube;

  update(renderer: WebGLRenderer, scene: Scene): void;

  clear(
    renderer: WebGLRenderer,
    color: boolean,
    depth: boolean,
    stencil: boolean,
  ): void;
}
import { PerspectiveCamera } from './PerspectiveCamera';

export class ArrayCamera extends PerspectiveCamera {
  constructor(cameras?: PerspectiveCamera[]);

  cameras: PerspectiveCamera[];
  isArrayCamera: true;
}
import { Matrix4 } from '../math/Matrix4';
import { Vector3 } from '../math/Vector3';
import { Object3D } from '../core/Object3D';

// Cameras ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Abstract base class for cameras. This class should always be inherited when you build a new camera.
 */
export class Camera extends Object3D {
  /**
   * This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.
   */
  constructor();

  /**
   * This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.
   */
  matrixWorldInverse: Matrix4;

  /**
   * This is the matrix which contains the projection.
   */
  projectionMatrix: Matrix4;

  /**
   * This is the inverse of projectionMatrix.
   */
  projectionMatrixInverse: Matrix4;

  isCamera: true;

  getWorldDirection(target: Vector3): Vector3;

  updateMatrixWorld(force?: boolean): void;
}
import { Object3D } from '../core/Object3D';
import { AudioContext } from './AudioContext';

export class AudioListener extends Object3D {
  constructor();

  type: 'AudioListener';
  context: AudioContext;
  gain: GainNode;
  filter: null | any;

  getInput(): GainNode;
  removeFilter(): void;
  setFilter(value: any): void;
  getFilter(): any;
  setMasterVolume(value: number): void;
  getMasterVolume(): number;
  updateMatrixWorld(force?: boolean): void;
}
import { AudioListener } from './AudioListener';
import { Audio } from './Audio';

export class PositionalAudio extends Audio {
  constructor(listener: AudioListener);

  panner: PannerNode;

  setRefDistance(value: number): this;
  getRefDistance(): number;
  setRolloffFactor(value: number): this;
  getRolloffFactor(): number;
  setDistanceModel(value: string): this;
  getDistanceModel(): string;
  setMaxDistance(value: number): this;
  getMaxDistance(): number;
  setDirectionalCone(
    coneInnerAngle: number,
    coneOuterAngle: number,
    coneOuterGain: number,
  ): this;
}
export const AudioContext: AudioContext;
export class AudioAnalyser {
  constructor(audio: any, fftSize: number);

  analyser: any;
  data: Uint8Array;

  getFrequencyData(): Uint8Array;
  getAverageFrequency(): number;

  /**
   * @deprecated Use {@link AudioAnalyser#getFrequencyData .getFrequencyData()} instead.
   */
  getData(file: any): any;
}
import { Object3D } from '../core/Object3D';
import { AudioListener } from './AudioListener';
import { AudioContext } from './AudioContext';

// Extras / Audio /////////////////////////////////////////////////////////////////////

export class Audio extends Object3D {
  constructor(listener: AudioListener);
  type: 'Audio';

  context: AudioContext;
  gain: GainNode;
  autoplay: boolean;
  buffer: null | Audio;
  detune: number;
  loop: boolean;
  offset: number;
  duration: number | undefined;
  playbackRate: number;
  isPlaying: boolean;
  hasPlaybackControl: boolean;
  sourceType: string;
  source: AudioBufferSourceNode;
  filters: any[];

  getOutput(): GainNode;
  setNodeSource(audioNode: AudioBufferSourceNode): this;
  setMediaElementSource(mediaElement: HTMLMediaElement): this;
  setMediaStreamSource(mediaStream: MediaStream): this;
  setBuffer(audioBuffer: AudioBuffer): this;
  play(delay?: number): this;
  onEnded(): void;
  pause(): this;
  stop(): this;
  connect(): this;
  disconnect(): this;
  setDetune(value: number): this;
  getDetune(): number;
  getFilters(): any[];
  setFilter(value: any[]): this;
  getFilter(): any;
  setFilter(filter: any): this;
  setPlaybackRate(value: number): this;
  getPlaybackRate(): number;
  getLoop(): boolean;
  setLoop(value: boolean): this;
  setLoopStart(value: number): this;
  setLoopEnd(value: number): this;
  getVolume(): number;
  setVolume(value: number): this;
  /**
   * @deprecated Use {@link AudioLoader} instead.
   */
  load(file: string): Audio;
}

export class AudioBuffer {
  constructor(context: any);

  context: any;
  ready: boolean;
  readyCallbacks: Function[];

  load(file: string): AudioBuffer;
  onReady(callback: Function): void;
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class VectorKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class StringKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class QuaternionKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class NumberKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';
import { InterpolationModes } from '../../constants';

export class ColorKeyframeTrack extends KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );
}
import { KeyframeTrack } from '../KeyframeTrack';

export class BooleanKeyframeTrack extends KeyframeTrack {
  constructor(name: string, times: any[], values: any[]);
}
export class PropertyMixer {
  constructor(binding: any, typeName: string, valueSize: number);

  binding: any;
  valueSize: number;
  buffer: any;
  cumulativeWeight: number;
  useCount: number;
  referenceCount: number;

  accumulate(accuIndex: number, weight: number): void;
  apply(accuIndex: number): void;
  saveOriginalState(): void;
  restoreOriginalState(): void;
}
export class PropertyBinding {
  constructor(rootNode: any, path: string, parsedPath?: any);

  path: string;
  parsedPath: any;
  node: any;
  rootNode: any;

  getValue(targetArray: any, offset: number): any;
  setValue(sourceArray: any, offset: number): void;
  bind(): void;
  unbind(): void;

  BindingType: { [bindingType: string]: number };
  Versioning: { [versioning: string]: number };

  GetterByBindingType: Function[];
  SetterByBindingTypeAndVersioning: Array<Function[]>;

  static create(
    root: any,
    path: any,
    parsedPath?: any,
  ): PropertyBinding | PropertyBinding.Composite;
  static parseTrackName(trackName: string): any;
  static findNode(root: any, nodeName: string): any;
}

export namespace PropertyBinding {
  export class Composite {
    constructor(targetGroup: any, path: any, parsedPath?: any);

    getValue(array: any, offset: number): any;
    setValue(array: any, offset: number): void;
    bind(): void;
    unbind(): void;
  }
}
import { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant';
import { LinearInterpolant } from '../math/interpolants/LinearInterpolant';
import { CubicInterpolant } from '../math/interpolants/CubicInterpolant';
import { InterpolationModes } from '../constants';

export class KeyframeTrack {
  constructor(
    name: string,
    times: any[],
    values: any[],
    interpolation?: InterpolationModes,
  );

  name: string;
  times: Float32Array;
  values: Float32Array;

  ValueTypeName: string;
  TimeBufferType: Float32Array;
  ValueBufferType: Float32Array;

  DefaultInterpolation: InterpolationModes;

  InterpolantFactoryMethodDiscrete(result: any): DiscreteInterpolant;
  InterpolantFactoryMethodLinear(result: any): LinearInterpolant;
  InterpolantFactoryMethodSmooth(result: any): CubicInterpolant;

  setInterpolation(interpolation: InterpolationModes): void;
  getInterpolation(): InterpolationModes;

  getValuesize(): number;

  shift(timeOffset: number): KeyframeTrack;
  scale(timeScale: number): KeyframeTrack;
  trim(startTime: number, endTime: number): KeyframeTrack;
  validate(): boolean;
  optimize(): KeyframeTrack;

  static parse(json: any): KeyframeTrack;
  static toJSON(track: KeyframeTrack): any;
}
import { AnimationClip } from './AnimationClip';

export namespace AnimationUtils {
  export function arraySlice(array: any, from: number, to: number): any;
  export function convertArray(array: any, type: any, forceClone: boolean): any;
  export function isTypedArray(object: any): boolean;
  export function getKeyFrameOrder(times: number): number[];
  export function sortedArray(
    values: any[],
    stride: number,
    order: number[],
  ): any[];
  export function flattenJSON(
    jsonKeys: string[],
    times: any[],
    values: any[],
    valuePropertyName: string,
  ): void;
  export function subclip(
    sourceClip: AnimationClip,
    name: string,
    startFrame: number,
    endFrame: number,
    fps?: number,
  ): AnimationClip;
}
export class AnimationObjectGroup {
  constructor(...args: any[]);

  uuid: string;
  stats: {
    bindingsPerObject: number;
    objects: {
      total: number;
      inUse: number;
    };
  };

  add(...args: any[]): void;
  remove(...args: any[]): void;
  uncache(...args: any[]): void;
}
import { AnimationClip } from './AnimationClip';
import { AnimationAction } from './AnimationAction';
import { EventDispatcher } from '../core/EventDispatcher';

export class AnimationMixer extends EventDispatcher {
  constructor(root: any);

  time: number;
  timeScale: number;

  clipAction(clip: AnimationClip, root?: any): AnimationAction;
  existingAction(clip: AnimationClip, root?: any): AnimationAction;
  stopAllAction(): AnimationMixer;
  update(deltaTime: number): AnimationMixer;
  setTime(timeInSeconds: number): AnimationMixer;
  getRoot(): any;
  uncacheClip(clip: AnimationClip): void;
  uncacheRoot(root: any): void;
  uncacheAction(clip: AnimationClip, root?: any): void;
}
import { KeyframeTrack } from './KeyframeTrack';
import { Bone } from '../objects/Bone';
import { MorphTarget } from '../core/Geometry';

export class AnimationClip {
  constructor(name?: string, duration?: number, tracks?: KeyframeTrack[]);

  name: string;
  tracks: KeyframeTrack[];
  duration: number;
  uuid: string;
  results: any[];

  resetDuration(): void;
  trim(): AnimationClip;
  optimize(): AnimationClip;

  static CreateFromMorphTargetSequence(
    name: string,
    morphTargetSequence: MorphTarget[],
    fps: number,
    noLoop: boolean,
  ): AnimationClip;
  static findByName(clipArray: AnimationClip[], name: string): AnimationClip;
  static CreateClipsFromMorphTargetSequences(
    morphTargets: MorphTarget[],
    fps: number,
    noLoop: boolean,
  ): AnimationClip[];
  static parse(json: any): AnimationClip;
  static parseAnimation(
    animation: any,
    bones: Bone[],
    nodeName: string,
  ): AnimationClip;
  static toJSON(): any;
}
import { AnimationMixer } from './AnimationMixer';
import { AnimationClip } from './AnimationClip';
import { AnimationActionLoopStyles } from '../constants';
// Animation ////////////////////////////////////////////////////////////////////////////////////////

export class AnimationAction {
  loop: AnimationActionLoopStyles;
  time: number;
  timeScale: number;
  weight: number;
  repetitions: number;
  paused: boolean;
  enabled: boolean;
  clampWhenFinished: boolean;
  zeroSlopeAtStart: boolean;
  zeroSlopeAtEnd: boolean;

  play(): AnimationAction;
  stop(): AnimationAction;
  reset(): AnimationAction;
  isRunning(): boolean;
  isScheduled(): boolean;
  startAt(time: number): AnimationAction;
  setLoop(
    mode: AnimationActionLoopStyles,
    repetitions: number,
  ): AnimationAction;
  setEffectiveWeight(weight: number): AnimationAction;
  getEffectiveWeight(): number;
  fadeIn(duration: number): AnimationAction;
  fadeOut(duration: number): AnimationAction;
  crossFadeFrom(
    fadeOutAction: AnimationAction,
    duration: number,
    warp: boolean,
  ): AnimationAction;
  crossFadeTo(
    fadeInAction: AnimationAction,
    duration: number,
    warp: boolean,
  ): AnimationAction;
  stopFading(): AnimationAction;
  setEffectiveTimeScale(timeScale: number): AnimationAction;
  getEffectiveTimeScale(): number;
  setDuration(duration: number): AnimationAction;
  syncWith(action: AnimationAction): AnimationAction;
  halt(duration: number): AnimationAction;
  warp(
    statTimeScale: number,
    endTimeScale: number,
    duration: number,
  ): AnimationAction;
  stopWarping(): AnimationAction;
  getMixer(): AnimationMixer;
  getClip(): AnimationClip;
  getRoot(): any;
}
export class Uniform {
  constructor(value: any);
  /**
   * @deprecated
   */
  constructor(type: string, value: any);
  /**
   * @deprecated
   */
  type: string;
  value: any;
  /**
   * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
   */
  dynamic: boolean;
  onUpdateCallback: Function;

  /**
   * @deprecated Use {@link Object3D#onBeforeRender object.onBeforeRender()} instead.
   */
  onUpdate(callback: Function): Uniform;
}
import { BufferGeometry } from './BufferGeometry';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferGeometry.js">src/core/InstancedBufferGeometry.js</a>
 */
export class InstancedBufferGeometry extends BufferGeometry {
  constructor();

  groups: { start: number; count: number; instances: number }[];
  maxInstancedCount: number;

  addGroup(start: number, count: number, instances: number): void;
}
import { BufferAttribute } from './BufferAttribute';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Matrix4 } from '../math/Matrix4';
import { Vector2 } from '../math/Vector2';
import { Vector3 } from '../math/Vector3';
import { Object3D } from './Object3D';
import { Geometry } from './Geometry';
import { DirectGeometry } from './DirectGeometry';
import { EventDispatcher } from './EventDispatcher';
import { InterleavedBufferAttribute } from './InterleavedBufferAttribute';

/**
 * This is a superefficent class for geometries because it saves all data in buffers.
 * It reduces memory costs and cpu cycles. But it is not as easy to work with because of all the nessecary buffer calculations.
 * It is mainly interesting when working with static objects.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js">src/core/BufferGeometry.js</a>
 */
export class BufferGeometry extends EventDispatcher {
  /**
   * This creates a new BufferGeometry. It also sets several properties to an default value.
   */
  constructor();

  static MaxIndex: number;

  /**
   * Unique number of this buffergeometry instance
   */
  id: number;
  uuid: string;
  name: string;
  type: string;
  index: BufferAttribute;
  attributes: {
    [name: string]: BufferAttribute | InterleavedBufferAttribute;
  };
  morphAttributes: {
    [name: string]: (BufferAttribute | InterleavedBufferAttribute)[];
  };
  groups: { start: number; count: number; materialIndex?: number }[];
  boundingBox: Box3;
  boundingSphere: Sphere;
  drawRange: { start: number; count: number };
  userData: { [key: string]: any };
  isBufferGeometry: boolean;

  getIndex(): BufferAttribute;
  setIndex(index: BufferAttribute | number[]): void;

  setAttribute(
    name: string,
    attribute: BufferAttribute | InterleavedBufferAttribute,
  ): BufferGeometry;
  getAttribute(name: string): BufferAttribute | InterleavedBufferAttribute;
  deleteAttribute(name: string): BufferGeometry;

  addGroup(start: number, count: number, materialIndex?: number): void;
  clearGroups(): void;

  setDrawRange(start: number, count: number): void;

  /**
   * Bakes matrix transform directly into vertex coordinates.
   */
  applyMatrix(matrix: Matrix4): BufferGeometry;

  rotateX(angle: number): BufferGeometry;
  rotateY(angle: number): BufferGeometry;
  rotateZ(angle: number): BufferGeometry;
  translate(x: number, y: number, z: number): BufferGeometry;
  scale(x: number, y: number, z: number): BufferGeometry;
  lookAt(v: Vector3): void;

  center(): BufferGeometry;

  setFromObject(object: Object3D): BufferGeometry;
  setFromPoints(points: Vector3[] | Vector2[]): BufferGeometry;
  updateFromObject(object: Object3D): void;

  fromGeometry(geometry: Geometry, settings?: any): BufferGeometry;

  fromDirectGeometry(geometry: DirectGeometry): BufferGeometry;

  /**
   * Computes bounding box of the geometry, updating Geometry.boundingBox attribute.
   * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingBox(): void;

  /**
   * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
   * Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingSphere(): void;

  /**
   * Computes vertex normals by averaging face normals.
   */
  computeVertexNormals(): void;

  merge(geometry: BufferGeometry, offset: number): BufferGeometry;
  normalizeNormals(): void;

  toNonIndexed(): BufferGeometry;

  toJSON(): any;
  clone(): this;
  copy(source: BufferGeometry): this;

  /**
   * Disposes the object from memory.
   * You need to call this when you want the bufferGeometry removed while the application is running.
   */
  dispose(): void;

  /**
   * @deprecated Use {@link BufferGeometry#groups .groups} instead.
   */
  drawcalls: any;

  /**
   * @deprecated Use {@link BufferGeometry#groups .groups} instead.
   */
  offsets: any;

  /**
   * @deprecated Use {@link BufferGeometry#setIndex .setIndex()} instead.
   */
  addIndex(index: any): void;

  /**
   * @deprecated Use {@link BufferGeometry#addGroup .addGroup()} instead.
   */
  addDrawCall(start: any, count: any, indexOffset?: any): void;

  /**
   * @deprecated Use {@link BufferGeometry#clearGroups .clearGroups()} instead.
   */
  clearDrawCalls(): void;

  /**
   * @deprecated Use {@link BufferGeometry#setAttribute .setAttribute()} instead.
   */
  addAttribute(
    name: string,
    attribute: BufferAttribute | InterleavedBufferAttribute,
  ): BufferGeometry;

  /**
   * @deprecated Use {@link BufferGeometry#deleteAttribute .deleteAttribute()} instead.
   */
  removeAttribute(name: string): BufferGeometry;

  addAttribute(name: any, array: any, itemSize: any): any;
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';
import { Face3 } from './Face3';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Matrix4 } from '../math/Matrix4';
import { BufferGeometry } from './BufferGeometry';
import { Matrix } from '../math/Matrix3';
import { Mesh } from '../objects/Mesh';
import { Bone } from '../objects/Bone';
import { AnimationClip } from '../animation/AnimationClip';
import { EventDispatcher } from './EventDispatcher';

/**
 * @deprecated Use {@link Face3} instead.
 */

export interface MorphTarget {
  name: string;
  vertices: Vector3[];
}

export interface MorphColor {
  name: string;
  colors: Color[];
}

export interface MorphNormals {
  name: string;
  normals: Vector3[];
}

export let GeometryIdCount: number;

/**
 * Base class for geometries
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/core/Geometry.js
 */
export class Geometry extends EventDispatcher {
  constructor();

  /**
   * Unique number of this geometry instance
   */
  id: number;

  uuid: string;

  isGeometry: boolean;

  /**
   * Name for this geometry. Default is an empty string.
   */
  name: string;

  type: string;

  /**
   * The array of vertices hold every position of points of the model.
   * To signal an update in this array, Geometry.verticesNeedUpdate needs to be set to true.
   */
  vertices: Vector3[];

  /**
   * Array of vertex colors, matching number and order of vertices.
   * Used in ParticleSystem, Line and Ribbon.
   * Meshes use per-face-use-of-vertex colors embedded directly in faces.
   * To signal an update in this array, Geometry.colorsNeedUpdate needs to be set to true.
   */
  colors: Color[];

  /**
   * Array of triangles or/and quads.
   * The array of faces describe how each vertex in the model is connected with each other.
   * To signal an update in this array, Geometry.elementsNeedUpdate needs to be set to true.
   */
  faces: Face3[];

  /**
   * Array of face UV layers.
   * Each UV layer is an array of UV matching order and number of vertices in faces.
   * To signal an update in this array, Geometry.uvsNeedUpdate needs to be set to true.
   */
  faceVertexUvs: Vector2[][][];

  /**
   * Array of morph targets. Each morph target is a Javascript object:
   *
   *		 { name: "targetName", vertices: [ new THREE.Vector3(), ... ] }
   *
   * Morph vertices match number and order of primary vertices.
   */
  morphTargets: MorphTarget[];

  /**
   * Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:
   *
   *		 morphNormal = { name: "NormalName", normals: [ new THREE.Vector3(), ... ] }
   */
  morphNormals: MorphNormals[];

  /**
   * Array of skinning weights, matching number and order of vertices.
   */
  skinWeights: Vector4[];

  /**
   * Array of skinning indices, matching number and order of vertices.
   */
  skinIndices: Vector4[];

  /**
   *
   */
  lineDistances: number[];

  /**
   * Bounding box.
   */
  boundingBox: Box3;

  /**
   * Bounding sphere.
   */
  boundingSphere: Sphere;

  /**
   * Set to true if the vertices array has been updated.
   */
  verticesNeedUpdate: boolean;

  /**
   * Set to true if the faces array has been updated.
   */
  elementsNeedUpdate: boolean;

  /**
   * Set to true if the uvs array has been updated.
   */
  uvsNeedUpdate: boolean;

  /**
   * Set to true if the normals array has been updated.
   */
  normalsNeedUpdate: boolean;

  /**
   * Set to true if the colors array has been updated.
   */
  colorsNeedUpdate: boolean;

  /**
   * Set to true if the linedistances array has been updated.
   */
  lineDistancesNeedUpdate: boolean;

  /**
   *
   */
  groupsNeedUpdate: boolean;

  /**
   * Bakes matrix transform directly into vertex coordinates.
   */
  applyMatrix(matrix: Matrix4): Geometry;

  rotateX(angle: number): Geometry;
  rotateY(angle: number): Geometry;
  rotateZ(angle: number): Geometry;

  translate(x: number, y: number, z: number): Geometry;
  scale(x: number, y: number, z: number): Geometry;
  lookAt(vector: Vector3): void;

  fromBufferGeometry(geometry: BufferGeometry): Geometry;

  center(): Geometry;

  normalize(): Geometry;

  /**
   * Computes face normals.
   */
  computeFaceNormals(): void;

  /**
   * Computes vertex normals by averaging face normals.
   * Face normals must be existing / computed beforehand.
   */
  computeVertexNormals(areaWeighted?: boolean): void;

  /**
   * Compute vertex normals, but duplicating face normals.
   */
  computeFlatVertexNormals(): void;

  /**
   * Computes morph normals.
   */
  computeMorphNormals(): void;

  /**
   * Computes bounding box of the geometry, updating {@link Geometry.boundingBox} attribute.
   */
  computeBoundingBox(): void;

  /**
   * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
   * Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are null.
   */
  computeBoundingSphere(): void;

  merge(
    geometry: Geometry,
    matrix?: Matrix,
    materialIndexOffset?: number,
  ): void;

  mergeMesh(mesh: Mesh): void;

  /**
   * Checks for duplicate vertices using hashmap.
   * Duplicated vertices are removed and faces' vertices are updated.
   */
  mergeVertices(): number;

  setFromPoints(points: Array<Vector2> | Array<Vector3>): this;

  sortFacesByMaterialIndex(): void;

  toJSON(): any;

  /**
   * Creates a new clone of the Geometry.
   */
  clone(): this;

  copy(source: Geometry): this;

  /**
   * Removes The object from memory.
   * Don't forget to call this method when you remove an geometry because it can cuase meomory leaks.
   */
  dispose(): void;

  // These properties do not exist in a normal Geometry class, but if you use the instance that was passed by JSONLoader, it will be added.
  bones: Bone[];
  animation: AnimationClip;
  animations: AnimationClip[];
}
import { InterleavedBuffer } from './InterleavedBuffer';
/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBufferAttribute.js">src/core/InterleavedBufferAttribute.js</a>
 */
export class InterleavedBufferAttribute {
  constructor(
    interleavedBuffer: InterleavedBuffer,
    itemSize: number,
    offset: number,
    normalized?: boolean,
  );

  uuid: string;
  data: InterleavedBuffer;
  itemSize: number;
  offset: number;
  count: number;
  normalized: boolean;
  array: any[];

  getX(index: number): number;
  setX(index: number, x: number): InterleavedBufferAttribute;
  getY(index: number): number;
  setY(index: number, y: number): InterleavedBufferAttribute;
  getZ(index: number): number;
  setZ(index: number, z: number): InterleavedBufferAttribute;
  getW(index: number): number;
  setW(index: number, z: number): InterleavedBufferAttribute;
  setXY(index: number, x: number, y: number): InterleavedBufferAttribute;
  setXYZ(
    index: number,
    x: number,
    y: number,
    z: number,
  ): InterleavedBufferAttribute;
  setXYZW(
    index: number,
    x: number,
    y: number,
    z: number,
    w: number,
  ): InterleavedBufferAttribute;
  /**
   * @deprecated Use {@link InterleavedBufferAttribute#count .count} instead.
   */
  length: number;
}
import { InterleavedBuffer } from './InterleavedBuffer';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedInterleavedBuffer.js">src/core/InstancedInterleavedBuffer.js</a>
 */
export class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(
    array: ArrayLike<number>,
    stride: number,
    meshPerAttribute?: number,
  );

  meshPerAttribute: number;
}
import { InterleavedBufferAttribute } from './InterleavedBufferAttribute';
import { Usage } from '../constants';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBuffer.js">src/core/InterleavedBuffer.js</a>
 */
export class InterleavedBuffer {
  constructor(array: ArrayLike<number>, stride: number);

  array: ArrayLike<number>;
  stride: number;
  usage: Usage;
  updateRange: { offset: number; count: number };
  version: number;
  length: number;
  count: number;
  needsUpdate: boolean;

  setUsage(usage: Usage): InterleavedBuffer;
  clone(): this;
  copy(source: InterleavedBuffer): this;
  copyAt(
    index1: number,
    attribute: InterleavedBufferAttribute,
    index2: number,
  ): InterleavedBuffer;
  set(value: ArrayLike<number>, index: number): InterleavedBuffer;
}
import { BufferGeometry } from './BufferGeometry';
import { BufferAttribute } from './BufferAttribute';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/BufferGeometryUtils.js">examples/js/BufferGeometryUtils.js</a>
 */
export namespace BufferGeometryUtils {
  export function mergeBufferGeometries(
    geometries: BufferGeometry[],
  ): BufferGeometry;
  export function computeTangents(geometry: BufferGeometry): null;
  export function mergeBufferAttributes(
    attributes: BufferAttribute[],
  ): BufferAttribute;
}

/**
 * @deprecated
 */
export namespace GeometryUtils {
  /**
   * @deprecated Use {@link Geometry#merge geometry.merge( geometry2, matrix, materialIndexOffset )} instead.
   */
  export function merge(
    geometry1: any,
    geometry2: any,
    materialIndexOffset?: any,
  ): any;
  /**
   * @deprecated Use {@link Geometry#center geometry.center()} instead.
   */
  export function center(geometry: any): any;
}

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferAttribute.js">src/core/InstancedBufferAttribute.js</a>
 */
export class InstancedBufferAttribute extends BufferAttribute {
  constructor(
    array: ArrayLike<number>,
    itemSize: number,
    normalized?: boolean,
    meshPerAttribute?: number,
  );

  meshPerAttribute: number;
}
import { Usage } from '../constants';

/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferAttribute.js">src/core/BufferAttribute.js</a>
 */
export class BufferAttribute {
  constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean); // array parameter should be TypedArray.

  name: string;
  array: ArrayLike<number>;
  itemSize: number;
  usage: Usage;
  updateRange: { offset: number; count: number };
  version: number;
  normalized: boolean;
  needsUpdate: boolean;
  count: number;
  onUpload: Function;

  setUsage(usage: Usage): BufferAttribute;
  clone(): this;
  copy(source: BufferAttribute): this;
  copyAt(
    index1: number,
    attribute: BufferAttribute,
    index2: number,
  ): BufferAttribute;
  copyArray(array: ArrayLike<number>): BufferAttribute;
  copyColorsArray(
    colors: { r: number; g: number; b: number }[],
  ): BufferAttribute;
  copyVector2sArray(vectors: { x: number; y: number }[]): BufferAttribute;
  copyVector3sArray(
    vectors: { x: number; y: number; z: number }[],
  ): BufferAttribute;
  copyVector4sArray(
    vectors: { x: number; y: number; z: number; w: number }[],
  ): BufferAttribute;
  set(
    value: ArrayLike<number> | ArrayBufferView,
    offset?: number,
  ): BufferAttribute;
  getX(index: number): number;
  setX(index: number, x: number): BufferAttribute;
  getY(index: number): number;
  setY(index: number, y: number): BufferAttribute;
  getZ(index: number): number;
  setZ(index: number, z: number): BufferAttribute;
  getW(index: number): number;
  setW(index: number, z: number): BufferAttribute;
  setXY(index: number, x: number, y: number): BufferAttribute;
  setXYZ(index: number, x: number, y: number, z: number): BufferAttribute;
  setXYZW(
    index: number,
    x: number,
    y: number,
    z: number,
    w: number,
  ): BufferAttribute;
  /**
   * @deprecated Use {@link BufferAttribute#count .count} instead.
   */
  length: number;
}

/**
 * @deprecated THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.
 */
export class Int8Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.
 */
export class Uint8Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.
 */
export class Uint8ClampedAttribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.
 */
export class Int16Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.
 */
export class Uint16Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.
 */
export class Int32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.
 */
export class Uint32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.
 */
export class Float32Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

/**
 * @deprecated THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.
 */
export class Float64Attribute extends BufferAttribute {
  constructor(array: any, itemSize: number);
}

export class Int8BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint8BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Int16BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint16BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Int32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Uint32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Float32BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}

export class Float64BufferAttribute extends BufferAttribute {
  constructor(
    array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number,
    itemSize: number,
    normalized?: boolean,
  );
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';

export interface Event {
  type: string;
  target?: any;
  [attachment: string]: any;
}

/**
 * Triangle face.
 *
 * @source https://github.com/mrdoob/three.js/blob/master/src/core/Face3.js
 */
export class Face3 {
  /**
   * @param a Vertex A index.
   * @param b Vertex B index.
   * @param c Vertex C index.
   * @param normal Face normal or array of vertex normals.
   * @param color Face color or array of vertex colors.
   * @param materialIndex Material index.
   */
  constructor(
    a: number,
    b: number,
    c: number,
    normal?: Vector3,
    color?: Color,
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    normal?: Vector3,
    vertexColors?: Color[],
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    vertexNormals?: Vector3[],
    color?: Color,
    materialIndex?: number,
  );
  constructor(
    a: number,
    b: number,
    c: number,
    vertexNormals?: Vector3[],
    vertexColors?: Color[],
    materialIndex?: number,
  );

  /**
   * Vertex A index.
   */
  a: number;

  /**
   * Vertex B index.
   */
  b: number;

  /**
   * Vertex C index.
   */
  c: number;

  /**
   * Face normal.
   */
  normal: Vector3;

  /**
   * Array of 4 vertex normals.
   */
  vertexNormals: Vector3[];

  /**
   * Face color.
   */
  color: Color;

  /**
   * Array of 4 vertex normals.
   */
  vertexColors: Color[];

  /**
   * Material index (points to {@link Geometry.materials}).
   */
  materialIndex: number;

  clone(): this;
  copy(source: Face3): this;
}
import { Vector3 } from '../math/Vector3';
import { Euler } from '../math/Euler';
import { Quaternion } from '../math/Quaternion';
import { Matrix4 } from '../math/Matrix4';
import { Matrix3 } from '../math/Matrix3';
import { Layers } from './Layers';
import { WebGLRenderer } from '../renderers/WebGLRenderer';
import { Scene } from '../scenes/Scene';
import { Camera } from '../cameras/Camera';
import { Geometry } from './Geometry';
import { Material } from '../materials/Material';
import { Group } from '../objects/Group';
import { Raycaster } from './Raycaster';
import { EventDispatcher } from './EventDispatcher';
import { BufferGeometry } from './BufferGeometry';
import { Intersection } from './Raycaster';

export let Object3DIdCount: number;

/**
 * Base class for scene graph objects
 */
export class Object3D extends EventDispatcher {
  constructor();

  /**
   * Unique number of this object instance.
   */
  id: number;

  /**
   *
   */
  uuid: string;

  /**
   * Optional name of the object (doesn't need to be unique).
   */
  name: string;

  type: string;

  /**
   * Object's parent in the scene graph.
   */
  parent: Object3D | null;

  /**
   * Array with object's children.
   */
  children: Object3D[];

  /**
   * Up direction.
   */
  up: Vector3;

  /**
   * Object's local position.
   */
  position: Vector3;

  /**
   * Object's local rotation (Euler angles), in radians.
   */
  rotation: Euler;

  /**
   * Global rotation.
   */
  quaternion: Quaternion;

  /**
   * Object's local scale.
   */
  scale: Vector3;

  modelViewMatrix: Matrix4;

  normalMatrix: Matrix3;

  /**
   * Local transform.
   */
  matrix: Matrix4;

  /**
   * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.
   */
  matrixWorld: Matrix4;

  /**
   * When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property.
   */
  matrixAutoUpdate: boolean;

  /**
   * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
   */
  matrixWorldNeedsUpdate: boolean;

  layers: Layers;
  /**
   * Object gets rendered if true.
   */
  visible: boolean;

  /**
   * Gets rendered into shadow map.
   */
  castShadow: boolean;

  /**
   * Material gets baked in shadow receiving.
   */
  receiveShadow: boolean;

  /**
   * When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible.
   */
  frustumCulled: boolean;

  /**
   * Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder. Opaque and transparent objects remain sorted independently though. When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.
   */
  renderOrder: number;

  /**
   * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.
   */
  userData: { [key: string]: any };

  /**
   * Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.
   * When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in
   * the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a
   * transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.
   */
  customDepthMaterial: Material;

  /**
   * Same as customDepthMaterial, but used with PointLight.
   */
  customDistanceMaterial: Material;

  /**
   * Used to check whether this or derived classes are Object3Ds. Default is true.
   * You should not change this, as it is used internally for optimisation.
   */
  isObject3D: true;

  /**
   * Calls before rendering object
   */
  onBeforeRender: (
    renderer: WebGLRenderer,
    scene: Scene,
    camera: Camera,
    geometry: Geometry | BufferGeometry,
    material: Material,
    group: Group,
  ) => void;

  /**
   * Calls after rendering object
   */
  onAfterRender: (
    renderer: WebGLRenderer,
    scene: Scene,
    camera: Camera,
    geometry: Geometry | BufferGeometry,
    material: Material,
    group: Group,
  ) => void;

  static DefaultUp: Vector3;
  static DefaultMatrixAutoUpdate: boolean;

  /**
   * This updates the position, rotation and scale with the matrix.
   */
  applyMatrix(matrix: Matrix4): void;

  applyQuaternion(quaternion: Quaternion): this;

  /**
   *
   */
  setRotationFromAxisAngle(axis: Vector3, angle: number): void;

  /**
   *
   */
  setRotationFromEuler(euler: Euler): void;

  /**
   *
   */
  setRotationFromMatrix(m: Matrix4): void;

  /**
   *
   */
  setRotationFromQuaternion(q: Quaternion): void;

  /**
   * Rotate an object along an axis in object space. The axis is assumed to be normalized.
   * @param axis	A normalized vector in object space.
   * @param angle	The angle in radians.
   */
  rotateOnAxis(axis: Vector3, angle: number): this;

  /**
   * Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.
   * @param axis	A normalized vector in object space.
   * @param angle	The angle in radians.
   */
  rotateOnWorldAxis(axis: Vector3, angle: number): this;

  /**
   *
   * @param angle
   */
  rotateX(angle: number): this;

  /**
   *
   * @param angle
   */
  rotateY(angle: number): this;

  /**
   *
   * @param angle
   */
  rotateZ(angle: number): this;

  /**
   * @param axis	A normalized vector in object space.
   * @param distance	The distance to translate.
   */
  translateOnAxis(axis: Vector3, distance: number): this;

  /**
   * Translates object along x axis by distance.
   * @param distance Distance.
   */
  translateX(distance: number): this;

  /**
   * Translates object along y axis by distance.
   * @param distance Distance.
   */
  translateY(distance: number): this;

  /**
   * Translates object along z axis by distance.
   * @param distance Distance.
   */
  translateZ(distance: number): this;

  /**
   * Updates the vector from local space to world space.
   * @param vector A local vector.
   */
  localToWorld(vector: Vector3): Vector3;

  /**
   * Updates the vector from world space to local space.
   * @param vector A world vector.
   */
  worldToLocal(vector: Vector3): Vector3;

  /**
   * Rotates object to face point in space.
   * @param vector A world vector to look at.
   */
  lookAt(vector: Vector3 | number, y?: number, z?: number): void;

  /**
   * Adds object as child of this object.
   */
  add(...object: Object3D[]): this;

  /**
   * Removes object as child of this object.
   */
  remove(...object: Object3D[]): this;

  /**
   * Adds object as a child of this, while maintaining the object's world transform.
   */
  attach(object: Object3D): this;

  /**
   * Searches through the object's children and returns the first with a matching id.
   * @param id	Unique number of the object instance
   */
  getObjectById(id: number): Object3D | undefined;

  /**
   * Searches through the object's children and returns the first with a matching name.
   * @param name	String to match to the children's Object3d.name property.
   */
  getObjectByName(name: string): Object3D | undefined;

  getObjectByProperty(name: string, value: string): Object3D | undefined;

  getWorldPosition(target: Vector3): Vector3;
  getWorldQuaternion(target: Quaternion): Quaternion;
  getWorldScale(target: Vector3): Vector3;
  getWorldDirection(target: Vector3): Vector3;

  raycast(raycaster: Raycaster, intersects: Intersection[]): void;

  traverse(callback: (object: Object3D) => any): void;

  traverseVisible(callback: (object: Object3D) => any): void;

  traverseAncestors(callback: (object: Object3D) => any): void;

  /**
   * Updates local transform.
   */
  updateMatrix(): void;

  /**
   * Updates global transform of the object and its children.
   */
  updateMatrixWorld(force?: boolean): void;

  updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;

  toJSON(meta?: {
    geometries: any;
    materials: any;
    textures: any;
    images: any;
  }): any;

  clone(recursive?: boolean): this;

  /**
   *
   * @param object
   * @param recursive
   */
  copy(source: this, recursive?: boolean): this;
}
import { Vector3 } from '../math/Vector3';
import { Face3 } from './Face3';
import { Object3D } from './Object3D';
import { Vector2 } from '../math/Vector2';
import { Ray } from '../math/Ray';
import { Camera } from '../cameras/Camera';

export interface Intersection {
  distance: number;
  distanceToRay?: number;
  point: Vector3;
  index?: number;
  face?: Face3 | null;
  faceIndex?: number;
  object: Object3D;
  uv?: Vector2;
}

export interface RaycasterParameters {
  Mesh?: any;
  Line?: any;
  LOD?: any;
  Points?: { threshold: number };
  Sprite?: any;
}

export class Raycaster {
  /**
   * This creates a new raycaster object.
   * @param origin The origin vector where the ray casts from.
   * @param direction The direction vector that gives direction to the ray. Should be normalized.
   * @param near All results returned are further away than near. Near can't be negative. Default value is 0.
   * @param far All results returned are closer then far. Far can't be lower then near . Default value is Infinity.
   */
  constructor(
    origin?: Vector3,
    direction?: Vector3,
    near?: number,
    far?: number,
  );

  /** The Ray used for the raycasting. */
  ray: Ray;

  /**
   * The near factor of the raycaster. This value indicates which objects can be discarded based on the
   * distance. This value shouldn't be negative and should be smaller than the far property.
   */
  near: number;

  /**
   * The far factor of the raycaster. This value indicates which objects can be discarded based on the
   * distance. This value shouldn't be negative and should be larger than the near property.
   */
  far: number;

  /**
   * The camera to use when raycasting against view-dependent objects such as billboarded objects like Sprites. This field
   * can be set manually or is set when calling "setFromCamera".
   */
  camera: Camera;

  params: RaycasterParameters;

  /**
   * The precision factor of the raycaster when intersecting Line objects.
   */
  linePrecision: number;

  /**
   * Updates the ray with a new origin and direction.
   * @param origin The origin vector where the ray casts from.
   * @param direction The normalized direction vector that gives direction to the ray.
   */
  set(origin: Vector3, direction: Vector3): void;

  /**
   * Updates the ray with a new origin and direction.
   * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
   * @param camera camera from which the ray should originate
   */
  setFromCamera(coords: { x: number; y: number }, camera: Camera): void;

  /**
   * Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.
   * @param object The object to check for intersection with the ray.
   * @param recursive If true, it also checks all descendants. Otherwise it only checks intersecton with the object. Default is false.
   * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
   */
  intersectObject(
    object: Object3D,
    recursive?: boolean,
    optionalTarget?: Intersection[],
  ): Intersection[];

  /**
   * Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by .intersectObject.
   * @param objects The objects to check for intersection with the ray.
   * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersecton with the objects. Default is false.
   * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
   */
  intersectObjects(
    objects: Object3D[],
    recursive?: boolean,
    optionalTarget?: Intersection[],
  ): Intersection[];
}
export class Layers {
  constructor();

  mask: number;

  set(channel: number): void;
  enable(channel: number): void;
  enableAll(): void;
  toggle(channel: number): void;
  disable(channel: number): void;
  disableAll(): void;
  test(layers: Layers): boolean;
}
import { Event } from './Face3';

/**
 * JavaScript events for custom objects
 *
 * @source src/core/EventDispatcher.js
 */
export class EventDispatcher {
  /**
   * Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
   */
  constructor();

  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(type: string, listener: (event: Event) => void): void;

  /**
   * Checks if listener is added to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  hasEventListener(type: string, listener: (event: Event) => void): boolean;

  /**
   * Removes a listener from an event type.
   * @param type The type of the listener that gets removed.
   * @param listener The listener function that gets removed.
   */
  removeEventListener(type: string, listener: (event: Event) => void): void;

  /**
   * Fire an event type.
   * @param type The type of event that gets fired.
   */
  dispatchEvent(event: { type: string; [attachment: string]: any }): void;
}
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';
import { Vector2 } from '../math/Vector2';
import { Vector4 } from '../math/Vector4';
import { Box3 } from '../math/Box3';
import { Sphere } from '../math/Sphere';
import { Geometry } from './Geometry';
import { MorphTarget } from './Geometry';
/**
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/DirectGeometry.js">src/core/DirectGeometry.js</a>
 */
export class DirectGeometry {
  constructor();

  id: number;
  uuid: string;
  name: string;
  type: string;
  indices: number[];
  vertices: Vector3[];
  normals: Vector3[];
  colors: Color[];
  uvs: Vector2[];
  uvs2: Vector2[];
  groups: { start: number; materialIndex: number }[];
  morphTargets: MorphTarget[];
  skinWeights: Vector4[];
  skinIndices: Vector4[];
  boundingBox: Box3;
  boundingSphere: Sphere;
  verticesNeedUpdate: boolean;
  normalsNeedUpdate: boolean;
  colorsNeedUpdate: boolean;
  uvsNeedUpdate: boolean;
  groupsNeedUpdate: boolean;

  computeBoundingBox(): void;
  computeBoundingSphere(): void;
  computeGroups(geometry: Geometry): void;
  fromGeometry(geometry: Geometry): DirectGeometry;
  dispose(): void;
}
/**
 * Object for keeping track of time.
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/core/Clock.js">src/core/Clock.js</a>
 */
export class Clock {
  /**
   * @param autoStart Automatically start the clock.
   */
  constructor(autoStart?: boolean);

  /**
   * If set, starts the clock automatically when the first update is called.
   */
  autoStart: boolean;

  /**
   * When the clock is running, It holds the starttime of the clock.
   * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
   */
  startTime: number;

  /**
   * When the clock is running, It holds the previous time from a update.
   * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
   */
  oldTime: number;

  /**
   * When the clock is running, It holds the time elapsed between the start of the clock to the previous update.
   * This parameter is in seconds of three decimal places.
   */
  elapsedTime: number;

  /**
   * This property keeps track whether the clock is running or not.
   */
  running: boolean;

  /**
   * Starts clock.
   */
  start(): void;

  /**
   * Stops clock.
   */
  stop(): void;

  /**
   * Get the seconds passed since the clock started.
   */
  getElapsedTime(): number;

  /**
   * Get the seconds passed since the last call to this method.
   */
  getDelta(): number;
}
import { Interpolant } from '../Interpolant';

export class QuaternionLinearInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class LinearInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class DiscreteInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
import { Interpolant } from '../Interpolant';

export class CubicInterpolant extends Interpolant {
  constructor(
    parameterPositions: any,
    samplesValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
export abstract class Interpolant {
  constructor(
    parameterPositions: any,
    sampleValues: any,
    sampleSize: number,
    resultBuffer?: any,
  );

  parameterPositions: any;
  sampleValues: any;
  valueSize: number;
  resultBuffer: any;

  evaluate(time: number): any;
}
import { Vector2 } from './Vector2';
import { Vector3 } from './Vector3';
import { Plane } from './Plane';
import { Box3 } from './Box3';

export interface SplineControlPoint {
  x: number;
  y: number;
  z: number;
}

export class Triangle {
  constructor(a?: Vector3, b?: Vector3, c?: Vector3);

  a: Vector3;
  b: Vector3;
  c: Vector3;

  set(a: Vector3, b: Vector3, c: Vector3): Triangle;
  setFromPointsAndIndices(
    points: Vector3[],
    i0: number,
    i1: number,
    i2: number,
  ): Triangle;
  clone(): this;
  copy(triangle: Triangle): this;
  getArea(): number;
  getMidpoint(target: Vector3): Vector3;
  getNormal(target: Vector3): Vector3;
  getPlane(target: Plane): Plane;
  getBarycoord(point: Vector3, target: Vector3): Vector3;
  getUV(
    point: Vector3,
    uv1: Vector2,
    uv2: Vector2,
    uv3: Vector2,
    target: Vector2,
  ): Vector2;
  containsPoint(point: Vector3): boolean;
  intersectsBox(box: Box3): boolean;
  isFrontFacing(direction: Vector3): boolean;
  closestPointToPoint(point: Vector3, target: Vector3): Vector3;
  equals(triangle: Triangle): boolean;

  static getNormal(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    target: Vector3,
  ): Vector3;
  static getBarycoord(
    point: Vector3,
    a: Vector3,
    b: Vector3,
    c: Vector3,
    target: Vector3,
  ): Vector3;
  static containsPoint(
    point: Vector3,
    a: Vector3,
    b: Vector3,
    c: Vector3,
  ): boolean;
  static getUV(
    point: Vector3,
    p1: Vector3,
    p2: Vector3,
    p3: Vector3,
    uv1: Vector2,
    uv2: Vector2,
    uv3: Vector2,
    target: Vector2,
  ): Vector2;
  static isFrontFacing(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    direction: Vector3,
  ): boolean;
}
import { Vector3 } from './Vector3';

export class Spherical {
  constructor(radius?: number, phi?: number, theta?: number);

  radius: number;
  phi: number;
  theta: number;

  set(radius: number, phi: number, theta: number): this;
  clone(): this;
  copy(other: Spherical): this;
  makeSafe(): this;
  setFromVector3(v: Vector3): this;
  setFromCartesianCoords(x: number, y: number, z: number): this;
}
import { Vector3 } from './Vector3';

export class Cylindrical {
  constructor(radius?: number, theta?: number, y?: number);

  radius: number;
  theta: number;
  y: number;

  clone(): this;
  copy(other: Cylindrical): this;
  set(radius: number, theta: number, y: number): this;
  setFromVector3(vec3: Vector3): this;
  setFromCartesianCoords(x: number, y: number, z: number): this;
}
import { Vector3 } from './Vector3';
import { Sphere } from './Sphere';
import { Line3 } from './Line3';
import { Box3 } from './Box3';
import { Matrix4 } from './Matrix4';
import { Matrix3 } from './Matrix3';

export class Plane {
  constructor(normal?: Vector3, constant?: number);

  normal: Vector3;
  constant: number;

  set(normal: Vector3, constant: number): Plane;
  setComponents(x: number, y: number, z: number, w: number): Plane;
  setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
  setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
  clone(): this;
  copy(plane: Plane): this;
  normalize(): Plane;
  negate(): Plane;
  distanceToPoint(point: Vector3): number;
  distanceToSphere(sphere: Sphere): number;
  projectPoint(point: Vector3, target: Vector3): Vector3;
  orthoPoint(point: Vector3, target: Vector3): Vector3;
  intersectLine(line: Line3, target: Vector3): Vector3;
  intersectsLine(line: Line3): boolean;
  intersectsBox(box: Box3): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  coplanarPoint(target: Vector3): Vector3;
  applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
  translate(offset: Vector3): Plane;
  equals(plane: Plane): boolean;

  /**
   * @deprecated Use {@link Plane#intersectsLine .intersectsLine()} instead.
   */
  isIntersectionLine(l: any): any;
}
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';
import { Object3D } from '../core/Object3D';
import { Sprite } from '../objects/Sprite';
import { Sphere } from './Sphere';
import { Box3 } from './Box3';
import { Vector3 } from './Vector3';

/**
 * Frustums are used to determine what is inside the camera's field of view. They help speed up the rendering process.
 */
export class Frustum {
  constructor(
    p0?: Plane,
    p1?: Plane,
    p2?: Plane,
    p3?: Plane,
    p4?: Plane,
    p5?: Plane,
  );

  /**
   * Array of 6 vectors.
   */
  planes: Plane[];

  set(
    p0?: number,
    p1?: number,
    p2?: number,
    p3?: number,
    p4?: number,
    p5?: number,
  ): Frustum;
  clone(): this;
  copy(frustum: Frustum): this;
  setFromMatrix(m: Matrix4): Frustum;
  intersectsObject(object: Object3D): boolean;
  intersectsSprite(sprite: Sprite): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsBox(box: Box3): boolean;
  containsPoint(point: Vector3): boolean;
}
import { Vector3 } from './Vector3';
import { Box3 } from './Box3';
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';

export class Sphere {
  constructor(center?: Vector3, radius?: number);

  center: Vector3;
  radius: number;

  set(center: Vector3, radius: number): Sphere;
  setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
  clone(): this;
  copy(sphere: Sphere): this;
  empty(): boolean;
  containsPoint(point: Vector3): boolean;
  distanceToPoint(point: Vector3): number;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsBox(box: Box3): boolean;
  intersectsPlane(plane: Plane): boolean;
  clampPoint(point: Vector3, target: Vector3): Vector3;
  getBoundingBox(target: Box3): Box3;
  applyMatrix4(matrix: Matrix4): Sphere;
  translate(offset: Vector3): Sphere;
  equals(sphere: Sphere): boolean;
}
import { Vector3 } from './Vector3';
import { Sphere } from './Sphere';
import { Plane } from './Plane';
import { Box3 } from './Box3';
import { Matrix4 } from './Matrix4';

export class Ray {
  constructor(origin?: Vector3, direction?: Vector3);

  origin: Vector3;
  direction: Vector3;

  set(origin: Vector3, direction: Vector3): Ray;
  clone(): this;
  copy(ray: Ray): this;
  at(t: number, target: Vector3): Vector3;
  lookAt(v: Vector3): Vector3;
  recast(t: number): Ray;
  closestPointToPoint(point: Vector3, target: Vector3): Vector3;
  distanceToPoint(point: Vector3): number;
  distanceSqToPoint(point: Vector3): number;
  distanceSqToSegment(
    v0: Vector3,
    v1: Vector3,
    optionalPointOnRay?: Vector3,
    optionalPointOnSegment?: Vector3,
  ): number;
  intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
  intersectsSphere(sphere: Sphere): boolean;
  distanceToPlane(plane: Plane): number;
  intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
  intersectsPlane(plane: Plane): boolean;
  intersectBox(box: Box3, target: Vector3): Vector3 | null;
  intersectsBox(box: Box3): boolean;
  intersectTriangle(
    a: Vector3,
    b: Vector3,
    c: Vector3,
    backfaceCulling: boolean,
    target: Vector3,
  ): Vector3 | null;
  applyMatrix4(matrix4: Matrix4): Ray;
  equals(ray: Ray): boolean;

  /**
   * @deprecated Use {@link Ray#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;

  /**
   * @deprecated Use {@link Ray#intersectsPlane .intersectsPlane()} instead.
   */
  isIntersectionPlane(p: any): any;

  /**
   * @deprecated Use {@link Ray#intersectsSphere .intersectsSphere()} instead.
   */
  isIntersectionSphere(s: any): any;
}
import { Vector3 } from './Vector3';
import { Euler } from './Euler';
import { Quaternion } from './Quaternion';
import { BufferAttribute } from '../core/BufferAttribute';
import { Matrix } from './Matrix3';
/**
 * A 4x4 Matrix.
 *
 * @example
 * // Simple rig for rotating around 3 axes
 * var m = new THREE.Matrix4();
 * var m1 = new THREE.Matrix4();
 * var m2 = new THREE.Matrix4();
 * var m3 = new THREE.Matrix4();
 * var alpha = 0;
 * var beta = Math.PI;
 * var gamma = Math.PI/2;
 * m1.makeRotationX( alpha );
 * m2.makeRotationY( beta );
 * m3.makeRotationZ( gamma );
 * m.multiplyMatrices( m1, m2 );
 * m.multiply( m3 );
 */
export class Matrix4 implements Matrix {
  constructor();

  /**
   * Array with matrix values.
   */
  elements: number[];

  /**
   * Sets all fields of this matrix.
   */
  set(
    n11: number,
    n12: number,
    n13: number,
    n14: number,
    n21: number,
    n22: number,
    n23: number,
    n24: number,
    n31: number,
    n32: number,
    n33: number,
    n34: number,
    n41: number,
    n42: number,
    n43: number,
    n44: number,
  ): Matrix4;

  /**
   * Resets this matrix to identity.
   */
  identity(): Matrix4;
  clone(): this;
  copy(m: Matrix4): this;
  copyPosition(m: Matrix4): Matrix4;
  extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
  makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;

  /**
   * Copies the rotation component of the supplied matrix m into this matrix rotation component.
   */
  extractRotation(m: Matrix4): Matrix4;
  makeRotationFromEuler(euler: Euler): Matrix4;
  makeRotationFromQuaternion(q: Quaternion): Matrix4;
  /**
   * Constructs a rotation matrix, looking from eye towards center with defined up vector.
   */
  lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4;

  /**
   * Multiplies this matrix by m.
   */
  multiply(m: Matrix4): Matrix4;

  premultiply(m: Matrix4): Matrix4;

  /**
   * Sets this matrix to a x b.
   */
  multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4;

  /**
   * Sets this matrix to a x b and stores the result into the flat array r.
   * r can be either a regular Array or a TypedArray.
   *
   * @deprecated This method has been removed completely.
   */
  multiplyToArray(a: Matrix4, b: Matrix4, r: number[]): Matrix4;

  /**
   * Multiplies this matrix by s.
   */
  multiplyScalar(s: number): Matrix4;

  /**
   * @deprecated Use {@link Matrix4#applyToBufferAttribute matrix4.applyToBufferAttribute( attribute )} instead.
   */
  applyToBuffer(
    buffer: BufferAttribute,
    offset?: number,
    length?: number,
  ): BufferAttribute;

  applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute;

  /**
   * Computes determinant of this matrix.
   * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
   */
  determinant(): number;

  /**
   * Transposes this matrix.
   */
  transpose(): Matrix4;

  /**
   * Sets the position component for this matrix from vector v.
   */
  setPosition(v: Vector3 | number, y?: number, z?: number): Matrix4;

  /**
   * Sets this matrix to the inverse of matrix m.
   * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm.
   */
  getInverse(m: Matrix4, throwOnDegeneratee?: boolean): Matrix4;

  /**
   * Multiplies the columns of this matrix by vector v.
   */
  scale(v: Vector3): Matrix4;

  getMaxScaleOnAxis(): number;
  /**
   * Sets this matrix as translation transform.
   */
  makeTranslation(x: number, y: number, z: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around x axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationX(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around y axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationY(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around z axis by theta radians.
   *
   * @param theta Rotation angle in radians.
   */
  makeRotationZ(theta: number): Matrix4;

  /**
   * Sets this matrix as rotation transform around axis by angle radians.
   * Based on http://www.gamedev.net/reference/articles/article1199.asp.
   *
   * @param axis Rotation axis.
   * @param theta Rotation angle in radians.
   */
  makeRotationAxis(axis: Vector3, angle: number): Matrix4;

  /**
   * Sets this matrix as scale transform.
   */
  makeScale(x: number, y: number, z: number): Matrix4;

  /**
   * Sets this matrix to the transformation composed of translation, rotation and scale.
   */
  compose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;

  /**
   * Decomposes this matrix into the translation, rotation and scale components.
   * If parameters are not passed, new instances will be created.
   */
  decompose(
    translation?: Vector3,
    rotation?: Quaternion,
    scale?: Vector3,
  ): Object[]; // [Vector3, Quaternion, Vector3]

  /**
   * Creates a frustum matrix.
   */
  makePerspective(
    left: number,
    right: number,
    bottom: number,
    top: number,
    near: number,
    far: number,
  ): Matrix4;

  /**
   * Creates a perspective projection matrix.
   */
  makePerspective(
    fov: number,
    aspect: number,
    near: number,
    far: number,
  ): Matrix4;

  /**
   * Creates an orthographic projection matrix.
   */
  makeOrthographic(
    left: number,
    right: number,
    top: number,
    bottom: number,
    near: number,
    far: number,
  ): Matrix4;
  equals(matrix: Matrix4): boolean;

  /**
   * Sets the values of this matrix from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): Matrix4;

  /**
   * Sets the values of this matrix from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): Matrix4;

  /**
   * Returns an array with the values of this matrix, or copies them into the provided array.
   * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies he values of this matrix into the provided array-like.
   * @param array array-like to store the matrix to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * @deprecated Use {@link Matrix4#copyPosition .copyPosition()} instead.
   */
  extractPosition(m: Matrix4): Matrix4;

  /**
   * @deprecated Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.
   */
  setRotationFromQuaternion(q: Quaternion): Matrix4;

  /**
   * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  multiplyVector3(v: any): any;

  /**
   * @deprecated Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  multiplyVector4(v: any): any;

  /**
   * @deprecated This method has been removed completely.
   */
  multiplyVector3Array(array: number[]): number[];

  /**
   * @deprecated Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.
   */
  rotateAxis(v: any): void;

  /**
   * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
   */
  crossVector(v: any): void;

  /**
   * @deprecated Use {@link Matrix4#toArray .toArray()} instead.
   */
  flattenToArrayOffset(array: number[], offset: number): number[];
}
import { Matrix4 } from './Matrix4';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector3 } from './Vector3';

/**
 * ( interface Matrix&lt;T&gt; )
 */
export interface Matrix {
  /**
   * Array with matrix values.
   */
  elements: number[];

  /**
   * identity():T;
   */
  identity(): Matrix;

  /**
   * copy(m:T):T;
   */
  copy(m: this): this;

  /**
   * multiplyScalar(s:number):T;
   */
  multiplyScalar(s: number): Matrix;

  determinant(): number;

  /**
   * getInverse(matrix:T, throwOnInvertible?:boolean):T;
   */
  getInverse(matrix: Matrix, throwOnInvertible?: boolean): Matrix;

  /**
   * transpose():T;
   */
  transpose(): Matrix;

  /**
   * clone():T;
   */
  clone(): this;
}

/**
 * ( class Matrix3 implements Matrix&lt;Matrix3&gt; )
 */
export class Matrix3 implements Matrix {
  /**
   * Creates an identity matrix.
   */
  constructor();

  /**
   * Array with matrix values.
   */
  elements: number[];

  set(
    n11: number,
    n12: number,
    n13: number,
    n21: number,
    n22: number,
    n23: number,
    n31: number,
    n32: number,
    n33: number,
  ): Matrix3;
  identity(): Matrix3;
  clone(): this;
  copy(m: Matrix3): this;
  setFromMatrix4(m: Matrix4): Matrix3;

  /**
   * @deprecated Use {@link Matrix3#applyToBufferAttribute matrix3.applyToBufferAttribute( attribute )} instead.
   */
  applyToBuffer(
    buffer: BufferAttribute,
    offset?: number,
    length?: number,
  ): BufferAttribute;

  applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute;

  multiplyScalar(s: number): Matrix3;
  determinant(): number;
  getInverse(matrix: Matrix3, throwOnDegenerate?: boolean): Matrix3;

  /**
   * Transposes this matrix in place.
   */
  transpose(): Matrix3;
  getNormalMatrix(matrix4: Matrix4): Matrix3;

  /**
   * Transposes this matrix into the supplied array r, and returns itself.
   */
  transposeIntoArray(r: number[]): number[];

  setUvTransform(
    tx: number,
    ty: number,
    sx: number,
    sy: number,
    rotation: number,
    cx: number,
    cy: number,
  ): Matrix3;

  scale(sx: number, sy: number): Matrix3;

  rotate(theta: number): Matrix3;

  translate(tx: number, ty: number): Matrix3;

  equals(matrix: Matrix3): boolean;

  /**
   * Sets the values of this matrix from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): Matrix3;

  /**
   * Sets the values of this matrix from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): Matrix3;

  /**
   * Returns an array with the values of this matrix, or copies them into the provided array.
   * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies he values of this matrix into the provided array-like.
   * @param array array-like to store the matrix to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * Multiplies this matrix by m.
   */
  multiply(m: Matrix3): Matrix3;

  premultiply(m: Matrix3): Matrix3;

  /**
   * Sets this matrix to a x b.
   */
  multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3;

  /**
   * @deprecated Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.
   */
  multiplyVector3(vector: Vector3): any;

  /**
   * @deprecated This method has been removed completely.
   */
  multiplyVector3Array(a: any): any;
  getInverse(matrix: Matrix4, throwOnDegenerate?: boolean): Matrix3;

  /**
   * @deprecated Use {@link Matrix3#toArray .toArray()} instead.
   */
  flattenToArrayOffset(array: number[], offset: number): number[];
}
import { Vector3 } from './Vector3';
import { Object3D } from '../core/Object3D';
import { Sphere } from './Sphere';
import { Plane } from './Plane';
import { Matrix4 } from './Matrix4';
import { Triangle } from './Triangle';

export class Box3 {
  constructor(min?: Vector3, max?: Vector3);

  max: Vector3;
  min: Vector3;

  set(min: Vector3, max: Vector3): this;
  setFromArray(array: ArrayLike<number>): this;
  setFromPoints(points: Vector3[]): this;
  setFromCenterAndSize(center: Vector3, size: Vector3): this;
  setFromObject(object: Object3D): this;
  clone(): this;
  copy(box: Box3): this;
  makeEmpty(): this;
  isEmpty(): boolean;
  getCenter(target: Vector3): Vector3;
  getSize(target: Vector3): Vector3;
  expandByPoint(point: Vector3): this;
  expandByVector(vector: Vector3): this;
  expandByScalar(scalar: number): this;
  expandByObject(object: Object3D): this;
  containsPoint(point: Vector3): boolean;
  containsBox(box: Box3): boolean;
  getParameter(point: Vector3): Vector3;
  intersectsBox(box: Box3): boolean;
  intersectsSphere(sphere: Sphere): boolean;
  intersectsPlane(plane: Plane): boolean;
  intersectsTriangle(triangle: Triangle): boolean;
  clampPoint(point: Vector3, target: Vector3): Vector3;
  distanceToPoint(point: Vector3): number;
  getBoundingSphere(target: Sphere): Sphere;
  intersect(box: Box3): this;
  union(box: Box3): this;
  applyMatrix4(matrix: Matrix4): this;
  translate(offset: Vector3): this;
  equals(box: Box3): boolean;
  /**
   * @deprecated Use {@link Box3#isEmpty .isEmpty()} instead.
   */
  empty(): any;
  /**
   * @deprecated Use {@link Box3#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;
  /**
   * @deprecated Use {@link Box3#intersectsSphere .intersectsSphere()} instead.
   */
  isIntersectionSphere(s: any): any;
}
import { Vector2 } from './Vector2';

// Math //////////////////////////////////////////////////////////////////////////////////

export class Box2 {
  constructor(min?: Vector2, max?: Vector2);

  max: Vector2;
  min: Vector2;

  set(min: Vector2, max: Vector2): Box2;
  setFromPoints(points: Vector2[]): Box2;
  setFromCenterAndSize(center: Vector2, size: Vector2): Box2;
  clone(): this;
  copy(box: Box2): this;
  makeEmpty(): Box2;
  isEmpty(): boolean;
  getCenter(target: Vector2): Vector2;
  getSize(target: Vector2): Vector2;
  expandByPoint(point: Vector2): Box2;
  expandByVector(vector: Vector2): Box2;
  expandByScalar(scalar: number): Box2;
  containsPoint(point: Vector2): boolean;
  containsBox(box: Box2): boolean;
  getParameter(point: Vector2): Vector2;
  intersectsBox(box: Box2): boolean;
  clampPoint(point: Vector2, target: Vector2): Vector2;
  distanceToPoint(point: Vector2): number;
  intersect(box: Box2): Box2;
  union(box: Box2): Box2;
  translate(offset: Vector2): Box2;
  equals(box: Box2): boolean;
  /**
   * @deprecated Use {@link Box2#isEmpty .isEmpty()} instead.
   */
  empty(): any;
  /**
   * @deprecated Use {@link Box2#intersectsBox .intersectsBox()} instead.
   */
  isIntersectionBox(b: any): any;
}
import { Vector3 } from './Vector3';
import { Matrix4 } from './Matrix4';

export class Line3 {
  constructor(start?: Vector3, end?: Vector3);

  start: Vector3;
  end: Vector3;

  set(start?: Vector3, end?: Vector3): Line3;
  clone(): this;
  copy(line: Line3): this;
  getCenter(target: Vector3): Vector3;
  delta(target: Vector3): Vector3;
  distanceSq(): number;
  distance(): number;
  at(t: number, target: Vector3): Vector3;
  closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
  closestPointToPoint(
    point: Vector3,
    clampToLine: boolean,
    target: Vector3,
  ): Vector3;
  applyMatrix4(matrix: Matrix4): Line3;
  equals(line: Line3): boolean;
}
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Vector3 } from './Vector3';

export class Euler {
  constructor(x?: number, y?: number, z?: number, order?: string);

  x: number;
  y: number;
  z: number;
  order: string;
  _onChangeCallback: Function;

  set(x: number, y: number, z: number, order?: string): Euler;
  clone(): this;
  copy(euler: Euler): this;
  setFromRotationMatrix(m: Matrix4, order?: string): Euler;
  setFromQuaternion(q: Quaternion, order?: string): Euler;
  setFromVector3(v: Vector3, order?: string): Euler;
  reorder(newOrder: string): Euler;
  equals(euler: Euler): boolean;
  fromArray(xyzo: any[]): Euler;
  toArray(array?: number[], offset?: number): number[];
  toVector3(optionalResult?: Vector3): Vector3;
  _onChange(callback: Function): this;

  static RotationOrders: string[];
  static DefaultOrder: string;
}
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Matrix3 } from './Matrix3';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector } from './Vector2';

/**
 * 4D vector.
 *
 * ( class Vector4 implements Vector<Vector4> )
 */
export class Vector4 implements Vector {
  constructor(x?: number, y?: number, z?: number, w?: number);

  x: number;
  y: number;
  z: number;
  w: number;
  width: number;
  height: number;
  isVector4: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number, z: number, w: number): this;

  /**
   * Sets all values of this vector.
   */
  setScalar(scalar: number): this;

  /**
   * Sets X component of this vector.
   */
  setX(x: number): this;

  /**
   * Sets Y component of this vector.
   */
  setY(y: number): this;

  /**
   * Sets Z component of this vector.
   */
  setZ(z: number): this;

  /**
   * Sets w component of this vector.
   */
  setW(w: number): this;

  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  /**
   * Clones this vector.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector4): this;

  /**
   * Adds v to this vector.
   */
  add(v: Vector4, w?: Vector4): this;

  addScalar(scalar: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector4, b: Vector4): this;

  addScaledVector(v: Vector4, s: number): this;
  /**
   * Subtracts v from this vector.
   */
  sub(v: Vector4): this;

  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector4, b: Vector4): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(s: number): this;

  applyMatrix4(m: Matrix4): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  /**
   * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
   * @param q is assumed to be normalized
   */
  setAxisAngleFromQuaternion(q: Quaternion): this;

  /**
   * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
   * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
   */
  setAxisAngleFromRotationMatrix(m: Matrix3): this;

  min(v: Vector4): this;
  max(v: Vector4): this;
  clamp(min: Vector4, max: Vector4): this;
  clampScalar(min: number, max: number): this;
  floor(): this;
  ceil(): this;
  round(): this;
  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector4): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;
  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(length: number): this;

  /**
   * Linearly interpolate between this vector and v with alpha factor.
   */
  lerp(v: Vector4, alpha: number): this;

  lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector4): boolean;

  /**
   * Sets this vector's x, y, z and w value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x, y, z and w value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y, z and w into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  fromBufferAttribute(
    attribute: BufferAttribute,
    index: number,
    offset?: number,
  ): this;
}
import { Euler } from './Euler';
import { Matrix3 } from './Matrix3';
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Camera } from '../cameras/Camera';
import { Spherical } from './Spherical';
import { Cylindrical } from './Cylindrical';
import { BufferAttribute } from '../core/BufferAttribute';
import { Vector } from './Vector2';
/**
 * 3D vector.
 *
 * @example
 * var a = new THREE.Vector3( 1, 0, 0 );
 * var b = new THREE.Vector3( 0, 1, 0 );
 * var c = new THREE.Vector3();
 * c.crossVectors( a, b );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js">src/math/Vector3.js</a>
 *
 * ( class Vector3 implements Vector<Vector3> )
 */
export class Vector3 implements Vector {
  constructor(x?: number, y?: number, z?: number);

  x: number;
  y: number;
  z: number;
  isVector3: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number, z: number): this;

  /**
   * Sets all values of this vector.
   */
  setScalar(scalar: number): this;

  /**
   * Sets x value of this vector.
   */
  setX(x: number): Vector3;

  /**
   * Sets y value of this vector.
   */
  setY(y: number): Vector3;

  /**
   * Sets z value of this vector.
   */
  setZ(z: number): Vector3;

  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  /**
   * Clones this vector.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector3): this;

  /**
   * Adds v to this vector.
   */
  add(a: Vector3, b?: Vector3): this;

  addScalar(s: number): this;

  addScaledVector(v: Vector3, s: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector3, b: Vector3): this;

  /**
   * Subtracts v from this vector.
   */
  sub(a: Vector3): this;

  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector3, b: Vector3): this;

  multiply(v: Vector3): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(s: number): this;

  multiplyVectors(a: Vector3, b: Vector3): this;

  applyEuler(euler: Euler): this;

  applyAxisAngle(axis: Vector3, angle: number): this;

  applyMatrix3(m: Matrix3): this;

  applyMatrix4(m: Matrix4): this;

  applyQuaternion(q: Quaternion): this;

  project(camera: Camera): this;

  unproject(camera: Camera): this;

  transformDirection(m: Matrix4): this;

  divide(v: Vector3): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  min(v: Vector3): this;

  max(v: Vector3): this;

  clamp(min: Vector3, max: Vector3): this;

  clampScalar(min: number, max: number): this;

  clampLength(min: number, max: number): this;

  floor(): this;

  ceil(): this;

  round(): this;

  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector3): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * Computes Manhattan length of this vector.
   * http://en.wikipedia.org/wiki/Taxicab_geometry
   *
   * @deprecated Use {@link Vector3#manhattanLength .manhattanLength()} instead.
   */
  lengthManhattan(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector3} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector3): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;

  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(l: number): this;
  lerp(v: Vector3, alpha: number): this;

  lerpVectors(v1: Vector3, v2: Vector3, alpha: number): this;

  /**
   * Sets this vector to cross product of itself and v.
   */
  cross(a: Vector3, w?: Vector3): this;

  /**
   * Sets this vector to cross product of a and b.
   */
  crossVectors(a: Vector3, b: Vector3): this;
  projectOnVector(v: Vector3): this;
  projectOnPlane(planeNormal: Vector3): this;
  reflect(vector: Vector3): this;
  angleTo(v: Vector3): number;

  /**
   * Computes distance of this vector to v.
   */
  distanceTo(v: Vector3): number;

  /**
   * Computes squared distance of this vector to v.
   */
  distanceToSquared(v: Vector3): number;

  /**
   * @deprecated Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.
   */
  distanceToManhattan(v: Vector3): number;

  setFromSpherical(s: Spherical): this;
  setFromSphericalCoords(r: number, phi: number, theta: number): this;
  setFromCylindrical(s: Cylindrical): this;
  setFromCylindricalCoords(radius: number, theta: number, y: number): this;
  setFromMatrixPosition(m: Matrix4): this;
  setFromMatrixScale(m: Matrix4): this;
  setFromMatrixColumn(matrix: Matrix4, index: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector3): boolean;

  /**
   * Sets this vector's x, y and z value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x, y and z value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z], or copies x, y and z into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y and z into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  fromBufferAttribute(
    attribute: BufferAttribute,
    index: number,
    offset?: number,
  ): this;
}
import { Matrix3 } from './Matrix3';
import { BufferAttribute } from '../core/BufferAttribute';

/**
 * ( interface Vector&lt;T&gt; )
 *
 * Abstract interface of Vector2, Vector3 and Vector4.
 * Currently the members of Vector is NOT type safe because it accepts different typed vectors.
 * Those definitions will be changed when TypeScript innovates Generics to be type safe.
 *
 * @example
 * var v:THREE.Vector = new THREE.Vector3();
 * v.addVectors(new THREE.Vector2(0, 1), new THREE.Vector2(2, 3));		// invalid but compiled successfully
 */
export interface Vector {
  setComponent(index: number, value: number): this;

  getComponent(index: number): number;

  set(...args: number[]): this;

  setScalar(scalar: number): this;

  /**
   * copy(v:T):T;
   */
  copy(v: Vector): this;

  /**
   * NOTE: The second argument is deprecated.
   *
   * add(v:T):T;
   */
  add(v: Vector, w?: Vector): this;

  /**
   * addVectors(a:T, b:T):T;
   */
  addVectors(a: Vector, b: Vector): this;

  addScaledVector(vector: Vector, scale: number): this;

  /**
   * Adds the scalar value s to this vector's values.
   */
  addScalar(scalar: number): this;

  /**
   * sub(v:T):T;
   */
  sub(v: Vector): this;

  /**
   * subVectors(a:T, b:T):T;
   */
  subVectors(a: Vector, b: Vector): this;

  /**
   * multiplyScalar(s:number):T;
   */
  multiplyScalar(s: number): this;

  /**
   * divideScalar(s:number):T;
   */
  divideScalar(s: number): this;

  /**
   * negate():T;
   */
  negate(): this;

  /**
   * dot(v:T):T;
   */
  dot(v: Vector): number;

  /**
   * lengthSq():number;
   */
  lengthSq(): number;

  /**
   * length():number;
   */
  length(): number;

  /**
   * normalize():T;
   */
  normalize(): this;

  /**
   * NOTE: Vector4 doesn't have the property.
   *
   * distanceTo(v:T):number;
   */
  distanceTo?(v: Vector): number;

  /**
   * NOTE: Vector4 doesn't have the property.
   *
   * distanceToSquared(v:T):number;
   */
  distanceToSquared?(v: Vector): number;

  /**
   * setLength(l:number):T;
   */
  setLength(l: number): this;

  /**
   * lerp(v:T, alpha:number):T;
   */
  lerp(v: Vector, alpha: number): this;

  /**
   * equals(v:T):boolean;
   */
  equals(v: Vector): boolean;

  /**
   * clone():T;
   */
  clone(): this;
}

/**
 * 2D vector.
 *
 * ( class Vector2 implements Vector<Vector2> )
 */
export class Vector2 implements Vector {
  constructor(x?: number, y?: number);

  x: number;
  y: number;
  width: number;
  height: number;
  isVector2: true;

  /**
   * Sets value of this vector.
   */
  set(x: number, y: number): this;

  /**
   * Sets the x and y values of this vector both equal to scalar.
   */
  setScalar(scalar: number): this;

  /**
   * Sets X component of this vector.
   */
  setX(x: number): this;

  /**
   * Sets Y component of this vector.
   */
  setY(y: number): this;

  /**
   * Sets a component of this vector.
   */
  setComponent(index: number, value: number): this;

  /**
   * Gets a component of this vector.
   */
  getComponent(index: number): number;

  /**
   * Returns a new Vector2 instance with the same `x` and `y` values.
   */
  clone(): this;

  /**
   * Copies value of v to this vector.
   */
  copy(v: Vector2): this;

  /**
   * Adds v to this vector.
   */
  add(v: Vector2, w?: Vector2): this;

  /**
   * Adds the scalar value s to this vector's x and y values.
   */
  addScalar(s: number): this;

  /**
   * Sets this vector to a + b.
   */
  addVectors(a: Vector2, b: Vector2): this;

  /**
   * Adds the multiple of v and s to this vector.
   */
  addScaledVector(v: Vector2, s: number): this;

  /**
   * Subtracts v from this vector.
   */
  sub(v: Vector2): this;

  /**
   * Subtracts s from this vector's x and y components.
   */
  subScalar(s: number): this;

  /**
   * Sets this vector to a - b.
   */
  subVectors(a: Vector2, b: Vector2): this;

  /**
   * Multiplies this vector by v.
   */
  multiply(v: Vector2): this;

  /**
   * Multiplies this vector by scalar s.
   */
  multiplyScalar(scalar: number): this;

  /**
   * Divides this vector by v.
   */
  divide(v: Vector2): this;

  /**
   * Divides this vector by scalar s.
   * Set vector to ( 0, 0 ) if s == 0.
   */
  divideScalar(s: number): this;

  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
   */
  applyMatrix3(m: Matrix3): this;

  /**
   * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
   */
  min(v: Vector2): this;

  /**
   * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
   */
  max(v: Vector2): this;

  /**
   * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
   * @param min the minimum x and y values.
   * @param max the maximum x and y values in the desired range.
   */
  clamp(min: Vector2, max: Vector2): this;

  /**
   * If this vector's x or y values are greater than the max value, they are replaced by the max value.
   * If this vector's x or y values are less than the min value, they are replaced by the min value.
   * @param min the minimum value the components will be clamped to.
   * @param max the maximum value the components will be clamped to.
   */
  clampScalar(min: number, max: number): this;

  /**
   * If this vector's length is greater than the max value, it is replaced by the max value.
   * If this vector's length is less than the min value, it is replaced by the min value.
   * @param min the minimum value the length will be clamped to.
   * @param max the maximum value the length will be clamped to.
   */
  clampLength(min: number, max: number): this;

  /**
   * The components of the vector are rounded down to the nearest integer value.
   */
  floor(): this;

  /**
   * The x and y components of the vector are rounded up to the nearest integer value.
   */
  ceil(): this;

  /**
   * The components of the vector are rounded to the nearest integer value.
   */
  round(): this;

  /**
   * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
   */
  roundToZero(): this;

  /**
   * Inverts this vector.
   */
  negate(): this;

  /**
   * Computes dot product of this vector and v.
   */
  dot(v: Vector2): number;

  /**
   * Computes cross product of this vector and v.
   */
  cross(v: Vector2): number;

  /**
   * Computes squared length of this vector.
   */
  lengthSq(): number;

  /**
   * Computes length of this vector.
   */
  length(): number;

  /**
   * @deprecated Use {@link Vector2#manhattanLength .manhattanLength()} instead.
   */
  lengthManhattan(): number;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Normalizes this vector.
   */
  normalize(): this;

  /**
   * computes the angle in radians with respect to the positive x-axis
   */
  angle(): number;

  /**
   * Computes distance of this vector to v.
   */
  distanceTo(v: Vector2): number;

  /**
   * Computes squared distance of this vector to v.
   */
  distanceToSquared(v: Vector2): number;

  /**
   * @deprecated Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.
   */
  distanceToManhattan(v: Vector2): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector2} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector2): number;

  /**
   * Normalizes this vector and multiplies it by l.
   */
  setLength(length: number): this;

  /**
   * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
   * @param v vector to interpolate towards.
   * @param alpha interpolation factor in the closed interval [0, 1].
   */
  lerp(v: Vector2, alpha: number): this;

  /**
   * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
   * @param v1 the starting vector.
   * @param v2 vector to interpolate towards.
   * @param alpha interpolation factor in the closed interval [0, 1].
   */
  lerpVectors(v1: Vector2, v2: Vector2, alpha: number): this;

  /**
   * Checks for strict equality of this vector and v.
   */
  equals(v: Vector2): boolean;

  /**
   * Sets this vector's x and y value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this vector's x and y value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y], or copies x and y into the provided array.
   * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x and y into the provided array-like.
   * @param array array-like to store the vector to.
   * @param offset (optional) optional offset into the array.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * Sets this vector's x and y values from the attribute.
   * @param attribute the source attribute.
   * @param index index in the attribute.
   */
  fromBufferAttribute(attribute: BufferAttribute, index: number): this;

  /**
   * Rotates the vector around center by angle radians.
   * @param center the point around which to rotate.
   * @param angle the angle to rotate, in radians.
   */
  rotateAround(center: Vector2, angle: number): this;

  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanLength(): number;

  /**
   * Computes the Manhattan length (distance) from this vector to the given vector v
   *
   * @param {Vector2} v
   *
   * @return {number}
   *
   * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
   */
  manhattanDistanceTo(v: Vector2): number;
}
import { Euler } from './Euler';
import { Vector3 } from './Vector3';
import { Matrix4 } from './Matrix4';

/**
 * Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.
 *
 * @example
 * var quaternion = new THREE.Quaternion();
 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
 * var vector = new THREE.Vector3( 1, 0, 0 );
 * vector.applyQuaternion( quaternion );
 */
export class Quaternion {
  /**
   * @param x x coordinate
   * @param y y coordinate
   * @param z z coordinate
   * @param w w coordinate
   */
  constructor(x?: number, y?: number, z?: number, w?: number);

  x: number;
  y: number;
  z: number;
  w: number;

  /**
   * Sets values of this quaternion.
   */
  set(x: number, y: number, z: number, w: number): Quaternion;

  /**
   * Clones this quaternion.
   */
  clone(): this;

  /**
   * Copies values of q to this quaternion.
   */
  copy(q: Quaternion): this;

  /**
   * Sets this quaternion from rotation specified by Euler angles.
   */
  setFromEuler(euler: Euler): Quaternion;

  /**
   * Sets this quaternion from rotation specified by axis and angle.
   * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
   * Axis have to be normalized, angle is in radians.
   */
  setFromAxisAngle(axis: Vector3, angle: number): Quaternion;

  /**
   * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
   */
  setFromRotationMatrix(m: Matrix4): Quaternion;
  setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
  angleTo(q: Quaternion): number;
  rotateTowards(q: Quaternion, step: number): Quaternion;

  /**
   * Inverts this quaternion.
   */
  inverse(): Quaternion;

  conjugate(): Quaternion;
  dot(v: Quaternion): number;
  lengthSq(): number;

  /**
   * Computes length of this quaternion.
   */
  length(): number;

  /**
   * Normalizes this quaternion.
   */
  normalize(): Quaternion;

  /**
   * Multiplies this quaternion by b.
   */
  multiply(q: Quaternion): Quaternion;
  premultiply(q: Quaternion): Quaternion;

  /**
   * Sets this quaternion to a x b
   * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
   */
  multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;

  slerp(qb: Quaternion, t: number): Quaternion;
  equals(v: Quaternion): boolean;

  /**
   * Sets this quaternion's x, y, z and w value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this quaternion's x, y, z and w value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
   * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies x, y, z and w into the provided array-like.
   * @param array array-like to store the quaternion to.
   * @param offset (optional) optional offset into the array.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  _onChange(callback: Function): Quaternion;
  _onChangeCallback: Function;

  /**
   * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/.
   */
  static slerp(
    qa: Quaternion,
    qb: Quaternion,
    qm: Quaternion,
    t: number,
  ): Quaternion;

  static slerpFlat(
    dst: number[],
    dstOffset: number,
    src0: number[],
    srcOffset: number,
    src1: number[],
    stcOffset1: number,
    t: number,
  ): Quaternion;

  /**
   * @deprecated Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.
   */
  multiplyVector3(v: any): any;
}
/**
 * @author Joe Pea / http://github.com/trusktr
 */

export interface HSL {
  h: number;
  s: number;
  l: number;
}

/**
 * Represents a color. See also {@link ColorUtils}.
 *
 * @example
 * var color = new THREE.Color( 0xff0000 );
 *
 * @see <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Color.js">src/math/Color.js</a>
 */
export class Color {
  constructor(color?: Color | string | number);
  constructor(r: number, g: number, b: number);

  isColor: boolean;

  /**
   * Red channel value between 0 and 1. Default is 1.
   */
  r: number;

  /**
   * Green channel value between 0 and 1. Default is 1.
   */
  g: number;

  /**
   * Blue channel value between 0 and 1. Default is 1.
   */
  b: number;

  set(color: Color): Color;
  set(color: number): Color;
  set(color: string): Color;
  setScalar(scalar: number): Color;
  setHex(hex: number): Color;

  /**
   * Sets this color from RGB values.
   * @param r Red channel value between 0 and 1.
   * @param g Green channel value between 0 and 1.
   * @param b Blue channel value between 0 and 1.
   */
  setRGB(r: number, g: number, b: number): Color;

  /**
   * Sets this color from HSL values.
   * Based on MochiKit implementation by Bob Ippolito.
   *
   * @param h Hue channel value between 0 and 1.
   * @param s Saturation value channel between 0 and 1.
   * @param l Value channel value between 0 and 1.
   */
  setHSL(h: number, s: number, l: number): Color;

  /**
   * Sets this color from a CSS context style string.
   * @param contextStyle Color in CSS context style format.
   */
  setStyle(style: string): Color;

  /**
   * Sets this color from a color name.
   * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
   * @param style Color name in X11 format.
   */
  setColorName(style: string): Color;

  /**
   * Clones this color.
   */
  clone(): this;

  /**
   * Copies given color.
   * @param color Color to copy.
   */
  copy(color: Color): this;

  /**
   * Copies given color making conversion from gamma to linear space.
   * @param color Color to copy.
   */
  copyGammaToLinear(color: Color, gammaFactor?: number): Color;

  /**
   * Copies given color making conversion from linear to gamma space.
   * @param color Color to copy.
   */
  copyLinearToGamma(color: Color, gammaFactor?: number): Color;

  /**
   * Converts this color from gamma to linear space.
   */
  convertGammaToLinear(gammaFactor?: number): Color;

  /**
   * Converts this color from linear to gamma space.
   */
  convertLinearToGamma(gammaFactor?: number): Color;

  /**
   * Copies given color making conversion from sRGB to linear space.
   * @param color Color to copy.
   */
  copySRGBToLinear(color: Color): Color;

  /**
   * Copies given color making conversion from linear to sRGB space.
   * @param color Color to copy.
   */
  copyLinearToSRGB(color: Color): Color;

  /**
   * Converts this color from sRGB to linear space.
   */
  convertSRGBToLinear(): Color;

  /**
   * Converts this color from linear to sRGB space.
   */
  convertLinearToSRGB(): Color;

  /**
   * Returns the hexadecimal value of this color.
   */
  getHex(): number;

  /**
   * Returns the string formated hexadecimal value of this color.
   */
  getHexString(): string;

  getHSL(target: HSL): HSL;

  /**
   * Returns the value of this color in CSS context style.
   * Example: rgb(r, g, b)
   */
  getStyle(): string;

  offsetHSL(h: number, s: number, l: number): this;

  add(color: Color): this;
  addColors(color1: Color, color2: Color): this;
  addScalar(s: number): this;
  sub(color: Color): this;
  multiply(color: Color): this;
  multiplyScalar(s: number): this;
  lerp(color: Color, alpha: number): this;
  lerpHSL(color: Color, alpha: number): this;
  equals(color: Color): boolean;

  /**
   * Sets this color's red, green and blue value from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets this color's red, green and blue value from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
   * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Copies red, green and blue into the provided array-like.
   * @param array array-like to store the color to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;

  /**
   * List of X11 color names.
   */
  static NAMES: Record<string, number>;
}
import { Vector3 } from './Vector3.js.js';

export class SphericalHarmonics3 {
  constructor();

  coefficients: Vector3[];
  isSphericalHarmonics3: boolean;

  set(coefficients: Vector3[]): SphericalHarmonics3;
  zero(): SphericalHarmonics3;
  add(sh: SphericalHarmonics3): SphericalHarmonics3;
  scale(s: number): SphericalHarmonics3;
  lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
  equals(sh: SphericalHarmonics3): boolean;
  copy(sh: SphericalHarmonics3): SphericalHarmonics3;
  clone(): SphericalHarmonics3;

  /**
   * Sets the values of this spherical harmonics from the provided array.
   * @param array the source array.
   * @param offset (optional) offset into the array. Default is 0.
   */
  fromArray(array: number[], offset?: number): this;

  /**
   * Sets the values of this spherical harmonics from the provided array-like.
   * @param array the source array-like.
   * @param offset (optional) offset into the array-like. Default is 0.
   */
  fromArray(array: ArrayLike<number>, offset?: number): this;

  /**
   * Returns an array with the values of this spherical harmonics, or copies them into the provided array.
   * @param array (optional) array to store the spherical harmonics to. If this is not provided, a new array will be created.
   * @param offset (optional) optional offset into the array.
   * @return The created or provided array.
   */
  toArray(array?: number[], offset?: number): number[];

  /**
   * Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.
   * @param array array-like to store the spherical harmonics to.
   * @param offset (optional) optional offset into the array-like.
   * @return The provided array-like.
   */
  toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;

  getAt(normal: Vector3, target: Vector3): Vector3;
  getIrradianceAt(normal: Vector3, target: Vector3): Vector3;

  static getBasisAt(normal: Vector3, shBasis: number[]): void;
}
import { Object3D } from '../../core/Object3D';
import { Material } from '../../materials/Material';

// Extras / Objects /////////////////////////////////////////////////////////////////////

export class ImmediateRenderObject extends Object3D {
  constructor(material: Material);

  material: Material;
  render(renderCallback: Function): void;
}
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

export class VertexNormalsHelper extends LineSegments {
  constructor(
    object: Object3D,
    size?: number,
    hex?: number,
    linewidth?: number,
  );

  object: Object3D;
  size: number;

  update(object?: Object3D): void;
}
import { Light } from '../lights/Light';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

export class SpotLightHelper extends Object3D {
  constructor(light: Light, color?: Color | string | number);

  light: Light;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;
  color: Color | string | number | undefined;
  cone: LineSegments;

  dispose(): void;
  update(): void;
}
import { Object3D } from '../core/Object3D';
import { Bone } from '../objects/Bone';
import { LineSegments } from '../objects/LineSegments';

export class SkeletonHelper extends LineSegments {
  constructor(bone: Object3D);

  bones: Bone[];
  root: Object3D;

  getBoneList(object: Object3D): Bone[];
  update(): void;
}
import { PointLight } from '../lights/PointLight';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';

export class PointLightHelper extends Object3D {
  constructor(
    light: PointLight,
    sphereSize?: number,
    color?: Color | string | number,
  );

  light: PointLight;
  color: Color | string | number | undefined;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;

  dispose(): void;
  update(): void;
}
import { RectAreaLight } from '../lights/RectAreaLight';
import { Color } from '../math/Color';
import { Line } from '../objects/Line';

export class RectAreaLightHelper extends Line {
  constructor(light: RectAreaLight, color?: Color | string | number);

  light: RectAreaLight;
  color: Color | string | number | undefined;

  update(): void;
  dispose(): void;
}
import { HemisphereLight } from '../lights/HemisphereLight';
import { Color } from '../math/Color';
import { Matrix4 } from '../math/Matrix4';
import { MeshBasicMaterial } from '../materials/MeshBasicMaterial';
import { Object3D } from '../core/Object3D';

export class HemisphereLightHelper extends Object3D {
  constructor(
    light: HemisphereLight,
    size: number,
    color?: Color | number | string,
  );

  light: HemisphereLight;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;
  material: MeshBasicMaterial;

  color: Color | string | number | undefined;

  dispose(): void;
  update(): void;
}
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class GridHelper extends LineSegments {
  constructor(
    size: number,
    divisions: number,
    color1?: Color | number,
    color2?: Color | number,
  );
  /**
   * @deprecated Colors should be specified in the constructor.
   */
  setColors(color1?: Color | number, color2?: Color | number): void;
}
import { LineSegments } from '../objects/LineSegments';
import { Color } from '../math/Color';

export class PolarGridHelper extends LineSegments {
  constructor(
    radius: number,
    radials: number,
    circles: number,
    divisions: number,
    color1: Color | string | number | undefined,
    color2: Color | string | number | undefined,
  );
}
import { PositionalAudio } from '../audio/PositionalAudio';
import { Line } from '../objects/Line';

export class PositionalAudioHelper extends Line {
  constructor(
    audio: PositionalAudio,
    range?: number,
    divisionsInnerAngle?: number,
    divisionsOuterAngle?: number,
  );

  audio: PositionalAudio;
  range: number;
  divisionsInnerAngle: number;
  divisionsOuterAngle: number;

  dispose(): void;
  update(): void;
}
import { Object3D } from '../core/Object3D';
import { LineSegments } from '../objects/LineSegments';

/**
 * @deprecated Use {@link EdgesGeometry THREE.EdgesGeometry}
 */
// export class EdgesHelper extends LineSegments {
//	 constructor(object: Object3D, hex?: number, thresholdAngle?: number);
// }

export class FaceNormalsHelper extends LineSegments {
  constructor(
    object: Object3D,
    size?: number,
    hex?: number,
    linewidth?: number,
  );

  object: Object3D;
  size: number;

  update(object?: Object3D): void;
}
import { DirectionalLight } from '../lights/DirectionalLight';
import { Color } from '../math/Color';
import { Line } from '../objects/Line';
import { Matrix4 } from '../math/Matrix4';
import { Object3D } from '../core/Object3D';

export class DirectionalLightHelper extends Object3D {
  constructor(
    light: DirectionalLight,
    size?: number,
    color?: Color | string | number,
  );

  light: DirectionalLight;
  lightPlane: Line;
  targetPlane: Line;
  color: Color | string | number | undefined;
  matrix: Matrix4;
  matrixAutoUpdate: boolean;

  dispose(): void;
  update(): void;
}
import { Camera } from '../cameras/Camera';
import { LineSegments } from '../objects/LineSegments';

export class CameraHelper extends LineSegments {
  constructor(camera: Camera);

  camera: Camera;
  pointMap: { [id: string]: number[] };

  update(): void;
}
import { Object3D } from '../core/Object3D';
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class BoxHelper extends LineSegments {
  constructor(object: Object3D, color?: Color);

  update(object?: Object3D): void;

  setFromObject(object: Object3D): this;
}
import { Box3 } from '../math/Box3';
import { Color } from '../math/Color';
import { LineSegments } from '../objects/LineSegments';

export class Box3Helper extends LineSegments {
  constructor(box: Box3, color?: Color);

  box: Box3;
}
import { Plane } from '../math/Plane';
import { LineSegments } from '../objects/LineSegments';

export class PlaneHelper extends LineSegments {
  constructor(plane: Plane, size?: number, hex?: number);

  plane: Plane;
  size: number;

  updateMatrixWorld(force?: boolean): void;
}
import { Vector3 } from '../math/Vector3';
import { Line } from '../objects/Line';
import { Mesh } from '../objects/Mesh';
import { Color } from '../math/Color';
import { Object3D } from '../core/Object3D';

// Extras / Helpers /////////////////////////////////////////////////////////////////////

export class ArrowHelper extends Object3D {
  constructor(
    dir: Vector3,
    origin?: Vector3,
    length?: number,
    hex?: number,
    headLength?: number,
    headWidth?: number,
  );

  line: Line;
  cone: Mesh;

  setDirection(dir: Vector3): void;
  setLength(length: number, headLength?: number, headWidth?: number): void;
  setColor(color: Color | string | number): void;
}
import { LineSegments } from '../objects/LineSegments';

export class AxesHelper extends LineSegments {
  constructor(size?: number);
}
export * from './ArcCurve';
export * from './CatmullRomCurve3';
export * from './CubicBezierCurve';
export * from './CubicBezierCurve3';
export * from './EllipseCurve';
export * from './LineCurve';
export * from './LineCurve3';
export * from './QuadraticBezierCurve';
export * from './QuadraticBezierCurve3';
export * from './SplineCurve';
import { Vector2 } from '../../math/Vector2';
import { Path } from './Path';
import { ExtrudeGeometry } from '../../geometries/ExtrudeGeometry';
import { ShapeGeometry } from '../../geometries/ShapeGeometry';

/**
 * Defines a 2d shape plane using paths.
 */
export class Shape extends Path {
  constructor(points?: Vector2[]);

  holes: Path[];

  /**
   * @deprecated Use {@link ExtrudeGeometry ExtrudeGeometry()} instead.
   */
  extrude(options?: any): ExtrudeGeometry;

  /**
   * @deprecated Use {@link ShapeGeometry ShapeGeometry()} instead.
   */
  makeGeometry(options?: any): ShapeGeometry;
  getPointsHoles(divisions: number): Vector2[][];

  /**
   * @deprecated Use {@link Shape#extractPoints .extractPoints()} instead.
   */
  extractAllPoints(
    divisions: number,
  ): {
    shape: Vector2[];
    holes: Vector2[][];
  };
  extractPoints(
    divisions: number,
  ): {
    shape: Vector2[];
    holes: Vector2[][];
  };
}
import { Vector2 } from '../../math/Vector2';
import { CurvePath } from './CurvePath';

export enum PathActions {
  MOVE_TO,
  LINE_TO,
  QUADRATIC_CURVE_TO, // Bezier quadratic curve
  BEZIER_CURVE_TO, // Bezier cubic curve
  CSPLINE_THRU, // Catmull-rom spline
  ARC, // Circle
  ELLIPSE,
}

export interface PathAction {
  action: PathActions;
  args: any;
}

/**
 * a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
 */
export class Path extends CurvePath<Vector2> {
  constructor(points?: Vector2[]);

  currentPoint: Vector2;

  /**
   * @deprecated Use {@link Path#setFromPoints .setFromPoints()} instead.
   */
  fromPoints(vectors: Vector2[]): this;
  setFromPoints(vectors: Vector2[]): this;
  moveTo(x: number, y: number): this;
  lineTo(x: number, y: number): this;
  quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
  bezierCurveTo(
    aCP1x: number,
    aCP1y: number,
    aCP2x: number,
    aCP2y: number,
    aX: number,
    aY: number,
  ): this;
  splineThru(pts: Vector2[]): this;
  arc(
    aX: number,
    aY: number,
    aRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
  ): this;
  absarc(
    aX: number,
    aY: number,
    aRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
  ): this;
  ellipse(
    aX: number,
    aY: number,
    xRadius: number,
    yRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
    aRotation: number,
  ): this;
  absellipse(
    aX: number,
    aY: number,
    xRadius: number,
    yRadius: number,
    aStartAngle: number,
    aEndAngle: number,
    aClockwise: boolean,
    aRotation: number,
  ): this;
}
import { Vector2 } from '../../math/Vector2';
import { Shape } from './Shape';

export class ShapePath {
  constructor();

  subPaths: any[];
  currentPath: any;

  moveTo(x: number, y: number): this;
  lineTo(x: number, y: number): this;
  quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
  bezierCurveTo(
    aCP1x: number,
    aCP1y: number,
    aCP2x: number,
    aCP2y: number,
    aX: number,
    aY: number,
  ): this;
  splineThru(pts: Vector2[]): this;
  toShapes(isCCW: boolean, noHoles?: boolean): Shape[];
}
export class Font {
  constructor(jsondata: any);

  data: string;

  generateShapes(text: string, size: number, divisions: number): any[];
}
import { Curve } from './Curve';
import { Geometry } from '../../core/Geometry';
import { Vector } from '../../math/Vector2';

export class CurvePath<T extends Vector> extends Curve<T> {
  constructor();

  curves: Curve<T>[];
  autoClose: boolean;

  add(curve: Curve<T>): void;
  checkConnection(): boolean;
  closePath(): void;
  getPoint(t: number): T;
  getLength(): number;
  updateArcLengths(): void;
  getCurveLengths(): number[];
  getSpacedPoints(divisions?: number): T[];
  getPoints(divisions?: number): T[];

  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createPointsGeometry(divisions: number): Geometry;
  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createSpacedPointsGeometry(divisions: number): Geometry;
  /**
   * @deprecated Use {@link Geometry#setFromPoints new THREE.Geometry().setFromPoints( points )} instead.
   */
  createGeometry(points: T[]): Geometry;
}
import { Vector } from '../../math/Vector2';

// Extras / Core /////////////////////////////////////////////////////////////////////

/**
 * An extensible curve object which contains methods for interpolation
 * class Curve&lt;T extends Vector&gt;
 */
export class Curve<T extends Vector> {
  /**
   * This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.
   * To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.
   * Default is 200.
   */
  arcLengthDivisions: number;

  /**
   * Returns a vector for point t of the curve where t is between 0 and 1
   * getPoint(t: number): T;
   */
  getPoint(t: number, optionalTarget?: T): T;

  /**
   * Returns a vector for point at relative position in curve according to arc length
   * getPointAt(u: number): T;
   */
  getPointAt(u: number, optionalTarget?: T): T;

  /**
   * Get sequence of points using getPoint( t )
   * getPoints(divisions?: number): T[];
   */
  getPoints(divisions?: number): T[];

  /**
   * Get sequence of equi-spaced points using getPointAt( u )
   * getSpacedPoints(divisions?: number): T[];
   */
  getSpacedPoints(divisions?: number): T[];

  /**
   * Get total curve arc length
   */
  getLength(): number;

  /**
   * Get list of cumulative segment lengths
   */
  getLengths(divisions?: number): number[];

  /**
   * Update the cumlative segment distance cache
   */
  updateArcLengths(): void;

  /**
   * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
   */
  getUtoTmapping(u: number, distance: number): number;

  /**
   * Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation
   * getTangent(t: number): T;
   */
  getTangent(t: number): T;

  /**
   * Returns tangent at equidistance point u on the curve
   * getTangentAt(u: number): T;
   */
  getTangentAt(u: number): T;

  /**
   * @deprecated since r84.
   */
  static create(constructorFunc: Function, getPointFunc: Function): Function;
}
import { Mapping } from '../constants';
import { Texture } from '../textures/Texture';

export namespace ImageUtils {
  export function getDataURL(image: any): string;

  /**
   * @deprecated
   */
  export let crossOrigin: string;

  /**
   * @deprecated Use {@link TextureLoader THREE.TextureLoader()} instead.
   */
  export function loadTexture(
    url: string,
    mapping?: Mapping,
    onLoad?: (texture: Texture) => void,
    onError?: (message: string) => void,
  ): Texture;

  /**
   * @deprecated Use {@link CubeTextureLoader THREE.CubeTextureLoader()} instead.
   */
  export function loadTextureCube(
    array: string[],
    mapping?: Mapping,
    onLoad?: (texture: Texture) => void,
    onError?: (message: string) => void,
  ): Texture;
}
interface Vec2 {
  x: number;
  y: number;
}

export namespace ShapeUtils {
  export function area(contour: Vec2[]): number;
  export function triangulateShape(
    contour: Vec2[],
    holes: Vec2[][],
  ): number[][];
  export function isClockWise(pts: Vec2[]): boolean;
}
// Renderers / WebGL /////////////////////////////////////////////////////////////////////
export class WebGLBufferRenderer {
  constructor(_gl: WebGLRenderingContext, extensions: any, _infoRender: any);

  setMode(value: any): void;
  render(start: any, count: number): void;
  renderInstances(geometry: any): void;
}
export interface WebGLCapabilitiesParameters {
  precision?: any;
  logarithmicDepthBuffer?: any;
}

export class WebGLCapabilities {
  constructor(
    gl: WebGLRenderingContext,
    extensions: any,
    parameters: WebGLCapabilitiesParameters,
  );

  isWebGL2: boolean;
  precision: any;
  logarithmicDepthBuffer: any;
  maxTextures: any;
  maxVertexTextures: any;
  maxTextureSize: any;
  maxCubemapSize: any;
  maxAttributes: any;
  maxVertexUniforms: any;
  maxVaryings: any;
  maxFragmentUniforms: any;
  vertexTextures: any;
  floatFragmentTextures: any;
  floatVertexTextures: any;

  getMaxAnisotropy(): number;
  getMaxPrecision(precision: string): string;
}
import { Camera } from '../../cameras/Camera';

export class WebGLClipping {
  uniform: { value: any; needsUpdate: boolean };
  numPlanes: number;

  init(planes: any[], enableLocalClipping: boolean, camera: Camera): boolean;
  beginShadows(): void;
  endShadows(): void;
  setState(
    planes: any[],
    clipShadows: boolean,
    camera: Camera,
    cache: boolean,
    fromCache: boolean,
  ): void;
}
export class WebGLExtensions {
  constructor(gl: WebGLRenderingContext);

  get(name: string): any;
}
export class WebGLGeometries {
  constructor(gl: WebGLRenderingContext, attributes: any, info: any);

  get(object: any, geometry: any): any;
  update(geometry: any): any;
  getWireframeAttribute(geometry: any): any;
}
export class WebGLIndexedBufferRenderer {
  constructor(
    gl: WebGLRenderingContext,
    extensions: any,
    info: any,
    capabilities: any,
  );

  setMode(value: any): void;
  setIndex(index: any): void;
  render(start: any, count: number): void;
  renderInstances(
    geometry: any,
    start: any,
    count: number,
    primcount: number,
  ): void;
}
import { WebGLProgram } from './WebGLProgram';

/**
 * An object with a series of statistical information about the graphics board memory and the rendering process.
 */
export class WebGLInfo {
  constructor(gl: WebGLRenderingContext);

  autoReset: boolean;
  memory: {
    geometries: number;
    textures: number;
  };
  programs: WebGLProgram[] | null;
  render: {
    calls: number;
    frame: number;
    lines: number;
    points: number;
    triangles: number;
  };
  update(count: any, mode: any, instanceCount: any): void;
  reset(): void;
}
export class WebGLLights {
  constructor(gl: WebGLRenderingContext, properties: any, info: any);

  state: {
    version: number;

    hash: {
      directionalLength: number;
      pointLength: number;
      spotLength: number;
      rectAreaLength: number;
      hemiLength: number;

      numDirectionalShadows: number;
      numPointShadows: number;
      numSpotShadows: number;
    };

    ambient: Array<number>;
    probe: Array<any>;
    directional: Array<any>;
    directionalShadowMap: Array<any>;
    directionalShadowMatrix: Array<any>;
    spot: Array<any>;
    spotShadowMap: Array<any>;
    spotShadowMatrix: Array<any>;
    rectArea: Array<any>;
    point: Array<any>;
    pointShadowMap: Array<any>;
    pointShadowMatrix: Array<any>;
    hemi: Array<any>;

    numDirectionalShadows: number;
    numPointShadows: number;
    numSpotShadows: number;
  };

  get(light: any): any;
  setup(lights: any, shadows: any, camera: any): void;
}
export class WebGLObjects {
  constructor(
    gl: WebGLRenderingContext,
    geometries: any,
    attributes: any,
    info: any,
  );

  update(object: any): any;
  dispose(): void;
}
import { WebGLRenderer, WebGLRendererParameters } from '../WebGLRenderer';
import { ShaderMaterial } from '../../materials/ShaderMaterial';
import { WebGLShader } from './WebGLShader';
import { WebGLExtensions } from './WebGLExtensions';
import { WebGLUniforms } from './WebGLUniforms';

export class WebGLProgram {
  constructor(
    renderer: WebGLRenderer,
    extensions: WebGLExtensions,
    cacheKey: string,
    material: ShaderMaterial,
    shader: WebGLShader,
    parameters: WebGLRendererParameters,
  );

  id: number;
  cacheKey: string; // unique identifier for this program, used for looking up compiled programs from cache.
  usedTimes: number;
  program: any;
  vertexShader: WebGLShader;
  fragmentShader: WebGLShader;
  /**
   * @deprecated Use {@link WebGLProgram#getUniforms getUniforms()} instead.
   */
  uniforms: any;
  /**
   * @deprecated Use {@link WebGLProgram#getAttributes getAttributes()} instead.
   */
  attributes: any;

  getUniforms(): WebGLUniforms;
  getAttributes(): any;
  destroy(): void;
}
import { WebGLRenderer } from '../WebGLRenderer';
import { WebGLProgram } from './WebGLProgram';
import { WebGLCapabilities } from './WebGLCapabilities';
import { WebGLExtensions } from './WebGLExtensions';
import { Material } from '../../materials/Material';

export class WebGLPrograms {
  constructor(
    renderer: WebGLRenderer,
    extensions: WebGLExtensions,
    capabilities: WebGLCapabilities,
  );

  programs: WebGLProgram[];

  getParameters(
    material: Material,
    lights: any,
    fog: any,
    nClipPlanes: number,
    object: any,
  ): any;
  getProgramCacheKey(material: Material, parameters: any): string;
  acquireProgram(
    material: Material,
    parameters: any,
    cacheKey: string,
  ): WebGLProgram;
  releaseProgram(program: WebGLProgram): void;
}
export class WebGLProperties {
  constructor();

  get(object: any): any;
  remove(object: any): void;
  update(object: any, key: any, value: any): any;
  dispose(): void;
}
import { Object3D } from '../../core/Object3D';
import { Material } from '../../materials/Material';
import { WebGLProgram } from './WebGLProgram';
import { Group } from '../../objects/Group';
import { Scene } from '../../scenes/Scene';
import { Camera } from '../../cameras/Camera';
import { BufferGeometry } from '../../core/BufferGeometry';

export interface RenderTarget {} // not defined in the code, used in LightShadow and WebGRenderer classes

export interface RenderItem {
  id: number;
  object: Object3D;
  geometry: BufferGeometry | null;
  material: Material;
  program: WebGLProgram;
  groupOrder: number;
  renderOrder: number;
  z: number;
  group: Group | null;
}

export class WebGLRenderList {
  opaque: Array<RenderItem>;
  transparent: Array<RenderItem>;
  init(): void;
  push(
    object: Object3D,
    geometry: BufferGeometry | null,
    material: Material,
    groupOrder: number,
    z: number,
    group: Group | null,
  ): void;
  unshift(
    object: Object3D,
    geometry: BufferGeometry | null,
    material: Material,
    groupOrder: number,
    z: number,
    group: Group | null,
  ): void;
  sort(): void;
}

export class WebGLRenderLists {
  dispose(): void;
  get(scene: Scene, camera: Camera): WebGLRenderList;
}
export class WebGLShader {
  constructor(gl: WebGLRenderingContext, type: string, string: string);
}
import { Scene } from '../../scenes/Scene';
import { Camera } from '../../cameras/Camera';
import { WebGLRenderer } from '../WebGLRenderer';
import { ShadowMapType } from '../../constants';

export class WebGLShadowMap {
  constructor(
    _renderer: WebGLRenderer,
    _lights: any[],
    _objects: any[],
    capabilities: any,
  );

  enabled: boolean;
  autoUpdate: boolean;
  needsUpdate: boolean;
  type: ShadowMapType;

  render(scene: Scene, camera: Camera): void;

  /**
   * @deprecated Use {@link WebGLShadowMap#renderReverseSided .shadowMap.renderReverseSided} instead.
   */
  cullFace: any;
}
import {
  CullFace,
  Blending,
  BlendingEquation,
  BlendingSrcFactor,
  BlendingDstFactor,
  DepthModes,
} from '../../constants';
import { WebGLCapabilities } from './WebGLCapabilities';
import { WebGLExtensions } from './WebGLExtensions';
import { Material } from '../../materials/Material';
import { Vector4 } from '../../math/Vector4';

export class WebGLColorBuffer {
  constructor();

  setMask(colorMask: boolean): void;
  setLocked(lock: boolean): void;
  setClear(
    r: number,
    g: number,
    b: number,
    a: number,
    premultipliedAlpha: boolean,
  ): void;
  reset(): void;
}

export class WebGLDepthBuffer {
  constructor();

  setTest(depthTest: boolean): void;
  setMask(depthMask: boolean): void;
  setFunc(depthFunc: DepthModes): void;
  setLocked(lock: boolean): void;
  setClear(depth: number): void;
  reset(): void;
}

export class WebGLStencilBuffer {
  constructor();

  setTest(stencilTest: boolean): void;
  setMask(stencilMask: number): void;
  setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
  setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
  setLocked(lock: boolean): void;
  setClear(stencil: number): void;
  reset(): void;
}

export class WebGLState {
  constructor(
    gl: WebGLRenderingContext,
    extensions: WebGLExtensions,
    capabilities: WebGLCapabilities,
  );

  buffers: {
    color: WebGLColorBuffer;
    depth: WebGLDepthBuffer;
    stencil: WebGLStencilBuffer;
  };

  initAttributes(): void;
  enableAttribute(attribute: number): void;
  enableAttributeAndDivisor(attribute: number, meshPerAttribute: number): void;
  disableUnusedAttributes(): void;
  enable(id: number): void;
  disable(id: number): void;
  useProgram(program: any): boolean;
  setBlending(
    blending: Blending,
    blendEquation?: BlendingEquation,
    blendSrc?: BlendingSrcFactor,
    blendDst?: BlendingDstFactor,
    blendEquationAlpha?: BlendingEquation,
    blendSrcAlpha?: BlendingSrcFactor,
    blendDstAlpha?: BlendingDstFactor,
    premultiplyAlpha?: boolean,
  ): void;
  setMaterial(material: Material, frontFaceCW: boolean): void;
  setFlipSided(flipSided: boolean): void;
  setCullFace(cullFace: CullFace): void;
  setLineWidth(width: number): void;
  setPolygonOffset(polygonoffset: boolean, factor: number, units: number): void;
  setScissorTest(scissorTest: boolean): void;
  activeTexture(webglSlot: number): void;
  bindTexture(webglType: number, webglTexture: any): void;
  unbindTexture(): void;
  // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
  compressedTexImage2D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    border: number,
    data: ArrayBufferView,
  ): void;
  // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
  texImage2D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    border: number,
    format: number,
    type: number,
    pixels: ArrayBufferView | null,
  ): void;
  texImage2D(
    target: number,
    level: number,
    internalformat: number,
    format: number,
    type: number,
    source: any,
  ): void;
  texImage3D(
    target: number,
    level: number,
    internalformat: number,
    width: number,
    height: number,
    depth: number,
    border: number,
    format: number,
    type: number,
    pixels: any,
  ): void;
  scissor(scissor: Vector4): void;
  viewport(viewport: Vector4): void;
  reset(): void;
}
import { WebGLExtensions } from './WebGLExtensions.js.js';
import { WebGLState } from './WebGLState.js.js';
import { WebGLProperties } from './WebGLProperties.js.js';
import { WebGLCapabilities } from './WebGLCapabilities.js.js';
import { WebGLUtils } from './WebGLUtils.js.js';
import { WebGLInfo } from './WebGLInfo.js.js';

export class WebGLTextures {
  constructor(
    gl: WebGLRenderingContext,
    extensions: WebGLExtensions,
    state: WebGLState,
    properties: WebGLProperties,
    capabilities: WebGLCapabilities,
    utils: WebGLUtils,
    info: WebGLInfo,
  );

  allocateTextureUnit(): void;
  resetTextureUnits(): void;
  setTexture2D(texture: any, slot: number): void;
  setTexture2DArray(texture: any, slot: number): void;
  setTexture3D(texture: any, slot: number): void;
  setTextureCube(texture: any, slot: number): void;
  setTextureCubeDynamic(texture: any, slot: number): void;
  setupRenderTarget(renderTarget: any): void;
  updateRenderTargetMipmap(renderTarget: any): void;
  updateMultisampleRenderTarget(renderTarget: any): void;
  safeSetTexture2D(texture: any, slot: number): void;
  safeSetTextureCube(texture: any, slot: number): void;
}
import { WebGLProgram } from './WebGLProgram';
import { WebGLTextures } from './WebGLTextures';

export class WebGLUniforms {
  constructor(gl: WebGLRenderingContext, program: WebGLProgram);

  setValue(
    gl: WebGLRenderingContext,
    name: string,
    value: any,
    textures: WebGLTextures,
  ): void;
  setOptional(gl: WebGLRenderingContext, object: any, name: string): void;

  static upload(
    gl: WebGLRenderingContext,
    seq: any,
    values: any[],
    textures: WebGLTextures,
  ): void;
  static seqWithValue(seq: any, values: any[]): any[];
}
import { Object3D } from '../../core/Object3D';
import { Group } from '../../objects/Group';
import { PerspectiveCamera } from '../../cameras/PerspectiveCamera';
import { ArrayCamera } from '../../cameras/ArrayCamera';
import { Matrix4 } from '../../math/Matrix4';

export class WebVRManager {
  constructor(renderer: any);

  enabled: boolean;
  getController(id: number): Group;
  getDevice(): VRDisplay | null;
  setDevice(device: VRDisplay | null): void;
  setFramebufferScaleFactor(value: number): void;
  setReferenceSpaceType(value: string): void;
  setPoseTarget(object: Object3D | null): void;
  getCamera(camera: PerspectiveCamera): PerspectiveCamera | ArrayCamera;
  getStandingMatrix(): Matrix4;
  isPresenting: () => boolean;
  setAnimationLoop(callback: Function): void;
  submitFrame(): void;
  dispose(): void;
}
export const REVISION: string;

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
export enum MOUSE {
  LEFT,
  MIDDLE,
  RIGHT,
  ROTATE,
  DOLLY,
  PAN,
}

export enum TOUCH {
  ROTATE,
  PAN,
  DOLLY_PAN,
  DOLLY_ROTATE,
}

// GL STATE CONSTANTS
export enum CullFace {}
export const CullFaceNone: CullFace;
export const CullFaceBack: CullFace;
export const CullFaceFront: CullFace;
export const CullFaceFrontBack: CullFace;

export enum FrontFaceDirection {}
export const FrontFaceDirectionCW: FrontFaceDirection;
export const FrontFaceDirectionCCW: FrontFaceDirection;

// Shadowing Type
export enum ShadowMapType {}
export const BasicShadowMap: ShadowMapType;
export const PCFShadowMap: ShadowMapType;
export const PCFSoftShadowMap: ShadowMapType;
export const VSMShadowMap: ShadowMapType;

// MATERIAL CONSTANTS

// side
export enum Side {}
export const FrontSide: Side;
export const BackSide: Side;
export const DoubleSide: Side;

// shading
export enum Shading {}
export const FlatShading: Shading;
export const SmoothShading: Shading;

// colors
export enum Colors {}
export const NoColors: Colors;
export const FaceColors: Colors;
export const VertexColors: Colors;

// blending modes
export enum Blending {}
export const NoBlending: Blending;
export const NormalBlending: Blending;
export const AdditiveBlending: Blending;
export const SubtractiveBlending: Blending;
export const MultiplyBlending: Blending;
export const CustomBlending: Blending;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)
export enum BlendingEquation {}
export const AddEquation: BlendingEquation;
export const SubtractEquation: BlendingEquation;
export const ReverseSubtractEquation: BlendingEquation;
export const MinEquation: BlendingEquation;
export const MaxEquation: BlendingEquation;

// custom blending destination factors
export enum BlendingDstFactor {}
export const ZeroFactor: BlendingDstFactor;
export const OneFactor: BlendingDstFactor;
export const SrcColorFactor: BlendingDstFactor;
export const OneMinusSrcColorFactor: BlendingDstFactor;
export const SrcAlphaFactor: BlendingDstFactor;
export const OneMinusSrcAlphaFactor: BlendingDstFactor;
export const DstAlphaFactor: BlendingDstFactor;
export const OneMinusDstAlphaFactor: BlendingDstFactor;
export const DstColorFactor: BlendingDstFactor;
export const OneMinusDstColorFactor: BlendingDstFactor;

// custom blending src factors
export enum BlendingSrcFactor {}
export const SrcAlphaSaturateFactor: BlendingSrcFactor;

// depth modes
export enum DepthModes {}
export const NeverDepth: DepthModes;
export const AlwaysDepth: DepthModes;
export const LessDepth: DepthModes;
export const LessEqualDepth: DepthModes;
export const EqualDepth: DepthModes;
export const GreaterEqualDepth: DepthModes;
export const GreaterDepth: DepthModes;
export const NotEqualDepth: DepthModes;

// TEXTURE CONSTANTS
// Operations
export enum Combine {}
export const MultiplyOperation: Combine;
export const MixOperation: Combine;
export const AddOperation: Combine;

// Tone Mapping modes
export enum ToneMapping {}
export const NoToneMapping: ToneMapping;
export const LinearToneMapping: ToneMapping;
export const ReinhardToneMapping: ToneMapping;
export const Uncharted2ToneMapping: ToneMapping;
export const CineonToneMapping: ToneMapping;
export const ACESFilmicToneMapping: ToneMapping;

// Mapping modes
export enum Mapping {}
export const UVMapping: Mapping;
export const CubeReflectionMapping: Mapping;
export const CubeRefractionMapping: Mapping;
export const EquirectangularReflectionMapping: Mapping;
export const EquirectangularRefractionMapping: Mapping;
export const SphericalReflectionMapping: Mapping;
export const CubeUVReflectionMapping: Mapping;
export const CubeUVRefractionMapping: Mapping;

// Wrapping modes
export enum Wrapping {}
export const RepeatWrapping: Wrapping;
export const ClampToEdgeWrapping: Wrapping;
export const MirroredRepeatWrapping: Wrapping;

// Filters
export enum TextureFilter {}
export const NearestFilter: TextureFilter;
export const NearestMipmapNearestFilter: TextureFilter;
export const NearestMipMapNearestFilter: TextureFilter;
export const NearestMipmapLinearFilter: TextureFilter;
export const NearestMipMapLinearFilter: TextureFilter;
export const LinearFilter: TextureFilter;
export const LinearMipmapNearestFilter: TextureFilter;
export const LinearMipMapNearestFilter: TextureFilter;
export const LinearMipmapLinearFilter: TextureFilter;
export const LinearMipMapLinearFilter: TextureFilter;

// Data types
export enum TextureDataType {}
export const UnsignedByteType: TextureDataType;
export const ByteType: TextureDataType;
export const ShortType: TextureDataType;
export const UnsignedShortType: TextureDataType;
export const IntType: TextureDataType;
export const UnsignedIntType: TextureDataType;
export const FloatType: TextureDataType;
export const HalfFloatType: TextureDataType;

// Pixel types
export enum PixelType {}
export const UnsignedShort4444Type: PixelType;
export const UnsignedShort5551Type: PixelType;
export const UnsignedShort565Type: PixelType;
export const UnsignedInt248Type: PixelType;

// Pixel formats
export enum PixelFormat {}
export const AlphaFormat: PixelFormat;
export const RGBFormat: PixelFormat;
export const RGBAFormat: PixelFormat;
export const LuminanceFormat: PixelFormat;
export const LuminanceAlphaFormat: PixelFormat;
export const RGBEFormat: PixelFormat;
export const DepthFormat: PixelFormat;
export const DepthStencilFormat: PixelFormat;
export const RedFormat: PixelFormat;

// Compressed texture formats
// DDS / ST3C Compressed texture formats
export enum CompressedPixelFormat {}
export const RGB_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT3_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT5_Format: CompressedPixelFormat;

// PVRTC compressed './texture formats
export const RGB_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGB_PVRTC_2BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_2BPPV1_Format: CompressedPixelFormat;

// ETC compressed texture formats
export const RGB_ETC1_Format: CompressedPixelFormat;

// ASTC compressed texture formats
export const RGBA_ASTC_4x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x12_Format: CompressedPixelFormat;

// Loop styles for AnimationAction
export enum AnimationActionLoopStyles {}
export const LoopOnce: AnimationActionLoopStyles;
export const LoopRepeat: AnimationActionLoopStyles;
export const LoopPingPong: AnimationActionLoopStyles;

// Interpolation
export enum InterpolationModes {}
export const InterpolateDiscrete: InterpolationModes;
export const InterpolateLinear: InterpolationModes;
export const InterpolateSmooth: InterpolationModes;

// Interpolant ending modes
export enum InterpolationEndingModes {}
export const ZeroCurvatureEnding: InterpolationEndingModes;
export const ZeroSlopeEnding: InterpolationEndingModes;
export const WrapAroundEnding: InterpolationEndingModes;

// Triangle Draw modes
export enum TrianglesDrawModes {}
export const TrianglesDrawMode: TrianglesDrawModes;
export const TriangleStripDrawMode: TrianglesDrawModes;
export const TriangleFanDrawMode: TrianglesDrawModes;

// Texture Encodings
export enum TextureEncoding {}
export const LinearEncoding: TextureEncoding;
export const sRGBEncoding: TextureEncoding;
export const GammaEncoding: TextureEncoding;
export const RGBEEncoding: TextureEncoding;
export const LogLuvEncoding: TextureEncoding;
export const RGBM7Encoding: TextureEncoding;
export const RGBM16Encoding: TextureEncoding;
export const RGBDEncoding: TextureEncoding;

// Depth packing strategies
export enum DepthPackingStrategies {}
export const BasicDepthPacking: DepthPackingStrategies;
export const RGBADepthPacking: DepthPackingStrategies;

// Normal Map types
export enum NormalMapTypes {}
export const TangentSpaceNormalMap: NormalMapTypes;
export const ObjectSpaceNormalMap: NormalMapTypes;

// Stencil Op types
export enum StencilOp {}
export const ZeroStencilOp: StencilOp;
export const KeepStencilOp: StencilOp;
export const ReplaceStencilOp: StencilOp;
export const IncrementStencilOp: StencilOp;
export const DecrementStencilOp: StencilOp;
export const IncrementWrapStencilOp: StencilOp;
export const DecrementWrapStencilOp: StencilOp;
export const InvertStencilOp: StencilOp;

// Stencil Func types
export enum StencilFunc {}
export const NeverStencilFunc: StencilFunc;
export const LessStencilFunc: StencilFunc;
export const EqualStencilFunc: StencilFunc;
export const LessEqualStencilFunc: StencilFunc;
export const GreaterStencilFunc: StencilFunc;
export const NotEqualStencilFunc: StencilFunc;
export const GreaterEqualStencilFunc: StencilFunc;
export const AlwaysStencilFunc: StencilFunc;

// usage types
export enum Usage {}
export const StaticDrawUsage: Usage;
export const DynamicDrawUsage: Usage;
export const StreamDrawUsage: Usage;
export const StaticReadUsage: Usage;
export const DynamicReadUsage: Usage;
export const StreamReadUsage: Usage;
export const StaticCopyUsage: Usage;
export const DynamicCopyUsage: Usage;
export const StreamCopyUsage: Usage;
import { Geometry } from './core/Geometry';
import { Material } from './materials/Material';
import { Object3D } from './core/Object3D';
import { Scene } from './scenes/Scene';

export namespace SceneUtils {
  export function createMultiMaterialObject(
    geometry: Geometry,
    materials: Material[],
  ): Object3D;
  export function detach(child: Object3D, parent: Object3D, scene: Scene): void;
  export function attach(child: Object3D, scene: Scene, parent: Object3D): void;
}



}
 export as namespace THREE;


/// <reference types="geojson" />


export as namespace vjmap;

declare namespace vjmap {
/**
 * .
 * :
 *   `strategy`:  JavaScript `inject``eval` `href`.
 *   `injectLocation`:  `document.querySelector`  `head`.
 *   `async`: 
 *   `src`: 
 * @method
 * @async
 * @param {typeof defaultOptions |  Array<typeof defaultOptions>} scripts - Options for a script
 * @return {Promise<void>}
 * @example
 * // you can add multiple loads
 * awit addScript([{
 *  src: "https://code.jquery.com/jquery-3.5.0.js"
 * }, {
 *  src: "https://code.jquery.com/jquery-3.2.0.js",
 *  async: true
 * }, {
 *  src: "https://code.jquery.com/jquery-3.3.0.js",
 *  async: true,
 *  injectLocation: '#main div.test',
 * }, {
 *  src: "https://code.jquery.com/jquery-3.4.0.js",
 *  strategy: 'eval',
 * }, {
 * // link tag
 * // css autodetected
 *  src: "https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap-grid.min.css",
 * }])
 */
export  function addScript(scripts: ScriptDefaultOptions | ScriptDefaultOptions[]): Promise<unknown[]>;

export  const angle: (a: Point23D, b?: Point23D) => number;

/**
 * .
 */
export  class AnimateMarkerLayer extends Evented {
    private map;
    private options;
    private features;
    private type;
    private width;
    private height;
    private colors;
    private textFontSize;
    private textColor;
    private textField;
    private _markersElement;
    private markers;
    private marker;
    constructor(features: FeatureCollection, options?: AnimateMarkerLayerOption);
    addTo(map: Map): void;
    remove(): void;
    getMarkers(): Marker[];
    private _initalizeOptions;
    private _initalizeMarkerLayer;
    private _createMarker;
    setType(type: AnimateMarkerType, options?: AnimateMarkerLayerOption): void;
    _getMarkerElement(): void;
    clearMarkerLayer(): void;
    render(): void;
}

export  interface AnimateMarkerLayerOption {
    type?: AnimateMarkerType;
    width?: number;
    height?: number;
    colors?: string[];
    textFontSize?: number;
    textColor?: string;
    textField?: string;
}

/**
 * breathingAperture .
 * rotatingAperture 
 * haloRing 
 * diffusedAperture 
 * rotatingTextBorder 
 * fluorescence 
 */
export  type AnimateMarkerType = "breathingAperture" | 'rotatingAperture' | 'haloRing' | 'diffusedAperture' | 'rotatingTextBorder' | 'fluorescence';

/**
 * 
 * @param map 
 * @param layerId id
 * @param options 
 * @param layerType  0  1  2 
 */
export  const animateVectorLayer: (map: Map, layerId: string, options?: IAnimateVectorLayerOptions, layerType?: number | undefined) => IAnimateVectorLayerResult;

 interface Animation_2<V> {
    next: (t: number) => {
        value: V;
        done: boolean;
    };
    flipTarget: () => void;
}
export { Animation_2 as Animation }

export  type AnimationOps<V> = PlaybackOptions<V> & (DecayOptions | KeyframeOptions<V> | SpringOptions);

export  interface AnimationState<V> {
    value: V;
    done: boolean;
}

export  const anticipate: Easing;

/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods and properties into.
 * @param baseCtors - Class to take all methods and properties from.
 */
export  function applyMixins(derivedCtor: any, baseCtors: any[]): void;

/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods into.
 * @param baseCtors - Class to take all methods from.
 */
export  function applyMixinsWithoutProperties(derivedCtor: any, baseCtors: any[]): void;

/**
 * Apply offset
 * A function that, given a value, will get the offset from `from`
 * and apply it to `to`
 * @param  {number} from
 * @param  {number} to
 * @return {function}
 */
export  const applyOffset: (from: number, to?: number | undefined) => (v: number) => number | undefined;

export  const attract: (constant: number, origin: number, v: number) => number;

export  const attractExpo: (constant: number, origin: number, v: number) => number;

/**
 * .
 *
 **/
export  class BackgroundLayer extends OverlayLayerBase {
    options: BackgroundLayerOptions;
    constructor(options: BackgroundLayerOptions);
    addTo(map: Map, beforeId?: string): void;
    setBackgroundColor(value: PropertyValueSpecificationEx<ColorSpecification>): this;
    getBackgroundColor(): PropertyValueSpecificationEx<ColorSpecification>;
    setBackgroundPattern(value: PropertyValueSpecificationEx<ResolvedImageSpecification>): this;
    getBackgroundPattern(): PropertyValueSpecificationEx<ResolvedImageSpecification>;
    setBackgroundOpacity(value: PropertyValueSpecificationEx<number>): this;
    getBackgroundOpacity(): PropertyValueSpecificationEx<number>;
}

export  interface BackgroundLayerOptions extends OverlayLayerBaseOptions {
    backgroundColor?: PropertyValueSpecificationEx<ColorSpecification>;
    backgroundPattern?: PropertyValueSpecificationEx<ResolvedImageSpecification>;
    backgroundOpacity?: PropertyValueSpecificationEx<number>;
}

export  type BackgroundLayerSpecification = {
    id: string;
    type: "background";
    metadata?: unknown;
    minzoom?: number;
    maxzoom?: number;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "background-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "background-pattern"?: PropertyValueSpecificationEx<ResolvedImageSpecification>;
        "background-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  const backIn: Easing;

export  const backInOut: Easing;

export  const backOut: Easing;

 type BBox = BBox2d | BBox3d;

/**
 * Bounding box
 *
 * https://tools.ietf.org/html/rfc7946#section-5
 * A GeoJSON object MAY have a member named 'bbox' to include information on the coordinate range for its Geometries, Features, or FeatureCollections.
 * The value of the bbox member MUST be an array of length 2*n where n is the number of dimensions represented in the contained geometries,
 * with all axes of the most southwesterly point followed by all axes of the more northeasterly point.
 * The axes order of a bbox follows the axes order of geometries.
 */
 type BBox2d = [number, number, number, number];

 type BBox3d = [number, number, number, number, number, number];

/**
 * [, , ...]
 * 
 */
 type BezierCurve = [CurvePoint, BezierCurveSegment, ...BezierCurveSegment[]];

/**
 * [12]
 */
 type BezierCurveSegment = [CurvePoint, CurvePoint, CurvePoint];

/**
 * @description  bezierCurve  [ px]
 * @param {BezierCurve} bezierCurve 
 * @param {number} precision       [ 5-10]
 * @param {number} recursiveCount   
 */
export  function bezierCurveToPolyline(bezierCurve: BezierCurve, precision?: number, recursiveCount?: number): CurvePoint[];

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param fns list of member function names
 * @param context the context value
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
export  function bindAll(fns: string[], context: Object): void;

export  const bounceIn: Easing;

export  const bounceInOut: (p: number) => number;

export  const bounceOut: (p: number) => number;

/**
 * .
 */
export  class BreathingApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    _createMarker(): void;
    private _createMakerElement;
    setMarkersWidth(width: number, index?: number): void;
    private _setBreathingApertureWidth;
    setDotSize(size: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
}

/**
 *  
 * @param ring
 * @param buffer
 * @return {any[]}
 */
export  function bufferConvexPolygon(ring: GeoPoint[], buffer: number): GeoPoint[];

/**
 * topo
 * @param lines 
 * @param precision  , 
 * @param hasDirection 
 * @return {{topo: any, graph: {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => NodeId[], addNode: (node: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => NodeId[], shortestPath: (source: NodeId, destination: NodeId) => NodeId[] & {weight?: EdgeWeight}, setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => NodeId[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => {topologicalSort: (sourceNodes?: NodeId[], includeSourceNodes?: boolean) => ...[], addNode: (node: NodeId) => any, lowestCommonAncestors: (node1: NodeId, node2: NodeId) => ...[], shortestPath: (source: NodeId, destination: NodeId) => ... & ..., setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any, adjacent: (node: NodeId) => NodeId[], depthFirstSearch: (sourceNodes?: NodeId[], includeSourceNodes?: boolean, errorOnCycle?: boolean) => ...[], hasCycle: () => boolean, getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight, serialize: () => Serialized, removeEdge: (u: NodeId, v: NodeId) => any, ...}, ...}}}
 */
export  function buildTopoGraph(lines: Array<{
    points: GeoPoint[];
    id?: string;
    weight?: number;
}>, precision?: number, hasDirection?: boolean): {
    graph: {
        addNode: (node: string) => any;
        removeNode: (node: string) => any;
        nodes: () => string[];
        adjacent: (node: string) => string[];
        addEdge: (u: string, v: string, weight?: number | undefined) => any;
        removeEdge: (u: string, v: string) => any;
        hasEdge: (u: string, v: string) => boolean;
        setEdgeWeight: (u: string, v: string, weight: number) => any;
        getEdgeWeight: (u: string, v: string) => number;
        indegree: (node: string) => number;
        outdegree: (node: string) => number;
        depthFirstSearch: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
        hasCycle: () => boolean;
        lowestCommonAncestors: (node1: string, node2: string) => string[];
        topologicalSort: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean) => string[];
        shortestPath: (source: string, destination: string) => string[] & {
            weight?: number | undefined;
        };
        serialize: () => Serialized;
        deserialize: (serialized: Serialized) => any;
    };
    topo: any;
};

/**
 * The algoritm is learnt from
 * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
 * And we made some optimization for matrix inversion.
 * Other similar approaches:
 * "cv::getPerspectiveTransform", "Direct Linear Transformation".
 */
/**
 * Usage:
 * ```js
 * const transformer = buildTransformer(
 *     [10, 44, 100, 44, 100, 300, 10, 300],
 *     [50, 54, 130, 14, 140, 330, 14, 220]
 * );
 * ```
 *
 * @param src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @param dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @return transformer If fail, return null/undefined.
 */
export  function buildTransformer(src: number[], dest: number[]): number[] | undefined;

/**
 * 3d css 
 * Usage:
 * ```js
 * const transformer = buildTransformerMatrix3d(
 *     [10, 44, 100, 44, 100, 300, 10, 300],
 *     [50, 54, 130, 14, 140, 330, 14, 220]
 * );
 * ```
 *
 * @param src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @param dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 */
export  function buildTransformerMatrix3d(src: number[], dest: number[]): string | undefined;

export  class ButtonGroupControl {
    constructor(options?: Record<string, any>);
    onAdd(map: Map): HTMLElement;
    onRemove(): void;
}

/**
 * 
 * @param points
 * @return {number}
 */
export  function calcPolygonArea(points: GeoPoint[]): number;

/**
 * 
 * @param ring
 * @return {number}
 */
export  function calculateSignedArea(ring: GeoPoint[]): number;

export  type CameraFunctionSpecificationEx<T> = {
    type: "exponential";
    stops: Array<[number, T]>;
} | {
    type: "interval";
    stops: Array<[number, T]>;
};

export  const circIn: Easing;

export  const circInOut: Easing;

/**
 * .
 *
 **/
export  class Circle extends OverlayLayerBase {
    options: CircleOptions;
    constructor(options: CircleOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setCircleSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleSortKey(): DataDrivenPropertyValueSpecification<number>;
    setVisibility(value: "visible" | "none"): this;
    getVisibility(): "visible" | "none";
    setCircleRadius(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleRadius(): DataDrivenPropertyValueSpecification<number>;
    setCircleColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getCircleColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setCircleBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleBlur(): DataDrivenPropertyValueSpecification<number>;
    setCircleOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleOpacity(): DataDrivenPropertyValueSpecification<number>;
    setCircleTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getCircleTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setCircleTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCircleTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCirclePitchScale(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCirclePitchScale(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCirclePitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getCirclePitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport">;
    setCircleStrokeWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleStrokeWidth(): DataDrivenPropertyValueSpecification<number>;
    setCircleStrokeColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getCircleStrokeColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setCircleStrokeOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getCircleStrokeOpacity(): DataDrivenPropertyValueSpecification<number>;
}

/**
 * 
 *
 **/
export  class CircleEdge extends Polyline {
    constructor(options: CircleEdgeOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /**  */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /**  */
    getCenter(): GeoPointLike;
    /**  */
    setRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getRadius(): number;
    /**  */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getStartAngle(): number;
    /**  */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getEndAngle(): number;
    /**  */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getPoints(): number;
}

export  interface CircleEdgeOptions extends PolylineOptions {
    /**  */
    center: GeoPointLike;
    /**  */
    radius: number;
    /**  */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /**  */
    properties?: object;
}

/**
 * 
 *
 **/
export  class CircleFill extends Polygon {
    constructor(options: CircleFillOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /**  */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /**  */
    getCenter(): GeoPointLike;
    /**  */
    setRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getRadius(): number;
    /**  */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getStartAngle(): number;
    /**  */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getEndAngle(): number;
    /**  */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getPoints(): number;
}

export  interface CircleFillOptions extends PolygonOptions {
    /**  */
    center: GeoPointLike;
    /**  */
    radius: number;
    /**  */
    startAngle?: number;
    /**  */
    endAngle?: number;
    /**  */
    points?: number;
    /**  */
    properties?: object;
}

export  type CircleLayerSpecification = {
    id: string;
    type: "circle";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "circle-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "circle-radius"?: DataDrivenPropertyValueSpecification<number>;
        "circle-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "circle-blur"?: DataDrivenPropertyValueSpecification<number>;
        "circle-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "circle-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "circle-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-pitch-scale"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "circle-stroke-width"?: DataDrivenPropertyValueSpecification<number>;
        "circle-stroke-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "circle-stroke-opacity"?: DataDrivenPropertyValueSpecification<number>;
    };
};

export  type CircleLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    circleSortKey?: DataDrivenPropertyValueSpecification<number>;
    visibility?: "visible" | "none";
    circleRadius?: DataDrivenPropertyValueSpecification<number>;
    circleColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleBlur?: DataDrivenPropertyValueSpecification<number>;
    circleOpacity?: DataDrivenPropertyValueSpecification<number>;
    circleTranslate?: PropertyValueSpecificationEx<[number, number]>;
    circleTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchScale?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport">;
    circleStrokeWidth?: DataDrivenPropertyValueSpecification<number>;
    circleStrokeColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleStrokeOpacity?: DataDrivenPropertyValueSpecification<number>;
};

export  interface CircleOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    circleSortKey?: DataDrivenPropertyValueSpecification<number>;
    circleRadius?: DataDrivenPropertyValueSpecification<number>;
    circleColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleBlur?: DataDrivenPropertyValueSpecification<number>;
    circleOpacity?: DataDrivenPropertyValueSpecification<number>;
    circleTranslate?: PropertyValueSpecificationEx<[number, number]>;
    circleTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchScale?: PropertyValueSpecificationEx<"map" | "viewport">;
    circlePitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport">;
    circleStrokeWidth?: DataDrivenPropertyValueSpecification<number>;
    circleStrokeColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    circleStrokeOpacity?: DataDrivenPropertyValueSpecification<number>;
}

export  const circOut: Easing;

export  const clamp: (min: number, max: number, v: number) => number;

/**
 * 
 * @param points
 * @param bounds
 * @return {GeoPoint[]}
 */
export  function clipPolygon(points: GeoPoint[], bounds: GeoBounds): GeoPoint[];

/**
 * 
 * @param a
 * @param b
 * @param bounds
 * @return {GeoPoint[] | boolean}
 */
export  function clipSegment(a: GeoPoint, b: GeoPoint, bounds: GeoBounds): GeoPoint[] | Boolean;

/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
export  function cloneDeep<T>(obj: T): T;

/**
 * 
 * @param points
 * @return points
 */
export  function closePolygon(points: GeoPoint[]): GeoPoint[];

/**
 * 
 * @param p
 * @param points
 */
export  function closestPointOnPolyline(p: GeoPoint, points: GeoPoint[]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPrePointDist: number;
};

/**
 * 
 * @param p
 * @param lines
 */
export  function closestPointOnPolylines(p: GeoPoint, lines: GeoPoint[][]): {
    closestLength: number;
    closestPoint: GeoPoint;
    closestIndex: number;
    closestPointIndex: number;
    closestPrePointDist: number;
};

/**
 * 
 * @param p
 * @param p1
 * @param p2
 * @return {GeoPoint}
 */
export  function closestPointOnSegment(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): GeoPoint;

export  type ColorSpecification = string;

export  class Compare extends Evented {
    constructor(a: Map, b: Map, container: Element | string, options?: {
        mousemove: boolean;
        orientation: 'vertical' | 'horizontal';
    });
    private _setPointerEvents;
    private _onDown;
    private _setPosition;
    private _onMove;
    private _onMouseUp;
    private _onTouchEnd;
    private _getX;
    private _getY;
    setSlider(x: number): void;
    remove(): void;
}

export  type CompositeFunctionSpecification<T> = {
    type: "exponential";
    stops: Array<[{
        zoom: number;
        value: number;
    }, T]>;
    property: string;
    default?: T;
} | {
    type: "interval";
    stops: Array<[{
        zoom: number;
        value: number;
    }, T]>;
    property: string;
    default?: T;
} | {
    type: "categorical";
    stops: Array<[{
        zoom: number;
        value: string | number | boolean;
    }, T]>;
    property: string;
    default?: T;
};

export  interface Config<T = unknown> {
    url?: string;
    method: keyof Methods;
    data?: Document | BodyInit;
    headers: {
        [key: string]: string;
    };
    dump: (data: T) => string;
    load: (str: string) => T;
    xmlHttpRequest: () => XMLHttpRequest;
    promise: (fn: () => Promise<unknown>) => Promise<unknown>;
    abort?: any;
    params?: string[][] | Record<string, string> | string | URLSearchParams;
    withCredentials: boolean;
    raw?: boolean;
    events?: {
        [key: string]: () => void;
    };
}

/**
 * .
 *
 **/
export  class ContextMenu {
    private options;
    private menuControl;
    private position;
    /**
     * Creates a new ContextMenu menu
     * @param {object} opts options which build the menu e.g. position and items
     * @param {number} opts.width sets the width of the menu including children
     * @param {object} opts.event 
     * @param {theme} opts.theme darklightdark
     * @param {boolean} opts.isSticky sets how the menu apears, follow the mouse or sticky
     * @param {Array<ContextMenuItem>} opts.items sets the default items in the menu
     */
    constructor(opts: ContextMenuOptions);
    /**
     * Adds item to this ContextMenu menu instance
     * @param {ContextMenuItem} item item to add to the ContextMenu menu
     */
    add(item: any): void;
    /**
     * Makes this ContextMenu menu visible
     */
    show(): void;
    /**
     * Hides this ContextMenu menu
     */
    hide(): void;
    /**
     * Toggle visibility of menu
     */
    toggle(): void;
}

/**
 * .
 *
 **/
export  interface ContextMenuOptions {
    /** . */
    event: Event;
    /** ),150px. */
    width?: string;
    /** .(darklight,dark)*/
    theme?: string;
    /** window  map.getContainer().getBoundingClientRect().width */
    innerWidth?: number;
    /** window  map.getContainer().getBoundingClientRect().height */
    innerHeight?: number;
    /**  */
    items: ContextMenuSubItemOptions[];
}

/**
 * .
 *
 **/
export  interface ContextMenuSubItemOptions {
    /** . */
    type?: "custom" | "multi" | "Button" | "seperator" | "submenu" | "hovermenu" | "normal";
    /** 'custom'html */
    markup?: string;
    /** 'multi'*/
    items?: ContextMenuSubItemOptions[];
    /** */
    onClick?: Function;
    /** */
    label?: string;
    /** */
    shortcut?: string;
    /** */
    enabled?: boolean;
    /** css*/
    cssIcon?: string;
    /** */
    icon?: string;
}

/**
 * transform
 *
 * @param {geojson|GeoPointLike|GeoPointLike[]|string} input
 * @returns {geojson|GeoPointLike | GeoPointLike[]} output
 */
 function convert<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(input: T | string, crsFrom: ((pt: GeoPoint) => GeoPoint) | CRSTypes, crsTo?: CRSTypes): T;

/**
 * 
 * @param pt 
 * @param param 
 * @return {GeoPoint}
 */
export  function coordTransfromByFourParamter(pt: GeoPoint, param: {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
}): GeoPoint;

/**
 * 
 * @param pt 
 * @param param 
 * @return {GeoPoint}
 */
export  function coordTransfromByInvFourParamter(pt: GeoPoint, param: {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
}): GeoPoint;

/**
 * 
 * @param srcArr 
 * @param destArr 
 * @param isSetRotateZero false,true,
 * @param isConsiderPointOrder (-180,180
 * @returns {{rotate: number, dx: number, dy: number, scale: number}}
 */
export  function coordTransfromGetFourParamter(srcArr: GeoPoint[], destArr: GeoPoint[], isSetRotateZero: boolean, isConsiderPointOrder?: boolean): {
    dx: number;
    dy: number;
    scale: number;
    rotate: number;
};

/**
 * 
 * @param map 
 * @param path (lngLat)
 * @param options 
 */
export  function createAnimateFillLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: IAnimateFillLayerOptions): ICreateFillAnimateLayerResult;

/**
 * 
 * @param options 
 */
export  function createAnimateImages(options?: ICreateAnimateImagesOptions): Array<ImageData>;

/**
 * 
 * @param map 
 * @param path (lngLat)
 * @param options 
 */
export  function createAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: IAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * 
 * @param map 
 * @param path (lngLat)
 * @param options 
 */
export  function createAnimateSymbolLayer(map: Map, path: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any, options?: IAnimateSymbolLayerOptions): ICreateSymbolAnimateLayerResult;

export  function createAnimation<V = number>({ from, autoplay, driver, elapsed, repeat: repeatMax, repeatType, repeatDelay, onPlay, onStop, onComplete, onRepeat, onUpdate, ...options }: any): {
    stop: () => void;
    start: (reset?: boolean | undefined) => void;
};

export  const createAnticipate: (power: number) => Easing;

/**
 * 
 * @param options 
 */
export  function createAntPathAnimateImages(options?: ICreateAntPathAnimateLineLayerOptions): ImageData[];

/**
 * 
 * @param map 
 * @param path (lngLat)
 * @param options 
 */
export  function createAntPathAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: ICreateAntPathAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * 
 * @param options 
 */
export  function createArrowAnimateImages(options?: ICreateArrowAnimateLineLayerOptions): ImageData[];

/**
 * 
 * @param map 
 * @param path (lngLat)
 * @param options 
 */
export  function createArrowAnimateLineLayer(map: Map, path: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any, options?: ICreateArrowAnimateLineLayerOptions): ICreateLineAnimateLayerResult;

/**
 * Creates an attractor that, given a strength constant, origin and value,
 * will calculate value as attracted to origin.
 */
export  const createAttractor: (alterDisplacement?: Function) => (constant: number, origin: number, v: number) => number;

export  const createBackIn: (power: number) => Easing;

export  const createExpoIn: (power: number) => Easing;

/**
 *  FrameAnimation .
 * @example
 * const count = 0;
 *
 * const animation = createFrameAnimation(() => {
 *   context.clearRect(0, 0, width, height);
 *   context.font = "4rem monospace";
 *   context.textAlign = 'center';
 *   context.fillText(count, width / 2, height / 2);
 *
 *   count++;
 * });
 *
 * animation.start();
 * @param {function():void} callback - ,truefalse .
 * @returns {{readonly running: boolean, stop: () => void, start: () => void} | boolean}
 * @param stopCallBack true)(false)
 * @param fps 0
 */
export  function createFrameAnimation(callback: (status: FrameAnimationStatus) => boolean, fps?: number, stopCallBack?: (status: FrameAnimationStatus) => void): FrameAnimation;

/**
 * geoson
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createLineGeoJson(input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any): GeoJsonGeomertry;

/**
 * Makrernew Marker()
 */
export  function createMarker(options?: createMarkerOptions): Marker;

export  interface createMarkerOptions extends MarkerOptions {
    /** LngLat. */
    lngLat?: LngLatLike;
    /** . */
    minZoom?: number;
    /** . */
    maxZoom?: number;
    /** div */
    scaleMaxZoom?: number;
    /** . */
    height?: number;
    /** marker*/
    removeWhenNoInMapView?: boolean;
    /** marker500pxmarker*/
    removeWhenNoInMapViewPadding?: number;
}

export  function createObjectOffset(): {
    offsetLines(dist: number): any;
    offset(dist: number): any;
    margin(dist: number): any;
    padding(dist: number): any;
    data(vertices: any): any;
};

export  function createObjectPolygonUtil(): {
    diff(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
    union(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
    intersection(polygonA: Array<Array<Number>>, polygonB: Array<Array<Number>>): Array<Array<Number>> | null;
};

/**
 * geoson
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createPointGeoJson(input: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): GeoJsonGeomertry;

/**
 * geoson
 * @param input
 * @return {{features: any[], type: string}}
 */
export  function createPolygonGeoJson(input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any): GeoJsonGeomertry;

 enum CRSTypes {
    WGS84 = "WGS84",
    WGS1984 = "WGS84",
    EPSG4326 = "WGS84",
    GCJ02 = "GCJ02",
    AMap = "GCJ02",
    BD09 = "BD09",
    BD09LL = "BD09",
    Baidu = "BD09",
    BMap = "BD09",
    BD09MC = "BD09MC",
    BD09Meter = "BD09MC",
    EPSG3857 = "EPSG3857",
    EPSG900913 = "EPSG3857",
    EPSG102100 = "EPSG3857",
    WebMercator = "EPSG3857",
    WM = "EPSG3857"
}

export  function cubicBezier(mX1: number, mY1: number, mX2: number, mY2: number): any;

 type CurvePoint = [number, number];

export  type DataDrivenPropertyValueSpecification<T> = T | CameraFunctionSpecificationEx<T> | SourceFunctionSpecification<T> | CompositeFunctionSpecification<T> | ExpressionSpecificationEx;

/**
 * `Db2dPolyline` .
 *
 */
export  class Db2dPolyline extends DbCurve {
    /** . */
    closed?: boolean;
    /** . */
    elevation?: number;
    /** 2d*/
    polyType?: Poly2dType;
    /** . */
    points?: Array<[number, number, number?]>;
    /** false. */
    smooth?: boolean;
    /**
     * 
     */
    constructor(prop?: IDb2dPolyline);
}

/**
 * `Db2LineAngularDimension` [].
 *
 */
export  class Db2LineAngularDimension extends DbDimension {
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /** 1. */
    xLine1Start?: Array<[number, number, number?]>;
    /** 1. */
    xLine1End?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Start?: Array<[number, number, number?]>;
    /** 2. */
    xLine2End?: Array<[number, number, number?]>;
    /**
     * 
     */
    constructor(prop?: IDb2LineAngularDimension);
}

/**
 * `Db3dPolyline` .
 *
 */
export  class Db3dPolyline extends DbCurve {
    /** . */
    closed?: boolean;
    /** 3d*/
    polyType?: Poly3dType;
    /** . */
    points?: Array<[number, number, number?]>;
    /** false. */
    smooth?: boolean;
    /**
     * 
     */
    constructor(prop?: IDb3dPolyline);
}

/**
 * `Db3PointAngularDimension` [].
 *
 */
export  class Db3PointAngularDimension extends DbDimension {
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /** . */
    centerPoint?: Array<[number, number, number?]>;
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /**
     * 
     */
    constructor(prop?: IDb3PointAngularDimension);
}

/**
 * `DbAlignedDimension` .
 *
 */
export  class DbAlignedDimension extends DbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** dimensionWCS. */
    dimLinePoint?: Array<[number, number, number?]>;
    /** . */
    jogSymbolHeight?: number;
    /**
     * 
     */
    constructor(prop?: IDbAlignedDimension);
}

/**
 * `DbArc` .
 *
 */
export  class DbArc extends DbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    radius?: number;
    /** . */
    startAngle?: number;
    /** . */
    endAngle?: number;
    /** . */
    thickness?: number;
    /** . */
    normal?: [number, number, number?];
    /**
     * 
     */
    constructor(prop?: IDbArc);
}

/**
 * `DbArcDimension` .
 *
 */
export  class DbArcDimension extends DbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** . */
    centerPoint?: Array<[number, number, number?]>;
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /**  0 ;   1 ;   2  . */
    arcSymbolType?: number;
    /**
     * 
     */
    constructor(prop?: IDbArcDimension);
}

/**
 * `DbText` .
 *
 */
export  class DbAttributeDefinition extends DbText {
    /** . */
    tag?: string;
    /** . */
    prompt?: string;
    /**
     * 
     */
    constructor(prop?: IDbText);
}

/**
 * `DbBlock` .
 *
 */
export  class DbBlock {
    /** . */
    name?: string;
    /** . */
    scaling?: number;
    /**  . */
    insertUnits?: number;
    /**  . */
    origin?: [number, number, number?];
    /** . */
    comments?: string;
    /** . */
    explodable?: boolean;
    /** . */
    entitys?: IDbEntity[];
    /**
     * 
     */
    constructor(prop?: IDbBlock);
}

/**
 * `DbBlockReference` .
 *
 */
export  class DbBlockReference extends DbEntity {
    /** . */
    blockname?: string;
    /**  mapid/version, exam/v1. */
    ref?: string;
    /** . */
    position?: [number, number, number?];
    /** . */
    normal?: [number, number, number?];
    /** . */
    rotation?: number;
    /** . [xy,z]*/
    scaleFactors?: [number, number, number?];
    /** */
    attribute?: Record<string, string | number | DbText>;
    /**
     * 
     */
    constructor(prop?: IDbBlockReference);
}

/**
 * `DbCircle` .
 *
 */
export  class DbCircle extends DbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    radius?: number;
    /** . */
    thickness?: number;
    /** . */
    normal?: [number, number, number?];
    /**
     * 
     */
    constructor(prop?: IDbCircle);
}

/**
 * `DbCurve` .
 *
 */
export  class DbCurve extends DbEntity {
    /**
     * 
     */
    constructor(prop?: IDbCurve);
}

/**
 * `DbDiametricDimension` .
 *
 */
export  class DbDiametricDimension extends DbDimension {
    /** 1. */
    chordPoint?: Array<[number, number, number?]>;
    /** 2. */
    farChordPoint?: Array<[number, number, number?]>;
    /** . */
    leaderLength?: number;
    /**
     * 
     */
    constructor(prop?: IDbDiametricDimension);
}

/**
 * `DbDimension` .
 *
 */
export  class DbDimension extends DbEntity {
    /** . */
    dimStyle?: string;
    /** . */
    textPosition?: Array<[number, number, number?]>;
    /** . */
    textHeight?: number;
    /** . */
    textRotation?: number;
    /** . */
    dimScale?: number;
    /** . */
    dimDec?: number;
    /** . */
    arrowSize?: number;
    /** . */
    dimRnd?: number;
    /** . */
    textColor?: number;
    /** . */
    arrowColor?: number;
    /** . */
    lineColor?: number;
    /** . */
    dimensionText?: string;
    /**
     * 
     */
    constructor(prop?: IDbDimension);
}

/**
 * `DbDocument` .
 *
 */
export  class DbDocument {
    /**   mapid/version, exam/v1 . */
    from?: string;
    /**  */
    pickLayers?: string[];
    /** IDID */
    pickEntitys?: string[];
    /** IDID pickEntitys */
    pickExpr?: string;
    isClearFromDb?: boolean;
    /** ,  LWDISPLAY ,true false*/
    environment?: Record<string, any>;
    /** . */
    entitys?: IDbEntity[];
    /** . */
    layers?: IDbLayer[];
    /** . */
    textStyles?: IDbTextStyle[];
    /** . */
    dimStyles?: IDbDimStyle[];
    /** . */
    linetypes?: IDbLinetype[];
    /** . */
    blocks?: IDbBlock[];
    /**  true */
    isRenameBlockNameIfExist?: boolean;
    /**  false */
    isZoomExtents?: boolean;
    /**
     * 
     */
    constructor(prop?: IDbDocument);
    /**
     * 
     * @param entity
     */
    appendEntity(entity: IDbEntity | IDbEntity[]): void;
    /**
     * 
     * @param layer
     */
    appendLayer(layer: IDbLayer | IDbLayer[]): void;
    /**
     * 
     * @param textStyle
     */
    appendTextStyle(textStyle: IDbTextStyle | IDbTextStyle[]): void;
    /**
     * 
     * @param dimStyle
     */
    appendDimStyle(dimStyle: IDbDimStyle | IDbDimStyle[]): void;
    /**
     * 
     * @param linetype
     */
    appendLinetype(linetype: IDbLinetype | IDbLinetype[]): void;
    /**
     * 
     * @param block
     */
    appendBlock(block: IDbBlock | IDbBlock[]): void;
    /**
     * 
     * @param content contentjson
     * @return {string}
     */
    toDoc(content?: string): string;
}

/**
 * `DbEllipse` .
 *
 */
export  class DbEllipse extends DbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    minorAxis?: [number, number, number?];
    /** . */
    startAngle?: number;
    /** . */
    endAngle?: number;
    /** . */
    radiusRatio?: number;
    /**
     * 
     */
    constructor(prop?: IDbEllipse);
}

/**
 * `DbEntity` .
 *
 */
export  abstract class DbEntity implements IDbEntity {
    /** . */
    typename?: string;
    /** . */
    color?: number;
    /** . 0 . 1 Red.  2 Yellow. 3   Green.  4 Cyan.  5  Blue. 6   Magenta. 256 */
    colorIndex?: number;
    /** . */
    layer?: string;
    /** . */
    linetype?: string;
    /** . */
    linetypeScale?: number;
    /** . */
    lineWidth?: number;
    /** . [0-255][0,255]*/
    alpha?: number;
    /** . */
    visibility?: boolean;
    /** . */
    matrix?: IDbMatrixOp[];
    /** . */
    xdata?: string;
    /** IDDbDocumentfrom. */
    cloneObjectId?: string;
    /** IDDbDocumentfrom*/
    cloneFromDb?: string;
    /**
    * 
    * @param prop
    */
    protected constructor(prop?: IDbEntity);
}

/**
 * `DbHatch` .
 *
 */
export  class DbHatch extends DbEntity {
    /** . */
    elevation?: number;
    /** ,  SOLID */
    pattern?: string;
    /**  */
    patternAngle?: number;
    /**  */
    patternDouble?: boolean;
    /**  */
    patternSpace?: number;
    /**  */
    patternScale?: number;
    /**  */
    patternAssociative?: boolean;
    /**  */
    patternOrigin?: [number, number];
    /**  */
    patternBackgroundColor?: number;
    /** . */
    points?: Array<[number, number, number?]> | Array<Array<[number, number, number?]>>;
    /**
     * 
     */
    constructor(prop?: IDbHatch);
}

/**
 * `DbLayer` .
 *
 */
export  class DbLayer {
    /** .  \*all_layers\* */
    name?: string;
    /** . */
    color?: number;
    /**  CONTINUOUS . */
    linetype?: string;
    /** . */
    isOff?: boolean;
    /** . */
    isLocked?: boolean;
    /** . */
    isFrozen?: boolean;
    /**
     * 
     */
    constructor(prop?: IDbLayer);
}

/**
 * `DbLine` .
 *
 */
export  class DbLine extends DbEntity implements IDbLine {
    /** . */
    start?: [number, number, number?];
    /** . */
    end?: [number, number, number?];
    /** . */
    thickness?: number;
    /**
     * 
     */
    constructor(prop?: IDbLine);
}

/**
 * `DbLineType` .
 *
 */
export  class DbLineType {
    /** . */
    name?: string;
    /** . */
    comments?: string;
    /**  . */
    style?: IDbLinetypeStyle[];
    /**
     * 
     */
    constructor(prop?: IDbLinetype);
}

/**
 * `DbMLeader` .
 *
 */
export  class DbMLeader extends DbEntity {
    /** . */
    textWidth?: number;
    /** . */
    height?: number;
    /** . */
    textRotation?: number;
    /** . */
    textHeight?: number;
    /** . */
    contents?: string;
    /** . */
    textLocation?: [number, number, number?];
    /** . */
    textAttachment?: MTextAttachmentPoint;
    /** . */
    textStyle?: string;
    /** . 0  1 */
    textAttachmentDirection?: 0 | 1;
    /** . type(0-10) value(0-4) [type1, value1, type2, value2....]*/
    textAttachmentType?: number[];
    /** . */
    leaderLinePoint?: [number, number, number?];
    /** . */
    leaderVertexPoints?: [number, number, number?][];
    enableDogleg?: boolean;
    landingGap?: number;
    doglegLength?: number;
    blockScale?: [number, number, number];
    blockPosition?: [number, number, number?];
    arrowSize?: number;
    blockRotation?: number;
    blockConnectionType?: 0 | 1;
    /**
     * 
     */
    constructor(prop?: IDbMText);
}

/**
 * `DbMText` .
 *
 */
export  class DbMText extends DbEntity {
    /** . */
    width?: number;
    /** . */
    height?: number;
    /** . */
    rotation?: number;
    /** . */
    textHeight?: number;
    /** . */
    contents?: string;
    /** . */
    location?: [number, number, number?];
    /** . */
    attachment?: MTextAttachmentPoint;
    /** . */
    textStyle?: string;
    /**
     * 
     */
    constructor(prop?: IDbMText);
}

/**
 * `DbOrdinateDimension`  .
 *
 */
export  class DbOrdinateDimension extends DbDimension {
    /** . */
    origin?: Array<[number, number, number?]>;
    /** . */
    definingPoint?: Array<[number, number, number?]>;
    /** . */
    leaderEndPoint?: Array<[number, number, number?]>;
    /** X. */
    useXAxis?: boolean;
    /**
     * 
     */
    constructor(prop?: IDbOrdinateDimension);
}

/**
 * `DbPolyline` .
 *
 */
export  class DbPolyline extends DbCurve {
    /** . */
    closed?: boolean;
    /** . */
    elevation?: number;
    /** . */
    points?: Array<[number, number, number?]>;
    /** . */
    bulge?: number[];
    /** . */
    startWidth?: number[];
    /** . */
    endWidth?: number[];
    /** false. */
    smooth?: boolean;
    /**
     * 
     */
    constructor(prop?: IDbPolyline);
}

/**
 * `DbRadialDimension` 
 *
 */
export  class DbRadialDimension extends DbDimension {
    /** . */
    center?: Array<[number, number, number?]>;
    /** . */
    chordPoint?: Array<[number, number, number?]>;
    /** . */
    leaderLength?: number;
    /**
     * 
     */
    constructor(prop?: IDbRadialDimension);
}

/**
 * `DbRadialDimensionLarge` .
 *
 */
export  class DbRadialDimensionLarge extends DbDimension {
    /** . */
    center?: Array<[number, number, number?]>;
    /** . */
    chordPoint?: Array<[number, number, number?]>;
    /** DimensionWCS. */
    overrideCenter?: Array<[number, number, number?]>;
    /** Dimension. */
    jogPoint?: Array<[number, number, number?]>;
    /** Dimension. */
    jogAngle?: number;
    /**
     * 
     */
    constructor(prop?: IDbRadialDimensionLarge);
}

/**
 * `DbRasterImage` .
 *
 */
export  class DbRasterImage extends DbEntity {
    /**  [0.0 .. 100.0] */
    brightness?: number;
    /** url. */
    sourceHttpUrl?: string;
    /** . */
    pixelWidth?: number;
    /** . */
    pixelHeight?: number;
    /** . */
    units?: RasterImageUnits;
    /** x. */
    xPelsPerUnit?: number;
    /** y. */
    yPelsPerUnit?: number;
    /** . */
    widthRatio?: number;
    /** .. */
    heightRatio?: number;
    /** . */
    position?: [number, number, number?];
    /** . */
    imageDisplayOptShow?: boolean;
    /** . */
    imageDisplayOptClip?: boolean;
    /** . */
    imageDisplayOptShowUnAligned?: boolean;
    /** . */
    imageDisplayOptTransparent?: boolean;
    /**
     * 
     */
    constructor(prop?: IDbRasterImage);
}

/**
 * `DbRotatedDimension` .
 *
 */
export  class DbRotatedDimension extends DbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** dimensionWCS. */
    dimLinePoint?: Array<[number, number, number?]>;
    /**
     * 
     */
    constructor(prop?: IDbRotatedDimension);
}

/**
 * `DbShape` 
 *
 */
export  class DbShape extends DbEntity {
    /** . */
    rotation?: number;
    /** . */
    position?: [number, number, number?];
    /** . */
    size?: number;
    /** . */
    normal?: [number, number, number?];
    /** . */
    name?: string;
    /**
     * 
     */
    constructor(prop?: IDbShape);
}

/**
 * `DbSpline` .
 *
 */
export  class DbSpline extends DbCurve {
    /** the curve fitting tolerance for this Spline entity. */
    fitTol?: number;
    /** Increased the degree of this spline to the specified value. */
    degree?: number;
    /** . */
    fitPoints?: Array<[number, number, number?]>;
    /** . */
    controlPoints?: Array<[number, number, number?]>;
    /**
     * 
     */
    constructor(prop?: IDbSpline);
}

/**
 * `DbBlockReference` .
 *
 */
export  class DbTable extends DbBlockReference {
    /** . */
    tableStyleName?: string;
    /** . */
    numColumns?: number;
    /** . */
    numRows?: number;
    /** . */
    columnWidth?: number;
    /** . */
    rowHeight?: number;
    /** . */
    disableTitle?: boolean;
    /** . */
    directionBottomToTop?: boolean;
    /** (). */
    textHeight?: number;
    /** .(kHorzTop(1), kHorzInside(2), kHorzBottom(4), kVertLeft(8), kVertInside(16), kVertRight(32);   kTitleRow(1), kHeaderRow(2), kDataRow(4) */
    gridVisibility?: [boolean, number, number];
    /** (). */
    backgroundColor?: number;
    /** (). */
    contentColor?: number;
    /** (). */
    gridColor?: number;
    /** (). */
    alignment?: TableCellAlignment;
    /** . */
    horzCellMargin?: number;
    /** . */
    vertCellMargin?: number;
    /**  [[minRow, maxRow,minColumn, maxColumn], ...]  */
    mergeCells?: Array<[number, number, number, number]>;
    /** . */
    data?: Array<Array<string | {
        /** . */
        text: string;
        /** . */
        alignment: TableCellAlignment;
        /** . */
        backgroundColor: number;
        /** . */
        gridColor: number;
        /** . */
        contentColor: number;
        /** . */
        textHeight: number;
        /** . */
        gridVisibility: boolean;
    }>>;
    /**
     * 
     */
    constructor(prop?: IDbTable);
}

/**
 * `DbText` .
 *
 */
export  class DbText extends DbEntity {
    /** . */
    height?: number;
    /** . */
    rotation?: number;
    /**  contents. */
    text?: string;
    /**  text. */
    contents?: string;
    /** . */
    position?: [number, number, number?];
    /** . */
    textStyle?: string;
    /** . */
    horizontalMode?: DbTextHorzMode;
    /** . */
    verticalMode?: DbTextVertMode;
    /**
     * 
     */
    constructor(prop?: IDbText);
}

export  enum DbTextHorzMode {
    kTextLeft = 0,
    kTextCenter = 1,
    kTextRight = 2,
    kTextAlign = 3,
    kTextMid = 4,
    kTextFit = 5
}

/**
 * `DbTextStyle` .
 *
 */
export  class DbTextStyle {
    /** . */
    name?: string;
    /** . */
    isShapeFile?: boolean;
    /**  . */
    textSize?: number;
    /** x . */
    xScale?: number;
    /**  . */
    priorSize?: number;
    /** 2*PI 0.0. */
    obliquingAngle?: number;
    /**  . */
    fileName?: string;
    /**  . */
    typeFace?: string;
    /**  . */
    bold?: boolean;
    /**  . */
    italic?: boolean;
    /** 0 . */
    charset?: number;
    /** 34 . */
    pitchAndFamily?: number;
    /**
     * 
     */
    constructor(prop?: IDbTextStyle);
}

export  enum DbTextVertMode {
    kTextBase = 0,
    kTextBottom = 1,
    kTextVertMid = 2,
    kTextTop = 3
}

/**
 * `DbWipeout` .
 *
 */
export  class DbWipeout extends DbRasterImage {
    /** . */
    points?: Array<[number, number, number?]>;
    /**
     * 
     */
    constructor(prop?: IDbWipeout);
}

export  function decay({ velocity, from, power, timeConstant, restDelta, modifyTarget }: DecayOptions): any;

export  interface DecayOptions {
    from?: number;
    to?: number;
    velocity?: number;
    power?: number;
    timeConstant?: number;
    modifyTarget?: (target: number) => number;
    restDelta?: number;
}

/**
 * deck.gl.
 *
 **/
export  class DeckLayer extends Evented implements CustomLayerInterface {
    id: string;
    deckNs: object;
    layer: object;
    type: "custom";
    renderingMode?: "2d" | "3d" | undefined;
    constructor(props: any);
    onAdd(map: any, gl: any): void;
    onRemove(): void;
    setProps(props: any): void;
    render(gl: any, matrix: any): void;
}

export  const degreesToRadians: (degrees: number) => number;

/**
 * 
 * @param a
 * @return {number}
 */
export  function degToRad(a: number): number;

/**
 * .
 */
export  class DiffusedApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
}

 type Direction = "start" | "end";

export  function distance<P extends Point23D | number>(a: P, b: P): number;

/**
 * div
 * svg viewBox="0 0 width height" preserveAspectRatio="xMinYMin meet", updateDivSizetrue
 **/
export  class DivOverlay {
    options: DivOverlayOptions;
    _map?: Map;
    isShow: boolean;
    minZoom: number;
    maxZoom: number;
    maxPitch: number;
    isRemoved: boolean;
    parentContainer?: HTMLElement;
    constructor(options: DivOverlayOptions);
    addTo(map: Map, insertId?: string | HTMLElement): void;
    private _isShow;
    private _add;
    private _remove;
    /**
     * 
     * @param visible 
     * @param isDisplay truestyledisplaydomfalse
     */
    setVisible(visible?: boolean, isDisplay?: boolean): void;
    remove(): void;
    updateBounds(bounds: [GeoPointLike, GeoPointLike, GeoPointLike, GeoPointLike] | GeoBounds): void;
    updateSize(width: number, height: number): void;
    private _updateZoom;
    private _updateDivSize;
    private _adjustCoord;
    private _update;
}

export  interface DivOverlayOptions {
    /**  */
    bounds: [GeoPointLike, GeoPointLike, GeoPointLike, GeoPointLike] | GeoBounds;
    /** html */
    element: HTMLElement;
    /**  */
    width: number;
    /**  */
    height: number;
    /**  */
    minZoom?: number;
    /**  */
    maxZoom?: number;
    /**  */
    maxPitch?: number;
    /** divsvgtrue) */
    updateDivSize?: boolean;
    /** divdiv */
    maxDivSize?: number;
}

export  namespace Dom {
    export function create(tagName: string, className?: string, container?: HTMLElement): HTMLElement;
    export function createNS(namespaceURI: string, tagName: string): Element;
    export function disableDrag(): void;
    export function enableDrag(): void;
    export function setTransform(el: HTMLElement, value: string): void;
    export function addEventListener(target: any, type: any, callback: any, options?: {
        passive?: boolean;
        capture?: boolean;
    }): void;
    export function removeEventListener(target: any, type: any, callback: any, options?: {
        passive?: boolean;
        capture?: boolean;
    }): void;
    export function suppressClick(): void;
    export function mousePos(el: HTMLElement, e: MouseEvent | WheelEvent): GeoPoint;
    export function touchPos(el: HTMLElement, touches: TouchList): GeoPoint[];
    export function mouseButton(e: MouseEvent): number;
    export function remove(node: HTMLElement): void;
    export function hasClass(el: HTMLElement, name: string): boolean;
    export function addClass(el: HTMLElement, name: string): void;
    export function removeClass(el: HTMLElement, name: string): void;
    export function setClass(el: HTMLElement, name: string): void;
    export function getClass(el: HTMLElement): any;
    export type Anchor = 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    const anchorTranslate: Record<Anchor, string>;
}

export  const Draw: {
    /** . */
    Tool: new (options?: IDrawOptions | undefined) => IDrawTool;
    /** . */
    defaultOptions: () => any;
    /** . */
    modes: Record<string, any>;
    /** . */
    actionDraw: (map: any, modename: string, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawCircle: (map: any, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawLineSting: (map: any, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawPoint: (map: any, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawPolygon: (map: any, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawRectangle: (map: any, options?: Record<string, any> | undefined) => any;
    /** . */
    actionDrawSlantRectangle: (map: any, options?: Record<string, any> | undefined) => any;
    /** . optionsselectSingletrue*/
    actionSelect: (map: any, draw: any, options?: Record<string, any> | undefined) => any;
};

export  type Driver = (update: Update) => DriverControls;

/**
 * Drivers accept a update function and call it at an interval. This interval
 * could be a synchronous loop, a setInterval, or tied to the device's framerate.
 */
export  interface DriverControls {
    start: () => void;
    stop: () => void;
}

export  const easeIn: Easing;

export  const easeInOut: Easing;

export  const easeOut: Easing;

export  type Easing = (v: number) => number;

export  type EasingModifier = (easing: Easing) => Easing;

 type EdgeWeight = number;

/**
 * 
 *
 **/
export  class EllipseEdge extends Polyline {
    constructor(options: EllipseEdgeOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /**  */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /**  */
    getCenter(): GeoPointLike;
    /**  */
    setMajorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getMajorAxisRadius(): number;
    /**  */
    setMinorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getMinorAxisRadius(): number;
    /**  */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getStartAngle(): number;
    /**  */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getEndAngle(): number;
    /**  */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getPoints(): number;
}

export  interface EllipseEdgeOptions extends PolylineOptions {
    /**  */
    center: GeoPointLike;
    /**  */
    majorAxisRadius: number;
    /**  */
    minorAxisRadius: number;
    /**  */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /**  */
    properties?: object;
}

/**
 * 
 *
 **/
export  class EllipseFill extends Polygon {
    constructor(options: EllipseFillOptions);
    addTo(map: Map, beforeId?: string): void;
    updateData(): void;
    /**  */
    setCenter(value: GeoPointLike, bFocusUpdateData?: boolean): this;
    /**  */
    getCenter(): GeoPointLike;
    /**  */
    setMajorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getMajorAxisRadius(): number;
    /**  */
    setMinorAxisRadius(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getMinorAxisRadius(): number;
    /**  */
    setStartAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getStartAngle(): number;
    /**  */
    setEndAngle(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getEndAngle(): number;
    /**  */
    setPoints(value: number, bFocusUpdateData?: boolean): this;
    /**  */
    getPoints(): number;
}

export  interface EllipseFillOptions extends PolygonOptions {
    /**  */
    center: GeoPointLike;
    /**  */
    majorAxisRadius: number;
    /**  */
    minorAxisRadius: number;
    /**  */
    startAngle?: number;
    endAngle?: number;
    points?: number;
    /**  */
    properties?: object;
}

/**
 * html
 * @param color 
 * @param darkMode  
 * @param alpha 
 * @return {string}
 */
export  function entColorToHtmlColor(color: number | string, darkMode?: boolean, alpha?: number): string;

 enum EpsgCrsTypes {
    Beijing54 = "Beijing54",
    Xian80 = "Xian80",
    CGCS2000 = "CGCS2000",
    Wgs84 = "Wgs84",
    Merc3857 = "Merc3857",
    NewBeijing54 = "NewBeijing54"
}

export  const EPSILON = 1e-8;

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
export  function equals(a: number, b: number): boolean;

export  const EVENTS: {
    READY_STATE_CHANGE: string;
    LOAD_START: string;
    PROGRESS: string;
    ABORT: string;
    ERROR: string;
    LOAD: string;
    TIMEOUT: string;
    LOAD_END: string;
};

export  interface Events {
    READY_STATE_CHANGE: "readystatechange";
    LOAD_START: "loadstart";
    PROGRESS: "progress";
    ABORT: "abort";
    ERROR: "error";
    LOAD: "load";
    TIMEOUT: "timeout";
    LOAD_END: "loadend";
}

export  type ExpressionSpecificationEx = Array<unknown>;

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 *
 * @param dest destination object
 * @param sources sources from which properties are pulled
 * @private
 */
export  function extend(dest: Object, ...sources: Object[]): Object;

/**
 * Feature
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * A Feature object represents a spatially bounded thing.
 * Every Feature object is a GeoJSON object no matter where it occurs in a GeoJSON text.
 */
 interface Feature<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
    type: "Feature";
    geometry: G;
    /**
     * A value that uniquely identifies this feature in a
     * https://tools.ietf.org/html/rfc7946#section-3.2.
     */
    id?: Id;
    /**
     * Properties associated with this feature.
     */
    properties: P;
}

/**
 * Feature Collection
 *
 * https://tools.ietf.org/html/rfc7946#section-3.3
 * A GeoJSON object with the type 'FeatureCollection' is a FeatureCollection object.
 * A FeatureCollection object has a member with the name 'features'.
 * The value of 'features' is a JSON array. Each element of the array is a Feature object as defined above.
 * It is possible for this array to be empty.
 */
 interface FeatureCollection<G = Geometry | GeometryCollection, P = Properties> extends GeoJSONObject {
    type: "FeatureCollection";
    features: Array<Feature<G, P>>;
}

/**
 * .
 *
 **/
export  class FillExtrusion extends OverlayLayerBase {
    options: FillExtrusionOptions;
    constructor(options: FillExtrusionOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setFillExtrusionOpacity(value: PropertyValueSpecificationEx<number>): this;
    getFillExtrusionOpacity(): PropertyValueSpecificationEx<number>;
    setFillExtrusionColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getFillExtrusionColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setFillExtrusionTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getFillExtrusionTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setFillExtrusionTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getFillExtrusionTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setFillExtrusionPattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getFillExtrusionPattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setFillExtrusionHeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getFillExtrusionHeight(): DataDrivenPropertyValueSpecification<number>;
    setFillExtrusionBase(value: DataDrivenPropertyValueSpecification<number>): this;
    getFillExtrusionBase(): DataDrivenPropertyValueSpecification<number>;
    setFillExtrusionVerticalGradient(value: PropertyValueSpecificationEx<boolean>): this;
    getFillExtrusionVerticalGradient(): PropertyValueSpecificationEx<boolean>;
}

export  type FillExtrusionLayerSpecification = {
    id: string;
    type: "fill-extrusion";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "fill-extrusion-opacity"?: PropertyValueSpecificationEx<number>;
        "fill-extrusion-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-extrusion-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "fill-extrusion-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "fill-extrusion-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "fill-extrusion-height"?: DataDrivenPropertyValueSpecification<number>;
        "fill-extrusion-base"?: DataDrivenPropertyValueSpecification<number>;
        "fill-extrusion-vertical-gradient"?: PropertyValueSpecificationEx<boolean>;
    };
};

export  type FillExtrusionLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    fillExtrusionOpacity?: PropertyValueSpecificationEx<number>;
    fillExtrusionColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillExtrusionTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillExtrusionTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillExtrusionPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    fillExtrusionHeight?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionBase?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionVerticalGradient?: PropertyValueSpecificationEx<boolean>;
};

export  interface FillExtrusionOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    fillExtrusionOpacity?: PropertyValueSpecificationEx<number>;
    fillExtrusionColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillExtrusionTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillExtrusionTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillExtrusionPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    fillExtrusionHeight?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionBase?: DataDrivenPropertyValueSpecification<number>;
    fillExtrusionVerticalGradient?: PropertyValueSpecificationEx<boolean>;
}

export  type FillLayerSpecification = {
    id: string;
    type: "fill";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "fill-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "fill-antialias"?: PropertyValueSpecificationEx<boolean>;
        "fill-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "fill-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-outline-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "fill-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "fill-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "fill-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    };
};

export  type FillLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    fillSortKey?: DataDrivenPropertyValueSpecification<number>;
    fillAntialias?: PropertyValueSpecificationEx<boolean>;
    fillOpacity?: DataDrivenPropertyValueSpecification<number>;
    fillColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillOutlineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
};

export  type FilterSpecification = ["has", string] | ["!has", string] | ["==", string, string | number | boolean] | ["!=", string, string | number | boolean] | [">", string, string | number | boolean] | [">=", string, string | number | boolean] | ["<", string, string | number | boolean] | ["<=", string, string | number | boolean] | Array<string | FilterSpecification>;

/**
 * 
 * @param startPoint 
 * @param endPoint 
 * @param lines 
 * @param precision  , 
 * @param hasDirection 
 */
export  function findShortestPath(startPoint: GeoPoint, endPoint: GeoPoint, lines: Array<{
    points: GeoPoint[];
    id?: string;
    weight?: number;
}>, precision?: number, hasDirection?: boolean): {
    startPoint: {
        closestLength: number;
        closestPoint: GeoPoint;
        closestIndex: number;
        closestPointIndex: number;
        closestPrePointDist: number;
    };
    endPoint: {
        closestLength: number;
        closestPoint: GeoPoint;
        closestIndex: number;
        closestPointIndex: number;
        closestPrePointDist: number;
    };
    route: any[];
    routeDetail: {
        points: any[];
        index: any;
        reverse: boolean;
    }[];
    error?: undefined;
} | {
    error: any;
    startPoint?: undefined;
    endPoint?: undefined;
    route?: undefined;
    routeDetail?: undefined;
};

/**
 * .
 */
export  class FluorescenceMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _setFluorescenceWidth;
    private _setFluorescenceColor;
}

export  type FogSpecification = {
    range?: PropertyValueSpecificationEx<[number, number]>;
    color?: PropertyValueSpecificationEx<ColorSpecification>;
    "horizon-blend"?: PropertyValueSpecificationEx<number>;
};

export  type FormattedSpecification = string;

/**
 * @property {Boolean} running - Getter that indicates if animation is running.
 * @property {function():void} stop - Stops the animation.
 * @property {function():void} start - Starts the animation.
 */
export  interface FrameAnimation {
    /**
     * A getter property that indicates if animation is running.
     */
    readonly running: boolean;
    /**
     * A getter property that indicates if animation is running.
     */
    readonly status: FrameAnimationStatus;
    /**
     * Stops the animation.
     */
    stop: () => void;
    /**
     * Starts the animation.
     */
    start: () => void;
    /**
     * pause the animation.
     */
    pause: () => void;
    /**
     * 
     */
    changeFps: (fps: number) => void;
}

export  enum FrameAnimationStatus {
    /** . */
    Run = 0,
    /** stop). */
    Stop = 1,
    /** . */
    Pause = 2,
    /**  (true). */
    End = 3
}

/**
 * `GeoBounds` .
 */
export  class GeoBounds {
    min: GeoPoint;
    max: GeoPoint;
    constructor(min?: GeoPoint, max?: GeoPoint);
    /**
     *  `GeoBounds`.
     *
     * Example:
     * ```typescript
     * const b = GeoBounds.fromArray([left, bottom, right, top]);
     * ```
     */
    static fromArray(input: [number, number, number, number]): GeoBounds;
    /**
     *  `GeoBounds`.
     *
     * Example:
     * ```typescript
     * const b = GeoBounds.fromString("[1,2,3,4]");
     * ```
     */
    static fromString(input: string): GeoBounds;
    /**
     * bounds
     * @param input
     * @return {GeoBounds}
     */
    static fromDataExtent(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoBounds;
    /**
     * bounds
     * @return {GeoBounds}
     * @param center 
     * @param width 
     * @param height 
     */
    static fromCenterWH(center: GeoPointLike, width: number, height?: number): GeoBounds;
    /**
     * 
     *
     * @param min 
     * @param max 
     */
    set(min: GeoPoint, max: GeoPoint): void;
    /**
     * 
     * @return {GeoPoint}
     */
    center(): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     */
    leftTop(): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     */
    leftBottom(): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     */
    rightTop(): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     */
    rightBottom(): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     * @param xRatio x  0.6
     * @param yRatio y  0.6
     */
    randomPoint(xRatio?: number, yRatio?: number): GeoPoint;
    /**
     * 
     * @return {GeoPoint}
     * @param xRatio x  0.6
     * @param yRatio y  0.6
     * @param minPointCount 
     * @param maxPointCount 
     */
    randomPoints(minPointCount: number, maxPointCount: number, xRatio?: number, yRatio?: number): GeoPoint[];
    /**
     * geojson
     * @return {GeoPoint}
     * @param xRatio x  0.6
     * @param yRatio y  0.6
     * @param count 
     * @param propertiesCb 
     */
    randomGeoJsonPointCollection(count: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object): GeoJsonGeomertry;
    /**
     * geojson
     * @return {GeoPoint}
     * @param xRatio x  0.6
     * @param yRatio y  0.6
     * @param maxLineCount 
     * @param maxPointCount 
     * @param propertiesCb 
     * @param minLineCount 1)
     * @param minPointCount 2)
     */
    randomGeoJsonLineCollection(maxLineCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minLineCount?: number, minPointCount?: number): GeoJsonGeomertry;
    /**
     * geojson
     * @return {GeoPoint}
     * @param xRatio x  0.6
     * @param yRatio y  0.6
     * @param maxPolygonCount 
     * @param maxPointCount 
     * @param propertiesCb 
     * @param minPolygonCount (1)
     * @param minPointCount (3)
     */
    randomGeoJsonPolygonCollection(maxPolygonCount: number, maxPointCount: number, xRatio?: number, yRatio?: number, propertiesCb?: (index: number) => Object, minPolygonCount?: number, minPointCount?: number): GeoJsonGeomertry;
    /**
     * 
     *
     * @returns {Array} The coordinates represented as a array of the format `[minx, miny, maxx, maxy]'`.
     *
     */
    toArray(): number[];
    /**
     * 
     *
     * @returns {Array} The coordinates represented as a array of the format `[[minx,maxy], [maxx,maxy], [maxx,miny], [minx,miny]]'`.
     *
     */
    toPointArray(): Array<[number, number]>;
    /**
     * .
     *
     * @returns {string} The coordinates represented as a string of the format `minx, miny, maxx, maxy'`.
     *
     */
    toString(fixed?: number): string;
    /**
     *  
     *
     */
    clone(): GeoBounds;
    /**
     * 
     * @param isLatlng 
     * @param isMinValue 
     * @return{GeoBounds}
     */
    square(isLatlng?: boolean, isMinValue?: boolean): GeoBounds;
    /**
     *  
     *
     */
    width(): number;
    /**
     *  
     *
     */
    height(): number;
    /**
     *  / GeoBounds
     * @param ratio 
     * @param origin  bounds 
     */
    scale(ratio: number, origin?: GeoPoint | null): GeoBounds;
    /**
     *  XY/ GeoBounds
     * @param ratioX X
     * @param ratioY Y
     * @param origin  bounds 
     */
    scaleXY(ratioX: number, ratioY: number, origin?: GeoPoint | null): GeoBounds;
    /**
     * 
     * @param dx
     * @param dy
     */
    translate(dx: number, dy: number): void;
    /**
     * 
     * @param vertices
     */
    update(vertices: GeoPoint[]): void;
    /**
     * 
     * @param bounds
     */
    updateByBounds(bounds: GeoBounds[] | GeoBounds): void;
    /**
     * 
     * @param b
     */
    intersect(b: GeoBounds): GeoBounds | null;
    /**
     * 
     * @param bound
     */
    union(bound: GeoBounds): GeoBounds;
    /**
     * 
     * @param bound
     */
    isIntersect(bound: GeoBounds): boolean;
    /**
     * 
     * @param bound
     */
    isContains(bound: GeoBounds): boolean;
    /**
     * 
     * @param point
     */
    contains(point: GeoPoint): boolean;
    /**
     * Returns the value in the interval that is nearest to `targetValue`.
     *
     * @ignore
     * @param interval        The interval to find the value within.
     * @param targetValue     The value to get nearest to.
     * @param includeInterior If false, the value will either be [[min]] or [[max]].
     *                        If true, the value may be any number between [[min]] and [[max]].
     */
    private closestInterval;
    /**
     * .
     * @param testPoint       .
     * @param includeInterior truefalse.
     */
    closestPoint(testPoint: GeoPoint, includeInterior?: boolean): GeoPoint;
}

/**
 * newGeoBounds
 * @param min
 * @param max
 */
export  function geoBounds(min?: GeoPoint, max?: GeoPoint): GeoBounds;

/**
 * GeoJSON
 *
 * All GeoJSON objects
 */
 type GeoJsonGeomertry = Feature | FeatureCollection | Geometry | GeometryCollection;

/**
 * GeoJSON Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 * The GeoJSON specification also allows [foreign members](https://tools.ietf.org/html/rfc7946#section-6.1)
 * Developers should use '&' type in TypeScript or extend the interface to add these foreign members.
 */
 interface GeoJSONObject {
    /**
     * Specifies the type of GeoJSON object.
     */
    type: string;
    /**
     * Bounding box of the coordinate range of the object's Geometries, Features, or Feature Collections.
     * https://tools.ietf.org/html/rfc7946#section-5
     */
    bbox?: BBox;
}

export  type GeoJSONSourceSpecification = {
    type: "geojson";
    data?: unknown;
    maxzoom?: number;
    attribution?: string;
    buffer?: number;
    filter?: unknown;
    tolerance?: number;
    cluster?: boolean;
    clusterRadius?: number;
    clusterMaxZoom?: number;
    clusterMinPoints?: number;
    clusterProperties?: unknown;
    lineMetrics?: boolean;
    generateId?: boolean;
    promoteId?: PromoteIdSpecificationEx;
};

/**
 * Geometry
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 */
 interface Geometry extends GeoJSONObject {
    coordinates: Position | Position[] | Position[][] | Position[][][];
}

/**
 * GeometryCollection
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.8
 *
 * A GeoJSON object with type 'GeometryCollection' is a Geometry object.
 * A GeometryCollection has a member with the name 'geometries'.
 * The value of 'geometries' is an array.  Each element of this array is a GeoJSON Geometry object.
 * It is possible for this array to be empty.
 */
 interface GeometryCollection extends GeometryObject {
    type: "GeometryCollection";
    geometries: Array<GeometryPoint | LineString | Polygon_2 | MultiPoint | MultiLineString | MultiPolygon>;
}

/**
 * Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3
 */
 interface GeometryObject extends GeoJSONObject {
    type: GeometryTypes;
}

/**
 * Point Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.2
 */
 interface GeometryPoint extends GeometryObject {
    type: "GeometryPoint";
    coordinates: Position;
}

/**
 * GeometryTypes
 *
 * https://tools.ietf.org/html/rfc7946#section-1.4
 * The valid values for the 'type' property of GeoJSON geometry objects.
 */
 type GeometryTypes = "GeometryPoint" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";

/**
 * `GeoPoint` .
 */
export  class GeoPoint {
    /**
     *  {@link GeoPoint} .
     *
     * Example:
     * ```typescript
     * const p1 = GeoPoint.convert(new GeoPoint(x, y, z));
     * const p2 = GeoPoint.convert([x, y]);
     * const p3 = GeoPoint.convert([x, y, z]);
     * const p4 = GeoPoint.convert(lng: -73.9749, lat: 40.7736});
     * const p5 = GeoPoint.convert(lon: -73.9749, lat: 40.7736});
     * ```
     *
     * @param input - Either [[GeoPointLike]], {@link GeoPointLike}
     * or {@link GeoPointLike} object literal.
     */
    static convert(input: GeoPointLike): GeoPoint;
    /**
     *  `GeoPoint`.
     *
     * Example:
     * ```typescript
     * const b = GeoPoint.fromString("1,2");
     * ```
     */
    static fromString(input: string): GeoPoint;
    /** X. */
    x: number;
    /** y. */
    y: number;
    /** z(. */
    z?: number;
    /**
     *  `GeoPoint` 
     *
     * @param x - x.
     * @param y - y.
     * @param z - z(.
     */
    constructor(x: number, y: number, z?: number);
    /**
     *  
     *
     */
    clone(): GeoPoint;
    private _add;
    /**
     * 
     *
     * @returns {Array<number>} The coordinates represeted as an array of x and y.
     * ```typescript
     * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
     * ll.toArray(); // = [-73.9749, 40.7736]
     * ```
     */
    toArray(): number[];
    /**
     * .
     * @param fixed
     * @returns {string} The coordinates represented as a string of the format `'x, y, z?'`.
     * ```typescript
     * var ll = new vjmap.GeoPoint(-73.9749, 40.7736);
     * ll.toString(); // = "GeoPoint(-73.9749, 40.7736)"
     * ```
     */
    toString(fixed?: number): string;
    /**
     * 
     * @param fixed
     * @return {GeoPoint}
     */
    round(fixed?: number): GeoPoint;
    roundStr(fixed?: number): string;
    /**
     * .
     *
     * @param p - .
     */
    add(p: GeoPoint): GeoPoint;
    private _sub;
    /**
     * .
     *
     * @param p - .
     */
    sub(p: GeoPoint): GeoPoint;
    lengthSq(): number;
    private _multByPoint;
    /**
     * .
     *
     * @param p - .
     */
    multByPoint(p: GeoPoint): GeoPoint;
    private _divByPoint;
    /**
     * .
     *
     * @param p - .
     */
    divByPoint(p: GeoPoint): GeoPoint;
    dot(p: GeoPoint): number;
    lerp(v: GeoPoint, alpha: number): this;
    private _mult;
    /**
     * .
     *
     * @param k - .
     */
    mult(k: number): GeoPoint;
    private _div;
    /**
     * .
     *
     * @param k - .
     */
    div(k: number): GeoPoint;
    private _rotate;
    /**
     * .
     *
     * @param angle - .
     */
    rotate(angle: number): GeoPoint;
    private _rotateAround;
    /**
     * .
     *
     * @param angle - .
     * @param p - .
     */
    roateAround(angle: number, p: GeoPoint): GeoPoint;
    private _matMult;
    /**
     * .
     *
     * @param m - .
     */
    matMult(m: number[]): GeoPoint;
    private _unit;
    /**
     * .
     *
     */
    unit(): GeoPoint;
    private _perp;
    /**
     *  [x,y] = [-y, x].
     *
     */
    perp(): GeoPoint;
    private _round;
    /**
     * .
     *
     */
    roundInt(): GeoPoint;
    /**
     * .
     *
     */
    mag(): number;
    /**
     * 
     * @param other 
     * @param dotErr 8
     * @return {boolean}
     */
    equals(other: GeoPoint, dotErr?: number): boolean;
    /**
     * z).
     *
     */
    equalsZ(other: GeoPoint): boolean;
    /**
     * .
     *
     */
    distanceTo(p: GeoPoint): number;
    /**
     * .
     *
     */
    distSqr(p: GeoPoint): number;
    /**
     * .
     *
     */
    angle(): number;
    /**
     * 
     *
     */
    angleTo(b: GeoPoint): number;
    /**
     * interiorAngle
     *
     */
    angleWith(b: GeoPoint): number;
    /**
     * interiorAngle
     *
     */
    angleWithSep(x: number, y: number): number;
    /**
     * .
     * @param basePt 
     * @param destPt 
     * @param scale 1.0
     * @param angle 0
     * @return {GeoPoint}
     *
     */
    transform(basePt: GeoPoint, destPt: GeoPoint, scale?: number, angle?: number): this;
}

/**
 * newGeoPoint
 * @param input
 * @return {GeoPoint}
 */
export  function geoPoint(input: GeoPointLike): GeoPoint;

export  type GeoPointLike = [number, number] | [number, number, number] | GeoPoint | {
    x: number;
    y: number;
    z?: number;
} | {
    lng: number;
    lat: number;
} | {
    lon: number;
    lat: number;
};

/**
 * `GeoProjection` .
 *
 * Example:
 * ```typescript
 * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
 * const prj = new GeoProjection(mapExtent);
 * const pt = [30, 30];
 * const latlng = prj.toLngLat(pt);
 * const pt_geo = prj.fromLngLat(latlng);
 * const mkt = prj.toMercator(pt);
 * const pt_mkt = prj.fromMercator(mkt);
 * ```
 */
export  class GeoProjection extends Projection {
    /** . */
    mapExtent: GeoBounds;
    private _ratio_x;
    private _ratio_y;
    /**
     *  `GeoBounds` 
     *
     * @extent extent - .
     */
    constructor(extent: GeoBounds);
    /**
     *  
     *
     * @extent extent - .
     */
    setExtent(extent: GeoBounds): void;
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    toMercator(input: GeoPointLike): [number, number];
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    fromMercator(input: GeoPointLike): [number, number];
    /**
     * 
     * @param input 
     * @return {[number, number]}
     */
    toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 
     * @param input 
     * @return {GeoPoint}
     */
    fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 
     * @return {GeoBounds}
     */
    getMapExtent(): GeoBounds;
    /**
     * 
     * @param dist
     */
    toMeter(dist: number): number;
    /**
     * 
     * @param meter
     */
    fromMeter(meter: number): number;
}

/**
 *
 * @param bezierCurve 
 * @param precision 
 * @param recursiveCount 
 */
export  function getBezierCurveLength(bezierCurve: BezierCurve, precision?: number, recursiveCount?: number): number;

/**
 *  geojson
 * @param center 
 * @param radius 
 * @param points 
 * @param startAngle 
 * @param endAngle 
 * @param includeCenterWhenArc 
 * @return {{geometry: {coordinates: [number[][]], type: string}, type: string, properties: {}}}
 */
export  function getCircleFeature(center: GeoPointLike, radius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): GeoJsonGeomertry;

/**
 *  
 * @param center 
 * @param radius 
 * @param points 
 * @param startAngle 
 * @param endAngle 
 * @param includeCenterWhenArc 
 */
export  function getCirclePolygonCoordinates(center: GeoPointLike, radius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): number[][];

export  function _getEdgeIntersection(a: GeoPoint, b: GeoPoint, code: number, bounds: GeoBounds): GeoPoint;

/**
 *  geojson
 * @param center 
 * @param majorAxisRadius: number,
 * @param minorAxisRadius: number,
 * @param points 
 * @param startAngle 
 * @param endAngle 
 * @param includeCenterWhenArc 
 * @return {{geometry: {coordinates: [number[][]], type: string}, type: string, properties: {}}}
 */
export  function getEllipseFeature(center: GeoPointLike, majorAxisRadius: number, minorAxisRadius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): GeoJsonGeomertry;

/**
 *  
 * @param center 
 * @param points 
 * @param startAngle 
 * @param endAngle 
 * @param includeCenterWhenArc /
 * @param majorAxisRadius 
 * @param minorAxisRadius 
 * @return {any[]}
 */
export  function getEllipsePolygonCoordinates(center: GeoPointLike, majorAxisRadius: number, minorAxisRadius: number, points?: number, startAngle?: number, endAngle?: number, includeCenterWhenArc?: boolean): number[][];

/**
 *  `GeoBounds`.
 *
 * Example:
 * ```typescript
 * const b = vjmap.getEnvelopBounds('POLYGON((3466315.697899 6704304.297588, 3466315.697899 7784496.211226, 4546475.901198 7784496.211226, 4546475.901198 6704304.297588, 3466315.697899 6704304.297588))', prj);
 * ```
 */
export  function getEnvelopBounds(envelop: string, prj: any): GeoBounds;

/**
 * epsg
 * @param coordinate xx[x,y][lng,lat]
 * @param crs   
 * @param is3DegreeBelt  
 * @returns
 */
 function getEpsgCode(coordinate: number | [number, number], crs?: EpsgCrsTypes, is3DegreeBelt?: boolean): {
    crs: string;
    is3DegreeBelt: boolean;
    epsg: string;
    proj: string | undefined;
}[];

/**
 * proj4
 * @param crs 
 * @param lon 54,8020008wgs843857
 * @returns {null | {epsg: string, proj: string}}
 */
 function getEpsgParam(crs: EpsgCrsTypes, lon?: number): {
    epsg: string;
    proj: string;
} | null;

/**
 * geojson
 * @param data 
 * @return {GeoBounds} 
 */
export  function getGeoBounds<T extends GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]>(data: T | string): GeoBounds;

/**
 * Get first defined value.
 *
 * Specialized "replacement" for `a || b || c` used frequently to get value from various sources
 * (defaults, configs  constants).
 * In contrast to `||`, this function provides proper typing for usual use cases (constant as last
 * argument) and correct treatment of `null` and `undefined`.
 *
 * If last parameter is "defined" then return type is `T`, otherwise return type is `T | undefined`.
 *
 * Usage example:
 *
 *     interface Config {
 *         x?: number;
 *     }
 *     const someConfig: Config = {};
 *     const val: number | undefined = undefined;
 *     const DEFAULT = 5;
 *     const x = getOptionValue(val, someConfig.x, DEFAULT);
 *         // typeof x === 'number' because DEFAULT is defined
 *     const y = getOptionValue(val, someConfig.x);
 *         // typeof y === 'number | undefined' because someConfig.x is possibly undefined
 */
export  function getOptionValue<T>(a: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T): T;

export  function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T | undefined, d: T): T;

export  function getOptionValue<T>(...values: Array<T | undefined>): T | undefined;

/**
 * id()
 * @param expireTime 30
 * @param isVisible ListMaps
 * @return
 */
export  function getTempMapId(expireTime?: number, isVisible?: boolean): string;

/**
 * 
 *
 * @example
 * var graph = Graph()
 * .addEdge("s", "t", 10)
 * .addEdge("s", "y", 5)
 * .addEdge("s", "y", 4)
 * .addEdge("t", "y", 2)
 * .addEdge("y", "t", 3)
 * .addEdge("t", "x", 1)
 * .addEdge("y", "x", 9)
 * .addEdge("y", "z", 2)
 * .addEdge("x", "z", 4)
 * .addEdge("z", "x", 6);
 * var res = graph.shortestPath("s", "z")
 */
export  function Graph(serialized?: Serialized): {
    addNode: (node: NodeId) => any;
    removeNode: (node: NodeId) => any;
    nodes: () => NodeId[];
    adjacent: (node: NodeId) => NodeId[];
    addEdge: (u: NodeId, v: NodeId, weight?: number | undefined) => any;
    removeEdge: (u: NodeId, v: NodeId) => any;
    hasEdge: (u: NodeId, v: NodeId) => boolean;
    setEdgeWeight: (u: NodeId, v: NodeId, weight: EdgeWeight) => any;
    getEdgeWeight: (u: NodeId, v: NodeId) => EdgeWeight;
    indegree: (node: NodeId) => number;
    outdegree: (node: NodeId) => number;
    depthFirstSearch: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean, errorOnCycle?: boolean) => string[];
    hasCycle: () => boolean;
    lowestCommonAncestors: (node1: NodeId, node2: NodeId) => string[];
    topologicalSort: (sourceNodes?: string[] | undefined, includeSourceNodes?: boolean) => string[];
    shortestPath: (source: NodeId, destination: NodeId) => string[] & {
        weight?: number | undefined;
    };
    serialize: () => Serialized;
    deserialize: (serialized: Serialized) => any;
};

/**
 * .
 */
export  class HaloRingMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _createMakerElement;
}

/**
 * .
 *
 **/
export  class Heatmap extends OverlayLayerBase {
    options: HeatmapOptions;
    constructor(options: HeatmapOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setHeatmapRadius(value: DataDrivenPropertyValueSpecification<number>): this;
    getHeatmapRadius(): DataDrivenPropertyValueSpecification<number>;
    setHeatmapWeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getHeatmapWeight(): DataDrivenPropertyValueSpecification<number>;
    setHeatmapIntensity(value: PropertyValueSpecificationEx<number>): this;
    getHeatmapIntensity(): PropertyValueSpecificationEx<number>;
    setHeatmapColor(value: ExpressionSpecificationEx): this;
    getHeatmapColor(): ExpressionSpecificationEx;
    setHeatmapOpacity(value: PropertyValueSpecificationEx<number>): this;
    getHeatmapOpacity(): PropertyValueSpecificationEx<number>;
}

export  type HeatmapLayerSpecification = {
    id: string;
    type: "heatmap";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "heatmap-radius"?: DataDrivenPropertyValueSpecification<number>;
        "heatmap-weight"?: DataDrivenPropertyValueSpecification<number>;
        "heatmap-intensity"?: PropertyValueSpecificationEx<number>;
        "heatmap-color"?: ExpressionSpecificationEx;
        "heatmap-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  type HeatmapLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    heatmapRadius?: DataDrivenPropertyValueSpecification<number>;
    heatmapWeight?: DataDrivenPropertyValueSpecification<number>;
    heatmapIntensity?: PropertyValueSpecificationEx<number>;
    heatmapColor?: ExpressionSpecificationEx;
    heatmapOpacity?: PropertyValueSpecificationEx<number>;
};

export  interface HeatmapOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    heatmapRadius?: DataDrivenPropertyValueSpecification<number>;
    heatmapWeight?: DataDrivenPropertyValueSpecification<number>;
    heatmapIntensity?: PropertyValueSpecificationEx<number>;
    heatmapColor?: ExpressionSpecificationEx;
    heatmapOpacity?: PropertyValueSpecificationEx<number>;
}

/**
 * ()
 * @param strHex 
 * @param isPadding 0true
 * @param reverse true
 */
export  function hexToBinStr(strHex: string, isPadding?: boolean, reverse?: boolean): string;

export  type HillshadeLayerSpecification = {
    id: string;
    type: "hillshade";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "hillshade-illumination-direction"?: PropertyValueSpecificationEx<number>;
        "hillshade-illumination-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "hillshade-exaggeration"?: PropertyValueSpecificationEx<number>;
        "hillshade-shadow-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "hillshade-highlight-color"?: PropertyValueSpecificationEx<ColorSpecification>;
        "hillshade-accent-color"?: PropertyValueSpecificationEx<ColorSpecification>;
    };
};

export  type HillshadeLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    hillshadeIlluminationDirection?: PropertyValueSpecificationEx<number>;
    hillshadeIlluminationAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    hillshadeExaggeration?: PropertyValueSpecificationEx<number>;
    hillshadeShadowColor?: PropertyValueSpecificationEx<ColorSpecification>;
    hillshadeHighlightColor?: PropertyValueSpecificationEx<ColorSpecification>;
    hillshadeAccentColor?: PropertyValueSpecificationEx<ColorSpecification>;
};

/**
 * html
 * @param color html
 * @return {number}
 */
export  function htmlColorToEntColor(color: string): number;

export  const httpHelper: {
    configure: (opts: Partial<Config>) => void;
    event: {
        READY_STATE_CHANGE: string;
        LOAD_START: string;
        PROGRESS: string;
        ABORT: string;
        ERROR: string;
        LOAD: string;
        TIMEOUT: string;
        LOAD_END: string;
    };
    methods: Methods;
    rqeust: (args: Partial<Config>) => Promise<any>;
    get: (url: string, params?: Record<string, any> | undefined, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    put: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    post: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    patch: (url: string, data: any, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    del: (url: string, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
    options: (url: string, args?: Partial<Config<unknown>> | undefined) => Promise<any>;
};

export  interface IAnimateFillLayerOptions extends Omit<PolygonOptions, "data"> {
    /** . */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 1. */
    speed?: number;
    /** true. */
    startAutoAnimation?: boolean;
    /** . */
    layerBefore?: string;
}

export  interface IAnimateLineLayerOptions extends Omit<PolylineOptions, "data"> {
    /** . */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 1. */
    speed?: number;
    /** true. */
    startAutoAnimation?: boolean;
    /** . */
    layerBefore?: string;
}

export  interface IAnimateSymbolLayerOptions extends Omit<SymbolOptions, "data"> {
    /** . */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 1. */
    speed?: number;
    /** true. */
    startAutoAnimation?: boolean;
    /** . */
    layerBefore?: string;
}

export  interface IAnimateVectorLayerOptions {
    /** . */
    animateImages?: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>;
    /** 1. */
    speed?: number;
    /** true. */
    startAutoAnimation?: boolean;
}

export  interface IAnimateVectorLayerResult {
    /** . */
    startAnimation: () => void;
    /** . */
    stopAnimation: () => void;
    /** . */
    remove: () => void;
    /** . */
    setSpeed: (speed: number) => void;
    /** . */
    updateImages: (images: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>) => void;
}

/**
 * 
 */
export  interface IComposeNewMap {
    /** ID. */
    mapid: string;
    /** (). */
    version?: string;
    /** [x1,y1,x2,y2]  */
    clipbounds?: [number, number, number, number];
    /** falsetrue */
    selByCrossing?: boolean;
    /** (x,y,)*/
    fourParameter?: [number, number, number, number];
    /** false*/
    isInverseFourParamter?: boolean;
    /**  */
    layers?: string[];
    /** null */
    layerPrefix?: string;
    /**  */
    layerSuffix?: string;
    /**  */
    savefilename?: string;
    /** dwg */
    purge?: boolean;
    /**  true */
    isRenameBlockNameIfExist?: boolean;
    /**  false () */
    isZoomExtents?: boolean;
    /** CAD*CAD */
    cadVersion?: string | "*" | "cad2000" | "cad2004" | "cad2007" | "cad2010" | "cad2013" | "cad2018";
}

/**
 * 
 */
export  interface IConditionQueryFeatures extends IQueryBaseFeatures {
    /** . */
    condition: string;
    /** . */
    bounds?: [number, number, number, number] | [number, number][];
    /**  bounds false */
    isGetIntersections?: boolean;
    /** . */
    beginpos?: number;
    /** ,realgeomfalse1.1geojsonrealgeomtruegeojson */
    includegeom?: boolean;
    /** geojson. includegeomincludegeom*/
    realgeom?: boolean;
    /** , true,falsefalse. (bounds)*/
    isContains?: boolean;
}

export  interface ICreateAnimateImagesOptions {
    /** (2n2,4,8, 16, 32....).64 */
    canvasWidth?: number;
    /** (2n2,4,8, 16, 32....).32 */
    canvasHeight?: number;
    /** (). */
    draw?: (context: CanvasRenderingContext2D, width: number, height: number, opts: ICreateAnimateImagesOptions) => void;
    /** (drawdrawFramedraw). */
    drawFrame?: (context: CanvasRenderingContext2D, width: number, height: number, frameCount: number, curFrameIndex: number, opts: ICreateAnimateImagesOptions) => void;
    /** .2 */
    frameCount?: number;
    /** . */
    directionReverse?: boolean;
    /** y. */
    yAxis?: boolean;
    /** . */
    fromImage?: HTMLImageElement;
    /** . */
    spriteWidth?: number;
    /** . */
    spriteHeight?: number;
    /** 0. */
    from?: number;
    /** .. */
    to?: number;
    /** . */
    [key: string]: any;
}

export  interface ICreateAnimateLayerResult {
    /** ID. */
    sourceId: string;
    /** ID. */
    layerId: string;
    /** . */
    startAnimation: () => void;
    /** . */
    stopAnimation: () => void;
    /** . */
    remove: () => void;
    /** . */
    setSpeed: (speed: number) => void;
    /** . */
    updateData: (input: LineGeoJsonInput | LineGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike[] | any) => void;
    /** . */
    updateImages: (images: Array<HTMLImageElement | string | ArrayBufferView | {
        width: number;
        height: number;
        data: Uint8Array | Uint8ClampedArray;
    } | ImageData | ImageBitmap>) => void;
    /** . */
    createAnimateImages: (options: ICreateAnimateImagesOptions) => Array<ImageData>;
}

export  interface ICreateAntPathAnimateLineLayerOptions extends IAnimateLineLayerOptions, ICreateAnimateImagesOptions {
    /** 1. */
    fillColor1?: string | CanvasGradient | CanvasPattern;
    /** 1. */
    fillColor2?: string | CanvasGradient | CanvasPattern;
}

export  interface ICreateArrowAnimateLineLayerOptions extends IAnimateLineLayerOptions, ICreateAnimateImagesOptions {
    /** . */
    arrowFillColor?: string | CanvasGradient | CanvasPattern;
    /** . */
    arrowStrokeColor?: string | CanvasGradient | CanvasPattern;
    /** . */
    arrowStrokeWidth?: number;
    /** (). */
    arrowWidth?: number;
}

/**
 * 
 */
export  interface ICreateEntitiesGeomData {
    /** . */
    filedoc: string;
    /** . */
    mapBounds?: [number, number, number, number];
    /** 1, */
    renderAccuracy?: number;
    /** ( true) */
    excludeAttribute?: boolean;
    /** zip( true) */
    useZip?: boolean;
}

export  interface ICreateFillAnimateLayerResult extends ICreateAnimateLayerResult {
    polygon: Polygon;
}

export  interface ICreateLineAnimateLayerResult extends ICreateAnimateLayerResult {
    polyline: Polyline;
}

export  interface ICreateSymbolAnimateLayerResult extends ICreateAnimateLayerResult {
    symbol: Symbol_2;
}

/**
 * Id
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * If a Feature has a commonly used identifier, that identifier SHOULD be included as a member of
 * the Feature object with the name 'id', and the value of this member is either a JSON string or number.
 */
 type Id = string | number;

/**
 * 2d
 */
export  interface IDb2dPolyline extends IDbCurve {
    /** . */
    closed?: boolean;
    /** . */
    elevation?: number;
    /** 2d*/
    polyType?: Poly2dType;
    /** . */
    points?: Array<[number, number, number?]>;
}

/**
 * []
 */
export  interface IDb2LineAngularDimension extends IDbDimension {
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /** 1. */
    xLine1Start?: Array<[number, number, number?]>;
    /** 1. */
    xLine1End?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Start?: Array<[number, number, number?]>;
    /** 2. */
    xLine2End?: Array<[number, number, number?]>;
}

/**
 * 3d
 */
export  interface IDb3dPolyline extends IDbCurve {
    /** . */
    closed?: boolean;
    /** 3d*/
    polyType?: Poly3dType;
    /** . */
    points?: Array<[number, number, number?]>;
}

/**
 * []
 */
export  interface IDb3PointAngularDimension extends IDbDimension {
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /** . */
    centerPoint?: Array<[number, number, number?]>;
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDbAlignedDimension extends IDbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** dimensionWCS. */
    dimLinePoint?: Array<[number, number, number?]>;
    /** . */
    jogSymbolHeight?: number;
}

/**
 * 
 */
export  interface IDbArc extends IDbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    radius?: number;
    /** . */
    startAngle?: number;
    /** . */
    endAngle?: number;
    /** . */
    thickness?: number;
    /** . */
    normal?: [number, number, number?];
}

/**
 * 
 */
export  interface IDbArcDimension extends IDbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** . */
    centerPoint?: Array<[number, number, number?]>;
    /** . */
    arcPoint?: Array<[number, number, number?]>;
    /**  0 ;   1 ;   2  . */
    arcSymbolType?: number;
}

/**
 * 
 */
export  interface IDbBlock {
    /** . */
    name?: string;
    /** . */
    scaling?: number;
    /**  . */
    insertUnits?: number;
    /**  . */
    origin?: Array<[number, number, number?]>;
    /** . */
    comments?: string;
    /** . */
    explodable?: boolean;
    /** . */
    entitys?: IDbEntity[];
}

/**
 * 
 */
export  interface IDbBlockReference extends IDbEntity {
    /** . */
    blockname?: string;
    /**  mapid/version, exam/v1. */
    ref?: string;
    /** . */
    position?: [number, number, number?];
    /** . */
    normal?: [number, number, number?];
    /** . */
    rotation?: number;
    /** . */
    scaleFactors?: number;
}

/**
 * 
 */
export  interface IDbCircle extends IDbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    radius?: number;
    /** . */
    thickness?: number;
    /** . */
    normal?: [number, number, number?];
}

/**
 * 
 */
export  interface IDbCurve extends IDbEntity {
}

/**
 * 
 */
export  interface IDbDiametricDimension extends IDbDimension {
    /** 1. */
    chordPoint?: Array<[number, number, number?]>;
    /** 2. */
    farChordPoint?: Array<[number, number, number?]>;
    /** . */
    leaderLength?: number;
}

/**
 * 
 */
export  interface IDbDimension extends IDbEntity {
    /** . */
    dimStyle?: string;
    /** . */
    textPosition?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDbDimStyle {
    /** . */
    name?: string;
    /** . */
    textStyle?: string;
    /**  . */
    dimsah?: boolean;
    /** 1 . ,_DOT ,_DOTSMALL ,_DOTBLANK ,_ORIGIN ,_ORIGIN2  2,_OPEN ,_OPEN90 ,_OPEN30 30 ,_CLOSED ,_SMALL ,_NONE ,_OBLIQUE ,_BOXFILLED ,_BOXBLANK ,_CLOSEDBLANK ,_DATUMFILLED ,_DATUMBLANK ,_INTEGRAL ,_ARCHTICK */
    dimblk1?: string;
    /** 2 .dimblk1 */
    dimblk2?: string;
}

/**
 * DB
 */
export  interface IDbDocument {
    /**   mapid/version, exam/v1 . */
    from?: string;
    /** . */
    entitys?: IDbEntity[];
    /** . */
    layers?: IDbLayer[];
    /** . */
    textStyles?: IDbTextStyle[];
    /** . */
    dimStyles?: IDbDimStyle[];
    /** . */
    linetypes?: IDbLinetype[];
    /** . */
    blocks?: IDbBlock[];
}

/**
 * 
 */
export  interface IDbEllipse extends IDbCurve {
    /** . */
    center?: [number, number, number?];
    /** . */
    minorAxis?: [number, number, number?];
    /** . */
    startAngle?: number;
    /** . */
    endAngle?: number;
    /** . */
    radiusRatio?: number;
}

/**
 * 
 */
export  interface IDbEntity {
    /** . */
    typename?: string;
    /** . */
    color?: number;
    /** . */
    colorIndex?: number;
    /** . */
    layer?: string;
    /** . */
    linetype?: string;
    /** . */
    linetypeScale?: number;
    /** . */
    lineWidth?: number;
    /** . [0-255][0,255]*/
    alpha?: number;
    /** . */
    visibility?: boolean;
    /** . */
    matrix?: IDbMatrixOp[];
    /** . */
    xdata?: string;
    /** . */
    objectid?: string;
    /** . */
    delete?: boolean;
}

/**
 * 
 */
export  interface IDbHatch extends IDbEntity {
    /** . */
    elevation?: number;
    /** ,  SOLID */
    pattern?: string;
    /** . */
    points?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDbLayer {
    /** . */
    name?: string;
    /** . */
    color?: number;
    /**  CONTINUOUS . */
    linetype?: string;
}

/**
 * 
 */
export  interface IDbLine extends IDbEntity {
    /** . */
    start?: [number, number, number?];
    /** . */
    end?: [number, number, number?];
    /** . */
    thickness?: number;
}

/**
 * 
 */
export  interface IDbLinetype {
    /** . */
    name?: string;
    /** . */
    comments?: string;
    /**  . */
    style?: IDbLinetypeStyle[];
}

/**
 * 
 */
export  interface IDbLinetypeStyle {
    /** . */
    method?: IDbLinetypeStyleMethod;
    /** . */
    parameter?: string;
}

export  enum IDbLinetypeStyleMethod {
    /** [int count] . */
    numDashes = "numDashes",
    /** [double dPatLen] . */
    patternLength = "patternLength",
    /** [int dashIndex, double dashLength ]. */
    dashLengthAt = "dashLengthAt",
    /** [int dashIndex, string idTextStyle] . */
    shapeStyleAt = "shapeStyleAt",
    /** [int dashIndex, [int, int] shapeOffset] . */
    shapeOffsetAt = "shapeOffsetAt",
    /** [int dashIndex, string textString] . */
    textAt = "textAt",
    /** [ int dashIndex, double shapeScale] . */
    shapeScaleAt = "shapeScaleAt",
    /** [int dashIndex, int shapeNumber] . */
    shapeNumberAt = "shapeNumberAt",
    /** [int dashIndex, double shapeRotation] . */
    shapeRotationAt = "shapeRotationAt",
    /** [ bool bScaleToFit] . */
    isScaledToFit = "isScaledToFit"
}

/**
 * 
 */
export  interface IDbMatrixOp {
    /** . */
    op?: IDbMatrixOpName;
    /** . */
    vector?: [number, number, number?];
    /**  . */
    scale?: number;
    /**  . */
    angle?: number;
    /** . */
    origin?: [number, number, number?];
}

export  enum IDbMatrixOpName {
    /**  . */
    translation = "translation",
    /**  . */
    scale = "scale",
    /** rotate. */
    rotate = "rotate"
}

/**
 * 
 */
export  interface IDbMText extends IDbEntity {
    /** . */
    width?: number;
    /** . */
    height?: number;
    /** . */
    rotation?: number;
    /** . */
    textHeight?: number;
    /** . */
    contents?: string;
    /** . */
    location?: [number, number, number?];
    /** . */
    attachment?: MTextAttachmentPoint;
    /** . */
    textStyle?: string;
}

/**
 * 
 */
export  interface IDbOrdinateDimension extends IDbDimension {
    /** . */
    origin?: Array<[number, number, number?]>;
    /** . */
    definingPoint?: Array<[number, number, number?]>;
    /** . */
    leaderEndPoint?: Array<[number, number, number?]>;
    /** X. */
    useXAxis?: boolean;
}

/**
 * 
 */
/**
 * 
 */
export  type IDbPoint = [number, number, number?];

/**
 * 
 */
export  interface IDbPolyline extends IDbCurve {
    /** . */
    closed?: boolean;
    /** . */
    elevation?: number;
    /** . */
    points?: Array<[number, number, number?]>;
    /** . */
    bulge?: number[];
    /** . */
    startWidth?: number[];
    /** . */
    endWidth?: number[];
}

/**
 * 
 */
export  interface IDbRadialDimension extends IDbDimension {
    /** . */
    center?: Array<[number, number, number?]>;
    /** . */
    chordPoint?: Array<[number, number, number?]>;
    /** . */
    leaderLength?: number;
}

/**
 * 
 */
export  interface IDbRadialDimensionLarge extends IDbDimension {
    /** . */
    center?: Array<[number, number, number?]>;
    /** . */
    chordPoint?: Array<[number, number, number?]>;
    /** DimensionWCS. */
    overrideCenter?: Array<[number, number, number?]>;
    /** Dimension. */
    jogPoint?: Array<[number, number, number?]>;
    /** Dimension. */
    jogAngle?: number;
}

/**
 * 
 */
export  interface IDbRasterImage extends IDbEntity {
    /**  [0.0 .. 100.0] */
    brightness?: number;
    /** url. */
    sourceHttpUrl?: string;
    /** . */
    pixelWidth?: number;
    /** . */
    pixelHeight?: number;
    /** . */
    units?: RasterImageUnits;
    /** x. */
    xPelsPerUnit?: number;
    /** y. */
    yPelsPerUnit?: number;
    /** . */
    width?: number;
    /** . */
    height?: number;
    /** . */
    position?: [number, number, number?];
    /** . */
    imageDisplayOptShow?: boolean;
    /** . */
    imageDisplayOptClip?: boolean;
    /** . */
    imageDisplayOptShowUnAligned?: boolean;
    /** . */
    imageDisplayOptTransparent?: boolean;
}

/**
 * 
 */
export  interface IDbRotatedDimension extends IDbDimension {
    /** 1. */
    xLine1Point?: Array<[number, number, number?]>;
    /** 2. */
    xLine2Point?: Array<[number, number, number?]>;
    /** dimensionWCS. */
    dimLinePoint?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDbShape extends IDbEntity {
    /** . */
    rotation?: number;
    /** . */
    position?: [number, number, number?];
    /** . */
    size?: number;
    /** . */
    normal?: [number, number, number?];
    /** . */
    name?: string;
}

/**
 * 
 */
export  interface IDbSpline extends IDbCurve {
    /** the curve fitting tolerance for this Spline entity. */
    fitTol?: number;
    /** Increased the degree of this spline to the specified value. */
    degree?: number;
    /** . */
    fitPoints?: Array<[number, number, number?]>;
    /** . */
    controlPoints?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDbTable extends IDbBlockReference {
    /** . */
    tableStyleName?: string;
    /** . */
    numColumns?: number;
    /** . */
    numRows?: number;
    /** . */
    columnWidth?: number;
    /** . */
    rowHeight?: number;
    /** . */
    width?: number;
    /** . */
    height?: number;
    /** . */
    disableTitle?: boolean;
    /** . */
    directionBottomToTop?: boolean;
    /** (). */
    textHeight?: number;
    /** .(kHorzTop(1), kHorzInside(2), kHorzBottom(4), kVertLeft(8), kVertInside(16), kVertRight(32);   kTitleRow(1), kHeaderRow(2), kDataRow(4) */
    gridVisibility?: [boolean, number, number];
    /** (). */
    backgroundColor?: number;
    /** (). */
    contentColor?: number;
    /** (). */
    gridColor?: number;
    /** (). */
    alignment?: TableCellAlignment;
    /** . */
    horzCellMargin?: number;
    /** . */
    vertCellMargin?: number;
    /**  [[minRow, maxRow,minColumn, maxColumn], ...]  */
    mergeCells?: Array<[number, number, number, number]>;
    /** . */
    data?: Array<Array<string | {
        /** . */
        text: string;
        /** . */
        alignment: TableCellAlignment;
        /** . */
        backgroundColor: number;
        /** . */
        gridColor: number;
        /** . */
        contentColor: number;
        /** . */
        textHeight: number;
        /** . */
        gridVisibility: boolean;
    }>>;
}

/**
 * 
 */
export  interface IDbText extends IDbEntity {
    /** . */
    height?: number;
    /** . */
    rotation?: number;
    /**  contents. */
    text?: string;
    /**  text. */
    contents?: string;
    /** . */
    widthFactor?: number;
    /** . */
    position?: [number, number, number?];
    /** . */
    textStyle?: string;
    /** . */
    horizontalMode?: DbTextHorzMode;
    /** . */
    verticalMode?: DbTextVertMode;
}

/**
 * 
 */
export  interface IDbTextStyle {
    /** . */
    name?: string;
    /** . */
    isShapeFile?: boolean;
    /**  . */
    textSize?: number;
    /** x . */
    xScale?: number;
    /**  . */
    priorSize?: number;
    /** 2*PI 0.0. */
    obliquingAngle?: number;
    /**  . */
    fileName?: string;
    /**  . */
    typeFace?: string;
    /**  . */
    bold?: boolean;
    /**  . */
    italic?: boolean;
    /** 0 . */
    charset?: number;
    /** 34 . */
    pitchAndFamily?: number;
}

/**
 * 
 */
export  interface IDbWipeout extends IDbRasterImage {
    /** . */
    points?: Array<[number, number, number?]>;
}

/**
 * 
 */
export  interface IDeleteCache {
    /** ID(mapid). */
    mapid?: string;
    /** (, "*"). */
    version?: string;
    /** . */
    key?: string;
}

/**
 * 
 */
export  interface IDeleteStyle {
    /** ID(mapid). */
    mapid?: string;
    /** (, "*"). */
    version?: string;
    /** ."*"  "a*","m*"; "s*"*/
    styleid: string;
    /** , false ; true . */
    onlycleardata: boolean;
}

export  interface IDraw {
    /** . */
    Tool: new (options?: IDrawOptions) => IDrawTool;
    /** . */
    defaultOptions: () => any;
    /** . */
    modes: Record<string, any>;
    /** . */
    actionDraw: (map: any, modename: string, options?: Record<string, any>) => any;
    /** . */
    actionDrawCircle: (map: any, options?: Record<string, any>) => any;
    /** . */
    actionDrawLineSting: (map: any, options?: Record<string, any>) => any;
    /** . */
    actionDrawPoint: (map: any, options?: Record<string, any>) => any;
    /** . */
    actionDrawPolygon: (map: any, options?: Record<string, any>) => any;
    /** . */
    actionDrawRectangle: (map: any, options?: Record<string, any>) => any;
    /** . */
    actionDrawSlantRectangle: (map: any, options?: Record<string, any>) => any;
    /** . optionsselectSingletrue*/
    actionSelect: (map: any, draw: any, options?: Record<string, any>) => any;
}

export  interface IDrawOptions {
    addControls?: any[];
    controls?: Record<string, boolean>;
    guides?: boolean;
    modes?: Record<string, any>;
    snap?: boolean;
    midpoints?: boolean;
    api: {
        getSnapFeatures: any;
        [key: string]: any;
    };
    snapOptions: {
        snapGridPx?: number;
        snapPx?: number;
        snapToMidPoints?: boolean;
        snapVertexPriorityDistance?: number;
    };
    styles?: any[];
    userProperties?: boolean;
    [key: string]: any;
}

export  interface IDrawTool {
    /**  GeoJSON FeatureFeatureCollection  Geometry  Draw id  id **/
    add: (geojson: any) => Array<string>;
    /** */
    changeMode: (mode: string, modeOptions?: any) => IDrawTool;
    /** combineFeatures */
    combineFeatures: () => IDrawTool;
    /**  ID */
    delete: (featureIds: string[] | string) => IDrawTool;
    /**  */
    deleteAll: () => IDrawTool;
    /**  */
    doAction: (actionName: string) => any;
    /**  */
    forceRefresh: () => any;
    /**  Draw  id  GeoJSON undefined id  */
    get: (id: string) => any;
    /**  FeatureCollection */
    getAll: () => FeatureCollection;
    /**  ID */
    getFeatureIdsAt: (point: {
        x: number;
        y: number;
    }) => Array<string>;
    /**  Draw  */
    getMode: () => string;
    /**  FeatureCollection */
    getSelected: () => FeatureCollection;
    /**  ID  */
    getSelectedIds: () => Array<string>;
    /**  FeatureCollection  */
    getSelectedPoints: () => FeatureCollection;
    /**  */
    modes: Record<string, any>;
    /**  */
    onAdd: (map: any) => any;
    /**  */
    onRemove: () => any;
    /**  */
    options: Record<string, any>;
    redo: () => any;
    /**  Draw  FeatureCollection */
    set: (featureCollection: FeatureCollection) => Array<string>;
    /**  id  */
    setFeatureProperty: (featureId: string, property: string, value: any) => IDrawTool;
    /** trash */
    trash: () => IDrawTool;
    uncombineFeatures: () => IDrawTool;
    undo: () => any;
}

/**
 * dwg
 */
export  interface IExportLayout {
    /** ID. */
    mapid: string;
    /** (). */
    version?: string;
    /** layoutIndexlayoutNamelayoutIndexdwg. */
    layoutIndex?: string;
    /** . layoutIndexlayoutNamelayoutIndexdwg. */
    layoutName?: string;
}

/**
 * 
 */
export  interface IExprQueryFeatures extends IQueryBaseFeatures {
    /** . */
    expr: string;
    /** . */
    beginpos?: number;
}

export  type ImageSourceSpecification = {
    type: "image";
    url: string;
    coordinates: [[number, number], [number, number], [number, number], [number, number]];
};

/**
 * 
 */
export  interface IMapDiff {
    /** ID. */
    mapid1: string;
    /** (). */
    version1?: string;
    /** . */
    layer1?: string;
    /** ID. */
    mapid2: string;
    /** (). */
    version2?: string;
    /** . */
    layer2?: string;
    /** . */
    noCompareNew?: boolean;
    /** . */
    noCompareDelete?: boolean;
    /** .  4096 */
    size?: number;
    /** .  10 */
    cellsize?: number;
    /** .   0 */
    diffMinPixel?: number;
    /** .   25 */
    diffMinAlpha?: number;
    /** .  6 */
    diffMinColor?: number;
}

/**
 * 
 */
export  interface IMapLayer {
    /** . */
    name: string;
    /** . */
    color: string;
    /** . */
    index: number;
    /** . */
    isFrozen: boolean;
    /** . */
    isLocked: boolean;
    /** . */
    isOff: boolean;
    /** . */
    lineWeight: number;
    /** . */
    linetype: number;
}

/**
 * 
 */
export  interface IMapStyleParam {
    /** . */
    name?: string;
    /** [0,1,3]. */
    layeron?: string | number[];
    /** [2,4]. layeronlayeroff*/
    layeroff?: string | number[];
    /** [x1,y1,x2,y2]. */
    clipbounds?: [number, number, number, number] | number;
    /** . */
    backcolor?: number;
    /** [11110].123455 */
    lineweight?: string | number[];
    /** . */
    expression?: string;
}

/**
 * 
 */
export  interface IMatchObject {
    /** ID. */
    mapid: string;
    /** (). */
    version?: string;
    /** . */
    layer?: string;
    /** . */
    mapBounds?: string;
    /** objectid||. */
    objectIds?: string;
    /**  */
    objectBounds: string;
    /**  */
    layeron?: string;
    /** 10000 */
    size?: number;
    /** .  matchPattern */
    method?: "matchTemplate" | "matchPattern";
    /** .  200 */
    maxCount?: number;
    /**  (0 -1) 0.6 . */
    score?: number;
    /**  (64-2048).256 matchPattern*/
    minReduceArea?: number;
    /**  (false). */
    canOverlap?: boolean;
    /**  (0-0.8) 0.3. */
    maxOverlap?: number;
    /** (-180, 180)matchPattern. 180*/
    toleranceAngle?: number;
    /** ,false. matchPattern*/
    useToleranceRange?: boolean;
    /** 1. matchPattern*/
    tolerance1?: number;
    /** 1. matchPattern*/
    tolerance2?: number;
    /** 2. matchPattern*/
    tolerance3?: number;
    /** 2. matchPattern*/
    tolerance4?: number;
}

export  function inertia({ from, velocity, min, max, power, timeConstant, bounceStiffness, bounceDamping, restDelta, modifyTarget, driver, onUpdate, onComplete, onStop }: InertiaOptions): {
    stop: () => void;
};

export  interface InertiaOptions extends DecayOptions {
    bounceStiffness?: number;
    bounceDamping?: number;
    min?: number;
    max?: number;
    restSpeed?: number;
    restDelta?: number;
    driver?: Driver;
    onUpdate?: (v: number) => void;
    onComplete?: () => void;
    onStop?: () => void;
}

/**
 * Create a function that maps from a numerical input array to a generic output array.
 *
 * Accepts:
 *   - Numbers
 *   - Colors (hex, hsl, hsla, rgb, rgba)
 *   - Complex (combinations of one or more numbers or strings)
 *
 * ```jsx
 * const mixColor = interpolate([0, 1], ['#fff', '#000'])
 *
 * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
 * ```
 *
 * @public
 */
export  function interpolate<T>(input: number[], output: T[], { clamp: isClamp, ease, mixer }?: InterpolateOptions<T>): (v: number) => T;

/**
 * @param points ().
 * @param number  2.
 * @param offsetDist .
 * @param minGap numbernumber.
 * @param includeSrcPoint 
 * @param isLngLat 
 * @return {any[]}
 */
export  function interpolateLineRange(points: GeoPointLike[] | any, number: number, isLngLat?: boolean, offsetDist?: number, minGap?: number, includeSrcPoint?: boolean): any[];

 interface InterpolateOptions<T> {
    clamp?: boolean;
    ease?: MixEasing;
    mixer?: MixerFactory<T>;
}

/**
 * (0-1)
 * @param points
 * @param isLngLat
 * @param ratio
 * @return {any[]}
 */
export  function interpolatePointsByRatio(points: GeoPointLike[] | any, ratio: number, isLngLat?: boolean): any[];

/**
 * 
 */
export  interface IOpenMapBaseParam {
    /** ID. */
    mapid: string;
    /** (: GeomRender) . */
    mapopenway?: MapOpenWay;
    /** ID. IDfileid */
    fileid?: string;
    /** . */
    filedoc?: string;
    /** . */
    filename?: string;
    /** . */
    uploadname?: string;
    /** (). */
    secretKey?: string;
    /** keysecretKey. */
    accessKey?: string;
    /** . */
    cbInputPassword?: (param: {
        mapid: string;
        isPasswordError: boolean;
        tryPasswordCount: number;
        result: any;
    }) => Promise<string>;
    /** . */
    mapfrom?: string;
    /** . */
    mapdependencies?: string;
    /** (mapfrom.mapfrom */
    subfrom?: string;
    /** (mapdependencies.mapdependencies  */
    subdependencies?: string;
    /** 1, */
    renderAccuracy?: number;
    /** . */
    style?: IMapStyleParam;
    /** . */
    notUseDefaultTtfFont?: boolean;
    /** . */
    notUseDefaultShxFont?: boolean;
    /** . */
    notReplaceLineType?: boolean;
    /** . openMapfindFontsfontReplaceRule: {"tssdeng.shx_1": "_default_.ttc"}*/
    fontReplaceRule?: Record<string, string> | string;
    /** 16 **/
    mapInitViewErrMaxRatio?: number;
    /** x */
    imageLeft?: number;
    /** y */
    imageTop?: number;
    /**  ,   /  */
    imageResolution?: number;
    /**  5s  */
    openFinishTryInterval?: number;
    /**  120  */
    openFinishMaxTryCount?: number;
    /** fileDoc */
    cadVersion?: string;
    /** post (get)*/
    httpUsePost?: boolean;
    /** 3d ()*/
    open3dview?: boolean;
    /**  */
    extData?: Record<string, any>;
}

/**
 * 
 */
export  interface IOpenMapParam extends IOpenMapBaseParam {
    /** (: "" ). */
    version?: string;
    /**  */
    layer?: string;
    /**  (1)0 */
    layoutIndex?: number;
}

/**
 * 
 */
export  interface IOpenMapResponse {
    /** ID. */
    mapid?: string;
    /** (: "" ). */
    version?: string;
    /**  */
    layer?: string;
    /** (: GeomRender) . */
    mapopenway?: MapOpenWay;
    /** DbID. */
    dbid?: string;
    /** ID. */
    fileid?: string;
    /** . */
    filename?: string;
    /** (clipBoundsclipBounds). */
    bounds?: GeoBounds;
    /** (clipBounds,). */
    mapBounds?: GeoBounds;
    /** */
    dbBounds?: GeoBounds;
    /** cmdGetDrawBounds*/
    drawBounds?: GeoBounds;
    /** . */
    styles?: any;
    /** . */
    layers?: any;
    /** . cadimage */
    maptype?: string;
    /** . */
    status?: string;
    /** (). */
    darkMode?: boolean;
    /** . */
    type?: string;
    /** ucs. */
    ucsorg?: string;
    /** . */
    uploadname?: string;
    /** . */
    description?: string;
    /** . */
    lineWidthDisplay?: boolean;
    /** . */
    layouts?: string[];
    /** . */
    mapfrom?: string;
    /** . */
    mapdependencies?: string;
    /** (mapfrom.mapfrom */
    subfrom?: string;
    /** (mapdependencies.mapdependencies  */
    subdependencies?: string;
    /** 1, */
    renderAccuracy?: number;
    /** bounds * initViewScale = dbBounds */
    initViewScale?: number;
    /** . */
    view?: {
        /** . */
        center?: [number, number];
        /** . */
        zoom?: number;
        /** . */
        bearing?: number;
    };
    /**  */
    maxzoom?: number;
    /**  */
    imageWidth?: number;
    /**  */
    imageHeight?: number;
    /** x */
    imageLeft?: number;
    /** y */
    imageTop?: number;
    /**     /  */
    imageResolution?: number;
    /** 3d */
    isMap3d?: boolean;
    /**  */
    createTime?: string;
    /**  */
    geomRecordCount?: string;
}

/**
 * 
 */
export  interface IPointQueryFeatures extends IQueryBaseFeatures {
    /** X. */
    x: number;
    /** Y. */
    y: number;
    /** . */
    pixelsize?: number;
    /** . */
    condition?: string;
    /** . */
    maxGeomBytesSize?: number;
    /** zoom. */
    pixelToGeoLength?: number;
}

/**
 * 
 */
export  interface IQueryBaseFeatures {
    /** . */
    zoom?: number;
    /** ID(mapid). */
    mapid?: string;
    /** (). */
    version?: string;
    /** ). */
    layer?: string;
    /** . */
    limit?: number;
    /** ,,. "name,objectid" */
    fields?: string;
    /** . */
    geom?: boolean;
    /** GeoJSON10 map.pixelToGeoLength(1, 10) * vjmap.Projection.EQUATORIAL_SEMIPERIMETER * 2 / map.getGeoBounds(1.0).width() */
    simplifyTolerance?: boolean;
    /** cache(). */
    useCache?: boolean;
    /** cadcadtoMapCoordinatetrue. */
    toMapCoordinate?: boolean;
}

/**
 * 
 */
export  interface IRectQueryFeatures extends IQueryBaseFeatures {
    /** X1. (x1,y1,x2,y2 */
    x1?: number;
    /** Y1. */
    y1?: number;
    /** X2. */
    x2?: number;
    /** Y2. */
    y2?: number;
    /** . */
    condition?: string;
    /** . */
    maxGeomBytesSize?: number;
}

export  interface IRequest {
    get: (url: string, params?: Record<string, any>, args?: Partial<Config>) => Promise<any>;
    put: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    post: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    patch: (url: string, data: any, args?: Partial<Config>) => Promise<any>;
    del: (url: string, args?: Partial<Config>) => Promise<any>;
    options: (url: string, args?: Partial<Config>) => Promise<any>;
}

/**
 * 
 * @param points
 * @return {boolean}
 */
export  function isClosedPolygon(points: GeoPoint[]): boolean;

/**
 * 
 * @param a
 * @param b
 * @param c
 * @return {boolean}
 */
export  function isCounterClockwise(a: GeoPoint, b: GeoPoint, c: GeoPoint): boolean;

/**
 * A {@link GeoPointLike} object, an array of two numbers representing longitude and latitude,
 * or an object with `lng` and `lat` or `lon` and `lat` properties.
 *
 * Example:
 * ```typescript
 * const center = { lat: 53.3, lng: 13.4 };
 * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
 * ```
 */
export  function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike;

/**
 * 
 */
export  interface ISliceCacheZoom {
    /** ID(mapid). */
    mapid?: string;
    /** (). */
    version?: string;
    /** ) */
    layer?: string;
    /**  */
    ismvt: boolean;
}

/**
 * 
 */
export  interface ISliceLayer {
    /** ID(mapid). */
    mapid?: string;
    /** (). */
    version?: string;
    /** ). */
    layer: string | string[];
    /** , layer */
    zoom: number | number[];
    /** . layer */
    ismvt: boolean | boolean[];
    /** . */
    iscancel?: boolean;
    /** . */
    isAllCancel?: boolean;
    /** 10000. */
    batchNum?: number;
    /** 1ms. */
    idleBatchSleepMs?: number;
    /** 10000ms. */
    busyBatchSleepMs?: number;
}

export  const isPoint: (point: Object) => point is Point23D;

export  const isPoint3D: (point: Point23D) => point is Point3D;

/**
 * 
 * @param pos 
 * @param polygon 
 * @return {boolean}
 */
export  const isPointInPolygon: (pos: GeoPoint, polygon: GeoPoint[]) => boolean;

/**
 * 
 * @param value 
 * @param precision 1e-6
 */
export  function isZero(value: number, precision?: number): boolean;

/**
 * 
 */
export  interface ITileUrlParam {
    /** ID. */
    mapid?: string;
    /** . */
    version?: string;
    /** . */
    layer?: string;
    /** ID. */
    fileid?: string;
}

/**
 * 
 */
export  interface IUpdateMapParam extends IOpenMapBaseParam {
    /** (: false ). */
    deleteOldVersion?: boolean;
}

/**
 * 
 */
export  interface IUpdateStyle {
    /** ID(mapid). */
    mapid?: string;
    /** (). */
    version?: string;
    /** . */
    name?: string;
    /** [0,1,3]. */
    layeron?: string | number[];
    /** [2,4]. layeronlayeroff*/
    layeroff?: string | number[];
    /** [x1,y1,x2,y2]. */
    clipbounds?: [number, number, number, number] | number;
    /** . */
    backcolor?: number;
    /** [11110].123455 */
    lineweight?: string | number[];
    /** . */
    expression?: string;
}

/**
 * wmsurl
 */
export  interface IWmsTileUrl {
    /** ID(mapid) . */
    mapid?: string | string[];
    /** (). */
    version?: string | string[];
    /** ). */
    layers?: string | string[];
    /** {bbox-epsg-3857}. (cadwmscad,srs,crs,mapbounds).*/
    bbox?: string;
    /** ,(EPSG:3857). */
    srs?: string;
    /** cad. proj4*/
    crs?: string | string[];
    /** ,srs */
    mapbounds?: string;
    /** . */
    width?: number;
    /** . */
    height?: number;
    /** . */
    transparent?: boolean;
    /** rgb(r,g,b)rgba(r,g,b,a),a255. */
    backgroundColor?: string;
    /** (x,y,)*/
    fourParameter?: string | string[];
    /** false*/
    isInverseFourParamter?: boolean | boolean[];
    /** . */
    mvt?: boolean;
    /** . */
    useImageRotate?: boolean;
    /** . 12,*/
    imageProcessAlg?: number;
    /**  WGS84(84osm), GCJ02() BD09LL() BD09MC()*/
    webMapType?: "WGS84" | "GCJ02" | "BD09LL" | "BD09MC";
}

/**
 * 
 */
export  interface IWorkspace {
    /** (). */
    name: string;
    /** (). */
    alias?: string;
    /** . */
    workDir?: string;
    /** . */
    isPublic?: boolean;
}

export  const kebabCase: (s: any) => any;

export  interface KeyframeOptions<V = number> {
    to: V | V[];
    from?: V;
    duration?: number;
    ease?: Easing | Easing[];
    offset?: number[];
}

export  function keyframes<V>({ from, to, ease, offset, duration }: KeyframeOptions): any;

export  type LayerCallback = (arg0: {}) => void;

export  type LayerRef = string | string[] | RegExp | ((arg0: LayerSpecification) => boolean);

export  type LayerRefFunc = (arg0: LayerRef, ...args: any[]) => void;

export  type LayerRefFunc0 = (arg0: LayerRef) => void;

export  type LayerRefFunc1<T1> = (arg0: LayerRef, arg1: T1) => void;

export  type LayerRefFunc2<T1, T2> = (arg0: LayerRef, arg1: T1, arg2: T2) => void;

export  type LayerRefFunc3<T1, T2, T3> = (arg0: LayerRef, arg1: T1, arg2: T2, arg3: T3) => void;

export  type LayerSpecification = FillLayerSpecification | LineLayerSpecification | SymbolLayerSpecification | CircleLayerSpecification | HeatmapLayerSpecification | FillExtrusionLayerSpecification | RasterLayerSpecification | HillshadeLayerSpecification | BackgroundLayerSpecification | SkyLayerSpecification;

export  type LightSpecification = {
    anchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    position?: PropertyValueSpecificationEx<[number, number, number]>;
    color?: PropertyValueSpecificationEx<ColorSpecification>;
    intensity?: PropertyValueSpecificationEx<number>;
};

export  const linear: Easing;

export  interface LineGeoJsonInput {
    points: GeoPointLike[];
    properties?: object;
}

export  type LineLayerSpecification = {
    id: string;
    type: "line";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "line-cap"?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
        "line-join"?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
        "line-miter-limit"?: PropertyValueSpecificationEx<number>;
        "line-round-limit"?: PropertyValueSpecificationEx<number>;
        "line-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "line-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "line-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "line-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "line-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "line-width"?: DataDrivenPropertyValueSpecification<number>;
        "line-gap-width"?: DataDrivenPropertyValueSpecification<number>;
        "line-offset"?: DataDrivenPropertyValueSpecification<number>;
        "line-blur"?: DataDrivenPropertyValueSpecification<number>;
        "line-dasharray"?: DataDrivenPropertyValueSpecification<Array<number>>;
        "line-pattern"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "line-gradient"?: ExpressionSpecificationEx;
    };
};

export  type LineLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    lineCap?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    lineJoin?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    lineMiterMimit?: PropertyValueSpecificationEx<number>;
    lineRoundLimit?: PropertyValueSpecificationEx<number>;
    lineSortKey?: DataDrivenPropertyValueSpecification<number>;
    visibility?: "visible" | "none";
    lineOpacity?: DataDrivenPropertyValueSpecification<number>;
    lineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    lineTranslate?: PropertyValueSpecificationEx<[number, number]>;
    lineTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    lineWidth?: DataDrivenPropertyValueSpecification<number>;
    lineGapWidth?: DataDrivenPropertyValueSpecification<number>;
    lineOffset?: DataDrivenPropertyValueSpecification<number>;
    lineBlur?: DataDrivenPropertyValueSpecification<number>;
    lineDasharray?: DataDrivenPropertyValueSpecification<Array<number>>;
    linePattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    lineGradient?: ExpressionSpecificationEx;
};

/**
 * 
 * @param line
 * @param splitLine
 * @param dotErr 6
 * @return {any[] | GeoPoint[][]}
 */
export  function lineSplit(line: GeoPoint[], splitLine: GeoPoint[], dotErr?: number): GeoPoint[][];

/**
 * LineString Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.4
 */
 interface LineString extends GeometryObject {
    type: "LineString";
    coordinates: Position[];
}

/**
 * `LnglatProjection` .
 *
 * Example:
 * ```typescript
 * const mapExtent = new GeoBounds(new GeoPoint(10, 20), new GeoPoint(80, 90));
 * const prj = new LnglatProjection(mapExtent);
 * const pt = [30, 30];
 * const latlng = prj.toLngLat(pt);
 * const pt_geo = prj.fromLngLat(latlng);
 * const mkt = prj.toMercator(pt);
 * const pt_mkt = prj.fromMercator(mkt);
 * ```
 */
export  class LnglatProjection extends Projection {
    /** . */
    mapExtent: GeoBounds;
    /**
     *  `GeoBounds` 
     *
     * @extent extent - .
     */
    constructor();
    /**
     *  
     *
     * @extent extent - .
     */
    setExtent(extent: GeoBounds): void;
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    toMercator(input: GeoPointLike): [number, number];
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    fromMercator(input: GeoPointLike): [number, number];
    /**
     * 
     * @param input 
     * @return {[number, number]}
     */
    toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 
     * @param input 
     * @return {GeoPoint}
     */
    fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 
     * @return {GeoBounds}
     */
    getMapExtent(): GeoBounds;
    /**
     * 
     * @param dist
     */
    toMeter(dist: number): number;
    /**
     * 
     * @param meter
     */
    fromMeter(meter: number): number;
}

export  class MapGlUtils {
    constructor();
    static init(map: any, bindToMap: any): any;
    static newMap(params?: {}, options?: {}): Promise<Map>;
}

export  enum MapOpenWay {
    /** . */
    Memory = "Memory",
    /**  */
    GeomRender = "GeomRender"
}

 class MarkerBase {
    protected options: AnimateMarkerLayerOption;
    protected markersElement: any;
    protected features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    };
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setFeatures(features: FeatureCollection): void;
    getMarkersElement(): any;
    getElement(index?: number): any;
    getLngLat(index?: number): any;
    createMarker(options?: createMarkerOptions, index?: number): Marker;
    setMarkersTextField(textField: string): void;
    setMarkersText(text: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    protected _getColorWithOpacity(color: string, opacity: string | number): string;
    protected _getTextContainer(feature: any, className: string): HTMLDivElement | null;
    set16ToRgb(str: string): string;
    getColorWithOpacity(color: string, opacity: string | number): string;
}

/**
 * .
 */
export  class MarkerCluster extends Evented {
    private options;
    private markers;
    private markersOnScreen;
    private _map;
    private _hidden;
    private data;
    /**
     * 
     * @param options
     */
    constructor(options: MarkerClusterOptions);
    /**
     *  `MarkerCluster`  `Map` 
     */
    addTo(map: Map): MarkerCluster;
    /**
     * 
     */
    updateData(data: FeatureCollection | MarkerClusterData[]): void;
    /**
     * 
     */
    getData(): MarkerClusterData[];
    /**
     * markers
     */
    updateMarkers(): void;
    /**
     * 
     */
    remove(): void;
    /**
     * 
     */
    show(): void;
    /**
     * 
     */
    hide(): void;
    allowOverlap(bAllowOverlap: boolean): void;
    allowOverlapMaxZoom(zoom: number): void;
}

export  interface MarkerClusterData {
    point: GeoPointLike;
    properties?: Record<string, any>;
    [propName: string]: any;
}

export  interface MarkerClusterOptions {
    /** .(CAD) */
    data: FeatureCollection | MarkerClusterData[];
    createMarker: (curMarkerData: MarkerClusterData, clusterMarkersData: MarkerClusterData[]) => Marker | Text_2;
    updateMarker?: (curMarkerData: MarkerClusterData, clusterMarkersData: MarkerClusterData[], marker: Marker) => Marker | Text_2 | undefined;
    /** false. */
    allowOverlap?: boolean;
    /** false. */
    cameraNearFront?: boolean;
    /** ().4*/
    allowOverlapMaxZoom?: number;
    /** marker div40. datapropertiesmarkerWidthdata*/
    markerWidth?: number;
    /** marker div40. datapropertiesmarkerHeightdata */
    markerHeight?: number;
}

export  namespace mat2 {
    export type valueType = mat2type;
    /**
     * Creates a new identity mat2
     *
     * @returns {mat2} a new 2x2 matrix
     */
    export function create(): Float32Array;
    /**
     * Creates a new mat2 initialized with values from an existing matrix
     *
     * @param {ReadonlyMat2} a matrix to clone
     * @returns {mat2} a new 2x2 matrix
     */
    export function clone(a: mat2type): Float32Array;
    /**
     * Copy the values from one mat2 to another
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function copy(out: mat2type, a: mat2type): mat2type;
    /**
     * Set a mat2 to the identity matrix
     *
     * @param {mat2} out the receiving matrix
     * @returns {mat2} out
     */
    export function identity(out: mat2type): mat2type;
    /**
     * Create a new mat2 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m10 Component in column 1, row 0 position (index 2)
     * @param {Number} m11 Component in column 1, row 1 position (index 3)
     * @returns {mat2} out A new 2x2 matrix
     */
    export function fromValues(m00: number, m01: number, m10: number, m11: number): mat2type;
    /**
     * Set the components of a mat2 to the given values
     *
     * @param {mat2} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m10 Component in column 1, row 0 position (index 2)
     * @param {Number} m11 Component in column 1, row 1 position (index 3)
     * @returns {mat2} out
     */
    export function set(out: mat2type, m00: number, m01: number, m10: number, m11: number): mat2type;
    /**
     * Transpose the values of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function transpose(out: mat2type, a: mat2type): mat2type;
    /**
     * Inverts a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function invert(out: mat2type, a: mat2type): mat2type | null;
    /**
     * Calculates the adjugate of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the source matrix
     * @returns {mat2} out
     */
    export function adjoint(out: mat2type, a: mat2type): mat2type;
    /**
     * Calculates the determinant of a mat2
     *
     * @param {ReadonlyMat2} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat2type): number;
    /**
     * Multiplies two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function multiply(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Rotates a mat2 by the given angle
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    export function rotate(out: mat2type, a: mat2type, rad: number): mat2type;
    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to rotate
     * @param {ReadonlyVec2} v the vec2 to scale the matrix by
     * @returns {mat2} out
     **/
    export function scale(out: mat2type, a: mat2type, v: mat2type): mat2type;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.rotate(dest, dest, rad);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    export function fromRotation(out: mat2type, rad: number): mat2type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.scale(dest, dest, vec);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {ReadonlyVec2} v Scaling vector
     * @returns {mat2} out
     */
    export function fromScaling(out: mat2type, v: mat2type): mat2type;
    /**
     * Returns a string representation of a mat2
     *
     * @param {ReadonlyMat2} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat2type): string;
    /**
     * Returns Frobenius norm of a mat2
     *
     * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat2type): number;
    /**
     * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
     * @param {ReadonlyMat2} L the lower triangular matrix
     * @param {ReadonlyMat2} D the diagonal matrix
     * @param {ReadonlyMat2} U the upper triangular matrix
     * @param {ReadonlyMat2} a the input matrix to factorize
     */
    export function LDU(L: mat2type, D: mat2type, U: mat2type, a: mat2type): mat2type[];
    /**
     * Adds two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function add(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @returns {mat2} out
     */
    export function subtract(out: mat2type, a: mat2type, b: mat2type): mat2type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyMat2} a The first matrix.
     * @param {ReadonlyMat2} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat2type, b: mat2type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {ReadonlyMat2} a The first matrix.
     * @param {ReadonlyMat2} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat2type, b: mat2type): boolean;
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat2} out the receiving matrix
     * @param {ReadonlyMat2} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat2} out
     */
    export function multiplyScalar(out: mat2type, a: mat2type, b: number): mat2type;
    /**
     * Adds two mat2's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat2} out the receiving vector
     * @param {ReadonlyMat2} a the first operand
     * @param {ReadonlyMat2} b the second operand
     * @param {Number} scale the amount to scale b's elements by before adding
     * @returns {mat2} out
     */
    export function multiplyScalarAndAdd(out: mat2type, a: mat2type, b: mat2type, scale: number): mat2type;
}

export  namespace mat2d {
    export type valueType = mat2dtype;
    /**
     * Creates a new identity mat2d
     *
     * @returns {mat2d} a new 2x3 matrix
     */
    export function create(): mat2dtype;
    /**
     * Creates a new mat2d initialized with values from an existing matrix
     *
     * @param {ReadonlyMat2d} a matrix to clone
     * @returns {mat2d} a new 2x3 matrix
     */
    export function clone(a: mat2dtype): mat2dtype;
    /**
     * Copy the values from one mat2d to another
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {mat2d} out
     */
    export function copy(out: mat2dtype, a: mat2dtype): mat2dtype;
    /**
     * Set a mat2d to the identity matrix
     *
     * @param {mat2d} out the receiving matrix
     * @returns {mat2d} out
     */
    export function identity(out: mat2dtype): mat2dtype;
    /**
     * Create a new mat2d with the given values
     *
     * @param {Number} a Component A (index 0)
     * @param {Number} b Component B (index 1)
     * @param {Number} c Component C (index 2)
     * @param {Number} d Component D (index 3)
     * @param {Number} tx Component TX (index 4)
     * @param {Number} ty Component TY (index 5)
     * @returns {mat2d} A new mat2d
     */
    export function fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): mat2dtype;
    /**
     * Set the components of a mat2d to the given values
     *
     * @param {mat2d} out the receiving matrix
     * @param {Number} a Component A (index 0)
     * @param {Number} b Component B (index 1)
     * @param {Number} c Component C (index 2)
     * @param {Number} d Component D (index 3)
     * @param {Number} tx Component TX (index 4)
     * @param {Number} ty Component TY (index 5)
     * @returns {mat2d} out
     */
    export function set(out: mat2dtype, a: number, b: number, c: number, d: number, tx: number, ty: number): mat2dtype;
    /**
     * Inverts a mat2d
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {mat2d} out
     */
    export function invert(out: mat2dtype, a: mat2dtype): mat2dtype | null;
    /**
     * Calculates the determinant of a mat2d
     *
     * @param {ReadonlyMat2d} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat2dtype): number;
    /**
     * Multiplies two mat2d's
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function multiply(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Rotates a mat2d by the given angle
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    export function rotate(out: mat2dtype, a: mat2dtype, rad: number): mat2dtype;
    /**
     * Scales the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to translate
     * @param {ReadonlyVec2} v the vec2 to scale the matrix by
     * @returns {mat2d} out
     **/
    export function scale(out: mat2dtype, a: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Translates the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to translate
     * @param {ReadonlyVec2} v the vec2 to translate the matrix by
     * @returns {mat2d} out
     **/
    export function translate(out: mat2dtype, a: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.rotate(dest, dest, rad);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    export function fromRotation(out: mat2dtype, rad: number): mat2dtype;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.scale(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {ReadonlyVec2} v Scaling vector
     * @returns {mat2d} out
     */
    export function fromScaling(out: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.translate(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {ReadonlyVec2} v Translation vector
     * @returns {mat2d} out
     */
    export function fromTranslation(out: mat2dtype, v: mat2dtype): mat2dtype;
    /**
     * Returns a string representation of a mat2d
     *
     * @param {ReadonlyMat2d} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat2dtype): string;
    /**
     * Returns Frobenius norm of a mat2d
     *
     * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat2dtype): number;
    /**
     * Adds two mat2d's
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function add(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @returns {mat2d} out
     */
    export function subtract(out: mat2dtype, a: mat2dtype, b: mat2dtype): mat2dtype;
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat2d} out the receiving matrix
     * @param {ReadonlyMat2d} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat2d} out
     */
    export function multiplyScalar(out: mat2dtype, a: mat2dtype, b: number): mat2dtype;
    /**
     * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat2d} out the receiving vector
     * @param {ReadonlyMat2d} a the first operand
     * @param {ReadonlyMat2d} b the second operand
     * @param {Number} scale the amount to scale b's elements by before adding
     * @returns {mat2d} out
     */
    export function multiplyScalarAndAdd(out: mat2dtype, a: mat2dtype, b: mat2dtype, scale: number): mat2dtype;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyMat2d} a The first matrix.
     * @param {ReadonlyMat2d} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat2dtype, b: mat2dtype): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {ReadonlyMat2d} a The first matrix.
     * @param {ReadonlyMat2d} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat2dtype, b: mat2dtype): boolean;
}

export  type mat2dtype = [number, number, number, number, number, number] | Float32Array;

export  type mat2type = [number, number, number, number] | Float32Array;

export  namespace mat3 {
    export type valueType = mat3type;
    /**
     * Creates a new identity mat3
     *
     * @returns {mat3} a new 3x3 matrix
     */
    export function create(): mat3type;
    /**
     * Copies the upper-left 3x3 values into the given mat3.
     *
     * @param {mat3} out the receiving 3x3 matrix
     * @param {mat4} a   the source 4x4 matrix
     * @returns {mat3} out
     */
    export function fromMat4(out: mat3type, a: mat3type): mat3type;
    /**
     * Creates a new mat3 initialized with values from an existing matrix
     *
     * @param {mat3} a matrix to clone
     * @returns {mat3} a new 3x3 matrix
     */
    export function clone(a: mat3type): mat3type;
    /**
     * Copy the values from one mat3 to another
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function copy(out: mat3type, a: mat3type): mat3type;
    /**
     * Create a new mat3 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m10 Component in column 1, row 0 position (index 3)
     * @param {Number} m11 Component in column 1, row 1 position (index 4)
     * @param {Number} m12 Component in column 1, row 2 position (index 5)
     * @param {Number} m20 Component in column 2, row 0 position (index 6)
     * @param {Number} m21 Component in column 2, row 1 position (index 7)
     * @param {Number} m22 Component in column 2, row 2 position (index 8)
     * @returns {mat3} A new mat3
     */
    export function fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3type;
    /**
     * Set the components of a mat3 to the given values
     *
     * @param {mat3} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m10 Component in column 1, row 0 position (index 3)
     * @param {Number} m11 Component in column 1, row 1 position (index 4)
     * @param {Number} m12 Component in column 1, row 2 position (index 5)
     * @param {Number} m20 Component in column 2, row 0 position (index 6)
     * @param {Number} m21 Component in column 2, row 1 position (index 7)
     * @param {Number} m22 Component in column 2, row 2 position (index 8)
     * @returns {mat3} out
     */
    export function set(out: mat3type, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3type;
    /**
     * Set a mat3 to the identity matrix
     *
     * @param {mat3} out the receiving matrix
     * @returns {mat3} out
     */
    export function identity(out: mat3type): mat3type;
    /**
     * Transpose the values of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function transpose(out: mat3type, a: mat3type): mat3type;
    /**
     * Inverts a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function invert(out: mat3type, a: mat3type): mat3type | null;
    /**
     * Calculates the adjugate of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    export function adjoint(out: mat3type, a: mat3type): mat3type;
    /**
     * Calculates the determinant of a mat3
     *
     * @param {mat3} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat3type): number;
    /**
     * Multiplies two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function multiply(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Alias for {@link mat3.multiply}
     * @function
     */
    /**
     * Translate a mat3 by the given vector
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to translate
     * @param {vec2} v vector to translate by
     * @returns {mat3} out
     */
    export function translate(out: mat3type, a: mat3type, v: vec2type): mat3type;
    /**
     * Rotates a mat3 by the given angle
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    export function rotate(out: mat3type, a: mat3type, rad: number): mat3type;
    /**
     * Scales the mat3 by the dimensions in the given vec2
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {vec2} v the vec2 to scale the matrix by
     * @returns {mat3} out
     */
    export function scale(out: mat3type, a: mat3type, v: vec2type): mat3type;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.translate(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Translation vector
     * @returns {mat3} out
     */
    export function fromTranslation(out: mat3type, v: vec2type): mat3type;
    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.rotate(dest, dest, rad);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    export function fromRotation(out: mat3type, rad: number): mat3type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.scale(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Scaling vector
     * @returns {mat3} out
     */
    export function fromScaling(out: mat3type, v: vec2type): mat3type;
    /**
     * Copies the values from a mat2d into a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat2d} a the matrix to copy
     * @returns {mat3} out
     */
    export function fromMat2d(out: mat3type, a: mat2dtype): mat3type;
    /**
     * Calculates a 3x3 matrix from the given quaternion
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat3} out
     */
    export function fromQuat(out: mat3type, q: quattype): mat3type;
    /**
     * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {mat4} a Mat4 to derive the normal matrix from
     *
     * @returns {mat3} out
     */
    export function normalFromMat4(out: mat3type, a: mat4type): mat3type | null;
    /**
     * Returns a string representation of a mat3
     *
     * @param {mat3} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat3type): string;
    /**
     * Returns Frobenius norm of a mat3
     *
     * @param {mat3} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat3type): number;
    /**
     * Adds two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function add(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    export function subtract(out: mat3type, a: mat3type, b: mat3type): mat3type;
    /**
     * Alias for {@link mat3.subtract}
     * @function
     */
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat3} out
     */
    export function multiplyScalar(out: mat3type, a: mat3type, b: number): mat3type;
    /**
     * Adds two mat3's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat3} out the receiving vector
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @param {Number} s the amount to scale b's elements by before adding
     * @returns {mat3} out
     */
    export function multiplyScalarAndAdd(out: mat3type, a: mat3type, b: mat3type, s: number): mat3type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {mat3} a The first matrix.
     * @param {mat3} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat3type, b: mat3type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {mat3} a The first matrix.
     * @param {mat3} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat3type, b: mat3type): boolean;
}

export  type mat3type = [number, number, number, number, number, number, number, number, number] | Float32Array;

export  namespace mat4 {
    export type valueType = mat4type;
    /**
     * Creates a new identity mat4
     *
     * @returns {mat4} a new 4x4 matrix
     */
    export function create(): mat4type;
    /**
     * Creates a new mat4 initialized with values from an existing matrix
     *
     * @param {mat4} a matrix to clone
     * @returns {mat4} a new 4x4 matrix
     */
    export function clone(a: mat4type): mat4type;
    /**
     * Copy the values from one mat4 to another
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function copy(out: mat4type, a: mat4type): mat4type;
    /**
     * Create a new mat4 with the given values
     *
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m03 Component in column 0, row 3 position (index 3)
     * @param {Number} m10 Component in column 1, row 0 position (index 4)
     * @param {Number} m11 Component in column 1, row 1 position (index 5)
     * @param {Number} m12 Component in column 1, row 2 position (index 6)
     * @param {Number} m13 Component in column 1, row 3 position (index 7)
     * @param {Number} m20 Component in column 2, row 0 position (index 8)
     * @param {Number} m21 Component in column 2, row 1 position (index 9)
     * @param {Number} m22 Component in column 2, row 2 position (index 10)
     * @param {Number} m23 Component in column 2, row 3 position (index 11)
     * @param {Number} m30 Component in column 3, row 0 position (index 12)
     * @param {Number} m31 Component in column 3, row 1 position (index 13)
     * @param {Number} m32 Component in column 3, row 2 position (index 14)
     * @param {Number} m33 Component in column 3, row 3 position (index 15)
     * @returns {mat4} A new mat4
     */
    export function fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4type;
    /**
     * Set the components of a mat4 to the given values
     *
     * @param {mat4} out the receiving matrix
     * @param {Number} m00 Component in column 0, row 0 position (index 0)
     * @param {Number} m01 Component in column 0, row 1 position (index 1)
     * @param {Number} m02 Component in column 0, row 2 position (index 2)
     * @param {Number} m03 Component in column 0, row 3 position (index 3)
     * @param {Number} m10 Component in column 1, row 0 position (index 4)
     * @param {Number} m11 Component in column 1, row 1 position (index 5)
     * @param {Number} m12 Component in column 1, row 2 position (index 6)
     * @param {Number} m13 Component in column 1, row 3 position (index 7)
     * @param {Number} m20 Component in column 2, row 0 position (index 8)
     * @param {Number} m21 Component in column 2, row 1 position (index 9)
     * @param {Number} m22 Component in column 2, row 2 position (index 10)
     * @param {Number} m23 Component in column 2, row 3 position (index 11)
     * @param {Number} m30 Component in column 3, row 0 position (index 12)
     * @param {Number} m31 Component in column 3, row 1 position (index 13)
     * @param {Number} m32 Component in column 3, row 2 position (index 14)
     * @param {Number} m33 Component in column 3, row 3 position (index 15)
     * @returns {mat4} out
     */
    export function set(out: mat4type, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4type;
    /**
     * Set a mat4 to the identity matrix
     *
     * @param {mat4} out the receiving matrix
     * @returns {mat4} out
     */
    export function identity(out: mat4type): mat4type;
    /**
     * Transpose the values of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function transpose(out: mat4type, a: mat4type): mat4type;
    /**
     * Inverts a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function invert(out: mat4type, a: mat4type): mat4type | null;
    /**
     * Calculates the adjugate of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    export function adjoint(out: mat4type, a: mat4type): mat4type;
    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} a the source matrix
     * @returns {Number} determinant of a
     */
    export function determinant(a: mat4type): number;
    /**
     * Multiplies two mat4s
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function multiply(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Alias for {@link mat4.multiply}
     * @function
     */
    /**
     * Translate a mat4 by the given vector
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to translate
     * @param {vec3} v vector to translate by
     * @returns {mat4} out
     */
    export function translate(out: mat4type, a: mat4type, v: vec3type): mat4type;
    /**
     * Scales the mat4 by the dimensions in the given vec3 not using vectorization
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to scale
     * @param {vec3} v the vec3 to scale the matrix by
     * @returns {mat4} out
     */
    export function scale(out: mat4type, a: mat4type, v: vec3type): mat4type;
    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    export function rotate(out: mat4type, a: mat4type, rad: number, axis: vec3type): mat4type | null;
    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateX(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateY(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function rotateZ(out: mat4type, a: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    export function fromTranslation(out: mat4type, v: vec3type): mat4type;
    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.scale(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Scaling vector
     * @returns {mat4} out
     */
    export function fromScaling(out: mat4type, v: vec3type): mat4type;
    /**
     * Creates a matrix from a given angle around a given axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotate(dest, dest, rad, axis);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    export function fromRotation(out: mat4type, rad: number, axis: vec3type): mat4type | null;
    /**
     * Creates a matrix from the given angle around the X axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateX(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromXRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from the given angle around the Y axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateY(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromYRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from the given angle around the Z axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateZ(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    export function fromZRotation(out: mat4type, rad: number): mat4type;
    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    export function fromRotationTranslation(out: mat4type, q: quattype, v: vec3type): mat4type;
    /**
     * Returns the translation vector component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslation,
     *  the returned vector will be the same as the translation vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive translation component
     * @param  {mat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */
    export function getTranslation(out: vec3type, mat: mat4type): vec3type;
    /**
     * Returns the scaling factor component of a transformation
     *  matrix. If a matrix is built with fromRotationTranslationScale
     *  with a normalized Quaternion paramter, the returned vector will be
     *  the same as the scaling vector
     *  originally supplied.
     * @param  {vec3} out Vector to receive scaling factor component
     * @param  {mat4} mat Matrix to be decomposed (input)
     * @return {vec3} out
     */
    export function getScaling(out: vec3type, mat: mat4type): vec3type;
    /**
     * Returns a quaternion representing the rotational component
     *  of a transformation matrix. If a matrix is built with
     *  fromRotationTranslation, the returned quaternion will be the
     *  same as the quaternion originally supplied.
     * @param {quat} out Quaternion to receive the rotation component
     * @param {mat4} mat Matrix to be decomposed (input)
     * @return {quat} out
     */
    export function getRotation(out: vec4type, mat: mat4type): quattype;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @returns {mat4} out
     */
    export function fromRotationTranslationScale(out: mat4type, q: quattype, v: vec3type, s: vec3type): mat4type;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     mat4.translate(dest, origin);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *     mat4.translate(dest, negativeOrigin);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @param {vec3} o The origin vector around which to scale and rotate
     * @returns {mat4} out
     */
    export function fromRotationTranslationScaleOrigin(out: mat4type, q: quattype, v: vec3type, s: vec3type, o: vec3type): mat4type;
    /**
     * Calculates a 4x4 matrix from the given quaternion
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat4} out
     */
    export function fromQuat(out: mat4type, q: quattype): mat4type;
    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {Number} left Left bound of the frustum
     * @param {Number} right Right bound of the frustum
     * @param {Number} bottom Bottom bound of the frustum
     * @param {Number} top Top bound of the frustum
     * @param {Number} near Near bound of the frustum
     * @param {Number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function frustum(out: mat4type, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4type;
    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function perspective(out: mat4type, fovy: number, aspect: number, near: number, far: number): mat4type;
    /**
     * Generates a perspective projection matrix with the given field of view.
     * This is primarily useful for generating projection matrices to be used
     * with the still experiemental WebVR API.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function perspectiveFromFieldOfView(out: mat4type, fov: {
        upDegrees: number;
        downDegrees: number;
        leftDegrees: number;
        rightDegrees: number;
    }, near: number, far: number): mat4type;
    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    export function ortho(out: mat4type, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4type;
    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing up
     * @returns {mat4} out
     */
    export function lookAt(out: mat4type, eye: vec3type, center: vec3type, up: vec3type): mat4type;
    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    export function str(a: mat4type): string;
    /**
     * Returns Frobenius norm of a mat4
     *
     * @param {mat4} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    export function frob(a: mat4type): number;
    /**
     * Adds two mat4's
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function add(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Subtracts matrix b from matrix a
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    export function subtract(out: mat4type, a: mat4type, b: mat4type): mat4type;
    /**
     * Alias for {@link mat4.subtract}
     * @function
     */
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat4} out
     */
    export function multiplyScalar(out: mat4type, a: mat4type, b: number): mat4type;
    /**
     * Adds two mat4's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat4} out the receiving vector
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @param {Number} s the amount to scale b's elements by before adding
     * @returns {mat4} out
     */
    export function multiplyScalarAndAdd(out: mat4type, a: mat4type, b: mat4type, s: number): mat4type;
    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     *
     * @param {mat4} a The first matrix.
     * @param {mat4} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function exactEquals(a: mat4type, b: mat4type): boolean;
    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     *
     * @param {mat4} a The first matrix.
     * @param {mat4} b The second matrix.
     * @returns {Boolean} True if the matrices are equal, false otherwise.
     */
    export function equals(a: mat4type, b: mat4type): boolean;
}

export  type mat4type = [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number] | Float32Array;

export  namespace Math2D {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    export class Box {
        x: number;
        y: number;
        w: number;
        h: number;
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        constructor(x?: number, y?: number, w?: number, h?: number);
        /**
         * Set new values to all properties of the box.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        set(x: number, y: number, w: number, h: number): void;
        /**
         * Test box for inclusion of point.
         *
         * @param x - X coordinate of point.
         * @param y - Y coordinate of point.
         */
        contains(x: number, y: number): boolean;
        /**
         * Test box for inclusion of another box.
         *
         * @param other - Box 2 to test for inclusion.
         */
        containsBox(other: Box): boolean;
        /**
         * Test two boxes for intersection.
         *
         * @param other - Box 2 to test for intersection.
         */
        intersects(other: Box): boolean;
    }
    /**
     * Box to store UV coordinates.
     */
    export interface UvBox {
        s0: number;
        t0: number;
        s1: number;
        t1: number;
    }
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns Squared distance between the two points
     */
    export function distSquared(ax: number, ay: number, bx: number, by: number): number;
    /**
     * Compute distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns {number} between the two points
     * @param az
     * @param bz
     */
    export function dist(ax: number, ay: number, bx: number, by: number, az?: number, bz?: number): number;
    /**
     * 
     * @param pts
     * @return {number}
     */
    export function lineDist(pts: GeoPointLike[]): number;
    /**
     * Computes the squared length of a line.
     *
     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    export function computeSquaredLineLength(line: number[]): number;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px - Test point X
     * @param py - Test point y
     * @param l0x - Line segment start X
     * @param l0y - Line segment start Y
     * @param l1x - Line segment end X
     * @param l1y - Line segment end Y
     * @returns Squared distance between point and line segment
     */
    export function distToSegmentSquared(px: number, py: number, l0x: number, l0y: number, l1x: number, l1y: number): number;
    /**
     * Finds the intersections of a line and a circle.
     *
     * @param xLine1 - abscissa of first line point.
     * @param yLine1 - ordinate of second line point.
     * @param xLine2 - abscissa of second line point.
     * @param yLine2 - ordinate of second line point.
     * @param radius - circle radius.
     * @param xCenter - abscissa of circle center.
     * @param yCenter - ordinate of circle center.
     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2
     * if it's secant) or undefined if there's no intersection.
     */
    export function intersectLineAndCircle(xLine1: number, yLine1: number, xLine2: number, yLine2: number, radius: number, xCenter?: number, yCenter?: number): {
        x1: number;
        y1: number;
        x2?: number;
        y2?: number;
    } | undefined;
    /**
     * Computes the intersection point between two lines.
     *
     * @remarks
     * This functions computes the
     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
     *    | line-line intersection} of two lines given two points on each line.
     *
     * @param x1 - x coordinate of the first point of the first line.
     * @param y1 - y coordinate of the first point of the first line.
     * @param x2 - x coordinate of the second point of the first line.
     * @param y2 - y coordinate of the second point of the first line.
     * @param x3 - x coordinate of the first point of the second line.
     * @param y3 - y coordinate of the first point of the second line.
     * @param x4 - x coordinate of the second point of the second line.
     * @param y4 - y coordinate of the second point of the second line.
     * @param result - The resulting point.
     */
    export function intersectLines(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, result?: Vec2Like): Vec2Like | undefined;
}

export  namespace MathUtils {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     *
     * @returns Clamped value.
     */
    export function clamp(value: number, min: number, max: number): number;
    /**
     * constrain n to the given range, excluding the minimum, via modular arithmetic
     *
     * @param n value
     * @param min the minimum value to be returned, (isMin is false, exclusive, is true inclusive)
     * @param max the maximum value to be returned, (isMin is false, inclusive, is true exclusive)
     * @returns {number} number
     * @param isMin
     */
    export function wrap(n: number, min: number, max: number, isMin?: boolean): number;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    export function smoothStep(edge0: number, edge1: number, x: number): number;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    export function smootherStep(edge0: number, edge1: number, x: number): number;
    /**
     * Maps a number from one range to another.
     *
     * @param val - The incoming value to be converted.
     * @param inMin - Lower bound of the value's current range.
     * @param inMax - Upper bound of the value's current range.
     * @param outMin - Lower bound of the value's target range.
     * @param outMax - Upper bound of the value's target range.
     */
    export function map(val: number, inMin: number, inMax: number, outMin: number, outMax: number): number;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    export function min2(a: number | undefined, b: number | undefined): number | undefined;
    /**
     * 
     * @param v1
     * @param v2
     * @param value
     * @return {number}
     */
    export function lerp(v1: number, v2: number, value: number): number;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    export function max2(a: number | undefined, b: number | undefined): number | undefined;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value - Value to check.
     * @param lowerBound - The lower bound to check the value against.
     * @param upperBound - The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    export function isClamped(value: number, lowerBound: number | undefined, upperBound: number | undefined): boolean;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue -
     * @param endValue -
     * @param time -
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    export function easeInOutCubic(startValue: number, endValue: number, time: number): number;
    /**
     * 
     * @param dotErr 8
     * @return {boolean}
     * @param num1
     * @param num2
     */
    export function equals(num1: number, num2: number, dotErr?: number): boolean;
}

/**
 * 
 * @param zoomLevel 0
 * @param latitude 
 * @return {number}
 */
export  function metersPerPixel(zoomLevel: number, latitude?: number): number;

export  const METHODS: Methods;

export  interface Methods {
    GET: "GET";
    POST: "POST";
    PUT: "PUT";
    DELETE: "DELETE";
    PATCH: "PATCH";
    OPTIONS: "OPTIONS";
    HEAD: "HEAD";
}

export  class MiniMapControl {
    private _ticking;
    private _lastMouseMoveEvent;
    private _parentMap;
    private _isDragging;
    private _isCursorOverFeature;
    private _previousPoint;
    private _currentPoint;
    private _trackingRectCoordinates;
    private options;
    private _container;
    private _miniMap;
    private _trackingRect;
    constructor(options: MiniMapControlOption);
    init(options: MiniMapControlOption): void;
    onAdd(parentMap: Map): HTMLElement;
    _onAdd(parentMap: Map): HTMLElement;
    _onSize(): void;
    _updateMapExtent(data: any): void;
    onRemove(): void;
    _onRemove(): void;
    getMap(): Map;
    getDefaultPosition(): string;
    _load(): void;
    _mouseDown(e: any): void;
    _mouseMove(e: any): void;
    _mouseUp(): void;
    _moveTrackingRect(offset: any): any;
    _setTrackingRectBounds(bounds: any): void;
    _convertBoundsToPoints(bounds: any): void;
    _update(e: any): void;
    _zoomAdjust(): void;
    _createContainer(parentMap: Map): HTMLDivElement;
    _preventDefault(e: any): void;
}

export  interface MiniMapControlOption {
    id?: string;
    width?: string;
    height?: string;
    style?: Style | string;
    center?: [number, number];
    zoom?: number;
    zoomAdjust?: null;
    lineColor?: string;
    lineWidth?: number;
    lineOpacity?: number;
    fillColor?: string;
    fillOpacity?: number;
    dragPan?: boolean;
    scrollZoom?: boolean;
    boxZoom?: boolean;
    dragRotate?: boolean;
    keyboard?: boolean;
    doubleClickZoom?: boolean;
    touchZoomRotate?: boolean;
    maxBounds?: LngLatBounds;
    containerStyle?: Partial<CSSStyleDeclaration>;
}

export  const mirrorEasing: EasingModifier;

 type Mix<T> = (v: number) => T;

export  const mix: (from: number, to: number, progress: number) => number;

export  const mixColor: (from: any | string, to: any | string) => (v: number) => any;

 type MixComplex = (p: number) => string;

export  const mixComplex: (origin: string, target: string) => MixComplex;

 type MixEasing = Easing | Easing[];

 type MixerFactory<T> = (from: T, to: T) => Mix<T>;

export  class MousePositionControl {
    private readonly digits;
    private readonly trackCenter;
    private readonly labelFormat;
    private coord;
    private readonly showLatLng;
    private readonly showZoom;
    private readonly showBearing;
    private readonly showPitch;
    private container;
    private panel;
    private map;
    private prj;
    private readonly style;
    constructor(options?: MousePositionControlOption);
    insertControl(): void;
    defaultLabelFormat(lng: number, lat: number, x: number, y: number): string;
    onMouseMove(evt?: any): void;
    onAdd(map: Map): HTMLElement;
    onRemove(): void;
    getDefaultPosition(): string;
}

export  interface MousePositionControlOption {
    digits?: number;
    trackCenter?: boolean;
    labelFormat?: (lng: number, lat: number, x: number, y: number, map?: Map) => string;
    projection?: Projection | undefined;
    style?: {
        border: string;
        backgroundColor: string;
    };
    showLatLng?: boolean;
    showZoom?: boolean;
    showBearing?: boolean;
    showPitch?: boolean;
}

export  enum MTextAttachmentPoint {
    kTopLeft = 1,
    kTopCenter = 2,
    kTopRight = 3,
    kMiddleLeft = 4,
    kMiddleCenter = 5,
    kMiddleRight = 6,
    kBottomLeft = 7,
    kBottomCenter = 8,
    kBottomRight = 9,
    kBaseLeft = 10,
    kBaseCenter = 11,
    kBaseRight = 12,
    kBaseAlign = 13,
    kBottomAlign = 14,
    kMiddleAlign = 15,
    kTopAlign = 16,
    kBaseFit = 17,
    kBottomFit = 18,
    kMiddleFit = 19,
    kTopFit = 20,
    kBaseMid = 21,
    kBottomMid = 22,
    kMiddleMid = 23,
    kTopMid = 24
}

/**
 * ,
 * @param lines
 * @param dotErr 6
 */
export  function multiLineSplit(lines: GeoPoint[][], dotErr?: number): GeoPoint[][];

/**
 * MultiLineString Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.5
 */
 interface MultiLineString extends GeometryObject {
    type: "MultiLineString";
    coordinates: Position[][];
}

/**
 * MultiPoint Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.3
 */
 interface MultiPoint extends GeometryObject {
    type: "MultiPoint";
    coordinates: Position[];
}

/**
 * MultiPolygon Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.7
 */
 interface MultiPolygon extends GeometryObject {
    type: "MultiPolygon";
    coordinates: Position[][][];
}

 type NodeId = string;

export  type OffHandler = () => void;

export  function offsetPointLine(points: GeoPoint[], distance: number): any[];

export  function offsetPoints(pts: GeoPointLike[], options: {
    smoothFactor?: number;
    offset: number;
}): any[];

/**
 *  {backcolor: 0}
 */
export  function openMapDarkStyle(): IMapStyleParam;

/**
 *  {backcolor: 0xFFFFFF}
 */
export  function openMapLightStyle(): IMapStyleParam;

export  class OverlayLayerBase {
    sourceId?: string;
    layerId?: string;
    _map?: Map;
    constructor();
    addTo(map: Map, beforeId?: string): void;
    /**
     * ID
     * @return {string | undefined}
     */
    getSourceId(): string | undefined;
    /**
     * ID
     * @return {string | undefined}
     */
    getLayerId(): string | undefined;
    /**
     * 
     * @return {GeoJsonGeomertry | undefined}
     */
    getData(): GeoJsonGeomertry | undefined;
    remove(): void;
    /** 
     @returns A function to remove the handler.
     * @param layerOrLayers
     */
    hoverPointer(): void;
    /**
      [s] 
     * @param enterCb
     * @param leaveCb
     */
    hoverFeatureState(enterCb?: (arg0: {}) => void, leaveCb?: (arg0: {}) => void): void;
    /** 
     @param htmlFunc Function that receives feature and popup, returns HTML.
     @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
     @example hoverPopup(f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { anchor: 'left' });
     */
    hoverPopup(htmlFunc: any, popupOptions?: PopupOptions): any;
    /** 
     @param htmlFunc Function that receives feature and popup, returns HTML.
     @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.

     @returns A function that removes the handler.
     @example clickPopup(f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { maxWidth: 500 });

     */
    clickPopup(htmlFunc: (arg0: {}) => void, popupOptions?: PopupOptions): any;
    /** 
     @param {function} cb Callback that receives event with .features property
     @returns A function that removes the handler.
     */
    clickLayer(cb: any): any;
    /** 
     @returns A function to remove the handler.
     */
    hoverLayer(cb: any): any;
    /**
     * 
     * @param layer
     */
    show(): void;
    /**
     * 
     * @param layer
     */
    hide(): void;
    /** 
     @param {boolean} state True for visible, false for hidden.
     */
    toggle(state: boolean): boolean;
    /** 
     @example setProperty('fillOpacity', 0.5)
     */
    setProperty(prop: string | object, value?: any): void;
    /**  ID 
     */
    getLayerStyle(): LayerSpecification;
    /**
     * 
     * @param layer
     * @param style
     */
    setLayerStyle(style: any): void;
    /** 
     @param {Array} filter New filter to set.
     @example setFilter(['==','level','0']]);
     */
    setFilter(filter: FilterSpecification): void;
}

export  interface OverlayLayerBaseOptions {
    sourceId?: string;
    sourceLayer?: string;
    layerId?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: any;
    visibility?: "visible" | "none";
    isHoverPointer?: boolean;
    isHoverFeatureState?: boolean;
}

export  interface PhysicsSpringOptions {
    velocity?: number;
    stiffness?: number;
    damping?: number;
    mass?: number;
}

/**
 * Pick `props` from `object.
 *
 * Runtime version of `Pick<T,K>`.
 */
export  function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K>;

export  const pipe: (...transformers: Function[]) => Function;

/**
 * 
 * @param meters 
 * @param zoomLevel 0
 * @param latitude 
 * @return {number}
 */
export  function pixelValue(meters: number, zoomLevel: number, latitude?: number): number;

export  interface PlaybackControls {
    stop: () => void;
}

/**
 * Playback options common to all animations.
 */
export  interface PlaybackOptions<V> {
    /**
     * Whether to autoplay the animation when animate is called. If
     * set to false, the animation must be started manually via the returned
     * play method.
     */
    autoplay?: boolean;
    driver?: Driver;
    elapsed?: number;
    from?: V;
    repeat?: number;
    repeatType?: "loop" | "reverse" | "mirror";
    repeatDelay?: number;
    type?: "spring" | "decay" | "keyframes";
    onUpdate?: (latest: V) => void;
    onPlay?: () => void;
    onComplete?: () => void;
    onRepeat?: () => void;
    onStop?: () => void;
}

 type Point23D = Point2D | Point3D;

 interface Point2D {
    x: number;
    y: number;
}

 type Point3D = Point2D & {
    z: number;
};

export  const pointFromVector: (origin: Point2D, angle: number, distance: number) => {
    x: number;
    y: number;
};

export  interface PointGeoJsonInput {
    point: GeoPointLike;
    properties?: object;
}

/**
 * 
 * @param p
 * @param p1
 * @param p2
 * @return {number}
 */
export  function pointToSegmentDistance(p: GeoPoint, p1: GeoPoint, p2: GeoPoint): number;

/**
 * 2d
 */
export  enum Poly2dType {
    k2dSimplePoly = 0,
    k2dFitCurvePoly = 1,
    k2dQuadSplinePoly = 2,
    k2dCubicSplinePoly = 3
}

/**
 * 3d
 */
export  enum Poly3dType {
    k3dSimplePoly = 0,
    k3dQuadSplinePoly = 1,
    k3dCubicSplinePoly = 2
}

/**
 * .
 *
 **/
export  class Polygon extends OverlayLayerBase {
    options: PolygonOptions;
    constructor(options: PolygonOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    /** `fill-sort-key` */
    setFillSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    /** `fill-antialias`  */
    setFillAntialias(value: PropertyValueSpecificationEx<boolean>): this;
    /** `fill-opacity`  */
    setFillOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    /** `fill-color`  */
    setFillColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    /** `fill-outline-color` */
    setFillOutlineColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    /** `fill-translate`  */
    setFillTranslate(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    /** `fill-translate-anchor`  */
    setFillTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    /** `fill-pattern`  */
    setFillPattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    /** `fill-sort-key` . */
    getFillSortKey(): DataDrivenPropertyValueSpecification<number>;
    /**  */
    getFillAntialias(): PropertyValueSpecificationEx<boolean>;
    /**  `fill-opacity`  */
    getFillOpacity(): DataDrivenPropertyValueSpecification<number>;
    /**  `fill-color`  */
    getFillColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    /**  `fill-outline-color`  */
    getFillOutlineColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    /**  `fill-translate`  */
    getFillTranslate(): PropertyValueSpecificationEx<[number, number]>;
    /**  `fill-translate-anchor`  */
    getFillTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    /** `fill-pattern`  */
    getFillPattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
}

/**
 * Polygon Geometry Object
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 */
 interface Polygon_2 extends GeometryObject {
    type: "Polygon";
    coordinates: Position[][];
}

/**
 *  [x,y] 
 * @return {GeoPoint}
 * @param vertices 
 */
export  function polygonCentroid(vertices: GeoPoint[]): GeoPoint;

/**
 * 
 *
 * @returns {boolean} false:
 * @param points
 */
export  function polygonIsClockwise(points: GeoPoint[]): boolean;

export  interface PolygonOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    fillSortKey?: DataDrivenPropertyValueSpecification<number>;
    fillAntialias?: PropertyValueSpecificationEx<boolean>;
    fillOpacity?: DataDrivenPropertyValueSpecification<number>;
    fillColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillOutlineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    fillTranslate?: PropertyValueSpecificationEx<[number, number]>;
    fillTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    fillPattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
}

/**
 * .
 *
 **/
export  class Polyline extends OverlayLayerBase {
    options: PolylineOptions;
    constructor(options: PolylineOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setLineCap(value: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">): this;
    getLineCap(): DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    setLineJoin(value: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">): this;
    getLineJoin(): DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    setLineMiterMimit(value: PropertyValueSpecificationEx<number>): this;
    getLineMiterMimit(): PropertyValueSpecificationEx<number>;
    setLineRoundLimit(value: PropertyValueSpecificationEx<number>): this;
    getLineRoundLimit(): PropertyValueSpecificationEx<number>;
    setLineSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineSortKey(): DataDrivenPropertyValueSpecification<number>;
    setLineOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineOpacity(): DataDrivenPropertyValueSpecification<number>;
    setLineColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getLineColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setLineTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getLineTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setLineTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getLineTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setLineWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineWidth(): DataDrivenPropertyValueSpecification<number>;
    setLineGapWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineGapWidth(): DataDrivenPropertyValueSpecification<number>;
    setLineOffset(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineOffset(): DataDrivenPropertyValueSpecification<number>;
    setLineBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getLineBlur(): DataDrivenPropertyValueSpecification<number>;
    setLineDasharray(value: DataDrivenPropertyValueSpecification<number[]>): this;
    getLineDasharray(): DataDrivenPropertyValueSpecification<number[]>;
    setLinePattern(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getLinePattern(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setLineGradient(value: ExpressionSpecificationEx): this;
    getLineGradient(): ExpressionSpecificationEx;
}

/**
 * .
 *
 **/
export  class PolylineArrow {
    options: PolylineArrowOptions;
    id: string;
    animateFun: Function | null;
    animatedPointIdx: number;
    geojson: any;
    type: string;
    lineArrowImageName: string;
    borderGeoJson: any;
    lineGeojson: any;
    strokeImageName: string | undefined;
    private _layers;
    private _map;
    private readonly _timeout;
    private readonly _interval;
    private _mapStyleCursor;
    constructor(options: PolylineArrowOptions);
    init(): void;
    createGeojson(): void;
    _createLineGeojson(): void;
    _createBorderLine(): void;
    _creatDirLine(): void;
    getLength(): number;
    getBounds(): GeoBounds;
    getId(): string;
    remove(): void;
    _addStrokeImage(): void;
    setStrokeImage(strokeImage: string): void;
    addTo(map: Map, beforeId?: string): void;
    _addShowDirFun(): void;
    _addLayer(): void;
    setCursor(cursor?: string): void;
    _mouseenterCallbackFun(): void;
    _mouseleaveCallbackFun(): void;
    setPath(val: GeoPointLike[]): void;
    getPath(): any;
    /**
     * 
     * @param step 
     * @param fps 
     * @param isLoop 
     * @param stopCallBack 
     * @param onFrameCallBack 
     * @return {FrameAnimation}
     */
    animate(step?: number, fps?: number, isLoop?: boolean, stopCallBack?: (status: FrameAnimationStatus) => void, onFrameCallBack?: (status: FrameAnimationStatus, context: any) => void): FrameAnimation;
    on(type: any, listener: EventedListener): void;
    once(type: any, listener: EventedListener): void;
    off(type: any, listener: EventedListener): void;
    setOptions(options: PolylineArrowOptions): void;
    _updateLineStyle(options: any): void;
    getOptions(): PolylineArrowOptions;
    setColor(color: any): void;
    setOpacity(val: any): void;
    setWeight(val: any): void;
    setBorderColor(value: any): void;
    setBorderOpacity(val: any): void;
    setBorderWidth(weight: any): void;
    show(): void;
    hide(): void;
    addDir(): void;
    removeDir(): void;
    hideDir(): void;
    showDir(): void;
}

export  interface PolylineArrowOptions {
    minZoom?: number;
    maxZoom?: number;
    borderGapWidth?: number;
    lineGapWidth?: number;
    borderBlur?: number;
    lineBlur?: number;
    borderGradient?: string;
    lineGradient?: string;
    borderOffset?: number;
    lineOffset?: number;
    borderTranslateAnchor?: string;
    lineTranslateAnchor?: string;
    borderMiterLimit?: number;
    lineMiterLimit?: number;
    lineSortKey?: number;
    showDir?: boolean;
    lineCap?: string;
    lineColor?: string;
    lineWidth?: number;
    strokeDasharray?: number[];
    strokeImage?: string;
    lineJoin?: string;
    lineOpacity?: number;
    lineTranslate?: number[];
    showBorder?: boolean;
    borderWidth?: number;
    borderOpacity?: number;
    borderColor?: string;
    visible?: boolean;
    strokeStyle?: string;
    animated?: boolean;
    dirSize?: number;
    dirLayout?: object;
    dirIconColor?: string;
    dirSpacing?: number;
    beforeId?: string;
    cursor?: string;
    zIndex?: number;
    dirImageSrc?: string;
    dirImageWidth?: number;
    dirImageHeight?: number;
    dirImageColor?: string;
    map?: Map;
    path?: GeoPointLike[] | any;
}

/**
 * 
 * @param pts
 * @param options
 */
export  function polylineMarginToPolygon(pts: GeoPointLike[], options: {
    smoothFactor?: number;
    offset: number;
    arcSegments?: number;
}): any;

export  interface PolylineOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    lineCap?: DataDrivenPropertyValueSpecification<"butt" | "round" | "square">;
    lineJoin?: DataDrivenPropertyValueSpecification<"bevel" | "round" | "miter">;
    lineMiterMimit?: PropertyValueSpecificationEx<number>;
    lineRoundLimit?: PropertyValueSpecificationEx<number>;
    lineSortKey?: DataDrivenPropertyValueSpecification<number>;
    lineOpacity?: DataDrivenPropertyValueSpecification<number>;
    lineColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    lineTranslate?: PropertyValueSpecificationEx<[number, number]>;
    lineTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    lineWidth?: DataDrivenPropertyValueSpecification<number>;
    lineGapWidth?: DataDrivenPropertyValueSpecification<number>;
    lineOffset?: DataDrivenPropertyValueSpecification<number>;
    lineBlur?: DataDrivenPropertyValueSpecification<number>;
    lineDasharray?: DataDrivenPropertyValueSpecification<number[]>;
    linePattern?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    lineGradient?: ExpressionSpecificationEx;
}

/**
 * @description 
 * @param {CurvePoint[]} polyline 
 * @param {boolean} close    
 * @param {number} offsetA   A
 * @param {number} offsetB   B
 * @return {BezierCurve} false
 */
export  function polylineToBezierCurve(polyline: CurvePoint[], close?: boolean, offsetA?: number, offsetB?: number): BezierCurve;

/**
 * Position
 *
 * https://tools.ietf.org/html/rfc7946#section-3.1.1
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
 type Position = [number, number] | [number, number, number];

export  const progress: (from: number, to: number, value: number) => number;

/**
 * `GeoPoint` .
 */
export  abstract class Projection {
    /** The equatorial semi perimeter in meters. */
    static EQUATORIAL_SEMIPERIMETER: number;
    /** The equatorial semi perimeter in meters. */
    static EARTH_BOUNDS: [number, number, number, number];
    /**
     *  .
     */
    static lngLat2Mercator(input: GeoPointLike): [number, number];
    /**
     *  .
     */
    static mercator2LngLat(input: GeoPointLike): [number, number];
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    abstract toMercator(input: GeoPointLike): [number, number];
    /**
     * (epsg:3857)
     * @param input 
     * @return {[number, number]}
     */
    abstract fromMercator(input: GeoPointLike): [number, number];
    /**
     * 
     * @param input 
     * @return {[number, number]}
     */
    abstract toLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): LngLatLike;
    /**
     * 
     * @param input 
     * @return {GeoPoint}
     */
    abstract fromLngLat(input: GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[]): GeoJsonGeomertry | GeoPoint | GeoPointLike | GeoPointLike[];
    /**
     * 
     * @return {GeoBounds}
     */
    abstract getMapExtent(): GeoBounds;
    /**
     * 
     * @param dist
     */
    abstract toMeter(dist: number): number;
    /**
     * 
     * @param meter
     */
    abstract fromMeter(meter: number): number;
}

export  type PromoteIdSpecificationEx = Record<string, string> | string;

/**
 * Properties
 *
 * https://tools.ietf.org/html/rfc7946#section-3.2
 * A Feature object has a member with the name 'properties'.
 * The value of the properties member is an object (any JSON object or a JSON null value).
 */
 type Properties = {
    [name: string]: any;
} | null;

export  type PropertyValueSpecificationEx<T> = T | CameraFunctionSpecificationEx<T> | ExpressionSpecificationEx;

export  type PropName = string;

export  type PropValue = string | any[] | null | number | {};

export  namespace quat {
    export type valueType = quattype;
    /**
     * Creates a new identity quat
     *
     * @returns {quat} a new quaternion
     */
    export function create(): quattype;
    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.
     *
     * Both vectors are assumed to be unit length.
     *
     * @param {quat} out the receiving quaternion.
     * @param {vec3} a the initial vector
     * @param {vec3} b the destination vector
     * @returns {quat} out
     */
    export function rotationTo(out: quattype, a: vec3type, b: vec3type): quattype;
    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
     * perpendicular to all other specified axes.
     *
     * @param {vec3} view  the vector representing the viewing direction
     * @param {vec3} right the vector representing the local "right" direction
     * @param {vec3} up    the vector representing the local "up" direction
     * @returns {quat} out
     */
    export function setAxes(out: quattype, view: vec3type, right: vec3type, up: vec3type): quattype;
    /**
     * Creates a new quat initialized with values from an existing quaternion
     *
     * @param {quat} a quaternion to clone
     * @returns {quat} a new quaternion
     * @function
     */
    const clone: typeof vec4.clone;
    /**
     * Creates a new quat initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} a new quaternion
     * @function
     */
    const fromValues: typeof vec4.fromValues;
    /**
     * Copy the values from one quat to another
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the source quaternion
     * @returns {quat} out
     * @function
     */
    const copy: typeof vec4.copy;
    /**
     * Set the components of a quat to the given values
     *
     * @param {quat} out the receiving quaternion
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} out
     * @function
     */
    const set: typeof vec4.set;
    /**
     * Set a quat to the identity quaternion
     *
     * @param {quat} out the receiving quaternion
     * @returns {quat} out
     */
    export function identity(out: quattype): quattype;
    /**
     * Sets a quat from the given angle and rotation axis,
     * then returns it.
     *
     * @param {quat} out the receiving quaternion
     * @param {vec3} axis the axis around which to rotate
     * @param {Number} rad the angle in radians
     * @returns {quat} out
     */
    export function setAxisAngle(out: quattype, axis: vec3type, rad: number): quattype;
    /**
     * Gets the rotation axis and angle for a given
     *  quaternion. If a quaternion is created with
     *  setAxisAngle, this method will return the same
     *  values as providied in the original parameter list
     *  OR functionally equivalent values.
     * Example: The quaternion formed by axis [0, 0, 1] and
     *  angle -90 is the same as the quaternion formed by
     *  [0, 0, 1] and 270. This method favors the latter.
     * @param  {vec3} outAxis  Vector receiving the axis of rotation
     * @param  {quat} q     Quaternion to be decomposed
     * @return {Number}     Angle, in radians, of the rotation
     */
    export function getAxisAngle(outAxis: vec3type, q: quattype): number;
    /**
     * Adds two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     * @function
     */
    const add: typeof vec4.add;
    /**
     * Multiplies two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     */
    export function multiply(out: quattype, a: quattype, b: quattype): quattype;
    /**
     * Alias for {@link quat.multiply}
     * @function
     */
    /**
     * Scales a quat by a scalar number
     *
     * @param {quat} out the receiving vector
     * @param {quat} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {quat} out
     * @function
     */
    const scale: typeof vec4.scale;
    /**
     * Rotates a quaternion by the given angle about the X axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateX(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Rotates a quaternion by the given angle about the Y axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateY(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Rotates a quaternion by the given angle about the Z axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    export function rotateZ(out: quattype, a: quattype, rad: number): quattype;
    /**
     * Calculates the W component of a quat from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate W component of
     * @returns {quat} out
     */
    export function calculateW(out: quattype, a: quattype): quattype;
    /**
     * Calculates the dot product of two quat's
     *
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {Number} dot product of a and b
     * @function
     */
    const dot: typeof vec4.dot;
    /**
     * Performs a linear interpolation between two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     * @function
     */
    const lerp: typeof vec4.lerp;
    /**
     * Performs a spherical linear interpolation between two quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     */
    export function slerp(out: quattype, a: quattype, b: quattype, t: number): quattype;
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {quat} c the third operand
     * @param {quat} d the fourth operand
     * @param {Number} t interpolation amount
     * @returns {quat} out
     */
    export function sqlerp(out: quattype, a: quattype, b: quattype, c: quattype, d: quattype, t: number): quattype;
    /**
     * Calculates the inverse of a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate inverse of
     * @returns {quat} out
     */
    export function invert(out: quattype, a: quattype): quattype;
    /**
     * Calculates the conjugate of a quat
     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate conjugate of
     * @returns {quat} out
     */
    export function conjugate(out: quattype, a: quattype): quattype;
    /**
     * Calculates the length of a quat
     *
     * @param {quat} a vector to calculate length of
     * @returns {Number} length of a
     * @function
     */
    const length: typeof vec4.length;
    /**
     * Alias for {@link quat.length}
     * @function
     */
    /**
     * Calculates the squared length of a quat
     *
     * @param {quat} a vector to calculate squared length of
     * @returns {Number} squared length of a
     * @function
     */
    const squaredLength: typeof vec4.squaredLength;
    /**
     * Alias for {@link quat.squaredLength}
     * @function
     */
    /**
     * Normalize a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quaternion to normalize
     * @returns {quat} out
     * @function
     */
    const normalize: typeof vec4.normalize;
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     *
     * NOTE: The resultant quaternion is not normalized, so you should be sure
     * to renormalize the quaternion yourself where necessary.
     *
     * @param {quat} out the receiving quaternion
     * @param {mat3} m rotation matrix
     * @returns {quat} out
     * @function
     */
    export function fromMat3(out: quattype, m: mat3type): quattype;
    /**
     * Returns a string representation of a quatenion
     *
     * @param {quat} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: quattype): string;
    /**
     * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
     *
     * @param {quat} a The first quaternion.
     * @param {quat} b The second quaternion.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    const exactEquals: typeof vec4.exactEquals;
    /**
     * Returns whether or not the quaternions have approximately the same elements in the same position.
     *
     * @param {quat} a The first vector.
     * @param {quat} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    const equals: typeof vec4.equals;
}

export  type quattype = [number, number, number, number] | Float32Array;

export  const radiansToDegrees: (radians: number) => number;

/**
 * 
 * @param a
 */
export  function radToDeg(a: number): number;

/**
 * 
 * @param n
 * @param m
 * @return {number}
 */
export  function randInt(n: number, m: number): number;

/**
 * 
 * @return {string}
 */
export  function randomColor(): string;

/**
 * ID
 * @param length
 * @return {string}
 */
export  function RandomID(length?: number): string;

export  type RasterDEMSourceSpecification = {
    type: "raster-dem";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    minzoom?: number;
    maxzoom?: number;
    tileSize?: number;
    attribution?: string;
    encoding?: "terrarium";
    volatile?: boolean;
};

export  enum RasterImageUnits {
    /** No measurement units are used. */
    kNone = 0,
    /** Millimeters are used. */
    kMillimeter = 1,
    /** Centimeters are used. */
    kCentimeter = 2,
    /** Meters are used. */
    kMeter = 3,
    /** Kilometers are used. */
    kKilometer = 4,
    /** Inches are used. */
    kInch = 5,
    /** Foots are used. */
    kFoot = 6,
    /** Yards are used. */
    kYard = 7,
    /** Miles are used. */
    kMile = 8,
    /** Microinches are used. */
    kMicroinches = 9,
    /** Mils (thousandths of an inch) are used. */
    kMils = 10,
    /** Angstroms (10^-10 of a meter or ten-billionths of a meter) are used. */
    kAngstroms = 11,
    /** Nanometers are used. */
    kNanometers = 12,
    /** Microns are used. */
    kMicrons = 13,
    /** Decimeters are used. */
    kDecimeters = 14,
    /** Dekameters (10 meters) are used. */
    kDekameters = 15,
    /** Hectometers (10^2 meters) are used. */
    kHectometers = 16,
    /** Gigameters (10^9 meters) are used. */
    kGigameters = 17,
    /** Astronominal units (149597870700 meters) are used. */
    kAstronomical = 18,
    /** Light years (9460730472580800 meters) are used. */
    kLightYears = 19,
    /** Parsecs (approx 3.261563777 light years) are used. */
    kParsecs = 20
}

export  type RasterLayerSpecification = {
    id: string;
    type: "raster";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "raster-opacity"?: PropertyValueSpecificationEx<number>;
        "raster-hue-rotate"?: PropertyValueSpecificationEx<number>;
        "raster-brightness-min"?: PropertyValueSpecificationEx<number>;
        "raster-brightness-max"?: PropertyValueSpecificationEx<number>;
        "raster-saturation"?: PropertyValueSpecificationEx<number>;
        "raster-contrast"?: PropertyValueSpecificationEx<number>;
        "raster-resampling"?: PropertyValueSpecificationEx<"linear" | "nearest">;
        "raster-fade-duration"?: PropertyValueSpecificationEx<number>;
    };
};

export  type RasterLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    visibility?: "visible" | "none";
    rasterOpacity?: PropertyValueSpecificationEx<number>;
    rasterHueRotate?: PropertyValueSpecificationEx<number>;
    rasterBrightnessMin?: PropertyValueSpecificationEx<number>;
    rasterBrightnessMax?: PropertyValueSpecificationEx<number>;
    rasterSaturation?: PropertyValueSpecificationEx<number>;
    rasterContrast?: PropertyValueSpecificationEx<number>;
    rasterResampling?: PropertyValueSpecificationEx<"linear" | "nearest">;
    rasterFadeDuration?: PropertyValueSpecificationEx<number>;
};

export  type RasterSourceSpecification = {
    type: "raster";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    minzoom?: number;
    maxzoom?: number;
    tileSize?: number;
    scheme?: "xyz" | "tms";
    attribution?: string;
    volatile?: boolean;
};

export  abstract class ReglBaseLayer extends Evented implements CustomLayerInterface {
    id: string;
    type: 'custom';
    map: Map;
    regl: any;
    renderAnimation?: boolean;
    protected abstract getReglInitialization(gl: WebGLRenderingContext): any;
    protected abstract init(map: Map, gl: WebGLRenderingContext): void;
    protected abstract frame(gl: WebGLRenderingContext, matrix: Array<number>, context?: any): void;
    protected abstract remove(map: Map, gl: WebGLRenderingContext): void;
    triggerRepaint(): void;
    onAdd(map: Map, gl: WebGLRenderingContext): void;
    onRemove(map: Map, gl: WebGLRenderingContext): void;
    /**
     * NOTE: map won't call it every frame.
     *
     * @param gl
     * @param matrix
     */
    render(gl: WebGLRenderingContext, matrix: Array<number>): void;
    prerender(gl: WebGLRenderingContext, matrix: Array<number>): void;
}

export  type ResolvedImageSpecification = string;

 interface Response_2 {
    status: number;
    response: Record<string, unknown>;
    data?: string | Record<string, unknown>;
    xhr: XMLHttpRequest;
}
export { Response_2 as Response }

export  const reverseEasing: EasingModifier;

/**
 * .
 */
export  class RotatingApertureMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    private _createMakerElement;
    private _getDotsStyleObj;
}

/**
 * .
 */
export  class RotatingTextBorderMarker extends MarkerBase {
    constructor(features: FeatureCollection | {
        lngLat: LngLatLike;
        text?: string;
    }, options?: AnimateMarkerLayerOption);
    setMarkersWidth(width: number): void;
    setMarkersHeight(height: number): void;
    setMarkersTextField(textField: string, index?: number): void;
    setMarkersTextColor(textColor: string, index?: number): void;
    setMarkersTextFontSize(textFontSize: number, index?: number): void;
    setMarkersColors(colors: string[], index?: number): void;
    _createMarker(): void;
    _setMarkerContainerProperty(properties: any, index?: number): void;
}

/**
 * L7https://l7.antv.vision/.
 * 
 * @param L7 L7
 * @param map
 * @param option
 * @return {(L7: any, map: Map, option?: object) => any}
 **/
export  function Scene(L7: any, map: Map, option?: object): {
    getServiceContainer(): any;
    getSize(): [number, number];
    getMinZoom(): number;
    getMaxZoom(): number;
    getType(): string;
    getMapContainer(): HTMLElement | null;
    getMapCanvasContainer(): HTMLElement;
    getMapService(): any;
    exportPng(type?: 'png' | 'jpg'): string;
    exportMap(type?: 'png' | 'jpg'): string;
    registerRenderService(render: any): void;
    setBgColor(color: string): void;
    addLayer(layer: any): void;
    getLayers(): any[];
    getLayer(id: string): any | undefined;
    getLayerByName(name: string): any | undefined;
    removeLayer(layer: any, parentLayer?: any): void;
    removeAllLayer(): void;
    render(): void;
    setEnableRender(flag: boolean): void;
    /**
     *  layer/point/text  iconfont 
     * @param fontUnicode
     * @param name
     */
    addIconFont(name: string, fontUnicode: string): void;
    addIconFonts(options: string[][]): void;
    /**
     * 
     * @param fontFamily
     * @param fontPath
     */
    addFontFace(fontFamily: string, fontPath: string): void;
    addImage(id: string, img: any): void;
    hasImage(id: string): boolean;
    removeImage(id: string): void;
    addIconFontGlyphs(fontFamily: string, glyphs: any[]): void;
    addControl(ctr: any): void;
    removeControl(ctr: any): void;
    getControlByName(name: string): any | undefined;
    addMarker(marker: any): void;
    addMarkerLayer(layer: any): void;
    removeMarkerLayer(layer: any): void;
    removeAllMakers(): void;
    addPopup(popup: any): void;
    on(type: string, handle: (...args: any[]) => void): void;
    once(type: string, handle: (...args: any[]) => void): void;
    off(type: string, handle: (...args: any[]) => void): void;
    getZoom(): number;
    getCenter(options?: any): any;
    setCenter(center: [number, number], options?: any): void;
    getPitch(): number;
    setPitch(pitch: number): void;
    getRotation(): number;
    getBounds(): any;
    setRotation(rotation: number): void;
    zoomIn(): void;
    zoomOut(): void;
    panTo(p: any): void;
    panBy(x: number, y: number): void;
    getContainer(): HTMLElement | null;
    setZoom(zoom: number): void;
    fitBounds(bound: any, options?: unknown): void;
    setZoomAndCenter(zoom: number, center: any): void;
    setMapStyle(style: any): void;
    setMapStatus(options: Partial<any>): void;
    pixelToLngLat(pixel: any): any;
    lngLatToPixel(lnglat: any): any;
    containerToLngLat(pixel: any): any;
    lngLatToContainer(lnglat: any): any;
    destroy(): void;
    registerPostProcessingPass(constructor: new (...args: any[]) => any, name: string): void;
    enableShaderPick(): void;
    diasbleShaderPick(): void;
    getPointSizeRange(): Float32Array;
};

export  interface ScriptDefaultOptions {
    src: string;
    strategy?: string;
    injectLocation?: string;
    async?: boolean;
}

/**
 * 
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param x3
 * @param y3
 * @param x4
 * @param y4
 * @return {{result: string, status: boolean} | {result: string, status: boolean} | {x: number, y: number, status: boolean, ratio: number} | {result: string, status: boolean}}
 */
export  function segmentIntersect(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): {
    result: string;
    status: boolean;
    x?: undefined;
    y?: undefined;
    ratio?: undefined;
} | {
    status: boolean;
    x: number;
    y: number;
    ratio: number;
    result?: undefined;
};

 interface Serialized {
    nodes: Array<{
        id: NodeId;
    }>;
    links: Array<{
        source: NodeId;
        target: NodeId;
        weight: EdgeWeight;
    }>;
}

/**
 * `Service` .
 *
 */
export  class Service {
    /**
     * 
     * @type {string}
     */
    serverUrl: string;
    /**
     * 
     * @type {string}
     */
    accessToken: string;
    private readonly _reqImpl;
    private _cur_map_param;
    private _svr_url_map;
    private readonly _svr_url_service;
    private _secretKeys?;
    private _accessKeys?;
    private _workspaceName?;
    /**
     * 
     * @param url 
     * @param token 
     * @param req )
     */
    constructor(url: string, token?: string, req?: IRequest);
    private _url;
    /**
     * 
     * @param isCloneWorkspace  ()
     * @return Service
     */
    clone(isCloneWorkspace?: boolean): Service;
    /**
     * 
     * @param u 
     * @return string
     */
    serviceUrl(u: string): string;
    /**
     * 
     * @param workspaceName 
     * @return
     */
    switchWorkspace(workspaceName: string): void;
    /**
     * 
     * @return
     */
    getCurWorkspaceName(): string;
    /**
     * (roottoken)
     * @return
     */
    getWorkspaces(): Promise<any>;
    /**
     * (root)
     * @param workspace 
     * @return
     */
    workspaceCreate(workspace: IWorkspace): Promise<any>;
    /**
     * (root)
     * @param workspace 
     * @return
     */
    workspaceModify(workspace: IWorkspace): Promise<any>;
    /**
     * (root)
     * @param name 
     * @return
     */
    workspaceDelete(name: string): Promise<any>;
    /**
     * 
     * @param pwd 
     */
    pwdToSecretKey(pwd: string): string;
    /**
     * key
     * @param key key
     */
    addSecretKey(key: string): Set<string>;
    /**
     * key, keyundefined
     * @param key key
     */
    removeSecretKey(key: string): Set<string> | undefined;
    /**
     * key
     * @param key key
     */
    addAccessKey(key: string): Set<string>;
    /**
     * key, keyundefined
     * @param key key
     */
    removeAccessKey(key: string): void;
    private _to_layer_string;
    private _addTokenHeader;
    private _get;
    private _post;
    private _del;
    /**
     * 
     * @param layernames 
     * @param layers 
     * @return {number[]}
     */
    toLayerIndex(layernames: string[], layers: any[]): number[];
    private _waitOpenMap;
    /**
     * 
     */
    setCurrentMapParam(param: IOpenMapResponse): IOpenMapResponse | null;
    /**
     * 
     */
    currentMapParam(): IOpenMapResponse | null;
    /**
     * 
     * @param param
     * @param isWaitFinish 
     * @return {Promise<any>}
     */
    openMap(param: IOpenMapParam, isWaitFinish?: boolean): Promise<any>;
    /**
     * 
     * @param param
     * @param isWaitFinish 
     */
    updateMap(param: IUpdateMapParam, isWaitFinish?: boolean): Promise<any>;
    /**
     * 
     * @param param
     */
    glyphsUrl(): string;
    /**
     * 
     */
    baseUrl(): string;
    /**
     * 
     * @param name 
     */
    spriteUrl(name: string): string;
    /**
     * 
     * @param name 
     */
    setSprite(name: string): string;
    /**
     * 
     */
    blankTileUrl(): string;
    /**
     * 
     * @param content 
     * @param size 256
     */
    qrcodeUrl(content: string, size?: number): string;
    /**
     * 
     * @param param
     */
    rasterTileUrl(param?: ITileUrlParam): string;
    /**
     * 
     * @param param
     */
    vectorTileUrl(param?: ITileUrlParam): string;
    /**
     * 
     * @param filemd5 md5
     */
    checkFileHasUpload(filemd5: string): Promise<any>;
    /**
     * url
     * @return {string}
     */
    uploadUrl(): string;
    /**
     * Md5
     * @param str
     * @return {string}
     */
    strMd5(str: string): string;
    /**
     * style
     */
    styleVersion(): number;
    /**
     * Md5
     * @param file
     * @return {Promise<any>}
     */
    fileMd5(file: File): Promise<any>;
    /**
     * 
     * @param file
     * @return {Promise<any>}
     */
    uploadMap(file: File): Promise<any>;
    /**
     * 
     * @return {string}
     */
    execCommand(cmdname: string, param?: Record<string, any>, mapid?: string, version?: string, useGet?: boolean): Promise<any>;
    /**
     * 
     * @param mapid ID , 
     * @param version  ;
     */
    metadata(mapid?: string, version?: string): Promise<any>;
    /**
     * 
     * @param meta 
     * @param mapid ID , 
     * @param version  ;
     */
    updateMetadata(meta: Record<string, number | boolean | string | undefined | null>, mapid?: string, version?: string): Promise<any>;
    /**
     * 
     * @param mapid IDIDID{curPage: 1, pageCount: 10}
     * @param version ; * 
     */
    listMaps(mapid?: string | string[] | {
        curPage: number;
        pageCount: number;
        mapIds?: string[];
    }, version?: string): Promise<any>;
    /**
     * 
     * @param mapid ID
     * @param version 
     * @param tryTime ()
     * @param maxTryTimes 
     * @return {Promise<void>}
     */
    waitMapOpenFinish(mapid: string, version: string, tryTime?: number, maxTryTimes?: number): Promise<any>;
    /**
     * 
     * @param param 
     * @param cb 
     */
    processQueryResult(param: any, cb?: (point: [number, number]) => [number, number] | null | undefined): any;
    /**
     * 
     * @private
     */
    private _processQueryResult;
    /**
     * 
     * @param param 
     * @param cb 
     */
    pointQueryFeature(param: IPointQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 
     * @param param 
     * @param cb 
     */
    rectQueryFeature(param: IRectQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 
     * @param param 
     * @param cb 
     */
    exprQueryFeature(param: IExprQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 
     * @param param 
     * @param cb 
     */
    conditionQueryFeature(param: IConditionQueryFeatures, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 
     */
    getMapLayers(): IMapLayer[];
    /**
     * 
     * @param visibleLayers 
     * @param expression 
     * @return {Promise<void>}
     */
    cmdSwitchLayers(visibleLayers: string[], expression?: string): Promise<any>;
    /**
     * 
     * @param param 
     * @return {Promise<any>}
     *
     *
     * Example:
     * ```typescript
     * const res = svc.cmdUpdateStyle({
     *     name: "style1",
     *     layeron: [0,1,2,4,5,6,7,8,9],
     *     layeroff: "",
     *     clipbounds: "",
     *     backcolor: 0,
     *     lineweight:[1,1,0]
     *     expression: "gOutColorRed := gInColorGreen;gOutColorGreen := gInColorBlue;gOutColorBlue := gInColorRed;gOutColorAlpha := gInColorAlpha;"
     * });
     * ```
     */
    cmdUpdateStyle(param: IUpdateStyle): Promise<any>;
    /**
     * 
     * @param param
     * @return {Promise<any>}
     */
    cmdSliceLayer(param: ISliceLayer): Promise<any>;
    /**
     * 
     * @param style 
     * @param mapid ID
     * @param version ;
     * @param isGeomLayer (true)
     * @return {Promise<any>}
     */
    createStyle(style: IMapStyleParam, mapid?: string, version?: string, isGeomLayer?: boolean): Promise<any>;
    /**
     * 
     * @param param 
     * @return {Promise<any>}
     */
    getSliceCacheZoom(param: ISliceCacheZoom): Promise<any>;
    /**
     * 
     * @param mapid id
     * @param version 
     * @return {Promise<any>}
     */
    cmdGetDrawBounds(mapid?: string, version?: string): Promise<GeoBounds | null>;
    /**
     * 
     * @param mapid ID
     * @param version ;
     * @param isGeomLayer (true)
     * @param name ;
     * @return {Promise<any>}
     */
    getStyleLayerName(mapid: string, version?: string, isGeomLayer?: boolean, name?: string): Promise<any>;
    /**
     * 
     * @param mapid
     * @param version
     * @param width
     * @param height
     * @param darkTheme 
     */
    thumbnailUrl(mapid?: string, version?: string, width?: number, height?: number, darkTheme?: boolean): string;
    wmsTileUrl(param: IWmsTileUrl): string;
    /**
     * 
     * @return {Promise<any>}
     * @param mapid ID
     * @param version "*"
     * @param retainVersionMaxCount 10retainVersionMaxCount33
     */
    cmdDeleteMap(mapid: string, version: string, retainVersionMaxCount?: number): Promise<any>;
    /**
     * AccessKey
     * @param mapid ID
     * @param key secretKeysuperKey
     * @return {Promise<any>}
     */
    cmdGetAccessKey(mapid: string, key: string): Promise<any>;
    /**
     * AccessKey
     * @param mapid ID
     * @param key secretKeysuperKey
     * @return {Promise<any>}
     */
    cmdResetAccessKey(mapid: string, key: string): Promise<any>;
    /**
     * 
     * @param mapid ID
     * @param key secretKeysuperKey
     * @param newKey secretKey
     * @return {Promise<any>}
     */
    cmdSetMapPassword(mapid: string, key: string, newKey: string): Promise<any>;
    /**
     * ID
     * @return {Promise<any>}
     * @param oldMapID ID
     * @param newMapID ID
     */
    cmdRenameMap(oldMapID: string, newMapID: string): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param mapid ID
     * @param version 
     */
    cmdClearMapCache(mapid: string, version: string): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param mapid ID
     * @param version 
     */
    cmdClearTileCache(mapid: string, version: string): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param param 
     */
    cmdDeleteStyle(param: IDeleteStyle): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param param 
     */
    cmdDeleteCache(param: IDeleteCache): Promise<any>;
    /**
     * 
     * @param mapfileNames 
     * @return {Promise<any>}
     */
    cmdDeleteMapFile(mapfileNames: string | string[]): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param bDetail  (false)
     */
    cmdRunStatus(bDetail?: boolean): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     */
    cmdGetSupportFormat(): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     */
    getConstData(): Promise<any>;
    /**
     * style
     * @param minzoom 0
     * @param maxzoom 24
     * @param prefix rasterBlank
     */
    rasterBlankStyle(minzoom?: number, maxzoom?: number, prefix?: string): Style;
    /**
     * ID
     * @param prefix
     * @return {string}
     */
    rasterLayerId(prefix?: string): string;
    /**
     * ID
     * @param prefix
     * @return {string}
     */
    rasterSourceId(prefix?: string): string;
    /**
     * style
     * @param tileUrl 
     * @param minzoom 0
     * @param maxzoom 24
     * @param prefix raster
     */
    rasterStyle(tileUrl?: string, minzoom?: number, maxzoom?: number, prefix?: string): Style;
    /**
     * style
     * @param tileUrl  ObjectObject
     * @param minzoom 0
     * @param maxzoom 24
     * @param prefix vector
     * @param hoverColor rgba(0,0,255,255)
     * @param hoverOpacity ,0.5
     * @param hoverLineWidth ,3
     * @param customColorCaseExpr [12,...][['==', ['feature-state', 'status'], 'alarm'], '#ff0000', ['==', ['feature-state', 'status'], 'normal'], '#00ff00'],
     * @param customOpacityCaseExpr ,
     * @param customLineWidthCaseExpr ,
     * @param disableHover hover
     */
    vectorStyle(tileUrl?: string | Record<string, any>, minzoom?: number, maxzoom?: number, prefix?: string, hoverColor?: string, hoverOpacity?: number, hoverLineWidth?: number, customColorCaseExpr?: any[], customOpacityCaseExpr?: any[], customLineWidthCaseExpr?: any[], disableHover?: boolean): Style;
    /**
     * 
     * @return {Promise<any>}
     */
    getFontsCapacity(): Promise<{}>;
    /**
     * 
     * @return {Promise<any>}
     * @param prefix key
     */
    clearCache(prefix?: string): Promise<{}>;
    /**
     * 
     * @param tileProvider
     * @return {string}
     */
    webMapUrl(tileProvider: {
        tileCrs?: "gcj02" | "wgs84";
        tileSize?: number;
        tileRetina?: number;
        tileMaxZoom?: number;
        tileUrl: string | string[];
        tileShards?: string;
        tileToken?: string | string[];
        tileFlipY?: boolean;
        mapbounds?: string;
        fourParameterBefore?: string;
        fourParameterAfter?: string;
        srs?: string;
    }): string;
    /**
     * 
     * @param param 
     * @return {Promise<any>}
     */
    composeNewMap(param: IComposeNewMap | IComposeNewMap[]): Promise<any>;
    /**
     * 
     * @param param 
     * @return {Promise<any>}
     */
    cmdMapDiff(param: IMapDiff): Promise<any>;
    /**
     * dwg
     * @param param 
     * @return {Promise<any>}
     */
    cmdExportLayout(param: IExportLayout): Promise<any>;
    /**
     * 
     * @param param 
     * @return {Promise<any>}
     */
    cmdMatchObject(param: IMatchObject): Promise<any>;
    /**
     * 
     * @param param 
     * @param cb 
     * @return {Promise<any>}
     */
    cmdCreateEntitiesGeomData(param: ICreateEntitiesGeomData, cb?: (point: [number, number]) => [number, number] | null | undefined): Promise<any>;
    /**
     * 
     * @return {Promise<any>}
     * @param srs  EPSG:4326
     * @param crs  EPSG:3857
     * @param points 
     * @param fourParameter (x,y,)
     * @param isInverseFourParamter 
     */
    cmdTransform(srs: string, crs: string, points: GeoPoint | GeoPoint[], fourParameter?: string | string[], isInverseFourParamter?: boolean): Promise<any>;
    /**
     * prjWKTproj4
     * @return {Promise<any>}
     * @param srs prjWKT
     * @param from WKT
     */
    cmdPrjWktToPrj4(wkt: string, from?: undefined | "" | "wmsauto" | "xml" | "urn" | "crsurl" | "url" | "micoordsys" | "pci"): Promise<any>;
    /**
     * 
     * @param key (key)
     * @param value 
     * @param prop 
     * @param ttl 
     */
    saveCustomData(key: string | {
        key: string;
        value: any;
        prop?: any;
        ttl?: number;
    }[], value?: any, prop?: any, ttl?: number): Promise<any>;
    /**
     * 
     * @param key .
     * @param options  retDataType,"value""prop"contentType,json"image".
     */
    getCustomData(key: string | string[], options?: {
        retDataType?: "" | "value" | "prop";
        contentType?: "" | "image";
    }): Promise<any>;
    /**
     * 
     * @param prefix 
     */
    getCustomDataKeysByPrefix(prefix: string): Promise<any>;
    /**
     * 
     * @param key 
     * @param isPrefix keyfalse
     */
    deleteCustomData(key: string | string[], isPrefix?: boolean): Promise<any>;
}

/**
 * 
 * @param points
 * @param tolerance
 * @return {GeoPoint[]}
 */
export  function simplify(points: GeoPoint[], tolerance?: number): GeoPoint[];

/**
 * .
 *
 **/
export  class SkyLayer extends OverlayLayerBase {
    options: SkyLayerOptions;
    constructor(options: SkyLayerOptions);
    addTo(map: Map, beforeId?: string): void;
    setSkyType(value: PropertyValueSpecificationEx<"gradient" | "atmosphere">): this;
    getSkyType(): PropertyValueSpecificationEx<"gradient" | "atmosphere">;
    setSkyAtmosphereSun(value: PropertyValueSpecificationEx<[number, number]>): this;
    getSkyAtmosphereSun(): PropertyValueSpecificationEx<[number, number]>;
    setSkyAtmosphereSunIntensity(value: number): this;
    getSkyAtmosphereSunIntensity(): number;
    setSkyGradientCenter(value: PropertyValueSpecificationEx<[number, number]>): this;
    getSkyGradientCenter(): PropertyValueSpecificationEx<[number, number]>;
    setSkyGradientRadius(value: PropertyValueSpecificationEx<number>): this;
    getSkyGradientRadius(): PropertyValueSpecificationEx<number>;
    setSkyGradient(value: ExpressionSpecificationEx): this;
    getSkyGradient(): ExpressionSpecificationEx;
    setSkyAtmosphereHaloColor(value: ColorSpecification): this;
    getSkyAtmosphereHaloColor(): ColorSpecification;
    setSkyAtmosphereColor(value: ColorSpecification): this;
    getSkyAtmosphereColor(): ColorSpecification;
    setSkyOpacity(value: PropertyValueSpecificationEx<number>): this;
    getSkyOpacity(): PropertyValueSpecificationEx<number>;
}

export  interface SkyLayerOptions extends OverlayLayerBaseOptions {
    skyType?: PropertyValueSpecificationEx<"gradient" | "atmosphere">;
    skyAtmosphereSun?: PropertyValueSpecificationEx<[number, number]>;
    skyAtmosphereSunIntensity?: number;
    skyGradientCenter?: PropertyValueSpecificationEx<[number, number]>;
    skyGradientRadius?: PropertyValueSpecificationEx<number>;
    skyGradient?: ExpressionSpecificationEx;
    skyAtmosphereHaloColor?: ColorSpecification;
    skyAtmosphereColor?: ColorSpecification;
    skyOpacity?: PropertyValueSpecificationEx<number>;
}

export  type SkyLayerSpecification = {
    id: string;
    type: "sky";
    metadata?: unknown;
    minzoom?: number;
    maxzoom?: number;
    layout?: {
        visibility?: "visible" | "none";
    };
    paint?: {
        "sky-type"?: PropertyValueSpecificationEx<"gradient" | "atmosphere">;
        "sky-atmosphere-sun"?: PropertyValueSpecificationEx<[number, number]>;
        "sky-atmosphere-sun-intensity"?: number;
        "sky-gradient-center"?: PropertyValueSpecificationEx<[number, number]>;
        "sky-gradient-radius"?: PropertyValueSpecificationEx<number>;
        "sky-gradient"?: ExpressionSpecificationEx;
        "sky-atmosphere-halo-color"?: ColorSpecification;
        "sky-atmosphere-color"?: ColorSpecification;
        "sky-opacity"?: PropertyValueSpecificationEx<number>;
    };
};

export  const smooth: (strength?: number) => (v: number) => number;

export  const smoothFrame: (prevValue: number, nextValue: number, duration: number, smoothing?: number) => number;

export  const snap: (points: number | number[]) => (v: number) => number | undefined;

export  type SourceBoundUtils = MapGlUtils;

export  type SourceFunctionSpecification<T> = {
    type: "exponential";
    stops: Array<[number, T]>;
    property: string;
    default?: T;
} | {
    type: "interval";
    stops: Array<[number, T]>;
    property: string;
    default?: T;
} | {
    type: "categorical";
    stops: Array<[string | number | boolean, T]>;
    property: string;
    default?: T;
} | {
    type: "identity";
    property: string;
    default?: T;
};

export  type SourceOrData = SourceSpecification | string | GeoJsonGeomertry;

export  type SourceRef = LayerRef;

export  type SourceRefFunc0 = (arg0: SourceRef) => void;

export  type SourceRefFunc1<T1> = (arg0: SourceRef, arg1: T1) => void;

export  type SourceRefFunc2<T1, T2> = (arg0: SourceRef, arg1: T1, arg2: T2) => void;

export  type SourceRefFunc3<T1, T2, T3> = (arg0: SourceRef, arg1: T1, arg2: T2, arg3: T3) => void;

export  type SourceSpecification = VectorSourceSpecification | RasterSourceSpecification | RasterDEMSourceSpecification | GeoJSONSourceSpecification | VideoSourceSpecification | ImageSourceSpecification;

/**
 * This is based on the spring implementation of Wobble https://github.com/skevy/wobble
 */
export  function spring({ from, to, restSpeed, restDelta, ...options }: SpringOptions): any;

export  namespace spring {
    var needsInterpolation: (a: any, b: any) => boolean;
}

export  interface SpringOptions extends PhysicsSpringOptions {
    from?: number;
    to?: number;
    duration?: number;
    bounce?: number;
    restSpeed?: number;
    restDelta?: number;
}

export  const steps: (steps: number, direction?: Direction) => Easing;

export  type StyleSpecification = {
    version: 8;
    name?: string;
    metadata?: unknown;
    center?: Array<number>;
    zoom?: number;
    bearing?: number;
    pitch?: number;
    light?: LightSpecification;
    terrain?: TerrainSpecificationEx;
    fog?: FogSpecification;
    sources: Record<string, SourceSpecification>;
    sprite?: string;
    glyphs?: string;
    transition?: TransitionSpecification;
    layers: Array<LayerSpecification>;
};

export  interface SvgElementOptions {
    /**  {{x,y}}{{r}} */
    html: string;
    /**  */
    event?: (svgParentElement: SVGSVGElement) => {};
    /**  */
    bounds?: GeoBounds | [number, number, number, number];
    /**   */
    hidden?: boolean;
    /**   */
    minZoom?: number;
    /**   */
    maxZoom?: boolean;
    /**  id */
    id?: string | number;
}

/**
 * svg(svg)
 **/
export  class SvgOverlay {
    options: SvgOverlayOptions;
    divOverlay: DivOverlay;
    elements: SvgElementOptions[];
    private _map;
    private bounds;
    private svgParentElement;
    constructor(options?: SvgOverlayOptions);
    addTo(map: Map, insertId?: string | HTMLElement): void;
    remove(): void;
    /**
     * svg
     * @param element 
     * @param noUpdate 
     */
    addElement(element: SvgElementOptions | string, noUpdate?: boolean): void;
    /**
     * svg
     * @param elements 
     * @param noUpdate 
     */
    addElements(elements: SvgElementOptions[], noUpdate?: boolean): void;
    /**
     * svg
     */
    getSvgContainer(): SVGSVGElement;
    /**
     * 
     */
    getElements(): SvgElementOptions[];
    /**
     * 
     */
    removeElements(id: string[] | string): SvgElementOptions[];
    /**
     * 
     */
    updateElements(elements: SvgElementOptions[] | SvgElementOptions): SvgElementOptions[];
    /**
     * 
     */
    private update;
    /**
     * 
     */
    static attr_cx_cy_r(cx: number, cy: number, r: number): string;
    /**
     * 
     */
    static attr_cx_cy_rx_ry(cx: number, cy: number, rx: number, ry: number): string;
    /**
     * 
     */
    static attr_x1_y1_x2_y2(x1: number, y1: number, x2: number, y2: number): string;
    /**
     * 
     */
    static attr_x_y_w_h(x: number, y: number, w: number, h: number): string;
    /**
     * 
     */
    static attr_x_y(x: number, y: number): string;
    /**
     * 
     */
    static attr_fontsize(fontsize: number): string;
    /**
     * 
     */
    static attr_length(len: number): string;
    /**
     * 
     */
    static attr_point(point: GeoPoint, joinComma?: boolean): string;
    /**
     * 
     */
    static attr_points(points: GeoPoint[]): string;
    /**
     * 
     */
    static attr_path(points: GeoPoint[]): string;
}

export  interface SvgOverlayOptions {
    /**  */
    minZoom?: number;
    /**  */
    maxZoom?: number;
    /**  */
    maxPitch?: number;
    /** divsvgtrue) */
    updateDivSize?: boolean;
    /** divdiv */
    maxDivSize?: number;
    /**  */
    noUpdateBoundsWhenMoveend?: boolean;
    /**  */
    divClassName?: string;
    /** svg,1000 */
    svgMaxWidth?: number;
    /** svg,1000 */
    svgMaxHeight?: number;
    /** svgOffset,100 */
    svgOffset?: number;
}

/**
 * .
 *
 **/
 class Symbol_2 extends OverlayLayerBase {
    options: SymbolOptions;
    constructor(options: SymbolOptions);
    addTo(map: Map, beforeId?: string): void;
    /**  GeoJSON 
     @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
     */
    setData(data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any): void;
    setSymbolPlacement(value: PropertyValueSpecificationEx<"point" | "line" | "line-center">): this;
    getSymbolPlacement(): PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    setSymbolSpacing(value: PropertyValueSpecificationEx<number>): this;
    getSymbolSpacing(): PropertyValueSpecificationEx<number>;
    setSymbolAvoidEdges(value: PropertyValueSpecificationEx<boolean>): this;
    getSymbolAvoidEdges(): PropertyValueSpecificationEx<boolean>;
    setSymbolSortKey(value: DataDrivenPropertyValueSpecification<number>): this;
    getSymbolSortKey(): DataDrivenPropertyValueSpecification<number>;
    setSymbolZOrder(value: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">): this;
    getSymbolZOrder(): PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    setIconAllowOverlap(value: PropertyValueSpecificationEx<boolean>): this;
    getIconAllowOverlap(): PropertyValueSpecificationEx<boolean>;
    setIconIgnorePlacement(value: PropertyValueSpecificationEx<boolean>): this;
    getIconIgnorePlacement(): PropertyValueSpecificationEx<boolean>;
    setIconOptional(value: PropertyValueSpecificationEx<boolean>): this;
    getIconOptional(): PropertyValueSpecificationEx<boolean>;
    setIconRotationAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getIconRotationAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setIconSize(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconSize(): DataDrivenPropertyValueSpecification<number>;
    setIconTextFit(value: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">): this;
    getIconTextFit(): PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    setIconTextFitPadding(value: PropertyValueSpecificationEx<[number, number, number, number]>): this;
    getIconTextFitPadding(): PropertyValueSpecificationEx<[number, number, number, number]>;
    setIconImage(value: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>): this;
    getIconImage(): DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    setIconRotate(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconRotate(): DataDrivenPropertyValueSpecification<number>;
    setIconPadding(value: PropertyValueSpecificationEx<number>): this;
    getIconPadding(): PropertyValueSpecificationEx<number>;
    setIconKeepUpright(value: PropertyValueSpecificationEx<boolean>): this;
    getIconKeepUpright(): PropertyValueSpecificationEx<boolean>;
    setIconOffset(value: DataDrivenPropertyValueSpecification<[number, number]>): this;
    getIconOffset(): DataDrivenPropertyValueSpecification<[number, number]>;
    setIconAnchor(value: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">): this;
    getIconAnchor(): DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    setIconPitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getIconPitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextPitchAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getTextPitchAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextRotationAlignment(value: PropertyValueSpecificationEx<"map" | "viewport" | "auto">): this;
    getTextRotationAlignment(): PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    setTextField(value: DataDrivenPropertyValueSpecification<FormattedSpecification>): this;
    getTextField(): DataDrivenPropertyValueSpecification<FormattedSpecification>;
    setTextFont(value: DataDrivenPropertyValueSpecification<string[]>): this;
    getTextFont(): DataDrivenPropertyValueSpecification<string[]>;
    setTextSize(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextSize(): DataDrivenPropertyValueSpecification<number>;
    setTextMaxWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextMaxWidth(): DataDrivenPropertyValueSpecification<number>;
    setTextLineHeight(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextLineHeight(): DataDrivenPropertyValueSpecification<number>;
    setTextLetterSpacing(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextLetterSpacing(): DataDrivenPropertyValueSpecification<number>;
    setTextJustify(value: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">): this;
    getTextJustify(): DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    setTextRadialOffset(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextRadialOffset(): DataDrivenPropertyValueSpecification<number>;
    setTextVariableAnchor(value: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>): this;
    getTextVariableAnchor(): PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    setTextAnchor(value: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">): this;
    getTextAnchor(): DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    setTextMaxAngle(value: PropertyValueSpecificationEx<number>): this;
    getTextMaxAngle(): PropertyValueSpecificationEx<number>;
    setTextWritingMode(value: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>): this;
    getTextWritingMode(): PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    setTextRotate(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextRotate(): DataDrivenPropertyValueSpecification<number>;
    setTextPadding(value: PropertyValueSpecificationEx<number>): this;
    getTextPadding(): PropertyValueSpecificationEx<number>;
    setTextKeepUpright(value: PropertyValueSpecificationEx<boolean>): this;
    getTextKeepUpright(): PropertyValueSpecificationEx<boolean>;
    setTextTransform(value: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">): this;
    getTextTransform(): DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    setTextOffset(value: DataDrivenPropertyValueSpecification<[number, number]>): this;
    getTextOffset(): DataDrivenPropertyValueSpecification<[number, number]>;
    setTextAllowOverlap(value: PropertyValueSpecificationEx<boolean>): this;
    getTextAllowOverlap(): PropertyValueSpecificationEx<boolean>;
    setTextIgnorePlacement(value: PropertyValueSpecificationEx<boolean>): this;
    getTextIgnorePlacement(): PropertyValueSpecificationEx<boolean>;
    setTextOptional(value: PropertyValueSpecificationEx<boolean>): this;
    getTextOptional(): PropertyValueSpecificationEx<boolean>;
    setIconOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconOpacity(): DataDrivenPropertyValueSpecification<number>;
    setIconColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getIconColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setIconHaloColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getIconHaloColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setIconHaloWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconHaloWidth(): DataDrivenPropertyValueSpecification<number>;
    setIconHaloBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getIconHaloBlur(): DataDrivenPropertyValueSpecification<number>;
    setIconTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getIconTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setIconTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getIconTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
    setTextOpacity(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextOpacity(): DataDrivenPropertyValueSpecification<number>;
    setTextColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getTextColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setTextHaloColor(value: DataDrivenPropertyValueSpecification<ColorSpecification>): this;
    getTextHaloColor(): DataDrivenPropertyValueSpecification<ColorSpecification>;
    setTextHaloWidth(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextHaloWidth(): DataDrivenPropertyValueSpecification<number>;
    setTextHaloBlur(value: DataDrivenPropertyValueSpecification<number>): this;
    getTextHaloBlur(): DataDrivenPropertyValueSpecification<number>;
    setTextTranslate(value: PropertyValueSpecificationEx<[number, number]>): this;
    getTextTranslate(): PropertyValueSpecificationEx<[number, number]>;
    setTextTranslateAnchor(value: PropertyValueSpecificationEx<"map" | "viewport">): this;
    getTextTranslateAnchor(): PropertyValueSpecificationEx<"map" | "viewport">;
}
export { Symbol_2 as Symbol }

export  type SymbolLayerSpecification = {
    id: string;
    type: "symbol";
    metadata?: unknown;
    source: string;
    "source-layer"?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    layout?: {
        "symbol-placement"?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
        "symbol-spacing"?: PropertyValueSpecificationEx<number>;
        "symbol-avoid-edges"?: PropertyValueSpecificationEx<boolean>;
        "symbol-sort-key"?: DataDrivenPropertyValueSpecification<number>;
        "symbol-z-order"?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
        "icon-allow-overlap"?: PropertyValueSpecificationEx<boolean>;
        "icon-ignore-placement"?: PropertyValueSpecificationEx<boolean>;
        "icon-optional"?: PropertyValueSpecificationEx<boolean>;
        "icon-rotation-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "icon-size"?: DataDrivenPropertyValueSpecification<number>;
        "icon-text-fit"?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
        "icon-text-fit-padding"?: PropertyValueSpecificationEx<[number, number, number, number]>;
        "icon-image"?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
        "icon-rotate"?: DataDrivenPropertyValueSpecification<number>;
        "icon-padding"?: PropertyValueSpecificationEx<number>;
        "icon-keep-upright"?: PropertyValueSpecificationEx<boolean>;
        "icon-offset"?: DataDrivenPropertyValueSpecification<[number, number]>;
        "icon-anchor"?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
        "icon-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-pitch-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-rotation-alignment"?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
        "text-field"?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
        "text-font"?: DataDrivenPropertyValueSpecification<Array<string>>;
        "text-size"?: DataDrivenPropertyValueSpecification<number>;
        "text-max-width"?: DataDrivenPropertyValueSpecification<number>;
        "text-line-height"?: DataDrivenPropertyValueSpecification<number>;
        "text-letter-spacing"?: DataDrivenPropertyValueSpecification<number>;
        "text-justify"?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
        "text-radial-offset"?: DataDrivenPropertyValueSpecification<number>;
        "text-variable-anchor"?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
        "text-anchor"?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
        "text-max-angle"?: PropertyValueSpecificationEx<number>;
        "text-writing-mode"?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
        "text-rotate"?: DataDrivenPropertyValueSpecification<number>;
        "text-padding"?: PropertyValueSpecificationEx<number>;
        "text-keep-upright"?: PropertyValueSpecificationEx<boolean>;
        "text-transform"?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
        "text-offset"?: DataDrivenPropertyValueSpecification<[number, number]>;
        "text-allow-overlap"?: PropertyValueSpecificationEx<boolean>;
        "text-ignore-placement"?: PropertyValueSpecificationEx<boolean>;
        "text-optional"?: PropertyValueSpecificationEx<boolean>;
        visibility?: "visible" | "none";
    };
    paint?: {
        "icon-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "icon-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "icon-halo-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "icon-halo-width"?: DataDrivenPropertyValueSpecification<number>;
        "icon-halo-blur"?: DataDrivenPropertyValueSpecification<number>;
        "icon-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "icon-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
        "text-opacity"?: DataDrivenPropertyValueSpecification<number>;
        "text-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "text-halo-color"?: DataDrivenPropertyValueSpecification<ColorSpecification>;
        "text-halo-width"?: DataDrivenPropertyValueSpecification<number>;
        "text-halo-blur"?: DataDrivenPropertyValueSpecification<number>;
        "text-translate"?: PropertyValueSpecificationEx<[number, number]>;
        "text-translate-anchor"?: PropertyValueSpecificationEx<"map" | "viewport">;
    };
};

export  type SymbolLayerStyleProp = {
    metadata?: unknown;
    source?: string;
    sourceLayer?: string;
    minzoom?: number;
    maxzoom?: number;
    filter?: FilterSpecification;
    symbolPlacement?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    symbolSpacing?: PropertyValueSpecificationEx<number>;
    symbolAvoidEdges?: PropertyValueSpecificationEx<boolean>;
    symbolSortKey?: DataDrivenPropertyValueSpecification<number>;
    symbolZOrder?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    iconAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    iconIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    iconOptional?: PropertyValueSpecificationEx<boolean>;
    iconRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    iconSize?: DataDrivenPropertyValueSpecification<number>;
    iconTextFit?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    iconTextFitPadding?: PropertyValueSpecificationEx<[number, number, number, number]>;
    iconImage?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    iconRotate?: DataDrivenPropertyValueSpecification<number>;
    iconPadding?: PropertyValueSpecificationEx<number>;
    iconKeepUpright?: PropertyValueSpecificationEx<boolean>;
    iconOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    iconAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    iconPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textField?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
    textFont?: DataDrivenPropertyValueSpecification<Array<string>>;
    textSize?: DataDrivenPropertyValueSpecification<number>;
    textMaxWidth?: DataDrivenPropertyValueSpecification<number>;
    textLineHeight?: DataDrivenPropertyValueSpecification<number>;
    textLetterSpacing?: DataDrivenPropertyValueSpecification<number>;
    textJustify?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    textRadialOffset?: DataDrivenPropertyValueSpecification<number>;
    textVariableAnchor?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    textAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    textMaxAngle?: PropertyValueSpecificationEx<number>;
    textWritingMode?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    textRotate?: DataDrivenPropertyValueSpecification<number>;
    textPadding?: PropertyValueSpecificationEx<number>;
    textKeepUpright?: PropertyValueSpecificationEx<boolean>;
    textTransform?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    textOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    textAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    textIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    textOptional?: PropertyValueSpecificationEx<boolean>;
    visibility?: "visible" | "none";
    iconOpacity?: DataDrivenPropertyValueSpecification<number>;
    iconColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    iconHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    iconTranslate?: PropertyValueSpecificationEx<[number, number]>;
    iconTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    textOpacity?: DataDrivenPropertyValueSpecification<number>;
    textColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    textHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    textTranslate?: PropertyValueSpecificationEx<[number, number]>;
    textTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
};

export  interface SymbolOptions extends OverlayLayerBaseOptions {
    data: PointGeoJsonInput | PointGeoJsonInput[] | GeoJsonGeomertry | GeoPointLike | any;
    symbolPlacement?: PropertyValueSpecificationEx<"point" | "line" | "line-center">;
    symbolSpacing?: PropertyValueSpecificationEx<number>;
    symbolAvoidEdges?: PropertyValueSpecificationEx<boolean>;
    symbolSortKey?: DataDrivenPropertyValueSpecification<number>;
    symbolZOrder?: PropertyValueSpecificationEx<"auto" | "viewport-y" | "source">;
    iconAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    iconIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    iconOptional?: PropertyValueSpecificationEx<boolean>;
    iconRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    iconSize?: DataDrivenPropertyValueSpecification<number>;
    iconTextFit?: PropertyValueSpecificationEx<"none" | "width" | "height" | "both">;
    iconTextFitPadding?: PropertyValueSpecificationEx<[number, number, number, number]>;
    iconImage?: DataDrivenPropertyValueSpecification<ResolvedImageSpecification>;
    iconRotate?: DataDrivenPropertyValueSpecification<number>;
    iconPadding?: PropertyValueSpecificationEx<number>;
    iconKeepUpright?: PropertyValueSpecificationEx<boolean>;
    iconOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    iconAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    iconPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textPitchAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textRotationAlignment?: PropertyValueSpecificationEx<"map" | "viewport" | "auto">;
    textField?: DataDrivenPropertyValueSpecification<FormattedSpecification>;
    textFont?: DataDrivenPropertyValueSpecification<string[]>;
    textSize?: DataDrivenPropertyValueSpecification<number>;
    textMaxWidth?: DataDrivenPropertyValueSpecification<number>;
    textLineHeight?: DataDrivenPropertyValueSpecification<number>;
    textLetterSpacing?: DataDrivenPropertyValueSpecification<number>;
    textJustify?: DataDrivenPropertyValueSpecification<"auto" | "left" | "center" | "right">;
    textRadialOffset?: DataDrivenPropertyValueSpecification<number>;
    textVariableAnchor?: PropertyValueSpecificationEx<Array<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">>;
    textAnchor?: DataDrivenPropertyValueSpecification<"center" | "left" | "right" | "top" | "bottom" | "top-left" | "top-right" | "bottom-left" | "bottom-right">;
    textMaxAngle?: PropertyValueSpecificationEx<number>;
    textWritingMode?: PropertyValueSpecificationEx<Array<"horizontal" | "vertical">>;
    textRotate?: DataDrivenPropertyValueSpecification<number>;
    textPadding?: PropertyValueSpecificationEx<number>;
    textKeepUpright?: PropertyValueSpecificationEx<boolean>;
    textTransform?: DataDrivenPropertyValueSpecification<"none" | "uppercase" | "lowercase">;
    textOffset?: DataDrivenPropertyValueSpecification<[number, number]>;
    textAllowOverlap?: PropertyValueSpecificationEx<boolean>;
    textIgnorePlacement?: PropertyValueSpecificationEx<boolean>;
    textOptional?: PropertyValueSpecificationEx<boolean>;
    iconOpacity?: DataDrivenPropertyValueSpecification<number>;
    iconColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    iconHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    iconHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    iconTranslate?: PropertyValueSpecificationEx<[number, number]>;
    iconTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
    textOpacity?: DataDrivenPropertyValueSpecification<number>;
    textColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloColor?: DataDrivenPropertyValueSpecification<ColorSpecification>;
    textHaloWidth?: DataDrivenPropertyValueSpecification<number>;
    textHaloBlur?: DataDrivenPropertyValueSpecification<number>;
    textTranslate?: PropertyValueSpecificationEx<[number, number]>;
    textTranslateAnchor?: PropertyValueSpecificationEx<"map" | "viewport">;
}

/**
 * 
 *
 */
export  function syncMaps(...args: Map[]): () => void;

/**
 * 
 */
export  enum TableCellAlignment {
    kTopLeft = 1,
    kTopCenter = 2,
    kTopRight = 3,
    kMiddleLeft = 4,
    kMiddleCenter = 5,
    kMiddleRight = 6,
    kBottomLeft = 7,
    kBottomCenter = 8,
    kBottomRight = 9
}

export  type TerrainSpecificationEx = {
    source: string;
    exaggeration?: PropertyValueSpecificationEx<number>;
};

/**
 * .
 *
 * @param {Object} [options]
 * @param {object}  [options.text] 
 * @param {object}  [options.style] 
 * @param {HTMLElement} [options.element]  DOM 
 * @param {string} [options.anchor='center'] centertopbottomleftrighttop-lefttop-righttop-right .
 * @param {PointLike} [options.offset] .
 * @param {string} [options.color='#3FB1CE'] `options.element`.
 * @param {number} [options.scale=1] `options.element`.
 * @param {boolean} [options.draggable=false] .
 * @param {number} [options.clickTolerance=0] `clickTolerance`.
 * @param {number} [options.rotation=0] rotationAlignment.
 * @param {string} [options.pitchAlignment='auto'] `map`  `Text`  `viewport`  `Text`  `auto`  `rotationAlignment` .
 * @param {string} [options.rotationAlignment='auto'] `map`  `Text`  `viewport`  `Text`  `auto`  `viewport`.
 * @example
 * // Create a new Text.
 * const text = new vjmap.Text({text: "abc})
 *     .setLngLat([30.5, 50.5])
 *     .addTo(map);
 * @example
 * // Set text options.
 * const text = new vjmap.Text({
 *     text: "abc,
 *     draggable: true
 * }).setLngLat([30.5, 50.5])
 *     .addTo(map);
 */
 class Text_2 extends Evented {
    private readonly _marker;
    _textContainerDom: HTMLElement;
    _style: object;
    /**
     * 
     * @param options
     */
    constructor(options?: TextOptions);
    /**
     *  `Text`  `Map` 
     *
     * @param {Map}  map to add the text to.
     * @returns {Text} Returns itself to allow for method chaining.
     * @example
     * const text = new vjmap.Text({text: "abc"})
     *     .setLngLat([30.5, 50.5])
     *     .addTo(map); // add the text to the map
     */
    addTo(map: Map): Text_2;
    /**
     * 
     *
     * @example
     * const text = new vjmap.Text().addTo(map);
     * text.remove();
     * @returns {Text} Returns itself to allow for method chaining.
     */
    remove(): Text_2;
    /**
     * 
     * @return {any}
     */
    getLngLat(): LngLatLike;
    /**
     * 
     * @param lnglat
     * @return {this}
     */
    setLngLat(lnglat: LngLatLike): Text_2;
    /**
     *  `Text`  HTML 
     *
     * @returns {HTMLElement} Returns the text element.
     * @example
     * const element = text.getElement();
     */
    getElement(): HTMLElement;
    /**
     *  `Text`  Marker 
     */
    getMarker(): Marker;
    /**
     * Binds a `Popup` to the `Text`
     * @param popup
     * @return {this}
     */
    setPopup(popup?: Popup): Text_2;
    /**
     *  `Text`  `Popup` 
     *
     * @returns {Popup} Returns the popup.
     */
    getPopup(): Popup;
    /**
     *  `Popup`  `Text`  `Popup` .
     *
     * @returns {Text} Returns itself to allow for method chaining.
     */
    togglePopup(): Text_2;
    /**
     * .
     *
     * @returns {Point} The text's screen coordinates in pixels.
     */
    getOffset(): number;
    /**
     * .
     *
     * @param {PointLike} offset  PointLike 
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setOffset(offset: PointLike): Text_2;
    /**
     *  `draggable` .
     *
     * @param {boolean} [shouldBeDraggable=false] Turns drag functionality on/off.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setDraggable(shouldBeDraggable: boolean): Text_2;
    /**
     *  true
     *
     * @returns {boolean} True if the text is draggable.
     */
    isDraggable(): boolean;
    /**
     * Sets the `rotation` property of the text.
     *
     * @param {number} [rotation=0] .
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setRotation(rotation: number): Text_2;
    /**
     * .
     *
     * @returns {number} The current rotation angle of the text.
     */
    getRotation(): number;
    /**
     *  `rotationAlignment` .
     *
     * @param {string} [alignment='auto']  `rotationAlignment` .
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setRotationAlignment(alignment: string): this;
    /**
     *  `rotationAlignment` .
     *
     * @returns {string} The current rotational alignment of the text.
     */
    getRotationAlignment(): string;
    /**
     *  `pitchAlignment` .
     *
     * @param {string} [alignment]  `pitchAlignment` alignment'auto''rotationAlignment'.
     * @returns {Text} Returns itself to allow for method chaining.
     */
    setPitchAlignment(alignment: string): Text_2;
    /**
     *  `pitchAlignment` .
     *
     * @returns {string} The current pitch alignment of the text in degrees.
     */
    getPitchAlignment(): string;
    /**
     * 
     * @param animationType
     * MAP_ANIMATION_NONE 
     * MAP_ANIMATION_BOUNCE 
     * MAP_ANIMATION_DROP 
     */
    setAnimation(animationType: string): void;
    /**
     * 
     */
    show(): void;
    /**
     * 
     */
    hide(): void;
    /**
     * 
     * @param cur 
     */
    setCursor(cur: string): void;
    /**
     * 
     * @param txt
     */
    setText(txt: string): Text_2;
    /**
     * 
     */
    getText(): string;
    /**
     * 
     * @param style
     */
    setStyle(style?: object): Text_2;
    /**
     * 
     */
    getStyle(): object;
}
export { Text_2 as Text }

export  interface TextOptions extends MarkerOptions {
    /** . */
    text?: string;
    /** . */
    style?: object;
}

export  interface ThreeJsContext {
    repaint(): void;
    createSkyLayer(): void;
    createTerrainLayer(): void;
    sphere(options: any): any;
    line(options: any): any;
    label(options: any): any;
    tooltip(options: any): any;
    tube(options: any): any;
    extrusion(options: any): any;
    Object3D(options: any): any;
    projectToWorld(coords: any): any;
    unprojectFromWorld(v3: any): any;
    projectedUnitsPerMeter(lat: any): any;
    getFeatureCenter(feature: any, obj: any, level: number): any;
    getObjectHeightOnFloor(coords: any, obj: any, level: number): any;
    queryRenderedFeatures(point: any): any;
    findParent3DObject(mesh: any): any;
    setLayoutProperty(layerId: string, name: string, value: any): any;
    setLayerZoomRange(layerId: string, minZoomLayer: number, maxZoomLayer: number): any;
    setLayerHeigthProperty(layerId: string, level: number): any;
    setObjectsScale(): any;
    setStyle(styleId: string, options: any): any;
    toggleLayer(layerId: string, visible?: boolean): any;
    toggle(layerId: string, visible?: boolean): any;
    update(): any;
    add(obj: any, layerId?: string, sourceId?: string): any;
    removeByName(name: string): any;
    remove(obj: any): any;
    clear(layerId?: string, dispose?: boolean): any;
    removeLayer(layerId: string): any;
    getSunPosition(date: any, coords: any): any;
    getSunTimes(date: any, coords: any): any;
    setBuildingShadows(options: any): any;
    setSunlight(newDate: any, coords: any): any;
    getSunSky(date: any, sunPos: any): any;
    updateSunSky(sunPos: any): any;
    updateSunGround(sunPos: any): any;
    updateLightHelper(): any;
    dispose(): any;
    defaultLights(): any;
    realSunlight(helper?: boolean): any;
    setDefaultView(options: any, defOptions: any): any;
    memory(): any;
    programs(): any;
    /**
     * threejs.
     **/
    mapToWorld(coords: any): any;
    /**
     * threejs.
     **/
    mapToWorldLength(coords: any): any;
    /**
     * threejs.
     **/
    mapToWorldLength(len: number): number;
    /**
     * threejs.
     **/
    worldToMapLength(len: number): number;
    /**
     * threejs.
     **/
    getWorldSize(): number;
    /**
     * base64 `THREE.Texture` .
     **/
    loadTexture(img: string, defaultImg?: string): any;
    /**
     * 
     **/
    coneMesh(co: GeoPoint, opts?: {
        size?: number;
        height?: number;
        color?: string | number;
        animation?: boolean;
        animationUpDown?: boolean;
        obj3dOpts?: object;
    }): any;
    /**
     * 
     **/
    wall(pts: GeoPoint[], opts?: {
        height?: number;
        flyline?: boolean;
        repeatX?: number;
        repeatY?: number;
        offsetX?: number;
        offsetY?: number;
        color1?: string | number;
        texture1?: string;
        color2?: string | number;
        texture2?: string;
        opacity?: number;
        obj3dOpts?: object;
    }): any;
    /**
     * 
     **/
    wave(co: GeoPoint, opts?: {
        size?: number;
        color?: string | number;
        texture?: string;
        speed?: number;
    }): any;
    /**
     * 
     **/
    radialGradient(co: GeoPoint, opts?: {
        size?: number;
        color?: string | number | any;
        speed?: number;
    }): any;
    /**
     * 
     **/
    radar(co: GeoPoint, opts?: {
        size?: number;
        color1?: string | number;
        texture1: string;
        color2?: string | number;
        texture2: string;
        speed?: number;
    }): any;
    /**
     * 
     **/
    waveWall(co: GeoPoint, opts?: {
        size?: number;
        height?: number;
        color?: string | number;
        texture?: string;
        speed?: number;
        opacity?: number;
    }): any;
    /**
     *  
     **/
    flyline(opts: {
        source: GeoPoint;
        target: GeoPoint;
        height?: number;
        size?: number;
        color: string | number;
        color2?: string | number;
        count?: number;
        range?: number;
        opacity?: number;
        speed?: number;
    }): any;
}

export  interface ThreeJsContextOptions {
    defaultLights?: boolean;
    realSunlight?: boolean;
    realSunlightHelper?: boolean;
    passiveRendering?: boolean;
    preserveDrawingBuffer?: boolean;
    enableSelectingFeatures?: boolean;
    enableSelectingObjects?: boolean;
    enableDraggingObjects?: boolean;
    enableRotatingObjects?: boolean;
    enableTooltips?: boolean;
    multiLayer?: boolean;
    orthographic?: boolean;
    fov?: number;
    sky?: boolean;
    terrain?: boolean;
}

/**
 * threejs.
 *
 **/
export  class ThreeLayer extends Evented implements CustomLayerInterface {
    id: string;
    type: "custom";
    renderingMode?: "2d" | "3d" | undefined;
    context: ThreeJsContext;
    constructor(options: ThreeLayerOptions);
    onAdd(map: any, gl: any): void;
    onRemove(): void;
    render(gl: any, matrix: any): void;
}

export  interface ThreeLayerOptions {
    id?: string;
    context: ThreeJsContext;
    onAdd?: (map: any, gl: any) => void;
    onRemove?: () => void;
    render?: (gl: any, matrix: any) => void;
}

export  const toDecimal: (num: number, precision?: number) => number;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
export  function toRadian(a: number): number;

export  const transform: {
    CRSTypes: typeof CRSTypes;
    convert: typeof convert;
    EpsgCrsTypes: typeof EpsgCrsTypes;
    getEpsgParam: typeof getEpsgParam;
    getEpsgCode: typeof getEpsgCode;
};

export  type TransitionSpecification = {
    duration?: number;
    delay?: number;
};

/**
 * An update function. It accepts a timestamp used to advance the animation.
 */
 type Update = (timestamp: number) => void;

export  const upperCamelCase: (s: any) => any;

/**
 * utf8unicode
 * @param strUtf8 utf8
 */
export  function utf8ToUnicode(strUtf8: string): string;

export  namespace vec2 {
    export type valueType = vec2type;
    /**
     * Creates a new, empty vec2
     *
     * @returns {vec2} a new 2D vector
     */
    export function create(): vec2type;
    /**
     * Creates a new vec2 initialized with values from an existing vector
     *
     * @param {ReadonlyVec2} a vector to clone
     * @returns {vec2} a new 2D vector
     */
    export function clone(a: vec2type): vec2type;
    /**
     * Creates a new vec2 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} a new 2D vector
     */
    export function fromValues(x: number, y: number): vec2type;
    /**
     * Copy the values from one vec2 to another
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the source vector
     * @returns {vec2} out
     */
    export function copy(out: vec2type, a: vec2type): vec2type;
    /**
     * Set the components of a vec2 to the given values
     *
     * @param {vec2} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} out
     */
    export function set(out: vec2type, x: number, y: number): vec2type;
    /**
     * Adds two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function add(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function subtract(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Multiplies two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function multiply(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Divides two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function divide(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Math.ceil the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to ceil
     * @returns {vec2} out
     */
    export function ceil(out: vec2type, a: vec2type): vec2type;
    /**
     * Math.floor the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to floor
     * @returns {vec2} out
     */
    export function floor(out: vec2type, a: vec2type): vec2type;
    /**
     * Returns the minimum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function min(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Returns the maximum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec2} out
     */
    export function max(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Math.round the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to round
     * @returns {vec2} out
     */
    export function round(out: vec2type, a: vec2type): vec2type;
    /**
     * Scales a vec2 by a scalar number
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec2} out
     */
    export function scale(out: vec2type, a: vec2type, b: number): vec2type;
    /**
     * Adds two vec2's after scaling the second operand by a scalar value
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @param {Number} scale the amount to scale b by before adding
     * @returns {vec2} out
     */
    export function scaleAndAdd(out: vec2type, a: vec2type, b: vec2type, scale: number): vec2type;
    /**
     * Calculates the euclidian distance between two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec2type, b: vec2type): number;
    /**
     * Calculates the squared euclidian distance between two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec2type, b: vec2type): number;
    /**
     * Calculates the length of a vec2
     *
     * @param {ReadonlyVec2} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec2type): number;
    /**
     * Calculates the squared length of a vec2
     *
     * @param {ReadonlyVec2} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec2type): number;
    /**
     * Negates the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to negate
     * @returns {vec2} out
     */
    export function negate(out: vec2type, a: vec2type): vec2type;
    /**
     * Returns the inverse of the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to invert
     * @returns {vec2} out
     */
    export function inverse(out: vec2type, a: vec2type): vec2type;
    /**
     * Normalize a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a vector to normalize
     * @returns {vec2} out
     */
    export function normalize(out: vec2type, a: vec2type): vec2type;
    /**
     * Calculates the dot product of two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec2type, b: vec2type): number;
    /**
     * Computes the cross product of two vec2's
     * Note that the cross product must by definition produce a 3D vector
     *
     * @param {vec3} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {vec3} out
     */
    export function cross(out: vec2type, a: vec2type, b: vec2type): vec2type;
    /**
     * Performs a linear interpolation between two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {vec2} out
     */
    export function lerp(out: vec2type, a: vec2type, b: vec2type, t: number): vec2type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec2} out the receiving vector
     * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
     * @returns {vec2} out
     */
    export function random(out: vec2type, scale: number): vec2type;
    /**
     * Transforms the vec2 with a mat2
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat2} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat2(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat2d
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat2d} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat2d(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat3
     * 3rd vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat3} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat3(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Transforms the vec2 with a mat4
     * 3rd vector component is implicitly '0'
     * 4th vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the vector to transform
     * @param {ReadonlyMat4} m matrix to transform with
     * @returns {vec2} out
     */
    export function transformMat4(out: vec2type, a: vec2type, m: vec2type): vec2type;
    /**
     * Rotate a 2D vector
     * @param {vec2} out The receiving vec2
     * @param {ReadonlyVec2} a The vec2 point to rotate
     * @param {ReadonlyVec2} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @returns {vec2} out
     */
    export function rotate(out: vec2type, a: vec2type, b: vec2type, rad: number): vec2type;
    /**
     * Get the angle between two 2D vectors
     * @param {ReadonlyVec2} a The first operand
     * @param {ReadonlyVec2} b The second operand
     * @returns {Number} The angle in radians
     */
    export function angle(a: vec2type, b: vec2type): number;
    /**
     * Set the components of a vec2 to zero
     *
     * @param {vec2} out the receiving vector
     * @returns {vec2} out
     */
    export function zero(out: vec2type): vec2type;
    /**
     * Returns a string representation of a vector
     *
     * @param {ReadonlyVec2} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec2type): string;
    /**
     * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
     *
     * @param {ReadonlyVec2} a The first vector.
     * @param {ReadonlyVec2} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec2type, b: vec2type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {ReadonlyVec2} a The first vector.
     * @param {ReadonlyVec2} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec2type, b: vec2type): boolean;
    /**
     * Perform some operation over an array of vec2s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    const forEach: (a: any, stride: any, offset: any, count: any, fn: any, arg: any) => any;
}

 interface Vec2Like {
    x: number;
    y: number;
}

export  type vec2type = [number, number] | Float32Array;

export  namespace vec3 {
    export type valueType = vec3type;
    /**
     * Creates a new, empty vec3
     *
     * @returns {vec3} a new 3D vector
     */
    export function create(): vec3type;
    /**
     * Creates a new vec3 initialized with values from an existing vector
     *
     * @param {vec3} a vector to clone
     * @returns {vec3} a new 3D vector
     */
    export function clone(a: vec3type): vec3type;
    /**
     * Creates a new vec3 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} a new 3D vector
     */
    export function fromValues(x: number, y: number, z: number): vec3type;
    /**
     * Copy the values from one vec3 to another
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the source vector
     * @returns {vec3} out
     */
    export function copy(out: vec3type, a: vec3type): vec3type;
    /**
     * Set the components of a vec3 to the given values
     *
     * @param {vec3} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} out
     */
    export function set(out: vec3type, x: number, y: number, z: number): vec3type;
    /**
     * Adds two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function add(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function subtract(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.subtract}
     * @function
     */
    /**
     * Multiplies two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function multiply(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.multiply}
     * @function
     */
    /**
     * Divides two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function divide(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Alias for {@link vec3.divide}
     * @function
     */
    /**
     * Math.ceil the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to ceil
     * @returns {vec3} out
     */
    export function ceil(out: vec3type, a: vec3type): vec3type;
    /**
     * Math.floor the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to floor
     * @returns {vec3} out
     */
    export function floor(out: vec3type, a: vec3type): vec3type;
    /**
     * Returns the minimum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function min(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Returns the maximum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function max(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Math.round the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to round
     * @returns {vec3} out
     */
    export function round(out: vec3type, a: vec3type): vec3type;
    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */
    export function scale(out: vec3type, a: vec3type, b: number): vec3type;
    /**
     * Adds two vec3's after scaling the second operand by a scalar value
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} s the amount to scale b by before adding
     * @returns {vec3} out
     */
    export function scaleAndAdd(out: vec3type, a: vec3type, b: vec3type, s: number): vec3type;
    /**
     * Calculates the euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec3type, b: vec3type): number;
    /**
     * Alias for {@link vec3.distance}
     * @function
     */
    /**
     * Calculates the squared euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec3type, b: vec3type): number;
    /**
     * Alias for {@link vec3.squaredDistance}
     * @function
     */
    /**
     * Calculates the length of a vec3
     *
     * @param {vec3} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec3type): number;
    /**
     * Alias for {@link vec3.length}
     * @function
     */
    /**
     * Calculates the squared length of a vec3
     *
     * @param {vec3} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec3type): number;
    /**
     * Alias for {@link vec3.squaredLength}
     * @function
     */
    /**
     * Negates the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to negate
     * @returns {vec3} out
     */
    export function negate(out: vec3type, a: vec3type): vec3type;
    /**
     * Returns the inverse of the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to invert
     * @returns {vec3} out
     */
    export function inverse(out: vec3type, a: vec3type): vec3type;
    /**
     * Normalize a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to normalize
     * @returns {vec3} out
     */
    export function normalize(out: vec3type, a: vec3type): vec3type;
    /**
     * Calculates the dot product of two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec3type, b: vec3type): number;
    /**
     * Computes the cross product of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    export function cross(out: vec3type, a: vec3type, b: vec3type): vec3type;
    /**
     * Performs a linear interpolation between two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function lerp(out: vec3type, a: vec3type, b: vec3type, t: number): vec3type;
    /**
     * Performs a hermite interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function hermite(out: vec3type, a: vec3type, b: vec3type, c: vec3type, d: vec3type, t: number): vec3type;
    /**
     * Performs a bezier interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    export function bezier(out: vec3type, a: vec3type, b: vec3type, c: vec3type, d: vec3type, t: number): vec3type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec3} out the receiving vector
     * @param {Number} [s] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec3} out
     */
    export function random(out: vec3type, s?: number): vec3type;
    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    export function transformMat4(out: vec3type, a: vec3type, m: mat4type): vec3type;
    /**
     * Transforms the vec3 with a mat3.
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m the 3x3 matrix to transform with
     * @returns {vec3} out
     */
    export function transformMat3(out: vec3type, a: vec3type, m: mat4type): vec3type;
    /**
     * Transforms the vec3 with a quat
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec3} out
     */
    export function transformQuat(out: vec3type, a: vec3type, q: quattype): vec3type;
    /**
     * Rotate a 3D vector around the x-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateX(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Rotate a 3D vector around the y-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateY(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Rotate a 3D vector around the z-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    export function rotateZ(out: vec3type, a: vec3type, b: vec3type, c: number): vec3type;
    /**
     * Perform some operation over an array of vec3s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    export function forEach(a: vec3type, stride: number, offset: number, count: number, fn: (out: vec3type, vec: vec3type, arg: any) => void, arg?: any): any;
    /**
     * Get the angle between two 3D vectors
     * @param {vec3} a The first operand
     * @param {vec3} b The second operand
     * @returns {Number} The angle in radians
     */
    export function angle(a: vec3type, b: vec3type): number;
    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec3type): string;
    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     *
     * @param {vec3} a The first vector.
     * @param {vec3} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec3type, b: vec3type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {vec3} a The first vector.
     * @param {vec3} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec3type, b: vec3type): boolean;
}

export  type vec3type = [number, number, number] | Float32Array;

export  namespace vec4 {
    export type valueType = vec4type;
    /**
     * Creates a new, empty vec4
     *
     * @returns {vec4} a new 4D vector
     */
    export function create(): vec4type;
    /**
     * Creates a new vec4 initialized with values from an existing vector
     *
     * @param {vec4} a vector to clone
     * @returns {vec4} a new 4D vector
     */
    export function clone(a: vec4type): vec4type;
    /**
     * Creates a new vec4 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} a new 4D vector
     */
    export function fromValues(x: number, y: number, z: number, w: number): vec4type;
    /**
     * Copy the values from one vec4 to another
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the source vector
     * @returns {vec4} out
     */
    export function copy(out: vec4type, a: vec4type): vec4type;
    /**
     * Set the components of a vec4 to the given values
     *
     * @param {vec4} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} out
     */
    export function set(out: vec4type, x: number, y: number, z: number, w: number): vec4type;
    /**
     * Adds two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function add(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function subtract(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.subtract}
     * @function
     */
    /**
     * Multiplies two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function multiply(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.multiply}
     * @function
     */
    /**
     * Divides two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function divide(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Alias for {@link vec4.divide}
     * @function
     */
    /**
     * Math.ceil the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to ceil
     * @returns {vec4} out
     */
    export function ceil(out: vec4type, a: vec4type): vec4type;
    /**
     * Math.floor the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to floor
     * @returns {vec4} out
     */
    export function floor(out: vec4type, a: vec4type): vec4type;
    /**
     * Returns the minimum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function min(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Returns the maximum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    export function max(out: vec4type, a: vec4type, b: vec4type): vec4type;
    /**
     * Math.round the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to round
     * @returns {vec4} out
     */
    export function round(out: vec4type, a: vec4type): vec4type;
    /**
     * Scales a vec4 by a scalar number
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec4} out
     */
    export function scale(out: vec4type, a: vec4type, b: number): vec4type;
    /**
     * Adds two vec4's after scaling the second operand by a scalar value
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} s the amount to scale b by before adding
     * @returns {vec4} out
     */
    export function scaleAndAdd(out: vec4type, a: vec4type, b: vec4type, s: number): vec4type;
    /**
     * Calculates the euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} distance between a and b
     */
    export function distance(a: vec4type, b: vec4type): number;
    /**
     * Alias for {@link vec4.distance}
     * @function
     */
    /**
     * Calculates the squared euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} squared distance between a and b
     */
    export function squaredDistance(a: vec4type, b: vec4type): number;
    /**
     * Alias for {@link vec4.squaredDistance}
     * @function
     */
    /**
     * Calculates the length of a vec4
     *
     * @param {vec4} a vector to calculate length of
     * @returns {Number} length of a
     */
    export function length(a: vec4type): number;
    /**
     * Alias for {@link vec4.length}
     * @function
     */
    /**
     * Calculates the squared length of a vec4
     *
     * @param {vec4} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    export function squaredLength(a: vec4type): number;
    /**
     * Alias for {@link vec4.squaredLength}
     * @function
     */
    /**
     * Negates the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to negate
     * @returns {vec4} out
     */
    export function negate(out: vec4type, a: vec4type): vec4type;
    /**
     * Returns the inverse of the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to invert
     * @returns {vec4} out
     */
    export function inverse(out: vec4type, a: vec4type): vec4type;
    /**
     * Normalize a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to normalize
     * @returns {vec4} out
     */
    export function normalize(out: vec4type, a: vec4type): vec4type;
    /**
     * Calculates the dot product of two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} dot product of a and b
     */
    export function dot(a: vec4type, b: vec4type): number;
    /**
     * Performs a linear interpolation between two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec4} out
     */
    export function lerp(out: vec4type, a: vec4type, b: vec4type, t: number): vec4type;
    /**
     * Generates a random vector with the given scale
     *
     * @param {vec4} out the receiving vector
     * @param {Number} [s] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec4} out
     */
    export function random(out: vec4type, s?: number): vec4type;
    /**
     * Transforms the vec4 with a mat4.
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec4} out
     */
    export function transformMat4(out: vec4type, a: vec4type, m: mat4type): vec4type;
    /**
     * Transforms the vec4 with a quat
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec4} out
     */
    export function transformQuat(out: vec4type, a: vec4type, q: quattype): vec4type;
    /**
     * Perform some operation over an array of vec4s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    export function forEach(a: vec4type, stride: number, offset: number, count: number, fn: (out: vec4type, vec: vec4type, arg: any) => void, arg?: any): any;
    /**
     * Returns a string representation of a vector
     *
     * @param {vec4} a vector to represent as a string
     * @returns {String} string representation of the vector
     */
    export function str(a: vec4type): string;
    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     *
     * @param {vec4} a The first vector.
     * @param {vec4} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function exactEquals(a: vec4type, b: vec4type): boolean;
    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     *
     * @param {vec4} a The first vector.
     * @param {vec4} b The second vector.
     * @returns {Boolean} True if the vectors are equal, false otherwise.
     */
    export function equals(a: vec4type, b: vec4type): boolean;
}

export  type vec4type = [number, number, number, number] | Float32Array;

/**
 * 
 * @param {json} featureCollectiongeojson (undefined
 * @param {string} weight
 * @param {array} breaks
 * @param params
 params:{
         model:'exponential','gaussian','spherical'exponential
         sigma2: 0, // sigma2z 0 
         alpha: 100, // Alpha ,,100
         canvas: HTMLCanvasElement, // 
         xlim: number, // canvas
         ylim: number, // canvas
         colors:string[] // canvas 
         width: number // 200
  }
 */
export  function vectorContour(featureCollection: FeatureCollection, weight: string, breaks: number[], params?: {
    model?: 'exponential' | 'gaussian' | 'spherical';
    sigma2?: number;
    alpha?: number;
    canvas?: HTMLCanvasElement;
    xlim?: number;
    ylim?: number;
    colors?: string[];
    extent?: [number, number, number, number];
    width?: number;
}): {
    grid?: {
        grid: number[];
        n: number;
        m: number;
        xlim: number;
        ylim: number;
        zlim: number;
        x_resolution: number;
        y_resolution: number;
    };
    contour?: FeatureCollection;
    variogram?: any;
    alg?: any;
};

export  type VectorSourceSpecification = {
    type: "vector";
    url?: string;
    tiles?: Array<string>;
    bounds?: [number, number, number, number];
    scheme?: "xyz" | "tms";
    minzoom?: number;
    maxzoom?: number;
    attribution?: string;
    promoteId?: PromoteIdSpecificationEx;
    volatile?: boolean;
};

export  function velocityPerFrame(xps: number, frameDuration: number): number;

export  function velocityPerSecond(velocity: number, frameDuration: number): number;

export  type VideoSourceSpecification = {
    type: "video";
    urls: Array<string>;
    coordinates: [[number, number], [number, number], [number, number], [number, number]];
};

export  function WorkerExpose(target: any): void;

/**
 * Worker
 * @param worker
 * @return {any}
 * @constructor
 */
export  function WorkerLink(worker: Worker): any;

/**
 * /  worker   async/await 
 *
 * Example:
 * ```typescript
 * function busyAdd(a, b) {
 *  let st = Date.now();
 *  while (true) {
 *    if ((Date.now() - st) > 2000) break;
 *  }
 *  return a + b;
 * }
 *
 * (async () => {
 *  let workerAdd = vjmap.WorkerProxy(busyAdd);
 *  console.log(await workerAdd(10, 20)); //30
 *  // the busyAdd is executed in a worker so
 *  // the UI does not get blocked
 * })();
 *
 * class Adder {
 * constructor() {
 *   this.count = 0;
 * }
 * add(a, b) {
 *  this.count++;
 *   return a + b;
 * }
 *}

 * (async () => {
 * let WAdder = vjmap.WorkerProxy(Adder);
 * let a = await new WAdder(); // instance created/running in worker
 * console.log(await a.count); // 0
 * console.log(await a.add(10, 20)); // 30
 * console.log(await a.count); // 1
 *})();
 *
 * // or:
 * // worker.js
 *
 *importScripts('https://cdn.jsdelivr.net/npm/moment@2.20.1/moment.min.js', '../dist/workly.js');
 *function friendlyTime(value) {
 *return moment(value).calendar(null, {
 *   sameDay: function (now) {
 *    if (now - this < 1000 * 60) {
 *       return "[Just now]";
 *    } else if (now - this < 1000 * 60 * 60) {
 *       return "[" + Math.round((now - this) / (1000 * 60)) + " mins ago]";
 *    } else {
 *      return '[Today at] LT'
 *    }
 *  }
 * });
 *}
 *vjmap.WorkerExpose(friendlyTime);
 *main.js
 *
 *(async () => {
 * let w = vjmap.WorkerProxy("./worker.js");
 *let now = Date.now();
 * console.log(now);
 * console.log(await w(now));
 *console.log(await w(now - (24 * 60 * 60 * 1000)));
 *console.log(await w(now - (4 * 24 * 60 * 60 * 1000)));
 *})();
 *
 *  function randAdd(a, b) {
 *      return randInt(a, b)  + 1000; // randInt
 *  }
 *
 * let randAddFunc = vjmap.WorkerProxy(randAdd, {
 *    randInt: vjmap.randInt // 
 * });
 * console.log(await randAddFunc(100, 300));
 * ```
 * @param obj
 * @param funcContext objobj
 * @return {any}
 * @constructor
 */
export  function WorkerProxy(obj: Function | string, funcContext?: Record<string, Function | string>): Function;

export  const wrap: (min: number, max: number, v: number) => number;


    export function supported(options?: { failIfMajorPerformanceCaveat?: boolean | undefined }): boolean;

    /**
     * Clears browser storage used by this library. Using this method flushes the Map tile cache that is managed by this library.
     * Tiles may still be cached by the browser in some cases.
     */
    export function clearStorage(callback?: (err?: Error) => void): void;

    export function setRTLTextPlugin(pluginURL: string, callback: (error: Error) => void, deferred?: boolean): void;
    export function getRTLTextPluginStatus(): PluginStatus;

    /**
     * Initializes resources like WebWorkers that can be shared across maps to lower load
     * times in some situations. `vjmap.workerUrl` and `vjmap.workerCount`, if being
     * used, must be set before `prewarm()` is called to have an effect.
     *
     * By default, the lifecycle of these resources is managed automatically, and they are
     * lazily initialized when a Map is first created. By invoking `prewarm()`, these
     * resources will be created ahead of time, and will not be cleared when the last Map
     * is removed from the page. This allows them to be re-used by new Map instances that
     * are created later. They can be manually cleared by calling
     * `vjmap.clearPrewarmedResources()`. This is only necessary if your web page remains
     * active but stops using maps altogether.
     *
     * This is primarily useful when using GL-JS maps in a single page app, wherein a user
     * would navigate between various views that can cause Map instances to constantly be
     * created and destroyed.
     */
    export function prewarm(): void;

    /**
     * Clears up resources that have previously been created by `vjmap.prewarm()`.
     * Note that this is typically not necessary. You should only call this function
     * if you expect the user of your app to not return to a Map view at any point
     * in your application.
     */
    export function clearPrewarmedResources(): void;

  export  type PluginStatus = 'unavailable' | 'loading' | 'loaded' | 'error';

  export  type LngLatLike = [number, number] | LngLat | { lng: number; lat: number } | { lon: number; lat: number };

  export  type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number] | LngLatLike;
  export  type PointLike = Point | [number, number];
  export  type Offset = number | PointLike | { [_: string]: PointLike };

  export  type ExpressionName =
        // Types
        | 'array'
        | 'boolean'
        | 'collator'
        | 'format'
        | 'literal'
        | 'number'
        | 'number-format'
        | 'object'
        | 'string'
        | 'image'
        | 'to-boolean'
        | 'to-color'
        | 'to-number'
        | 'to-string'
        | 'typeof'
        // Feature data
        | 'feature-state'
        | 'geometry-type'
        | 'id'
        | 'line-progress'
        | 'properties'
        // Lookup
        | 'at'
        | 'get'
        | 'has'
        | 'in'
        | 'index-of'
        | 'length'
        | 'slice'
        // Decision
        | '!'
        | '!='
        | '<'
        | '<='
        | '=='
        | '>'
        | '>='
        | 'all'
        | 'any'
        | 'case'
        | 'match'
        | 'coalesce'
        | 'within'
        // Ramps, scales, curves
        | 'interpolate'
        | 'interpolate-hcl'
        | 'interpolate-lab'
        | 'step'
        // Variable binding
        | 'let'
        | 'var'
        // String
        | 'concat'
        | 'downcase'
        | 'is-supported-script'
        | 'resolved-locale'
        | 'upcase'
        // Color
        | 'rgb'
        | 'rgba'
        | 'to-rgba'
        // Math
        | '-'
        | '*'
        | '/'
        | '%'
        | '^'
        | '+'
        | 'abs'
        | 'acos'
        | 'asin'
        | 'atan'
        | 'ceil'
        | 'cos'
        | 'e'
        | 'floor'
        | 'ln'
        | 'ln2'
        | 'log10'
        | 'log2'
        | 'max'
        | 'min'
        | 'pi'
        | 'round'
        | 'sin'
        | 'sqrt'
        | 'tan'
        // Zoom, Heatmap
        | 'zoom'
        | 'heatmap-density';

  export  type Expression = [ExpressionName, ...any[]];

  export  type Anchor =
        | 'center'
        | 'left'
        | 'right'
        | 'top'
        | 'bottom'
        | 'top-left'
        | 'top-right'
        | 'bottom-left'
        | 'bottom-right';

  export  type DragPanOptions = {
        linearity?: number;
        easing?: (t: number) => number;
        deceleration?: number;
        maxSpeed?: number;
    };

  export  type InteractiveOptions = { around?: 'center' };

    /**
     * Map
     */
    export class Map extends Evented {
        constructor(options?: MapOptions);

        /**
         *  `contextMenuPreOpen`, `contextMenuOpened`, `contextMenuNoContent`, isInteracting()truecontextMenuCancel
         * @param menu 
         * @param key setMenukeykeykeynullContextMenu
         */
        setMenu(menu?: (event: any) => ContextMenu | null, key?: string): void;


        /**
         * 
         * @param map 
         * @param tiles 
         *  @param source   raster-source
         */
        changeSourceTiles(tiles: string[] | string, source?: string): void;

        /**
         * 
         * @param svc 
         * @param projection 
         * @param options 
         */
        attach(svc: Service, projection: Projection, options?: object): void;

        /**
         * 
         */
        getService(): Service;

        /**
         * 
         */
        getAttachOptions(): object;

        /**
         * 
         * @param projection
         */
        setMapProjection(projection: Projection): void;

        /**
         * 
         */
        getMapProjection(): Projection;


        /**
         * 
         * @param input 
         * @return {[number, number]}
         */
        toLngLat<
            T extends
                | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
        >(
            input: T
        ): any;

        /**
         * 
         * @param input 
         * @return {GeoPoint}
         */
        fromLngLat<
            T extends
                | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
        >(
            input: T
        ): any;


        /**
         *
         * @param tileUrl  
         * @param rasterPrefix raster
         * @param minzoom 0
         * @param maxzoom 24
         * @param vecotrPrefix vector
         * @param hoverColor rgba(0,0,255,255)
         * @param hoverOpacity ,0.5
         * @param hoverLineWidth ,3
         */
        switchRasterToVectorStyle(
            tileUrl: string,
            rasterPrefix?: string,
            minzoom?: number,
            maxzoom?: number,
            vecotrPrefix?: string,
            hoverColor?: string,
            hoverOpacity?: number,
            hoverLineWidth?: number
        ): void;

        /**
         *
         * @param tileUrl 
         * @param vecotrPrefix vector
         * @param minzoom 0
         * @param maxzoom 24
         * @param rasterPrefix raster
         */
        switchVectorToRasterStyle(
            tileUrl: string,
            vecotrPrefix?: string,
            minzoom?: number,
            maxzoom?: number,
            rasterPrefix?: string
        ): void;

        /**
         * 
         * @param cb 
         * @param prefix 
         */
        enableVectorLayerHoverHighlight(
            cb?: (eventName: string, hoverFeature: any, hoverLayer: string, event: any) => void,
            prefix?: string
        ): void;

        /**
         * 
         * @param prefix 
         */
        disableVectorLayerHoverHighlight(prefix?: string): boolean;

        /**
         * 
         * @param svc 
         * @param cb 
         * @param HighlightColor  #0000
         * @param prefix (highlight)
         * @param filterCb 
         * @param enterQueryCb 
         */
        enableLayerClickHighlight(
            svc: Service,
            cb?: (res: any, event: any) => void,
            HighlightColor?: string,
            prefix?: string,
            filterCb?: (curResult: any, zoom?: number, x?: number, y?: number) => any,
            enterQueryCb?: (lngLat: LngLatLike) => IPointQueryFeatures
        ): void;

        /**
         * 
         * @param prefix (highlight)
         */
        disableLayerClickHighlight(prefix?: string): boolean;

        /**
         * 
         */
        hasVectorLayer(): boolean;



        /**
         * 
         * @param svc 
         * @param visibleLayers 
         * @return {Promise<void>}
         */
        switchLayers(svc: Service, visibleLayers: string[]): Promise<any>;

        /**
         * 
         * @param svc 
         * @param param 
         * @param noInheritFromCurStyle ,false,
         * @return {Promise<any>}
         *
         */
         updateStyle(svc: Service, param: IUpdateStyle, noInheritFromCurStyle?: boolean): Promise<any>;

        /**
         * 
         * @param extent
         */
        updateMapExtent(extent: string | [number, number, number, number] | GeoBounds): Projection;

        /**
         * 
         * @param bounds  bounds (0.4)
         * @param options
         * - **`Object`?** Options [AnimationOptions][195][CameraOptions][194]
         * - `options.padding` **( `number`| [PaddingOptions][196] )**
         * - `options.linear` **`boolean`**`true` `Map#easeTo ``false``Map#flyTo `[AnimationOptions][195]`false`
         * - `options.easing` ****``
         * - `options.offset` **[PointLike][166]**`[0,0]`
         * - `options.maxZoom` **`number`?** 
         * - `options.fitFillClip` **`boolean`?** true
         * @param eventData
         * - `eventData` **`Object`?** 
         * @return {this}
         */
        fitMapBounds(bounds?: number | GeoBounds, options?: Record<string, any>, eventData?: any): Map;

        /**
         * 
         * @param ratio  0.4
         */
        getGeoBounds(ratio?: number): GeoBounds;

        /**
         * , getGeoBounds,getGeoBounds(1.0)
         */
        getMapExtent(): GeoBounds;


        /**
         * []
         */
        getCanvasSize(): [number, number];

        /**
         * marker
         */
        getMarkers(): Marker[];

        /**
         * DivOverlay
         */
        getDivOverlays(): DivOverlay[];

        /**
         * SvgOverlay
         */
        getSvgOverlays(): SvgOverlay[];

        /**
         * markerText,divOverlays`removeMarkers`, noIncludeDivOverlaydivOverlays
         */
        removeMarkers(noIncludeDivOverlay?: boolean): any;

        /**
         * popups`removePopups`
         */
        removePopups(): any;

        /**
         * 
         * @param lnglat
         * @param altitude (m)
         */
        projectEx(lnglat: LngLatLike, altitude?: number): Point;

        /**
         * Threejs
         * @param Options
         */
        createThreeJsContext(Options: ThreeJsContextOptions): ThreeJsContext;

        /**
         * 
         * @param len 
         * @param zoom 
         */
        pixelToHeight(len: number, zoom: number): number

        /**
         * 
         * @param len 
         */
        geoLengthToHeight(len: number): number

        /**
         * 
         * @param len 
         * @param zoom 
         */
        pixelToGeoLength(len: number, zoom: number): number

        /**
         * 
         * @param len 
         * @param zoom 
         */
        geoToPixelLength(len: number, zoom: number): number

        /**
         * 
         * @param len 
         * @return number 
         */
         geoToMercatorLength(len: number): number;


        /**
         * 
         * @param len 
         * @param number 
         */
         mercatorToGeoLength(len: number): number;

        /**
         * 
         * @param key 
         * @param value 
         */
        setCustomKeyValue(key: string, value: any): void

        /**
         * 
         * @param key 
         */
        getCustomKeyValue(key: string): any


        /**
         * 
         * @param value 
         */
        setError(value: any): void

        /**
         * 
         */
        getError(): any

        /**
         * ,`mapopenstart``mapopenfinish`
         * @param param 
         * @param isKeepOldLayers false
         * @param isVectorStyle 
         * @param isSetCenter 
         * @param isFitBounds 
         * @param source idsource
         */
        switchMap(param: IOpenMapParam, isKeepOldLayers?:boolean, isVectorStyle?:boolean, isSetCenter?: boolean, isFitBounds?: boolean, source?: string): Promise<any>;

        /**
         *  `GeoBounds`.
         *
         * Example:
         * ```typescript
         * const b = map.getEnvelopBounds('POLYGON((3466315.697899 6704304.297588, 3466315.697899 7784496.211226, 4546475.901198 7784496.211226, 4546475.901198 6704304.297588, 3466315.697899 6704304.297588))');
         * ```
         */
        getEnvelopBounds(envelop: string): GeoBounds;


        /**
         * 
         * @param input GeoJson
         * @param isLngLat trueCAD.false
         * @return CAD
         */
        getFeatureBounds<
            T extends
                    | GeoJsonGeomertry
                | GeoPoint
                | GeoPointLike
                | GeoPointLike[]
                | LngLatBounds
                | any
            >(
            input: T,
            isLngLat?: boolean
        ): GeoBounds;

        /**
         * 
         */
         isInteracting(): boolean;

        /**
         * 
         */
         setIsInteracting(interacting: boolean): boolean;

        /**
         * ID
         */
        getSourceData(sourceId: string): any;


        /**
         * 
         * @param isMKT  true, false
         */
        getCameraPosition(isMKT?: boolean): LngLatLike


        /**
         * 
         */
        getDrawLayer(options?: IDrawOptions): IDrawTool;

        /**
         * 
         */
        createDrawLayer(options?: IDrawOptions): IDrawTool;

        /**
         * ,getDrawLayer
         */
        removeDrawLayer(layer?: IDrawTool): void;

        /**
         * html
         * @param color 
         * @return {string}
         */
        entColorToHtmlColor(color: number): string

        /**
         * html
         * @param color html  "#rrggbb"
         * @return {number}
         */
        htmlColorToEntColor(color: string): number

        /**
         * imagesvgbase64
         * @param id id
         * @param data 
         * @param width 
         * @param height 
         * @param options 
         * @return
         */
        addImageData(id: string, data: string, width: number, height: number, options?: Record<string, any>): Promise<any>


        /**
         * geojson
         * @param doc 
         * @param isAutoUpdateMapExtent 
         * @param isDarkMode 
         * @param options cmdCreateEntitiesGeomData
         * @param includeAttrSet 
         * @return {number}
         */
        createDbGeomData(doc: DbDocument, isAutoUpdateMapExtent?: boolean, isDarkMode?: boolean, options?: ICreateEntitiesGeomData, includeAttrSet?: string[]): Promise<any>

        

        /** 
         @returns A function to remove the handler.
         * @param layerOrLayers
         */
        hoverPointer(layerOrLayers: LayerRef): void;

        /**
          [s] 
         @param layer Layer(s) to add handler to.
         @param {string|Array} [source] Source whose features will be updated. If not provided, use the source defined for the layer.
         @param {string} [sourceLayer] Source layer (if using vector source)
         * @param enterCb
         * @param leaveCb
         */
        hoverFeatureState(
            layer: LayerRef,
            source?: string,
            sourceLayer?: string,
            enterCb?: (arg0: {}) => void,
            leaveCb?: (arg0: {}) => void
        ): void;

        /** 
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param htmlFunc Function that receives feature and popup, returns HTML.
         @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
         @example hoverPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { anchor: 'left' });
         */
        hoverPopup(
            layers: LayerRef,
            htmlFunc: LayerCallback,
            popupOptions?: PopupOptions
        ): OffHandler;

        /** 
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param htmlFunc Function that receives feature and popup, returns HTML.
         @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.

         @returns A function that removes the handler.
         @example clickPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { maxWidth: 500 });

         */
        clickPopup(
            layers: LayerRef,
            htmlFunc: (arg0: {}) => void,
            popupOptions?: PopupOptions
        ): OffHandler;

        /** 
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param {function} cb Callback that receives event with .features property
         @returns A function that removes the handler.
         */
        clickLayer(layers: LayerRef, cb: LayerCallback): OffHandler;

        /**
         
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param cb Callback, receives `{ event, layer, feature, features }`.
         @param noMatchCb Callback when a click happens that misses all these layers. Receives `{ event }`.
         @returns A function to remove the handler.
         */
        clickOneLayer(
            layerRef: LayerRef,
            cb: LayerCallback,
            noMatchCb: LayerCallback | null | undefined
        ): OffHandler;

        /** 
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @returns A function to remove the handler.
         */
        hoverLayer(layers: LayerRef, cb: LayerCallback): OffHandler;

        /**
         * 
         * @param layerDef
         * @param beforeLayerId
         */
        mapAddLayerBefore(layerDef: LayerSpecification, beforeLayerId?: string): void;

        /**  id
         * @param id
         * @param source
         * @param type
         * @param props
         * @param before
         */
        addLayerEx(
            id: string,
            source: string,
            type: string,
            props: {},
            before: string | null | undefined
        ): SourceBoundUtils;

        /**  id
         * @param id
         * @param source
         * @param type
         * @param props
         * @param before
         */
        addLayerBefore(
            id: string,
            source: SourceOrData,
            type: string,
            props: {},
            before?: string
        ): SourceBoundUtils | null | undefined;

        /**
         * 
         * @param id
         */
        removeLayerEx(id: string | string[]): this;

        /**
         *  GeoJSON 
         * @param id
         * @param geojson
         * @param props
         */
        addGeoJSONSource(
            id: string,
            geojson?: GeoJsonGeomertry,
            props?: GeoJSONSourceSpecification
        ): SourceBoundUtils;

        /**
         * 
         * @param id
         * @param sourceDef
         */
        addSourceEx(id: string, sourceDef: SourceSpecification): SourceBoundUtils;

        /**
         * 
         * @param source
         */
        layersBySource(source: string): string[];

        /**
         * 
         * @param sourceId
         * @param props
         * @param extraProps
         * @param data
         */
        addVectorSource(
            sourceId: string,
            props: object | string,
            extraProps: {},
            data?: string
        ): SourceBoundUtils;

        /**
         *  pascalCase  kebab-case 
         * @param props
         */
        properties(props?: {}): {} | null | undefined;

        /**
         * layerStyle([id,] [source,] [type,] props)
         * @param args
         */
        layerStyle(...args: unknown[]): any;

        /**
         * 
         * @param layer
         */
        show(layer: LayerRef): void;

        /**
         * 
         * @param layer
         */
        hide(layer: LayerRef): void;

        /** 
         @param {string|Array<string>|RegExp|function} Layer to toggle.
         @param {boolean} state True for visible, false for hidden.
         */
        toggle(Layer: LayerRef, state: boolean): boolean;

        /**
         * 
         * @param source
         */
        showSource(source: string): void;

        /**
         * 
         * @param source
         */
        hideSource(source: string): void;

        /** .
         @param {string} sourceId Source[s] whose layers will be toggled.
         @param {boolean} state True for visible, false for hidden.*/
        toggleSource(sourceId: string, state: boolean): void;

        /**
         * 
         * @param source
         */
        removeSourceEx(source: string | string[]): void;

        /**
         * 
         * @param cb ,   boolean,true,loadedtrue
         */
        onLoad(cb?: ((arg0: void) => void) | boolean): void | Promise<void>;

        /**  URL urlsvgbase64svgbase64width, height
         @example loadImageEx('marker', '/assets/marker-pin@2x.png', { pixelRatio: 2})  loadImageEx('marker2', '<svg>...<svg>', { width: 20, height:20})  loadImageEx('marker3', 'data:image/png;base64,xxxx', { width: 20, height:20})
         */
        loadImageEx(id: string, url: string, options?: Record<string, any>): any;

        /**
         * 
         */
        lockOrientation(): void;

        /**
         * 
         */
        fontsInUse(): string[];

        /** line
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addLineLayer(id: string, source: string, props: LineLayerStyleProp, before?: string): void;

        /** fill
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addFillLayer(id: string, source: string, props: FillLayerStyleProp, before?: string): void;

        /** circle
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addCircleLayer(
            id: string,
            source: string,
            props: CircleLayerStyleProp,
            before?: string
        ): void;

        /** 
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addSymbolLayer(
            id: string,
            source: string,
            props: SymbolLayerStyleProp,
            before?: string
        ): void;

        /** `video`
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addVideoLayer(id: string, source: string, props: object, before?: string): void;

        /** `raster` 
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addRasterLayer(
            id: string,
            source: string,
            props: RasterLayerStyleProp,
            before?: string
        ): void;

        /** FillExtrusion
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addFillExtrusionLayer(
            id: string,
            source: string,
            props: FillExtrusionLayerStyleProp,
            before?: string
        ): void;

        /** Heatmap
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addHeatmapLayer(
            id: string,
            source: string,
            props: HeatmapLayerStyleProp,
            before?: string
        ): void;

        /** hillshade
         * @param id
         * @param props
         * @param before
         * @param source
         */
        addHillshadeLayer(
            id: string,
            source: string,
            props: HillshadeLayerStyleProp,
            before?: string
        ): void;

        /**  `raster` 
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addRasterSource(sourceId: string, props: RasterSourceSpecification): SourceBoundUtils;

        /**  `raster-dem` 
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addRasterDemSource(sourceId: string, props: RasterDEMSourceSpecification): SourceBoundUtils;

        /**  `image` 
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addImageSource(sourceId: string, props: ImageSourceSpecification): SourceBoundUtils;

        /** Video
         @param sourceId ID of the new source.
         @param {object} props Properties defining the source, per the style spec.
         */
        addVideoSource(sourceId: string, props: VideoSourceSpecification): SourceBoundUtils;

        /**
         * 
         * @param layerId
         * @param source
         * @param type
         * @param props
         * @param before
         */
        setLayer(
            layerId: string,
            source: string,
            type: string,
            props: SourceSpecification,
            before?: string
        ): SourceBoundUtils;

        /** 
         @example setProperty(['buildings-fill', 'parks-fill'], 'fillOpacity', 0.5)
         */
        setProperty(layer: LayerRef, prop: string | object, value?: PropValue): void;

        /**  ID 
         * @param layerId
         */
        getLayerStyle(layerId: string): LayerSpecification;

        /**
         * 
         * @param layer
         * @param style
         */
        setLayerStyle(
            layer:
                | LayerRef
                | {
                      id: string;
                  },
            style: {}
        ): void;

        /**  GeoJSON 
         @param sourceId Id of the source being updated.
         @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
         */
        setData(sourceId: string, data?: GeoJsonGeomertry): void;

        /** 
         @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
         @param {Array} filter New filter to set.
         @example map.setFilterEx(['buildings-fill', 'buildings-outline', 'buildings-label'], ['==','level','0']]);
         */
        setFilterEx(layer: LayerRef, filter: FilterSpecification): void;

        /**
         * 
         * @param layerId
         * @param source
         * @param sourceLayer
         */
        setLayerSource(layerId: string, source: string, sourceLayer: string): void;

        /**  `light`  `transition`.
         * @param propName
         * @param val
         */
        setRootProperty(propName: string, val: PropValue): void;

        /** 
         @example setTransition({ duration: 500, delay: 100 })
         */
        setTransition(val: TransitionSpecification): void;

        /** `fill-antialias`  */
        setFillAntialias(layer: LayerRef, value: any): void;

        /** `fill-opacity`  */
        setFillOpacity(layer: LayerRef, value: any): void;

        /** `fill-color`  */
        setFillColor(layer: LayerRef, value: any): void;

        /** `fill-outline-color` */
        setFillOutlineColor(layer: LayerRef, value: any): void;

        /** `fill-translate`  */
        setFillTranslate(layer: LayerRef, value: any): void;

        /** `fill-translate-anchor`  */
        setFillTranslateAnchor(layer: LayerRef, value: any): void;

        /** `fill-pattern`  */
        setFillPattern(layer: LayerRef, value: any): void;

        /** `fill-extrusion-opacity`  */
        setFillExtrusionOpacity(layer: LayerRef, value: any): void;

        /** `fill-extrusion-color`  */
        setFillExtrusionColor(layer: LayerRef, value: any): void;

        /** `fill-extrusion-translate`  */
        setFillExtrusionTranslate(layer: LayerRef, value: any): void;

        /** `fill-extrusion-translate-anchor`  */
        setFillExtrusionTranslateAnchor(layer: LayerRef, value: any): void;

        /** `fill-extrusion-pattern`  */
        setFillExtrusionPattern(layer: LayerRef, value: any): void;

        /** `fill-extrusion-height`  */
        setFillExtrusionHeight(layer: LayerRef, value: any): void;

        /** `fill-extrusion-base`  */
        setFillExtrusionBase(layer: LayerRef, value: any): void;

        /** `fill-extrusion-vertical-gradient` */
        setFillExtrusionVerticalGradient(layer: LayerRef, value: any): void;

        /** `line-opacity`  */
        setLineOpacity(layer: LayerRef, value: any): void;

        /**  `line-color`  */
        setLineColor(layer: LayerRef, value: any): void;

        /**  `line-translate`  */
        setLineTranslate(layer: LayerRef, value: any): void;

        /**  `line-translate-anchor`  */
        setLineTranslateAnchor(layer: LayerRef, value: any): void;

        /**  */
        setLineWidth(layer: LayerRef, value: any): void;

        /** `line-gap-width`  */
        setLineGapWidth(layer: LayerRef, value: any): void;

        /** `line-offset`  */
        setLineOffset(layer: LayerRef, value: any): void;

        /**  `line-blur`  */
        setLineBlur(layer: LayerRef, value: any): void;

        /**  `line-dasharray`  */
        setLineDasharray(layer: LayerRef, value: any): void;

        /** `line-pattern`  */
        setLinePattern(layer: LayerRef, value: any): void;

        /**  `line-gradient`  */
        setLineGradient(layer: LayerRef, value: any): void;

        /** `circle-radius`  */
        setCircleRadius(layer: LayerRef, value: any): void;

        /** `circle-color`  */
        setCircleColor(layer: LayerRef, value: any): void;

        /** `circle-blur` */
        setCircleBlur(layer: LayerRef, value: any): void;

        /** `circle-opacity`  */
        setCircleOpacity(layer: LayerRef, value: any): void;

        /**  `circle-translate`  */
        setCircleTranslate(layer: LayerRef, value: any): void;

        /**  `circle-translate-anchor`  */
        setCircleTranslateAnchor(layer: LayerRef, value: any): void;

        /** circle-pitch-scale */
        setCirclePitchScale(layer: LayerRef, value: any): void;

        /** circle-pitch-alignment */
        setCirclePitchAlignment(layer: LayerRef, value: any): void;

        /** `circle-stroke-width`  */
        setCircleStrokeWidth(layer: LayerRef, value: any): void;

        /** `circle-stroke-color`  */
        setCircleStrokeColor(layer: LayerRef, value: any): void;

        /** `circle-stroke-opacity`  */
        setCircleStrokeOpacity(layer: LayerRef, value: any): void;

        /** `heatmap-radius`  */
        setHeatmapRadius(layer: LayerRef, value: any): void;

        /**  */
        setHeatmapWeight(layer: LayerRef, value: any): void;

        /**  */
        setHeatmapIntensity(layer: LayerRef, value: any): void;

        /**  */
        setHeatmapColor(layer: LayerRef, value: any): void;

        /** `heatmap-opacity`  */
        setHeatmapOpacity(layer: LayerRef, value: any): void;

        /** `icon-opacity`  */
        setIconOpacity(layer: LayerRef, value: any): void;

        /** `icon-color`  */
        setIconColor(layer: LayerRef, value: any): void;

        /** `icon-halo-color`  */
        setIconHaloColor(layer: LayerRef, value: any): void;

        /** `icon-halo-width`  */
        setIconHaloWidth(layer: LayerRef, value: any): void;

        /**  `icon-halo-blur`  */
        setIconHaloBlur(layer: LayerRef, value: any): void;

        /** `icon-translate`  */
        setIconTranslate(layer: LayerRef, value: any): void;

        /**  `icon-translate-anchor`  */
        setIconTranslateAnchor(layer: LayerRef, value: any): void;

        /** `text-opacity`  */
        setTextOpacity(layer: LayerRef, value: any): void;

        /**  `text-color`  */
        setTextColor(layer: LayerRef, value: any): void;

        /**  `text-halo-color`  */
        setTextHaloColor(layer: LayerRef, value: any): void;

        /**  `text-halo-width`  */
        setTextHaloWidth(layer: LayerRef, value: any): void;

        /**  `text-halo-blur`  */
        setTextHaloBlur(layer: LayerRef, value: any): void;

        /**  `text-translate`  */
        setTextTranslate(layer: LayerRef, value: any): void;

        /**  `text-translate-anchor`  */
        setTextTranslateAnchor(layer: LayerRef, value: any): void;

        /** `raster-opacity`  */
        setRasterOpacity(layer: LayerRef, value: any): void;

        /** `raster-hue-rotate`  */
        setRasterHueRotate(layer: LayerRef, value: any): void;

        /** `raster-monochrome`  */
        setRasterMonochrome(layer: LayerRef, value: any): void;

        /** `raster-inverse`  */
        setRasterInverse(layer: LayerRef, value: any): void;

        /**  `raster-brightness-min`  */
        setRasterBrightnessMin(layer: LayerRef, value: any): void;

        /** `raster-brightness-max`  */
        setRasterBrightnessMax(layer: LayerRef, value: any): void;

        /** `raster-saturation`  */
        setRasterSaturation(layer: LayerRef, value: any): void;

        /** `raster-contrast`  */
        setRasterContrast(layer: LayerRef, value: any): void;

        /** `raster-resampling`  */
        setRasterResampling(layer: LayerRef, value: any): void;

        /** `raster-fade-duration`  */
        setRasterFadeDuration(layer: LayerRef, value: any): void;

        /** `hillshade-illumination-direction`  */
        setHillshadeIlluminationDirection(layer: LayerRef, value: any): void;

        /** `hillshade-illumination-anchor`  */
        setHillshadeIlluminationAnchor(layer: LayerRef, value: any): void;

        /** `hillshade-exaggeration`  */
        setHillshadeExaggeration(layer: LayerRef, value: any): void;

        /**  `hillshade-shadow-color`  */
        setHillshadeShadowColor(layer: LayerRef, value: any): void;

        /** `hillshade-highlight-color`  */
        setHillshadeHighlightColor(layer: LayerRef, value: any): void;

        /** `hillshade-accent-color`  */
        setHillshadeAccentColor(layer: LayerRef, value: any): void;

        /** `background-color`  */
        setBackgroundColor(layer: LayerRef, value: any): void;

        /** `background-pattern`  */
        setBackgroundPattern(layer: LayerRef, value: any): void;

        /** `background-opacity`  */
        setBackgroundOpacity(layer: LayerRef, value: any): void;

        /**  */
        setVisibility(layer: LayerRef, value: any): void;

        /** `fill-sort-key` */
        setFillSortKey(layer: LayerRef, value: any): void;

        /**  `circle-sort-key`  */
        setCircleSortKey(layer: LayerRef, value: any): void;

        /**  `line-cap`  */
        setLineCap(layer: LayerRef, value: any): void;

        /** line-join */
        setLineJoin(layer: LayerRef, value: any): void;

        /** line-miter-limit */
        setLineMiterLimit(layer: LayerRef, value: any): void;

        /** `line-round-limit` */
        setLineRoundLimit(layer: LayerRef, value: any): void;

        /** `line-sort-key` */
        setLineSortKey(layer: LayerRef, value: any): void;

        /**  `symbol-placement`  */
        setSymbolPlacement(layer: LayerRef, value: any): void;

        /**  `symbol-spacing`  */
        setSymbolSpacing(layer: LayerRef, value: any): void;

        /**  `symbol-avoid-edges`  */
        setSymbolAvoidEdges(layer: LayerRef, value: any): void;

        /**  `symbol-sort-key`  */
        setSymbolSortKey(layer: LayerRef, value: any): void;

        /**  `symbol-z-order`  */
        setSymbolZOrder(layer: LayerRef, value: any): void;

        /** `icon-allow-overlap` */
        setIconAllowOverlap(layer: LayerRef, value: any): void;

        /** `icon-ignore-placement`  */
        setIconIgnorePlacement(layer: LayerRef, value: any): void;

        /** `icon-optional`  */
        setIconOptional(layer: LayerRef, value: any): void;

        /** `icon-rotation-alignment`  */
        setIconRotationAlignment(layer: LayerRef, value: any): void;

        /** `icon-size` */
        setIconSize(layer: LayerRef, value: any): void;

        /** `icon-text-fit` */
        setIconTextFit(layer: LayerRef, value: any): void;

        /** `icon-text-fit-padding` */
        setIconTextFitPadding(layer: LayerRef, value: any): void;

        /** `icon-image` */
        setIconImage(layer: LayerRef, value: any): void;

        /** `icon-rotate` */
        setIconRotate(layer: LayerRef, value: any): void;

        /** `icon-padding` */
        setIconPadding(layer: LayerRef, value: any): void;

        /** `icon-keep-upright` */
        setIconKeepUpright(layer: LayerRef, value: any): void;

        /** `icon-offset` */
        setIconOffset(layer: LayerRef, value: any): void;

        /** `icon-anchor` */
        setIconAnchor(layer: LayerRef, value: any): void;

        /** `icon-pitch-alignment` */
        setIconPitchAlignment(layer: LayerRef, value: any): void;

        /** `text-pitch-alignment`  */
        setTextPitchAlignment(layer: LayerRef, value: any): void;

        /** `text-rotation-alignment`  */
        setTextRotationAlignment(layer: LayerRef, value: any): void;

        /** `text-field`  */
        setTextField(layer: LayerRef, value: any): void;

        /**  `text-font`  */
        setTextFont(layer: LayerRef, value: any): void;

        /**  `text-size`  */
        setTextSize(layer: LayerRef, value: any): void;

        /** `text-max-width` */
        setTextMaxWidth(layer: LayerRef, value: any): void;

        /** `text-line-height` */
        setTextLineHeight(layer: LayerRef, value: any): void;

        /** `text-letter-spacing` */
        setTextLetterSpacing(layer: LayerRef, value: any): void;

        /** `text-justify`  */
        setTextJustify(layer: LayerRef, value: any): void;

        /** `text-radial-offset` */
        setTextRadialOffset(layer: LayerRef, value: any): void;

        /** `text-variable-anchor` */
        setTextVariableAnchor(layer: LayerRef, value: any): void;

        /** `text-anchor` */
        setTextAnchor(layer: LayerRef, value: any): void;

        /** `text-max-angle` */
        setTextMaxAngle(layer: LayerRef, value: any): void;

        /** `text-writing-mode`  */
        setTextWritingMode(layer: LayerRef, value: any): void;

        /**  `text-rotate`  */
        setTextRotate(layer: LayerRef, value: any): void;

        /** `text-padding` */
        setTextPadding(layer: LayerRef, value: any): void;

        /** `text-keep-upright`  */
        setTextKeepUpright(layer: LayerRef, value: any): void;

        /** `text-transform`  */
        setTextTransform(layer: LayerRef, value: any): void;

        /**  `text-offset`  */
        setTextOffset(layer: LayerRef, value: any): void;

        /** `text-allow-overlap`  */
        setTextAllowOverlap(layer: LayerRef, value: any): void;

        /** `text-ignore-placement`  */
        setTextIgnorePlacement(layer: LayerRef, value: any): void;

        /** `text-optional`  */
        setTextOptional(layer: LayerRef, value: any): void;

        /**  */
        getFillAntialias(layer: LayerRef): any;

        /**  `fill-opacity`  */
        getFillOpacity(layer: LayerRef): any;

        /**  `fill-color`  */
        getFillColor(layer: LayerRef): any;

        /**  `fill-outline-color`  */
        getFillOutlineColor(layer: LayerRef): any;

        /**  `fill-translate`  */
        getFillTranslate(layer: LayerRef): any;

        /**  `fill-translate-anchor`  */
        getFillTranslateAnchor(layer: LayerRef): any;

        /** `fill-pattern`  */
        getFillPattern(layer: LayerRef): any;

        /**  `fill-extrusion-opacity`  */
        getFillExtrusionOpacity(layer: LayerRef): any;

        /** `fill-extrusion-color`  */
        getFillExtrusionColor(layer: LayerRef): any;

        /** `fill-extrusion-translate`  */
        getFillExtrusionTranslate(layer: LayerRef): any;

        /**  `fill-extrusion-translate-anchor`  */
        getFillExtrusionTranslateAnchor(layer: LayerRef): any;

        /** `fill-extrusion-pattern`  */
        getFillExtrusionPattern(layer: LayerRef): any;

        /** `fill-extrusion-height` */
        getFillExtrusionHeight(layer: LayerRef): any;

        /** `fill-extrusion-base`  */
        getFillExtrusionBase(layer: LayerRef): any;

        /** `fill-extrusion-vertical-gradient` */
        getFillExtrusionVerticalGradient(layer: LayerRef): any;

        /**  `line-opacity`  */
        getLineOpacity(layer: LayerRef): any;

        /**  `line-color`  */
        getLineColor(layer: LayerRef): any;

        /**  `line-translate`  */
        getLineTranslate(layer: LayerRef): any;

        /**  `line-translate-anchor`  */
        getLineTranslateAnchor(layer: LayerRef): any;

        /**  */
        getLineWidth(layer: LayerRef): any;

        /**  `line-gap-width`  */
        getLineGapWidth(layer: LayerRef): any;

        /**  `line-offset`  */
        getLineOffset(layer: LayerRef): any;

        /**  `line-blur`  */
        getLineBlur(layer: LayerRef): any;

        /**  `line-dasharray`  */
        getLineDasharray(layer: LayerRef): any;

        /**  `line-pattern`  */
        getLinePattern(layer: LayerRef): any;

        /**  `line-gradient`  */
        getLineGradient(layer: LayerRef): any;

        /**  `circle-radius`  */
        getCircleRadius(layer: LayerRef): any;

        /**  `circle-color`  */
        getCircleColor(layer: LayerRef): any;

        /**  `circle-blur` */
        getCircleBlur(layer: LayerRef): any;

        /**  `circle-opacity`  */
        getCircleOpacity(layer: LayerRef): any;

        /**  `circle-translate`  */
        getCircleTranslate(layer: LayerRef): any;

        /**  `circle-translate-anchor`  */
        getCircleTranslateAnchor(layer: LayerRef): any;

        /**  `circle-pitch-scale`  */
        getCirclePitchScale(layer: LayerRef): any;

        /**  `circle-pitch-alignment`  */
        getCirclePitchAlignment(layer: LayerRef): any;

        /**  `circle-stroke-width`  */
        getCircleStrokeWidth(layer: LayerRef): any;

        /**  `circle-stroke-color`  */
        getCircleStrokeColor(layer: LayerRef): any;

        /** Gets the `circle-stroke-opacity`  . */
        getCircleStrokeOpacity(layer: LayerRef): any;

        /** Gets the `heatmap-radius`  . */
        getHeatmapRadius(layer: LayerRef): any;

        /** Gets the `heatmap-weight`  . */
        getHeatmapWeight(layer: LayerRef): any;

        /** Gets the `heatmap-intensity`  . */
        getHeatmapIntensity(layer: LayerRef): any;

        /** Gets the `heatmap-color`  . */
        getHeatmapColor(layer: LayerRef): any;

        /** Gets the `heatmap-opacity`  . */
        getHeatmapOpacity(layer: LayerRef): any;

        /** Gets the `icon-opacity`  . */
        getIconOpacity(layer: LayerRef): any;

        /** Gets the `icon-color`  . */
        getIconColor(layer: LayerRef): any;

        /** Gets the `icon-halo-color`  . */
        getIconHaloColor(layer: LayerRef): any;

        /** Gets the `icon-halo-width`  . */
        getIconHaloWidth(layer: LayerRef): any;

        /** Gets the `icon-halo-blur`  . */
        getIconHaloBlur(layer: LayerRef): any;

        /** Gets the `icon-translate`  . */
        getIconTranslate(layer: LayerRef): any;

        /** Gets the `icon-translate-anchor`  . */
        getIconTranslateAnchor(layer: LayerRef): any;

        /** Gets the `text-opacity`  . */
        getTextOpacity(layer: LayerRef): any;

        /** Gets the `text-color`  . */
        getTextColor(layer: LayerRef): any;

        /** Gets the `text-halo-color`  . */
        getTextHaloColor(layer: LayerRef): any;

        /** Gets the `text-halo-width`  . */
        getTextHaloWidth(layer: LayerRef): any;

        /** Gets the `text-halo-blur`  . */
        getTextHaloBlur(layer: LayerRef): any;

        /** Gets the `text-translate`  . */
        getTextTranslate(layer: LayerRef): any;

        /** Gets the `text-translate-anchor`  . */
        getTextTranslateAnchor(layer: LayerRef): any;

        /** Gets the `raster-opacity`  . */
        getRasterOpacity(layer: LayerRef): any;

        /** Gets the `raster-hue-rotate`  . */
        getRasterHueRotate(layer: LayerRef): any;

        /** `raster-brightness-min`  . */
        getRasterBrightnessMin(layer: LayerRef): any;

        /** `raster-brightness-max`  . */
        getRasterBrightnessMax(layer: LayerRef): any;

        /** `raster-saturation`  . */
        getRasterSaturation(layer: LayerRef): any;

        /** `raster-contrast`  . */
        getRasterContrast(layer: LayerRef): any;

        /** `raster-resampling`  . */
        getRasterResampling(layer: LayerRef): any;

        /** `raster-fade-duration`  . */
        getRasterFadeDuration(layer: LayerRef): any;

        /** `hillshade-illumination-direction`  . */
        getHillshadeIlluminationDirection(layer: LayerRef): any;

        /** `hillshade-illumination-anchor`  . */
        getHillshadeIlluminationAnchor(layer: LayerRef): any;

        /** `hillshade-exaggeration`  . */
        getHillshadeExaggeration(layer: LayerRef): any;

        /** `hillshade-shadow-color`  . */
        getHillshadeShadowColor(layer: LayerRef): any;

        /** `hillshade-highlight-color`  . */
        getHillshadeHighlightColor(layer: LayerRef): any;

        /** `hillshade-accent-color`  . */
        getHillshadeAccentColor(layer: LayerRef): any;

        /** `background-color`  . */
        getBackgroundColor(layer: LayerRef): any;

        /** `background-pattern`  . */
        getBackgroundPattern(layer: LayerRef): any;

        /** `background-opacity`  . */
        getBackgroundOpacity(layer: LayerRef): any;

        /** `visibility` . */
        getVisibility(layer: LayerRef): any;

        /** `fill-sort-key` . */
        getFillSortKey(layer: LayerRef): any;

        /** `circle-sort-key` . */
        getCircleSortKey(layer: LayerRef): any;

        /** `line-cap` . */
        getLineCap(layer: LayerRef): any;

        /** `line-join` . */
        getLineJoin(layer: LayerRef): any;

        /** `line-miter-limit` . */
        getLineMiterLimit(layer: LayerRef): any;

        /** `line-round-limit` . */
        getLineRoundLimit(layer: LayerRef): any;

        /** `line-sort-key` . */
        getLineSortKey(layer: LayerRef): any;

        /** `symbol-placement` . */
        getSymbolPlacement(layer: LayerRef): any;

        /**  `symbol-spacing`  */
        getSymbolSpacing(layer: LayerRef): any;

        /**  `symbol-avoid-edges`  */
        getSymbolAvoidEdges(layer: LayerRef): any;

        /**  `symbol-sort-key`  */
        getSymbolSortKey(layer: LayerRef): any;

        /**  `symbol-z-order`  */
        getSymbolZOrder(layer: LayerRef): any;

        /** `icon-allow-overlap`  */
        getIconAllowOverlap(layer: LayerRef): any;

        /** `icon-ignore-placement`  */
        getIconIgnorePlacement(layer: LayerRef): any;

        /** `icon-optional`  */
        getIconOptional(layer: LayerRef): any;

        /** `icon-rotation-alignment`  */
        getIconRotationAlignment(layer: LayerRef): any;

        /** `icon-size`  */
        getIconSize(layer: LayerRef): any;

        /** `icon-text-fit`  */
        getIconTextFit(layer: LayerRef): any;

        /** `icon-text-fit-padding` */
        getIconTextFitPadding(layer: LayerRef): any;

        /** `icon-image`  */
        getIconImage(layer: LayerRef): any;

        /** `icon-rotate`  */
        getIconRotate(layer: LayerRef): any;

        /** `icon-padding` */
        getIconPadding(layer: LayerRef): any;

        /**  `icon-keep-upright`  */
        getIconKeepUpright(layer: LayerRef): any;

        /** `icon-offset` */
        getIconOffset(layer: LayerRef): any;

        /** `icon-anchor`  */
        getIconAnchor(layer: LayerRef): any;

        /** `icon-pitch-alignment` */
        getIconPitchAlignment(layer: LayerRef): any;

        /**  `text-pitch-alignment`  */
        getTextPitchAlignment(layer: LayerRef): any;

        /** `text-rotation-alignment`  */
        getTextRotationAlignment(layer: LayerRef): any;

        /**  */
        getTextField(layer: LayerRef): any;

        /**  `text-font`  */
        getTextFont(layer: LayerRef): any;

        /**  `text-size`  */
        getTextSize(layer: LayerRef): any;

        /**  `text-max-width` */
        getTextMaxWidth(layer: LayerRef): any;

        /**  `text-line-height` */
        getTextLineHeight(layer: LayerRef): any;

        /**  `text-letter-spacing`  */
        getTextLetterSpacing(layer: LayerRef): any;

        /**  `text-justify`  */
        getTextJustify(layer: LayerRef): any;

        /**  `text-radial-offset`  */
        getTextRadialOffset(layer: LayerRef): any;

        /**  `text-variable-anchor`  */
        getTextVariableAnchor(layer: LayerRef): any;

        /**  `text-anchor` */
        getTextAnchor(layer: LayerRef): any;

        /**  `text-max-angle`  */
        getTextMaxAngle(layer: LayerRef): any;

        /**  `text-writing-mode`  */
        getTextWritingMode(layer: LayerRef): any;

        /**  `text-rotate`  */
        getTextRotate(layer: LayerRef): any;

        /**  `text-padding`  */
        getTextPadding(layer: LayerRef): any;

        /**  `text-keep-upright`  */
        getTextKeepUpright(layer: LayerRef): any;

        /**  `text-transform`  */
        getTextTransform(layer: LayerRef): any;

        /**  `text-offset`  */
        getTextOffset(layer: LayerRef): any;

        /**  `text-allow-overlap`  */
        getTextAllowOverlap(layer: LayerRef): any;

        /**  `text-ignore-placement`  */
        getTextIgnorePlacement(layer: LayerRef): any;

        /**  `text-optional`  */
        getTextOptional(layer: LayerRef): any;

        

        addControl(
            control: Control | IControl,
            position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left',
        ): this;

        removeControl(control: Control | IControl): this;

        /**
         * Checks if a control exists on the map.
         *
         * @param {IControl} control The {@link IControl} to check.
         * @returns {boolean} True if map contains control.
         * @example
         */
        hasControl(control: IControl): boolean;

        resize(eventData?: EventData): this;

        getBounds(): LngLatBounds;

        getMaxBounds(): LngLatBounds | null;

        setMaxBounds(lnglatbounds?: LngLatBoundsLike): this;

        setMinZoom(minZoom?: number | null): this;

        getMinZoom(): number;

        setMaxZoom(maxZoom?: number | null): this;

        getMaxZoom(): number;

        setMinPitch(minPitch?: number | null): this;

        getMinPitch(): number;

        setMaxPitch(maxPitch?: number | null): this;

        getMaxPitch(): number;

        getRenderWorldCopies(): boolean;

        setRenderWorldCopies(renderWorldCopies?: boolean): this;

        project(lnglat: LngLatLike): vjmap.Point;

        unproject(point: PointLike): vjmap.LngLat;

        isMoving(): boolean;

        isZooming(): boolean;

        isRotating(): boolean;

        /**
         * Returns an array of GeoJSON Feature objects representing visible features that satisfy the query parameters.
         *
         * The properties value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only string and numeric property values are supported (i.e. null, Array, and Object values are not supported).
         *
         * Each feature includes top-level layer, source, and sourceLayer properties. The layer property is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
         *
         * Only features that are currently rendered are included. Some features will not be included, like:
         *
         * - Features from layers whose visibility property is "none".
         * - Features from layers whose zoom range excludes the current zoom level.
         * - Symbol features that have been hidden due to text or icon collision.
         *
         * Features from all other layers are included, including features that may have no visible contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to 0.
         *
         * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low zoom levels) are returned only once (though subject to the following caveat).
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param pointOrBox The geometry of the query region: either a single point or southwest and northeast points describing a bounding box. Omitting this parameter (i.e. calling Map#queryRenderedFeatures with zero arguments, or with only a  options argument) is equivalent to passing a bounding box encompassing the entire map viewport.
         * @param options
         */
        queryRenderedFeatures(
            pointOrBox?: PointLike | [PointLike, PointLike],
            options?: { layers?: string[] | undefined; filter?: any[] | undefined } & FilterOptions,
        ): MapGeoJSONFeature[];

        /**
         * Returns an array of GeoJSON Feature objects representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
         *
         * In contrast to Map#queryRenderedFeatures, this function returns all features matching the query parameters, whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently visible viewport.
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param sourceID The ID of the vector tile or GeoJSON source to query.
         * @param parameters
         */
        querySourceFeatures(
            sourceID: string,
            parameters?: {
                sourceLayer?: string | undefined;
                filter?: any[] | undefined;
            } & FilterOptions,
        ): MapGeoJSONFeature[];

        setStyle(
            style: vjmap.Style | string,
            options?: { diff?: boolean | undefined; localIdeographFontFamily?: string | undefined },
        ): this;

        getStyle(): vjmap.Style;

        isStyleLoaded(): boolean;

        addSource(id: string, source: AnySourceData): this;

        isSourceLoaded(id: string): boolean;

        areTilesLoaded(): boolean;

        removeSource(id: string): this;

        getSource(id: string): AnySourceImpl;

        addImage(
            name: string,
            image:
                | HTMLImageElement
                | ArrayBufferView
                | { width: number; height: number; data: Uint8Array | Uint8ClampedArray }
                | ImageData
                | ImageBitmap,
            options?: { pixelRatio?: number | undefined; sdf?: boolean | undefined },
        ): void;

        updateImage(
            name: string,
            image:
                | HTMLImageElement
                | ArrayBufferView
                | { width: number; height: number; data: Uint8Array | Uint8ClampedArray }
                | ImageData
                | ImageBitmap,
        ): void;

        hasImage(name: string): boolean;

        removeImage(name: string): void;

        loadImage(url: string, callback: (error?: Error, result?: HTMLImageElement | ImageBitmap) => void): void;

        listImages(): string[];

        addLayer(layer: vjmap.AnyLayer, before?: string): this;

        moveLayer(id: string, beforeId?: string): this;

        removeLayer(id: string): this;

        getLayer(id: string): vjmap.AnyLayer;

        setFilter(layer: string, filter?: any[] | boolean | null, options?: FilterOptions | null): this;

        setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this;

        getFilter(layer: string): any[];

        setPaintProperty(layer: string, name: string, value: any, klass?: string): this;

        getPaintProperty(layer: string, name: string): any;

        setLayoutProperty(layer: string, name: string, value: any): this;

        getLayoutProperty(layer: string, name: string): any;

        setLight(options: vjmap.Light, lightOptions?: any): this;

        getLight(): vjmap.Light;

        /**
         * Sets the terrain property of the style.
         *
         * @param terrain Terrain properties to set. Must conform to the [Map Style Specification](https://www.Map.com/Map-gl-style-spec/#terrain).
         * If `null` or `undefined` is provided, function removes terrain.
         * @returns {Map} `this`
         * @example
         * map.addSource('Map-dem', {
         *     'type': 'raster-dem',
         *     'url': 'Map://Map.Map-terrain-dem-v1',
         *     'tileSize': 512,
         *     'maxzoom': 14
         * });
         * // add the DEM source as a terrain layer with exaggerated height
         * map.setTerrain({ 'source': 'Map-dem', 'exaggeration': 1.5 });
         */
        setTerrain(terrain?: TerrainSpecification | null): this;

        getTerrain(): TerrainSpecification | null;

        showTerrainWireframe: boolean;

        /**
         *
         * @param lngLat The coordinate to query
         * @param options Optional {ElevationQueryOptions}
         * @returns The elevation in meters at mean sea level or null
         */
        queryTerrainElevation(lngLat: LngLatLike, options?: ElevationQueryOptions): number | null;

        setFeatureState(
            feature: FeatureIdentifier | vjmap.MapGeoJSONFeature,
            state: { [key: string]: any },
        ): void;

        getFeatureState(feature: FeatureIdentifier | vjmap.MapGeoJSONFeature): { [key: string]: any };

        removeFeatureState(target: FeatureIdentifier | vjmap.MapGeoJSONFeature, key?: string): void;

        getContainer(): HTMLElement;

        getCanvasContainer(): HTMLElement;

        getCanvas(): HTMLCanvasElement;

        loaded(): boolean;

        remove(): void;

        triggerRepaint(): void;

        showTileBoundaries: boolean;

        showCollisionBoxes: boolean;

        /**
         * Gets and sets a Boolean indicating whether the map will visualize
         * the padding offsets.
         *
         * @name showPadding
         * @type {boolean}
         * @instance
         * @memberof Map
         */
        showPadding: boolean;

        repaint: boolean;

        getCenter(): vjmap.LngLat;

        setCenter(center: LngLatLike, eventData?: vjmap.EventData): this;

        panBy(offset: PointLike, options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        panTo(lnglat: LngLatLike, options?: vjmap.AnimationOptions, eventdata?: vjmap.EventData): this;

        getZoom(): number;

        setZoom(zoom: number, eventData?: vjmap.EventData): this;

        zoomTo(zoom: number, options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        zoomIn(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        zoomOut(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        getBearing(): number;

        setBearing(bearing: number, eventData?: vjmap.EventData): this;

        /**
         * Returns the current padding applied around the map viewport.
         *
         * @memberof Map#
         * @returns The current padding around the map viewport.
         */
        getPadding(): PaddingOptions;

        /**
         * Sets the padding in pixels around the viewport.
         *
         * Equivalent to `jumpTo({padding: padding})`.
         *
         * @memberof Map#
         * @param padding The desired padding. Format: { left: number, right: number, top: number, bottom: number }
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * // Sets a left padding of 300px, and a top padding of 50px
         * map.setPadding({ left: 300, top: 50 });
         */
        setPadding(padding: PaddingOptions, eventData?: EventData): this;

        rotateTo(bearing: number, options?: vjmap.AnimationOptions, eventData?: EventData): this;

        resetNorth(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        resetNorthPitch(options?: vjmap.AnimationOptions | null, eventData?: vjmap.EventData | null): this;

        snapToNorth(options?: vjmap.AnimationOptions, eventData?: vjmap.EventData): this;

        getPitch(): number;

        setPitch(pitch: number, eventData?: EventData): this;

        cameraForBounds(bounds: LngLatBoundsLike, options?: CameraForBoundsOptions): CameraForBoundsResult | undefined;

        fitBounds(bounds: LngLatBoundsLike, options?: vjmap.FitBoundsOptions, eventData?: vjmap.EventData): this;

        fitScreenCoordinates(
            p0: PointLike,
            p1: PointLike,
            bearing: number,
            options?: AnimationOptions & CameraOptions,
            eventData?: EventData,
        ): this;

        jumpTo(options: vjmap.CameraOptions, eventData?: vjmap.EventData): this;

        /**
         * Returns position and orientation of the camera entity.
         *
         * @memberof Map#
         * @returns {FreeCameraOptions} The camera state
         */
        getFreeCameraOptions(): FreeCameraOptions;

        /**
         * FreeCameraOptions provides more direct access to the underlying camera entity.
         * For backwards compatibility the state set using this API must be representable with
         * `CameraOptions` as well. Parameters are clamped into a valid range or discarded as invalid
         * if the conversion to the pitch and bearing presentation is ambiguous. For example orientation
         * can be invalid if it leads to the camera being upside down, the quaternion has zero length,
         * or the pitch is over the maximum pitch limit.
         *
         * @memberof Map#
         * @param {FreeCameraOptions} options FreeCameraOptions object
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires zoomstart
         * @fires pitchstart
         * @fires rotate
         * @fires move
         * @fires zoom
         * @fires pitch
         * @fires moveend
         * @fires zoomend
         * @fires pitchend
         * @returns {Map} `this`
         */
        setFreeCameraOptions(options: FreeCameraOptions, eventData?: Object): this;

        easeTo(options: vjmap.EaseToOptions, eventData?: vjmap.EventData): this;

        flyTo(options: vjmap.FlyToOptions, eventData?: vjmap.EventData): this;

        isEasing(): boolean;

        stop(): this;

        on<T extends keyof MapLayerEventType>(
            type: T,
            layer: string | ReadonlyArray<string>,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        on<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        on(type: string, listener: (ev: any) => void): this;

        once<T extends keyof MapLayerEventType>(
            type: T,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        once<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        once(type: string, listener: (ev: any) => void): this;
        once<T extends keyof MapEventType>(type: T): Promise<MapEventType[T]>;

        off<T extends keyof MapLayerEventType>(
            type: T,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        off<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        off(type: string, listener: (ev: any) => void): this;

        scrollZoom: ScrollZoomHandler;

        boxZoom: BoxZoomHandler;

        dragRotate: DragRotateHandler;

        dragPan: DragPanHandler;

        keyboard: KeyboardHandler;

        doubleClickZoom: DoubleClickZoomHandler;

        touchZoomRotate: TouchZoomRotateHandler;

        touchPitch: TouchPitchHandler;

        getFog(): Fog | null;
        setFog(fog: Fog): this;
    }

    export interface MapOptions {
        /**
         * If true, the gl context will be created with MSA antialiasing, which can be useful for antialiasing custom layers.
         * This is false by default as a performance optimization.
         */
        antialias?: boolean | undefined;

        /** If true, an attribution control will be added to the map. */
        attributionControl?: boolean | undefined;

        bearing?: number | undefined;

        /** Snap to north threshold in degrees. */
        bearingSnap?: number | undefined;

        /** The initial bounds of the map. If bounds is specified, it overrides center and zoom constructor options. */
        bounds?: LngLatBoundsLike | undefined;

        /** If true, enable the "box zoom" interaction (see BoxZoomHandler) */
        boxZoom?: boolean | undefined;

        /** initial map center */
        center?: LngLatLike | undefined;

        /**
         * The max number of pixels a user can shift the mouse pointer during a click for it to be
         * considered a valid click (as opposed to a mouse drag).
         *
         * @default 3
         */
        clickTolerance?: number | undefined;

        /**
         * If `true`, Resource Timing API information will be collected for requests made by GeoJSON
         * and Vector Tile web workers (this information is normally inaccessible from the main
         * Javascript thread). Information will be returned in a `resourceTiming` property of
         * relevant `data` events.
         *
         * @default false
         */
        collectResourceTiming?: boolean | undefined;

        /**
         * If `true`, symbols from multiple sources can collide with each other during collision
         * detection. If `false`, collision detection is run separately for the symbols in each source.
         *
         * @default true
         */
        crossSourceCollisions?: boolean | undefined;

        /** ID of the container element */
        container: string | HTMLElement;

        /**
         * If `true` , scroll zoom will require pressing the ctrl or  key while scrolling to zoom map,
         * and touch pan will require using two fingers while panning to move the map.
         * Touch pitch will require three fingers to activate if enabled.
         */
        cooperativeGestures?: boolean;

        /** String or strings to show in an AttributionControl.
         * Only applicable if options.attributionControl is `true`. */
        customAttribution?: string | string[] | undefined;

        /**
         * If `true`, the "drag to pan" interaction is enabled.
         * An `Object` value is passed as options to {@link DragPanHandler#enable}.
         */
        dragPan?: boolean | DragPanOptions | undefined;

        /** If true, enable the "drag to rotate" interaction (see DragRotateHandler). */
        dragRotate?: boolean | undefined;

        /** If true, enable the "double click to zoom" interaction (see DoubleClickZoomHandler). */
        doubleClickZoom?: boolean | undefined;

        /** If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.
         * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.
         * An additional string may optionally be provided to indicate a parameter-styled hash,
         * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo
         * is a custom parameter and bar is an arbitrary hash distinct from the map hash.
         * */
        hash?: boolean | string | undefined;

        /**
         * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.
         * This setting affects all symbol layers. This setting does not affect the duration of runtime
         * styling transitions or raster tile cross-fading.
         *
         * @default 300
         */
        fadeDuration?: number | undefined;

        /** If true, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected. */
        failIfMajorPerformanceCaveat?: boolean | undefined;

        /** A fitBounds options object to use only when setting the bounds option. */
        fitBoundsOptions?: FitBoundsOptions | undefined;

        /** If false, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input */
        interactive?: boolean | undefined;

        /** If true, enable keyboard shortcuts (see KeyboardHandler). */
        keyboard?: boolean | undefined;

        /** A patch to apply to the default localization table for UI strings, e.g. control tooltips.
         * The `locale` object maps namespaced UI string IDs to translated strings in the target language;
         * see `src/ui/default_locale.js` for an example with all supported string IDs.
         * The object may specify all UI strings (thereby adding support for a new translation) or
         * only a subset of strings (thereby patching the default translation table).
         */
        locale?: { [key: string]: string } | undefined;

        /**
         * Overrides the generation of all glyphs and font settings except font-weight keywords
         * Also overrides localIdeographFontFamily
         * @default null
         */
        localFontFamily?: string | undefined;

        /**
         * If specified, defines a CSS font-family for locally overriding generation of glyphs in the
         * 'CJK Unified Ideographs' and 'Hangul Syllables' ranges. In these ranges, font settings from
         * the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
         * The purpose of this option is to avoid bandwidth-intensive glyph server requests.
         *
         * @default null
         */
        localIdeographFontFamily?: string | undefined;

        /**
         * A string representing the position of the Map wordmark on the map.
         *
         * @default "bottom-left"
         */
        logoPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | undefined;

        /** If set, the map is constrained to the given bounds. */
        maxBounds?: LngLatBoundsLike | undefined;

        /** Maximum pitch of the map. */
        maxPitch?: number | undefined;

        /** Maximum zoom of the map. */
        maxZoom?: number | undefined;

        /** Minimum pitch of the map. */
        minPitch?: number | undefined;

        /** Minimum zoom of the map. */
        minZoom?: number | undefined;

        /**
         * If true, map will prioritize rendering for performance by reordering layers
         * If false, layers will always be drawn in the specified order
         *
         * @default true
         */
        optimizeForTerrain?: boolean | undefined;

        /** If true, The maps canvas can be exported to a PNG using map.getCanvas().toDataURL();. This is false by default as a performance optimization. */
        preserveDrawingBuffer?: boolean | undefined;

        /**
         * The initial pitch (tilt) of the map, measured in degrees away from the plane of the
         * screen (0-60).
         *
         * @default 0
         */
        pitch?: number | undefined;

        /**
         * A style's projection property sets which projection a map is rendered in.
         *
         * @default 'mercator'
         */
         projection?: {
            name: 'albers' | 'equalEarth' | 'equirectangular' | 'lambertConformalConic' | 'mercator' | 'naturalEarth' | 'winkelTripel' | 'globe',
            center?: [number, number],
            parallels?: [number, number]
        };

        /**
         * If `false`, the map's pitch (tilt) control with "drag to rotate" interaction will be disabled.
         *
         * @default true
         */
        pitchWithRotate?: boolean | undefined;

        /**
         * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP
         * `cacheControl`/`expires` headers.
         *
         * @default true
         */
        refreshExpiredTiles?: boolean | undefined;

        /**
         * If `true`, multiple copies of the world will be rendered, when zoomed out.
         *
         * @default true
         */
        renderWorldCopies?: boolean | undefined;

        /**
         * If `true`, the "scroll to zoom" interaction is enabled.
         * An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.
         */
        scrollZoom?: boolean | InteractiveOptions | undefined;

        /** stylesheet location */
        style?: vjmap.Style | string | undefined;

        /** If  true, the map will automatically resize when the browser window resizes */
        trackResize?: boolean | undefined;

        /**
         * A callback run before the Map makes a request for an external URL. The callback can be
         * used to modify the url, set headers, or set the credentials property for cross-origin requests.
         *
         * @default null
         */
        transformRequest?: TransformRequestFunction | undefined;

        /**
         * If `true`, the "pinch to rotate and zoom" interaction is enabled.
         * An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.
         */
        touchZoomRotate?: boolean | InteractiveOptions | undefined;

        /**
         * If `true`, the "drag to pitch" interaction is enabled.
         * An `Object` value is passed as options to {@link TouchPitchHandler#enable}.
         */
        touchPitch?: boolean | InteractiveOptions | undefined;

        /** Initial zoom level */
        zoom?: number | undefined;

        /**
         * The maximum number of tiles stored in the tile cache for a given source. If omitted, the
         * cache will be dynamically sized based on the current viewport.
         *
         * @default null
         */
        maxTileCacheSize?: number | undefined;

        /**
         * If specified, map will use this token instead of the one defined in vjmap.accessToken.
         *
         * @default null
         */
        accessToken?: string | undefined;

        /**
         * Allows for the usage of the map in automated tests without an accessToken with custom self-hosted test fixtures.
         *
         * @default null
         */
        testMode?: boolean | undefined;
    }

  export  type quat = number[];
  export  type vec3 = number[];

    /**
     * Various options for accessing physical properties of the underlying camera entity.
     * A direct access to these properties allows more flexible and precise controlling of the camera
     * while also being fully compatible and interchangeable with CameraOptions. All fields are optional.
     * See {@Link Camera#setFreeCameraOptions} and {@Link Camera#getFreeCameraOptions}
     *
     * @param {MercatorCoordinate} position Position of the camera in slightly modified web mercator coordinates
            - The size of 1 unit is the width of the projected world instead of the "mercator meter".
            Coordinate [0, 0, 0] is the north-west corner and [1, 1, 0] is the south-east corner.
            - Z coordinate is conformal and must respect minimum and maximum zoom values.
            - Zoom is automatically computed from the altitude (z)
    * @param {quat} orientation Orientation of the camera represented as a unit quaternion [x, y, z, w]
            in a left-handed coordinate space. Direction of the rotation is clockwise around the respective axis.
            The default pose of the camera is such that the forward vector is looking up the -Z axis and
            the up vector is aligned with north orientation of the map:
            forward: [0, 0, -1]
            up:      [0, -1, 0]
            right    [1, 0, 0]
            Orientation can be set freely but certain constraints still apply
            - Orientation must be representable with only pitch and bearing.
            - Pitch has an upper limit
    */
    export class FreeCameraOptions {
        constructor(position?: MercatorCoordinate, orientation?: quat);

        position: MercatorCoordinate | undefined;

        /**
         * Helper function for setting orientation of the camera by defining a focus point
         * on the map.
         *
         * @param {LngLatLike} location Location of the focus point on the map
         * @param {vec3} up Up vector of the camera is required in certain scenarios where bearing can't be deduced
         *      from the viewing direction.
         */
        lookAtPoint(location: LngLatLike, up?: vec3): void;

        /**
         * Helper function for setting the orientation of the camera as a pitch and a bearing.
         *
         * @param {number} pitch Pitch angle in degrees
         * @param {number} bearing Bearing angle in degrees
         */
        setPitchBearing(pitch: number, bearing: number): void;
    }

    export type ResourceType =
        | 'Unknown'
        | 'Style'
        | 'Source'
        | 'Tile'
        | 'Glyphs'
        | 'SpriteImage'
        | 'SpriteJSON'
        | 'Image';

    export interface RequestParameters {
        /**
         * The URL to be requested.
         */
        url: string;

        /**
         * Use `'include'` to send cookies with cross-origin requests.
         */
        credentials?: 'same-origin' | 'include' | undefined;

        /**
         * The headers to be sent with the request.
         */
        headers?: { [header: string]: any } | undefined;

        method?: 'GET' | 'POST' | 'PUT' | undefined;

        collectResourceTiming?: boolean | undefined;
    }

    export type TransformRequestFunction = (url: string, resourceType: ResourceType) => RequestParameters;

    export interface PaddingOptions {
        top: number;
        bottom: number;
        left: number;
        right: number;
    }

    export interface FeatureIdentifier {
        id?: string | number | undefined;
        source: string;
        sourceLayer?: string | undefined;
    }

    /**
     * BoxZoomHandler
     */
    export class BoxZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * ScrollZoomHandler
     */
    export class ScrollZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(options?: InteractiveOptions): void;

        disable(): void;

        setZoomRate(zoomRate: number): void;

        setWheelZoomRate(wheelZoomRate: number): void;
    }

    /**
     * DragPenHandler
     */
    export class DragPanHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(options?: DragPanOptions): void;

        disable(): void;
    }

    /**
     * DragRotateHandler
     */
    export class DragRotateHandler {
        constructor(
            map: vjmap.Map,
            options?: { bearingSnap?: number | undefined; pitchWithRotate?: boolean | undefined },
        );

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * KeyboardHandler
     */
    export class KeyboardHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;

        /**
         * Returns true if the handler is enabled and has detected the start of a
         * zoom/rotate gesture.
         *
         * @returns {boolean} `true` if the handler is enabled and has detected the
         * start of a zoom/rotate gesture.
         */
        isActive(): boolean;

        /**
         * Disables the "keyboard pan/rotate" interaction, leaving the
         * "keyboard zoom" interaction enabled.
         *
         * @example
         *   map.keyboard.disableRotation();
         */
        disableRotation(): void;

        /**
         * Enables the "keyboard pan/rotate" interaction.
         *
         * @example
         *   map.keyboard.enable();
         *   map.keyboard.enableRotation();
         */
        enableRotation(): void;
    }

    /**
     * DoubleClickZoomHandler
     */
    export class DoubleClickZoomHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * TouchZoomRotateHandler
     */
    export class TouchZoomRotateHandler {
        constructor(map: vjmap.Map);

        isEnabled(): boolean;

        enable(options?: InteractiveOptions): void;

        disable(): void;

        disableRotation(): void;

        enableRotation(): void;
    }

    export class TouchPitchHandler {
        constructor(map: vjmap.Map);

        enable(options?: InteractiveOptions): void;

        isActive(): boolean;

        isEnabled(): boolean;

        disable(): void;
    }

    export interface IControl {
        onAdd(map: Map): HTMLElement;

        onRemove(map: Map): void;

        getDefaultPosition?: (() => string) | undefined;
    }

    /**
     * Control
     */
    export class Control extends Evented implements IControl {
        onAdd(map: Map): HTMLElement;
        onRemove(map: Map): void;
        getDefaultPosition?: (() => string) | undefined;
    }

    /**
     * Navigation
     */
    export class NavigationControl extends Control {
        constructor(options?: {
            showCompass?: boolean | undefined;
            showZoom?: boolean | undefined;
            visualizePitch?: boolean | undefined;
        });
    }

    export class PositionOptions {
        enableHighAccuracy?: boolean | undefined;
        timeout?: number | undefined;
        maximumAge?: number | undefined;
    }

    /**
     * Geolocate
     */
    export class GeolocateControl extends Control {
        constructor(options?: {
            positionOptions?: PositionOptions | undefined;
            fitBoundsOptions?: FitBoundsOptions | undefined;
            trackUserLocation?: boolean | undefined;
            showAccuracyCircle?: boolean | undefined;
            showUserLocation?: boolean | undefined;
            showUserHeading?: boolean | undefined;
        });
        trigger(): boolean;
    }

    /**
     * Attribution
     */
    export class AttributionControl extends Control {
        constructor(options?: { compact?: boolean | undefined; customAttribution?: string | string[] | undefined });
    }

    /**
     * Scale
     */
    export class ScaleControl extends Control {
        constructor(options?: { maxWidth?: number | undefined; unit?: string | undefined });

        setUnit(unit: 'imperial' | 'metric' | 'nautical'): void;
    }

    /**
     * FullscreenControl
     */
    export class FullscreenControl extends Control {
        constructor(options?: FullscreenControlOptions | null);
    }

    export interface FullscreenControlOptions {
        /**
         * A compatible DOM element which should be made full screen.
         * By default, the map container element will be made full screen.
         */
        container?: HTMLElement | null | undefined;
    }

    /**
     * Popup
     */
    export class Popup extends Evented {

        /**
         * 
         * @param height 
         */
        setHeight(height: number): Popup;


        /**
         * 
         */
        getHeight(): number | undefined;


        
        constructor(options?: vjmap.PopupOptions);

        addTo(map: vjmap.Map): this;

        isOpen(): boolean;

        remove(): this;

        getLngLat(): vjmap.LngLat;

        /**
         * Sets the geographical location of the popup's anchor, and moves the popup to it. Replaces trackPointer() behavior.
         *
         * @param lnglat The geographical location to set as the popup's anchor.
         */
        setLngLat(lnglat: LngLatLike): this;

        /**
         * Tracks the popup anchor to the cursor position, on screens with a pointer device (will be hidden on touchscreens). Replaces the setLngLat behavior.
         * For most use cases, `closeOnClick` and `closeButton` should also be set to `false` here.
         */
        trackPointer(): this;

        /** Returns the `Popup`'s HTML element. */
        getElement(): HTMLElement;

        setText(text: string): this;

        setHTML(html: string): this;

        setDOMContent(htmlNode: Node): this;

        getMaxWidth(): string;

        setMaxWidth(maxWidth: string): this;

        /**
         * Adds a CSS class to the popup container element.
         *
         * @param {string} className Non-empty string with CSS class name to add to popup container
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.addClassName('some-class')
         */
        addClassName(className: string): void;

        /**
         * Removes a CSS class from the popup container element.
         *
         * @param {string} className Non-empty string with CSS class name to remove from popup container
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.removeClassName('some-class')
         */
        removeClassName(className: string): void;

        /**
         * Sets the popup's offset.
         *
         * @param offset Sets the popup's offset.
         * @returns {Popup} `this`
         */
        setOffset(offset?: Offset | null): this;

        /**
         * Add or remove the given CSS class on the popup container, depending on whether the container currently has that class.
         *
         * @param {string} className Non-empty string with CSS class name to add/remove
         *
         * @returns {boolean} if the class was removed return false, if class was added, then return true
         *
         * @example
         * let popup = new vjmap.Popup()
         * popup.toggleClassName('toggleClass')
         */
        toggleClassName(className: string): void;
    }

    export interface PopupOptions {
        closeButton?: boolean | undefined;

        closeOnClick?: boolean | undefined;

        /**
         * @param {boolean} [options.closeOnMove=false] If `true`, the popup will closed when the map moves.
         */
        closeOnMove?: boolean | undefined;

        /**
         * @param {boolean} [options.focusAfterOpen=true] If `true`, the popup will try to focus the
         *   first focusable element inside the popup.
         */
        focusAfterOpen?: boolean | null | undefined;

        anchor?: Anchor | undefined;

        offset?: Offset | null | undefined;

        className?: string | undefined;

        maxWidth?: string | undefined;
    }

    export interface Style {
        layers: AnyLayer[];
        sources: Sources;

        bearing?: number | undefined;
        center?: number[] | undefined;
        fog?: Fog | undefined;
        glyphs?: string | undefined;
        metadata?: any;
        name?: string | undefined;
        pitch?: number | undefined;
        light?: Light | undefined;
        sprite?: string | undefined;
        terrain?: TerrainSpecification | undefined;
        transition?: Transition | undefined;
        version: number;
        zoom?: number | undefined;
    }

    export interface Transition {
        delay?: number | undefined;
        duration?: number | undefined;
    }

    export interface Light {
        anchor?: 'map' | 'viewport' | undefined;
        position?: number[] | undefined;
        'position-transition'?: Transition | undefined;
        color?: string | undefined;
        'color-transition'?: Transition | undefined;
        intensity?: number | undefined;
        'intensity-transition'?: Transition | undefined;
    }

    export interface Fog {
        color?: string | Expression | undefined;
        'horizon-blend'?: number | Expression | undefined;
        range?: number[] | Expression | undefined;
    }

    export interface Sources {
        [sourceName: string]: AnySourceData;
    }

    export type PromoteIdSpecification = { [key: string]: string } | string;

    export type AnySourceData =
        | GeoJSONSourceRaw
        | VideoSourceRaw
        | ImageSourceRaw
        | CanvasSourceRaw
        | VectorSource
        | RasterSource
        | RasterDemSource
        | CustomSourceInterface<HTMLImageElement | ImageData | ImageBitmap>;

    interface VectorSourceImpl extends VectorSource {
        /**
         * Sets the source `tiles` property and re-renders the map.
         *
         * @param {string[]} tiles An array of one or more tile source URLs, as in the TileJSON spec.
         * @returns {VectorTileSource} this
         */
        setTiles(tiles: ReadonlyArray<string>): VectorSourceImpl;

        /**
         * Sets the source `url` property and re-renders the map.
         *
         * @param {string} url A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `Map://<Tileset ID>`.
         * @returns {VectorTileSource} this
         */
        setUrl(url: string): VectorSourceImpl;
    }

    export type AnySourceImpl =
        | GeoJSONSource
        | VideoSource
        | ImageSource
        | CanvasSource
        | VectorSourceImpl
        | RasterSource
        | RasterDemSource
        | CustomSource<HTMLImageElement | ImageData | ImageBitmap>;

    export interface Source {
        type: 'vector' | 'raster' | 'raster-dem' | 'geojson' | 'image' | 'video' | 'canvas' | 'custom';
    }

    /**
     * GeoJSONSource
     */

    export interface GeoJSONSourceRaw extends Source, GeoJSONSourceOptions {
        type: 'geojson';
    }

    export class GeoJSONSource implements GeoJSONSourceRaw {
        type: 'geojson';

        constructor(options?: vjmap.GeoJSONSourceOptions);

        setData(data: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | String): this;

        getClusterExpansionZoom(clusterId: number, callback: (error: any, zoom: number) => void): this;

        getClusterChildren(
            clusterId: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;

        getClusterLeaves(
            cluserId: number,
            limit: number,
            offset: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;
    }

    export interface GeoJSONSourceOptions {
        data?: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | string | undefined;

        maxzoom?: number | undefined;

        attribution?: string | undefined;

        buffer?: number | undefined;

        tolerance?: number | undefined;

        cluster?: number | boolean | undefined;

        clusterRadius?: number | undefined;

        clusterMaxZoom?: number | undefined;

        /**
         * Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`.
         */
        clusterMinPoints?: number | undefined;

        clusterProperties?: object | undefined;

        lineMetrics?: boolean | undefined;

        generateId?: boolean | undefined;

        promoteId?: PromoteIdSpecification | undefined;

        filter?: any;
    }

    /**
     * VideoSource
     */
    export interface VideoSourceRaw extends Source, VideoSourceOptions {
        type: 'video';
    }

    export class VideoSource implements VideoSourceRaw {
        type: 'video';

        constructor(options?: vjmap.VideoSourceOptions);

        getVideo(): HTMLVideoElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface VideoSourceOptions {
        urls?: string[] | undefined;

        coordinates?: number[][] | undefined;
    }

    /**
     * ImageSource
     */
    export interface ImageSourceRaw extends Source, ImageSourceOptions {
        type: 'image';
    }

    export class ImageSource implements ImageSourceRaw {
        type: 'image';

        constructor(options?: vjmap.ImageSourceOptions);

        updateImage(options: ImageSourceOptions): this;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface ImageSourceOptions {
        url?: string | undefined;

        coordinates?: number[][] | undefined;
    }

    /**
     * CanvasSource
     */
    export interface CanvasSourceRaw extends Source, CanvasSourceOptions {
        type: 'canvas';
    }

    export class CanvasSource implements CanvasSourceRaw {
        type: 'canvas';

        coordinates: number[][];

        canvas: string | HTMLCanvasElement;

        play(): void;

        pause(): void;

        getCanvas(): HTMLCanvasElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface CanvasSourceOptions {
        coordinates: number[][];

        animate?: boolean | undefined;

        canvas: string | HTMLCanvasElement;
    }

    export type CameraFunctionSpecification<T> =
        | { type: 'exponential'; stops: Array<[number, T]> }
        | { type: 'interval'; stops: Array<[number, T]> };

    export type ExpressionSpecification = Array<unknown>;

    export type PropertyValueSpecification<T> = T | CameraFunctionSpecification<T> | ExpressionSpecification;

    export interface TerrainSpecification {
        source: string;
        exaggeration?: PropertyValueSpecification<number> | undefined;
    }

    /**
     * @see https://github.com/Map/tilejson-spec/tree/master/3.0.0#33-vector_layers
     */
  export  type SourceVectorLayer = {
        id: string;
        fields?: Record<string, string>;
        description?: string;
        minzoom?: number;
        maxzoom?: number;

        // Non standard extensions that are valid in a Map context.
        source?: string;
        source_name?: string;
    };

    interface VectorSource extends Source {
        type: 'vector';
        format?: 'pbf';

        url?: string | undefined;
        id?: string;
        name?: string;

        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        scheme?: 'xyz' | 'tms' | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        attribution?: string | undefined;
        promoteId?: PromoteIdSpecification | undefined;

        vector_layers?: SourceVectorLayer[];
    }

    interface RasterSource extends Source {
        name?: string;
        type: 'raster';
        id?: string;
        format?: 'webp' | string;

        url?: string | undefined;
        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        tileSize?: number | undefined;
        scheme?: 'xyz' | 'tms' | undefined;
        attribution?: string | undefined;
    }

    interface RasterDemSource extends Source {
        name?: string;
        type: 'raster-dem';
        id?: string;

        url?: string | undefined;
        tiles?: string[] | undefined;
        bounds?: number[] | undefined;
        minzoom?: number | undefined;
        maxzoom?: number | undefined;
        tileSize?: number | undefined;
        attribution?: string | undefined;
        encoding?: 'terrarium' | 'Map' | undefined;
    }

    interface CustomSourceInterface<T> {
        id: string;
        type: 'custom';
        dataType: 'raster';
        minzoom?: number;
        maxzoom?: number;
        scheme?: string;
        tileSize?: number;
        attribution?: string;
        bounds?: [number, number, number, number];
        hasTile?: (tileID: { z: number, x: number, y: number }) => boolean;
        loadTile: (tileID: { z: number, x: number, y: number }, options: { signal: AbortSignal }) => Promise<T>;
        prepareTile?: (tileID: { z: number, x: number, y: number }) => T | undefined;
        unloadTile?: (tileID: { z: number, x: number, y: number }) => void;
        onAdd?: (map: Map) => void;
        onRemove?: (map: Map) => void;
    }

    interface CustomSource<T> extends Source {
        id: string;
        type: 'custom';
        scheme: string;
        minzoom: number;
        maxzoom: number;
        tileSize: number;
        attribution: string;

        _implementation: CustomSourceInterface<T>;
    }

    /**
     * LngLat
     */
    export class LngLat {
        lng: number;
        lat: number;

        constructor(lng: number, lat: number);

        /** Return a new LngLat object whose longitude is wrapped to the range (-180, 180). */
        wrap(): vjmap.LngLat;

        /** Return a LngLat as an array */
        toArray(): number[];

        /** Return a LngLat as a string */
        toString(): string;

        /** Returns the approximate distance between a pair of coordinates in meters
         * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159) */
        distanceTo(lngLat: LngLat): number;

        toBounds(radius: number): LngLatBounds;

        static convert(input: LngLatLike): vjmap.LngLat;
    }

    /**
     * LngLatBounds
     */
    export class LngLatBounds {
        sw: LngLatLike;
        ne: LngLatLike;

        constructor(boundsLike?: [LngLatLike, LngLatLike] | [number, number, number, number]);
        constructor(sw: LngLatLike, ne: LngLatLike);

        setNorthEast(ne: LngLatLike): this;

        setSouthWest(sw: LngLatLike): this;

        /** Check if the point is within the bounding box. */
        contains(lnglat: LngLatLike): boolean;

        /** Extend the bounds to include a given LngLat or LngLatBounds. */
        extend(obj: LngLatLike | LngLatBoundsLike): this;

        /** Get the point equidistant from this box's corners */
        getCenter(): vjmap.LngLat;

        /** Get southwest corner */
        getSouthWest(): vjmap.LngLat;

        /** Get northeast corner */
        getNorthEast(): vjmap.LngLat;

        /** Get northwest corner */
        getNorthWest(): vjmap.LngLat;

        /** Get southeast corner */
        getSouthEast(): vjmap.LngLat;

        /** Get west edge longitude */
        getWest(): number;

        /** Get south edge latitude */
        getSouth(): number;

        /** Get east edge longitude */
        getEast(): number;

        /** Get north edge latitude */
        getNorth(): number;

        /** Returns a LngLatBounds as an array */
        toArray(): number[][];

        /** Return a LngLatBounds as a string */
        toString(): string;

        /** Returns a boolean */
        isEmpty(): boolean;

        /** Convert an array to a LngLatBounds object, or return an existing LngLatBounds object unchanged. */
        static convert(input: LngLatBoundsLike): vjmap.LngLatBounds;
    }

    /**
     * Point
     */
    // Todo: Pull out class to seperate definition for Module "point-geometry"
    export class Point {
        x: number;
        y: number;

        constructor(x: number, y: number);

        clone(): Point;

        add(p: Point): Point;

        sub(p: Point): Point;

        mult(k: number): Point;

        div(k: number): Point;

        rotate(a: number): Point;

        matMult(m: number): Point;

        unit(): Point;

        perp(): Point;

        round(): Point;

        mag(): number;

        equals(p: Point): boolean;

        dist(p: Point): number;

        distSqr(p: Point): number;

        angle(): number;

        angleTo(p: Point): number;

        angleWidth(p: Point): number;

        angleWithSep(x: number, y: number): number;

        static convert(a: PointLike): Point;
    }

    /**
     * MercatorCoordinate
     */
    export class MercatorCoordinate {
        /** The x component of the position. */
        x: number;

        /** The y component of the position. */
        y: number;

        /**
         * The z component of the position.
         *
         * @default 0
         */
        z?: number | undefined;

        constructor(x: number, y: number, z?: number);

        /** Returns the altitude in meters of the coordinate. */
        toAltitude(): number;

        /** Returns the LngLat for the coordinate. */
        toLngLat(): LngLat;

        /**
         * Returns the distance of 1 meter in MercatorCoordinate units at this latitude.
         *
         * For coordinates in real world units using meters, this naturally provides the
         * scale to transform into MercatorCoordinates.
         */
        meterInMercatorCoordinateUnits(): number;

        /** Project a LngLat to a MercatorCoordinate. */
        static fromLngLat(lngLatLike: LngLatLike, altitude?: number): MercatorCoordinate;
    }

    /**
     * Marker
     */
    export class Marker extends Evented {

        /**
         * 
         * @param animationType
         * MAP_ANIMATION_NONE 
         * MAP_ANIMATION_BOUNCE 
         * MAP_ANIMATION_DROP 
         */
        setAnimation(animationType: string): void;

        /**
         * 
         * @param color 
         */
        setColor(color: string): void;

        /**
         * 
         */
        show(): void;

        /**
         * 
         */
        hide(): void;

        /**
         * hidetruefalse
         */
        isHidden(): boolean;

        /**
         * 
         * @param cur 
         */
        setCursor(cur: string): void;

        /**
         * 
         * @param height 
         */
        setHeight(height: number): Marker;

        /**
         * 
         * @param zoom 
         */
        setMinZoom(zoom: number): Marker;

        /**
         * 
         * @param zoom 
         */
        setMaxZoom(zoom: number): Marker;

        /**
         * marker`autoAdd``autoRemove`
         * @param autoRemove truefalse
         * @param padding 500pxmarker
         */
        setRemoveWhenNoInMapView(autoRemove: boolean, padding?: number): Marker;

        /**
         * div`autoAdd``autoRemove`
         * @param zoom 
         */
        setScaleMaxZoom(zoom: number): Marker;

        /**
         * 
         */
        getHeight(): number | undefined;

        /**
         * 
         */
        getMinZoom(): number | undefined;

        /**
         * 
         */
        getMaxZoom(): number | undefined;

        /**
         * div
         */
        getScaleMaxZoom(zoom: number): number | undefined;

        /**
         * marker
         */
        getRemoveWhenNoInMapView(): boolean;

        /**
         * 
         * @param visible 
         * @param isDisplay truestyledisplaydomfalse
         */
        setVisible(visible?: boolean, isDisplay?: boolean): Marker;

        
        constructor(options?: vjmap.MarkerOptions);

        constructor(element?: HTMLElement, options?: vjmap.MarkerOptions);

        addTo(map: Map): this;

        remove(): this;

        getLngLat(): LngLat;

        setLngLat(lngLat: LngLatLike): this;

        getElement(): HTMLElement;

        setPopup(popup?: Popup): this;

        getPopup(): Popup;

        togglePopup(): this;

        getOffset(): PointLike;

        setOffset(offset: PointLike): this;

        setDraggable(shouldBeDraggable: boolean): this;

        isDraggable(): boolean;

        getRotation(): number;

        setRotation(rotation: number): this;

        getRotationAlignment(): Alignment;

        setRotationAlignment(alignment: Alignment): this;

        getPitchAlignment(): Alignment;

        setPitchAlignment(alignment: Alignment): this;
    }

  export  type Alignment = 'map' | 'viewport' | 'auto';

    export interface MarkerOptions {
        /** DOM element to use as a marker. The default is a light blue, droplet-shaped SVG marker */
        element?: HTMLElement | undefined;

        /** The offset in pixels as a PointLike object to apply relative to the element's center. Negatives indicate left and up. */
        offset?: PointLike | undefined;

        /** A string indicating the part of the Marker that should be positioned closest to the coordinate set via Marker.setLngLat.
         * Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`.
         * The default value os `'center'`
         */
        anchor?: Anchor | undefined;

        /** The color to use for the default marker if options.element is not provided. The default is light blue (#3FB1CE). */
        color?: string | undefined;

        /** A boolean indicating whether or not a marker is able to be dragged to a new position on the map. The default value is false */
        draggable?: boolean | undefined;

        /**
         * The max number of pixels a user can shift the mouse pointer during a click on the marker for it to be considered a valid click
         * (as opposed to a marker drag). The default (0) is to inherit map's clickTolerance.
         */
        clickTolerance?: number | null | undefined;

        /** The rotation angle of the marker in degrees, relative to its `rotationAlignment` setting. A positive value will rotate the marker clockwise.
         * The default value is 0.
         */
        rotation?: number | undefined;

        /** `map` aligns the `Marker`'s rotation relative to the map, maintaining a bearing as the map rotates.
         * `viewport` aligns the `Marker`'s rotation relative to the viewport, agnostic to map rotations.
         * `auto` is equivalent to `viewport`.
         * The default value is `auto`
         */
        rotationAlignment?: Alignment | undefined;

        /** `map` aligns the `Marker` to the plane of the map.
         * `viewport` aligns the `Marker` to the plane of the viewport.
         * `auto` automatically matches the value of `rotationAlignment`.
         * The default value is `auto`.
         */
        pitchAlignment?: Alignment | undefined;

        /** The scale to use for the default marker if options.element is not provided.
         * The default scale (1) corresponds to a height of `41px` and a width of `27px`.
         */
        scale?: number | undefined;
    }

  export  type EventedListener = (object?: Object) => any;
    /**
     * Evented
     */
    export class Evented {
        on(type: string, listener: EventedListener): this;

        off(type?: string | any, listener?: EventedListener): this;

        once(type: string, listener: EventedListener): this;

        
        fire(type: string, properties?: { [key: string]: any }): this;
    }

    /**
     * StyleOptions
     */
    export interface StyleOptions {
        transition?: boolean | undefined;
    }

    export type MapGeoJSONFeature = GeoJSON.Feature<GeoJSON.Geometry> & {
        layer: Layer;
        source: string;
        sourceLayer: string;
        state: { [key: string]: any };
    };

    export type EventData = { [key: string]: any };

    export class MapEvent<TOrig = undefined> {
        type: string;
        target: Map;
        originalEvent: TOrig;
    }

    export class MapMouseEvent extends MapEvent<MouseEvent> {
        type:
            | 'mousedown'
            | 'mouseup'
            | 'click'
            | 'dblclick'
            | 'mousemove'
            | 'mouseover'
            | 'mouseenter'
            | 'mouseleave'
            | 'mouseout'
            | 'contextmenu';

        point: Point;
        lngLat: LngLat;

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerMouseEvent = MapMouseEvent & { features?: MapGeoJSONFeature[] | undefined };

    export class MapTouchEvent extends MapEvent<TouchEvent> {
        type: 'touchstart' | 'touchend' | 'touchcancel';

        point: Point;
        lngLat: LngLat;
        points: Point[];
        lngLats: LngLat[];

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerTouchEvent = MapTouchEvent & { features?: MapGeoJSONFeature[] | undefined };

    export class MapWheelEvent extends MapEvent<WheelEvent> {
        type: 'wheel';

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export interface MapZoomEvent extends MapEvent<MouseEvent> {
        type: 'boxzoomstart' | 'boxzoomend' | 'boxzoomcancel';

        boxZoomBounds: LngLatBounds;
    }

    export type MapDataEvent = MapSourceDataEvent | MapStyleDataEvent;

    export interface MapStyleDataEvent extends MapEvent {
        dataType: 'style';
    }

    export interface MapSourceDataEvent extends MapEvent {
        dataType: 'source';
        isSourceLoaded: boolean;
        source: Source;
        sourceId: string;
        sourceDataType: 'metadata' | 'content';
        tile: any;
        coord: Coordinate;
    }

    export interface Coordinate {
        canonical: CanonicalCoordinate;
        wrap: number;
        key: number;
    }

    export interface CanonicalCoordinate {
        x: number;
        y: number;
        z: number;
        key: number;
        equals(coord: CanonicalCoordinate): boolean;
    }

    export interface MapContextEvent extends MapEvent<WebGLContextEvent> {
        type: 'webglcontextlost' | 'webglcontextrestored';
    }

    export class ErrorEvent extends MapEvent {
        type: 'error';
        error: Error;
    }

    /**
     * FilterOptions
     */
    export interface FilterOptions {
        /**
         * Whether to check if the filter conforms to the Map GL Style Specification.
         * Disabling validation is a performance optimization that should only be used
         * if you have previously validated the values you will be passing to this function.
         */
        validate?: boolean | null | undefined;
    }

    /**
     * AnimationOptions
     */
    export interface AnimationOptions {
        /** Number in milliseconds */
        duration?: number | undefined;
        /**
         * A function taking a time in the range 0..1 and returning a number where 0 is the initial
         * state and 1 is the final state.
         */
        easing?: ((time: number) => number) | undefined;
        /** point, origin of movement relative to map center */
        offset?: PointLike | undefined;
        /** When set to false, no animation happens */
        animate?: boolean | undefined;

        /** If `true`, then the animation is considered essential and will not be affected by `prefers-reduced-motion`.
         * Otherwise, the transition will happen instantly if the user has enabled the `reduced motion` accesibility feature in their operating system.
         */
        essential?: boolean | undefined;
    }

    /**
     * CameraOptions
     */
    export interface CameraOptions {
        /** Map center */
        center?: LngLatLike | undefined;
        /** Map zoom level */
        zoom?: number | undefined;
        /** Map rotation bearing in degrees counter-clockwise from north */
        bearing?: number | undefined;
        /** Map angle in degrees at which the camera is looking at the ground */
        pitch?: number | undefined;
        /** If zooming, the zoom center (defaults to map center) */
        around?: LngLatLike | undefined;
        /** Dimensions in pixels applied on each side of the viewport for shifting the vanishing point. */
        padding?: number | PaddingOptions | undefined;
    }

    export interface CameraForBoundsOptions extends CameraOptions {
        offset?: PointLike | undefined;
        maxZoom?: number | undefined;
    }

    // The Map docs say that if the result is defined, it will have zoom, center and bearing set.
    // In practice center is always a {lat, lng} object.
    export type CameraForBoundsResult = Required<Pick<CameraOptions, 'zoom' | 'bearing'>> & {
        /** Map center */
        center: { lng: number; lat: number };
    };

    /**
     * FlyToOptions
     */
    export interface FlyToOptions extends AnimationOptions, CameraOptions {
        curve?: number | undefined;
        minZoom?: number | undefined;
        speed?: number | undefined;
        screenSpeed?: number | undefined;
        maxDuration?: number | undefined;
    }

    /**
     * EaseToOptions
     */
    export interface EaseToOptions extends AnimationOptions, CameraOptions {
        delayEndEvents?: number | undefined;
    }

    export interface FitBoundsOptions extends vjmap.FlyToOptions {
        linear?: boolean | undefined;
        offset?: PointLike | undefined;
        maxZoom?: number | undefined;
        maxDuration?: number | undefined;
    }

    /**
     * MapEvent
     */
    export type MapEventType = {
        error: ErrorEvent;

        load: MapEvent;
        idle: MapEvent;
        remove: MapEvent;
        render: MapEvent;
        resize: MapEvent;

        webglcontextlost: MapContextEvent;
        webglcontextrestored: MapContextEvent;

        dataloading: MapDataEvent;
        data: MapDataEvent;
        tiledataloading: MapDataEvent;
        sourcedataloading: MapSourceDataEvent;
        styledataloading: MapStyleDataEvent;
        sourcedata: MapSourceDataEvent;
        styledata: MapStyleDataEvent;

        boxzoomcancel: MapZoomEvent;
        boxzoomstart: MapZoomEvent;
        boxzoomend: MapZoomEvent;

        touchcancel: MapTouchEvent;
        touchmove: MapTouchEvent;
        touchend: MapTouchEvent;
        touchstart: MapTouchEvent;

        click: MapMouseEvent;
        contextmenu: MapMouseEvent;
        dblclick: MapMouseEvent;
        mousemove: MapMouseEvent;
        mouseup: MapMouseEvent;
        mousedown: MapMouseEvent;
        mouseout: MapMouseEvent;
        mouseover: MapMouseEvent;

        movestart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        move: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        moveend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        zoomstart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoom: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoomend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        rotatestart: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotate: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotateend: MapEvent<MouseEvent | TouchEvent | undefined>;

        dragstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        drag: MapEvent<MouseEvent | TouchEvent | undefined>;
        dragend: MapEvent<MouseEvent | TouchEvent | undefined>;

        pitchstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitch: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitchend: MapEvent<MouseEvent | TouchEvent | undefined>;

        wheel: MapWheelEvent;
    };

    export type MapLayerEventType = {
        click: MapLayerMouseEvent;
        dblclick: MapLayerMouseEvent;
        mousedown: MapLayerMouseEvent;
        mouseup: MapLayerMouseEvent;
        mousemove: MapLayerMouseEvent;
        mouseenter: MapLayerMouseEvent;
        mouseleave: MapLayerMouseEvent;
        mouseover: MapLayerMouseEvent;
        mouseout: MapLayerMouseEvent;
        contextmenu: MapLayerMouseEvent;

        touchstart: MapLayerTouchEvent;
        touchend: MapLayerTouchEvent;
        touchcancel: MapLayerTouchEvent;
    };

    export type AnyLayout =
        | BackgroundLayout
        | FillLayout
        | FillExtrusionLayout
        | LineLayout
        | SymbolLayout
        | RasterLayout
        | CircleLayout
        | HeatmapLayout
        | HillshadeLayout
        | SkyLayout;

    export type AnyPaint =
        | BackgroundPaint
        | FillPaint
        | FillExtrusionPaint
        | LinePaint
        | SymbolPaint
        | RasterPaint
        | CirclePaint
        | HeatmapPaint
        | HillshadePaint
        | SkyPaint;

    interface Layer {
        id: string;
        type: string;

        metadata?: any;
        ref?: string | undefined;

        source?: string | AnySourceData | undefined;

        'source-layer'?: string | undefined;

        minzoom?: number | undefined;
        maxzoom?: number | undefined;

        interactive?: boolean | undefined;

        filter?: any[] | undefined;
        layout?: AnyLayout | undefined;
        paint?: AnyPaint | undefined;
    }

    interface BackgroundLayer extends Layer {
        type: 'background';
        layout?: BackgroundLayout | undefined;
        paint?: BackgroundPaint | undefined;
    }

    interface CircleLayer extends Layer {
        type: 'circle';
        layout?: CircleLayout | undefined;
        paint?: CirclePaint | undefined;
    }

    interface FillExtrusionLayer extends Layer {
        type: 'fill-extrusion';
        layout?: FillExtrusionLayout | undefined;
        paint?: FillExtrusionPaint | undefined;
    }

    interface FillLayer extends Layer {
        type: 'fill';
        layout?: FillLayout | undefined;
        paint?: FillPaint | undefined;
    }

    interface HeatmapLayer extends Layer {
        type: 'heatmap';
        layout?: HeatmapLayout | undefined;
        paint?: HeatmapPaint | undefined;
    }

    interface HillshadeLayer extends Layer {
        type: 'hillshade';
        layout?: HillshadeLayout | undefined;
        paint?: HillshadePaint | undefined;
    }

    interface LineLayer extends Layer {
        type: 'line';
        layout?: LineLayout | undefined;
        paint?: LinePaint | undefined;
    }

    interface RasterLayer extends Layer {
        type: 'raster';
        layout?: RasterLayout | undefined;
        paint?: RasterPaint | undefined;
    }

    interface SymbolLayer extends Layer {
        type: 'symbol';
        layout?: SymbolLayout | undefined;
        paint?: SymbolPaint | undefined;
    }

    interface SkyLayer extends Layer {
        type: 'sky';
        layout?: SkyLayout | undefined;
        paint?: SkyPaint | undefined;
    }

    export type AnyLayer =
        | BackgroundLayer
        | CircleLayer
        | FillExtrusionLayer
        | FillLayer
        | HeatmapLayer
        | HillshadeLayer
        | LineLayer
        | RasterLayer
        | SymbolLayer
        | CustomLayerInterface
        | SkyLayer;

    
    export interface CustomLayerInterface {
        /** A unique layer id. */
        id: string;

        /* The layer's type. Must be "custom". */
        type: 'custom';

        /* Either "2d" or "3d". Defaults to  "2d". */
        renderingMode?: '2d' | '3d' | undefined;

        /**
         * Optional method called when the layer has been removed from the Map with Map#removeLayer.
         * This gives the layer a chance to clean up gl resources and event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onRemove?(map: vjmap.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called when the layer has been added to the Map with Map#addLayer.
         * This gives the layer a chance to initialize gl resources and register event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onAdd?(map: vjmap.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called during a render frame to allow a layer to prepare resources
         * or render into a texture.
         *
         * The layer cannot make any assumptions about the current GL state and must bind a framebuffer
         * before rendering.
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        prerender?(gl: WebGLRenderingContext, matrix: number[]): void;

        /**
         * Called during a render frame allowing the layer to draw into the GL context.
         *
         * The layer can assume blending and depth state is set to allow the layer to properly blend
         * and clip other layers. The layer cannot make any other assumptions about the current GL state.
         *
         * If the layer needs to render to a texture, it should implement the prerender method to do this
         * and only use the render method for drawing directly into the main framebuffer.
         *
         * The blend function is set to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA). This expects
         * colors to be provided in premultiplied alpha form where the r, g and b values are already
         * multiplied by the a value. If you are unable to provide colors in premultiplied form you may
         * want to change the blend function to
         * gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA).
         *
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        render(gl: WebGLRenderingContext, matrix: number[]): void;
    }

    export interface StyleFunction {
        stops?: any[][] | undefined;
        property?: string | undefined;
        base?: number | undefined;
        type?: 'identity' | 'exponential' | 'interval' | 'categorical' | undefined;
        default?: any;
        colorSpace?: 'rgb' | 'lab' | 'hcl' | undefined;
    }

  export  type Visibility = 'visible' | 'none';

    export interface Layout {
        visibility?: Visibility | undefined;
    }

    export interface BackgroundLayout extends Layout {}

    export interface BackgroundPaint {
        'background-color'?: string | Expression | undefined;
        'background-color-transition'?: Transition | undefined;
        'background-pattern'?: string | undefined;
        'background-pattern-transition'?: Transition | undefined;
        'background-opacity'?: number | Expression | undefined;
        'background-opacity-transition'?: Transition | undefined;
    }

    export interface FillLayout extends Layout {
        'fill-sort-key'?: number | Expression | undefined;
    }

    export interface FillPaint {
        'fill-antialias'?: boolean | Expression | undefined;
        'fill-opacity'?: number | StyleFunction | Expression | undefined;
        'fill-opacity-transition'?: Transition | undefined;
        'fill-color'?: string | StyleFunction | Expression | undefined;
        'fill-color-transition'?: Transition | undefined;
        'fill-outline-color'?: string | StyleFunction | Expression | undefined;
        'fill-outline-color-transition'?: Transition | undefined;
        'fill-translate'?: number[] | undefined;
        'fill-translate-transition'?: Transition | undefined;
        'fill-translate-anchor'?: 'map' | 'viewport' | undefined;
        'fill-pattern'?: string | Expression | undefined;
        'fill-pattern-transition'?: Transition | undefined;
    }

    export interface FillExtrusionLayout extends Layout {}

    export interface FillExtrusionPaint {
        'fill-extrusion-opacity'?: number | Expression | undefined;
        'fill-extrusion-opacity-transition'?: Transition | undefined;
        'fill-extrusion-color'?: string | StyleFunction | Expression | undefined;
        'fill-extrusion-color-transition'?: Transition | undefined;
        'fill-extrusion-translate'?: number[] | Expression | undefined;
        'fill-extrusion-translate-transition'?: Transition | undefined;
        'fill-extrusion-translate-anchor'?: 'map' | 'viewport' | undefined;
        'fill-extrusion-pattern'?: string | Expression | undefined;
        'fill-extrusion-pattern-transition'?: Transition | undefined;
        'fill-extrusion-height'?: number | StyleFunction | Expression | undefined;
        'fill-extrusion-height-transition'?: Transition | undefined;
        'fill-extrusion-base'?: number | StyleFunction | Expression | undefined;
        'fill-extrusion-base-transition'?: Transition | undefined;
        'fill-extrusion-vertical-gradient'?: boolean | undefined;
    }

    export interface LineLayout extends Layout {
        'line-cap'?: 'butt' | 'round' | 'square' | Expression | undefined;
        'line-join'?: 'bevel' | 'round' | 'miter' | Expression | undefined;
        'line-miter-limit'?: number | Expression | undefined;
        'line-round-limit'?: number | Expression | undefined;
        'line-sort-key'?: number | Expression | undefined;
    }

    export interface LinePaint {
        'line-opacity'?: number | StyleFunction | Expression | undefined;
        'line-opacity-transition'?: Transition | undefined;
        'line-color'?: string | StyleFunction | Expression | undefined;
        'line-color-transition'?: Transition | undefined;
        'line-translate'?: number[] | Expression | undefined;
        'line-translate-transition'?: Transition | undefined;
        'line-translate-anchor'?: 'map' | 'viewport' | undefined;
        'line-width'?: number | StyleFunction | Expression | undefined;
        'line-width-transition'?: Transition | undefined;
        'line-gap-width'?: number | StyleFunction | Expression | undefined;
        'line-gap-width-transition'?: Transition | undefined;
        'line-offset'?: number | StyleFunction | Expression | undefined;
        'line-offset-transition'?: Transition | undefined;
        'line-blur'?: number | StyleFunction | Expression | undefined;
        'line-blur-transition'?: Transition | undefined;
        'line-dasharray'?: number[] | Expression | undefined;
        'line-dasharray-transition'?: Transition | undefined;
        'line-pattern'?: string | Expression | undefined;
        'line-pattern-transition'?: Transition | undefined;
        'line-gradient'?: Expression | undefined;
    }

    export interface SymbolLayout extends Layout {
        'symbol-placement'?: 'point' | 'line' | 'line-center' | undefined;
        'symbol-spacing'?: number | Expression | undefined;
        'symbol-avoid-edges'?: boolean | undefined;
        'symbol-z-order'?: 'viewport-y' | 'source' | undefined;
        'icon-allow-overlap'?: boolean | StyleFunction | Expression | undefined;
        'icon-ignore-placement'?: boolean | Expression | undefined;
        'icon-optional'?: boolean | undefined;
        'icon-rotation-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'icon-size'?: number | StyleFunction | Expression | undefined;
        'icon-text-fit'?: 'none' | 'both' | 'width' | 'height' | undefined;
        'icon-text-fit-padding'?: number[] | Expression | undefined;
        'icon-image'?: string | StyleFunction | Expression | undefined;
        'icon-rotate'?: number | StyleFunction | Expression | undefined;
        'icon-padding'?: number | Expression | undefined;
        'icon-keep-upright'?: boolean | undefined;
        'icon-offset'?: number[] | StyleFunction | Expression | undefined;
        'icon-anchor'?: Anchor | StyleFunction | Expression | undefined;
        'icon-pitch-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-pitch-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-rotation-alignment'?: 'map' | 'viewport' | 'auto' | undefined;
        'text-field'?: string | StyleFunction | Expression | undefined;
        'text-font'?: string[] | Expression | undefined;
        'text-size'?: number | StyleFunction | Expression | undefined;
        'text-max-width'?: number | StyleFunction | Expression | undefined;
        'text-line-height'?: number | Expression | undefined;
        'text-letter-spacing'?: number | Expression | undefined;
        'text-justify'?: 'auto' | 'left' | 'center' | 'right' | Expression | undefined;
        'text-anchor'?: Anchor | StyleFunction | Expression | undefined;
        'text-max-angle'?: number | Expression | undefined;
        'text-rotate'?: number | StyleFunction | Expression | undefined;
        'text-padding'?: number | Expression | undefined;
        'text-keep-upright'?: boolean | undefined;
        'text-transform'?: 'none' | 'uppercase' | 'lowercase' | StyleFunction | Expression | undefined;
        'text-offset'?: number[] | Expression | undefined;
        'text-allow-overlap'?: boolean | undefined;
        'text-ignore-placement'?: boolean | undefined;
        'text-optional'?: boolean | undefined;
        'text-radial-offset'?: number | Expression | undefined;
        'text-variable-anchor'?: Anchor[] | undefined;
        'text-writing-mode'?: ('horizontal' | 'vertical')[] | undefined;
        'symbol-sort-key'?: number | Expression | undefined;
    }

    export interface SymbolPaint {
        'icon-opacity'?: number | StyleFunction | Expression | undefined;
        'icon-opacity-transition'?: Transition | undefined;
        'icon-color'?: string | StyleFunction | Expression | undefined;
        'icon-color-transition'?: Transition | undefined;
        'icon-halo-color'?: string | StyleFunction | Expression | undefined;
        'icon-halo-color-transition'?: Transition | undefined;
        'icon-halo-width'?: number | StyleFunction | Expression | undefined;
        'icon-halo-width-transition'?: Transition | undefined;
        'icon-halo-blur'?: number | StyleFunction | Expression | undefined;
        'icon-halo-blur-transition'?: Transition | undefined;
        'icon-translate'?: number[] | Expression | undefined;
        'icon-translate-transition'?: Transition | undefined;
        'icon-translate-anchor'?: 'map' | 'viewport' | undefined;
        'text-opacity'?: number | StyleFunction | Expression | undefined;
        'text-opacity-transition'?: Transition | undefined;
        'text-color'?: string | StyleFunction | Expression | undefined;
        'text-color-transition'?: Transition | undefined;
        'text-halo-color'?: string | StyleFunction | Expression | undefined;
        'text-halo-color-transition'?: Transition | undefined;
        'text-halo-width'?: number | StyleFunction | Expression | undefined;
        'text-halo-width-transition'?: Transition | undefined;
        'text-halo-blur'?: number | StyleFunction | Expression | undefined;
        'text-halo-blur-transition'?: Transition | undefined;
        'text-translate'?: number[] | Expression | undefined;
        'text-translate-transition'?: Transition | undefined;
        'text-translate-anchor'?: 'map' | 'viewport' | undefined;
    }

    export interface RasterLayout extends Layout {}

    export interface RasterPaint {
        'raster-opacity'?: number | Expression | undefined;
        'raster-opacity-transition'?: Transition | undefined;
        'raster-hue-rotate'?: number | Expression | undefined;
        'raster-hue-rotate-transition'?: Transition | undefined;
        'raster-brightness-min'?: number | Expression | undefined;
        'raster-brightness-min-transition'?: Transition | undefined;
        'raster-brightness-max'?: number | Expression | undefined;
        'raster-brightness-max-transition'?: Transition | undefined;
        'raster-saturation'?: number | Expression | undefined;
        'raster-saturation-transition'?: Transition | undefined;
        'raster-contrast'?: number | Expression | undefined;
        'raster-contrast-transition'?: Transition | undefined;
        'raster-fade-duration'?: number | Expression | undefined;
        'raster-resampling'?: 'linear' | 'nearest' | undefined;
    }

    export interface CircleLayout extends Layout {
        'circle-sort-key'?: number | Expression | undefined;
    }

    export interface CirclePaint {
        'circle-radius'?: number | StyleFunction | Expression | undefined;
        'circle-radius-transition'?: Transition | undefined;
        'circle-color'?: string | StyleFunction | Expression | undefined;
        'circle-color-transition'?: Transition | undefined;
        'circle-blur'?: number | StyleFunction | Expression | undefined;
        'circle-blur-transition'?: Transition | undefined;
        'circle-opacity'?: number | StyleFunction | Expression | undefined;
        'circle-opacity-transition'?: Transition | undefined;
        'circle-translate'?: number[] | Expression | undefined;
        'circle-translate-transition'?: Transition | undefined;
        'circle-translate-anchor'?: 'map' | 'viewport' | undefined;
        'circle-pitch-scale'?: 'map' | 'viewport' | undefined;
        'circle-pitch-alignment'?: 'map' | 'viewport' | undefined;
        'circle-stroke-width'?: number | StyleFunction | Expression | undefined;
        'circle-stroke-width-transition'?: Transition | undefined;
        'circle-stroke-color'?: string | StyleFunction | Expression | undefined;
        'circle-stroke-color-transition'?: Transition | undefined;
        'circle-stroke-opacity'?: number | StyleFunction | Expression | undefined;
        'circle-stroke-opacity-transition'?: Transition | undefined;
    }

    export interface HeatmapLayout extends Layout {}

    export interface HeatmapPaint {
        'heatmap-radius'?: number | StyleFunction | Expression | undefined;
        'heatmap-radius-transition'?: Transition | undefined;
        'heatmap-weight'?: number | StyleFunction | Expression | undefined;
        'heatmap-intensity'?: number | StyleFunction | Expression | undefined;
        'heatmap-intensity-transition'?: Transition | undefined;
        'heatmap-color'?: string | StyleFunction | Expression | undefined;
        'heatmap-opacity'?: number | StyleFunction | Expression | undefined;
        'heatmap-opacity-transition'?: Transition | undefined;
    }

    export interface HillshadeLayout extends Layout {}

    export interface HillshadePaint {
        'hillshade-illumination-direction'?: number | Expression | undefined;
        'hillshade-illumination-anchor'?: 'map' | 'viewport' | undefined;
        'hillshade-exaggeration'?: number | Expression | undefined;
        'hillshade-exaggeration-transition'?: Transition | undefined;
        'hillshade-shadow-color'?: string | Expression | undefined;
        'hillshade-shadow-color-transition'?: Transition | undefined;
        'hillshade-highlight-color'?: string | Expression | undefined;
        'hillshade-highlight-color-transition'?: Transition | undefined;
        'hillshade-accent-color'?: string | Expression | undefined;
        'hillshade-accent-color-transition'?: Transition | undefined;
    }

    export interface SkyLayout extends Layout {}

    export interface SkyPaint {
        'sky-atmosphere-color'?: string | Expression | undefined;
        'sky-atmosphere-halo-color'?: string | Expression | undefined;
        'sky-atmosphere-sun'?: number[] | Expression | undefined;
        'sky-atmosphere-sun-intensity'?: number | Expression | undefined;
        'sky-gradient'?: string | Expression | undefined;
        'sky-gradient-center'?: number[] | Expression | undefined;
        'sky-gradient-radius'?: number | Expression | undefined;
        'sky-opacity'?: number | Expression | undefined;
        'sky-type'?: 'gradient' | 'atmosphere' | undefined;
    }

    export type ElevationQueryOptions = {
        exaggerated: boolean;
    };

}
